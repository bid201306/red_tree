{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-flow.js","webpack:/webpack/bootstrap f6a3121777ab2b67d7a6","webpack:///index.flow.js","webpack:///lib/fish-topo-flow/lib/FishTopoFlow.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///lib/fish-topo-core/lib/minimap.js","webpack:///lib/fish-topo-core/lib/util.js","webpack:///lib/fish-topo-core/lib/Point.js","webpack:///lib/fish-topo-core/lib/LineStruct.js","webpack:///lib/fish-topo-flow/lib/ExtensionApi.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///lib/fish-topo-flow/lib/node/GroupNode.js","webpack:///lib/fish-topo-core/lib/Node.js","webpack:///lib/fish-topo-core/lib/shapes/Connector.js","webpack:///lib/fish-topo-core/lib/shapes/Symbol.js","webpack:///lib/fish-topo-core/lib/shapes/Handle.js","webpack:///lib/fish-topo-core/lib/shapes/EffectLine.js","webpack:///lib/fish-topo-core/lib/shapes/ConnectionPoint.js","webpack:///lib/fish-topo-core/lib/manager/OperationNode.js","webpack:///lib/fish-topo-flow/lib/manager/FlowConnectionManager.js","webpack:///lib/fish-topo-core/lib/manager/ConnectionManager.js","webpack:///lib/fish-topo-core/lib/Log.js","webpack:///lib/fish-topo-flow/lib/util/FlowConstants.js","webpack:///lib/fish-topo-core/lib/model.js","webpack:///lib/fish-topo-core/lib/clazz.js","webpack:///lib/fish-topo-flow/lib/layout/forceLayout.js","webpack:///lib/fish-topo-flow/lib/layout/forceHelper.js","webpack:///lib/fish-topo-flow/lib/layout/treeLayout.js","webpack:///lib/fish-topo-flow/lib/util/FlowUtil.js","webpack:///lib/fish-topo-core/lib/manager/LineOperationManager.js","webpack:///lib/fish-topo-flow/lib/Flow.js","webpack:///lib/fish-topo-core/lib/ImagePool.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoFlow","dom","opts","group","_dom","nowZoom","canScale","eagleEye","eagleEyeNode","initScaleRatio","operationNode","selectedNode","allNodes","minimap","_layoutTimeout","_zr","zrender","init","renderer","devicePixelRatio","_api","ExtensionAPI","Shape","graphic","model","Model","set","Constants","ELEMENT_TYPE","MODE","options","Eventful","Minimap","util","Point","zrUtil","GroupNode","OperationNode","FlowConnectionManager","forceInstance","treeLayout","FlowUtil","eventTool","Connector","LineOperationManager","Flow","textContain","ImagePool","fishTopoProto","prototype","getDom","getZr","getWidth","getHeight","isDisposed","_disposed","dispose","instances","resize","clearSelect","e","that","remove","shape","target","isLink","connector","clearSelectCon","operation","hideAllLineOperation","Group","isBg","groupDrag","add","zrScale","connectors","on","nodeTarget","isNode","params","event","type","trigger","argument","bindOperation","lineNode","Element","parentNode","removeChild","toJson","fromJson","json","clear","setBackground","get","BACKGROUND","layoutRootNode","CHILDS","i","length","console","log","layoutNode","node","treeType","addNode","setProperties","width","getBoundingRect","height","parentZr","parent","deleteSelectCon","connectorMap","addIcon","key","lineDefaultIcon","addLineDeleteIcon","addLineChangeIcon","lineOperation","deleteIconObj","_triggerDeleteEvent","modifyNextLineType","line","index","indexOf","arrLineType","style","lineType","nextLineType","startNode","endNode","deleteLine","merge","nextLine","_createConnectorByNodes","icons","TYPE_STRAIGHT","TYPE_JAGGED","TYPE_CURVE","icon","callback","selConnector","initOperationNode","ARROW_DRAGSTART","x","offsetX","position","y","offsetY","arrow","hide","rEndPoint","manageTempConnector","cancelBubble","ARROW_DRAG","ARROW_DRAGEND","isHover","rectContain","findHover","list","excludes","isExclude","ignore","targetNode","show","removeTempConnector","connectOptions","data","DELETE_CLICK","removeNode","cmsImage","splice","eventParams","connectorCreate","bind","connectorForbidEdit","linkModify","isAllowEdit","connectorEdit","_triggerCreateEvent","_triggerDropDragEvent","nodeClickHandler","sX","sY","noSelected","fromCmsImage","shapeRect","getRect","refreshPostion","groupDragFunction","moveDrag","gx","gy","min","max","clientX","startX","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","attr","updataSelectionPosition","endDrag","off","moveFunction","upFunction","Circle","drag","isMove","nodeMessage","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","newAlarmPosition1","newAlarmPosition2","refreshLineByNode","layout","forceLayoutOption","once","nodes","openEagleEye","isdraggable","creatNode","opt","userData","OPTIONS","clone","USERDATA","draggable","z","Rect","mergedImage","imageShape","Image","image","text","textPosition","relationImage","setTimeout","merged","Text","Sector","Ring","Polygon","Polyline","Line","BezierCurve","Arc","operationIcons","nowNode","nodeEdit","push","ID","getUUID","childOfName","name","arrResult","childrenNode","childrenLine","j","findElements","cb","context","arr","child","childL","imageUrl","substr","document","createElement","getContext","fill","cursor","backgroundColor","gridLineGroup","gridLine","imageShape1","scale","backgroundImage","backgroundRepeat","opacity","pixel","widthLen","parseInt","lineX","x1","y1","x2","y2","lineDash","heightLen","lineY","creatLink","isEdit","thisConnector","lineText","textarea","creatTextArea","border","innerHTML","setStyle","appendChild","textRect","textFont","lineHeight","top","left","focus","select","$","textareaResize","value","thisNode","nodeText","nodeRect","maxWidth","offestI","textAlign","offestP","handleWrap","overflow","padding","spanNode","content","split","result","each","val","valLength","innerVal","tempWidth","conWidth","pre","innerI","charAt","Number","substring","minWidth","scrollHeight","setShape","creatAlarm","stroke","textFill","textBaseline","groupWidth","groupHeight","points","textBackground","groupPosition","ALARM","RELATIONID","creatCmsRect","rect","r","_children","option","eachChild","defaultOptions","allCons","repulsion","gravity","edgeLength","forceLayout","preservedPoints","defaults","BoundingRect","startForceLayoutIteration","layoutAnimation","self","step","stopped","_layouting","toDataURL","initScale","groupMaxWidth","groupMaxHeight","rangeWidth","rangeHeight","initRatio","pos","Math","abs","distance","zoomDelta1","zoom","zoomDelta","isNaN","zoomScale","_zoom","setScale","stop","wheelDelta","zoomX","zoomY","newZoom","toFixed","updataSelection","groupScale","imgSrc","updataMap","selection","addEventListener","eagleEyeMove","minimapLeft","minimapTop","updataGroupPosition","eagleEyeUp","removeEventListener","mixin","idBase","Date","DOM_ATTRIBUTE_KEY","fishTopoFlow","version","dependencies","Error","setAttribute","getInstanceByDom","getAttribute","chart","topo","isDom","clearTimeout","initImagePool","doSingleEnterHover","el","__isHover","__hoverStlDirty","hoverStyle","__hoverStl","lift","colorTool","Gradient","normalStyle","hasOwnProperty","__normalStl","z2","doSingleLeaveHover","normalStl","doEnterHover","traverse","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","postfix","duration","getShallow","animationEasing","animateTo","pathTool","round","Path","matrix","vector","Draggable","Util","LinearGradient","RadialGradient","extendShape","extend","extendPath","pathData","extendFromString","makePath","path","createFromString","boundingRect","aspect","cx","cy","resizePath","inherits","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","lineWidth","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","setText","textStyle","labelModel","color","labelPosition","labelColor","textStyleModel","getModel","textDistance","getFont","getTextColor","updateProps","curry","initProps","getTransform","ancestor","mat","identity","mul","getLocalTransform","vertex","transform","invert","transformDirection","direction","hBase","vBase","source","Array","len","isBuildInObject","overwrite","isObject","targetProp","sourceProp","isArray","mergeAll","targetAndSources","overlay","createCanvas","_ctx","array","clazz","baseClazz","F","clazzPrototype","prop","constructor","superClass","isArrayLike","obj","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","args","nativeSlice","arguments","apply","concat","objToString","isFunction","isString","BUILTIN_OBJECT","nodeType","retrieve","values","slice","Function","assert","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","Object","toString","arrayProto","noop","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","PI","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","n","cs","replace","cc","RegExp","prevCmd","cpx","cpy","PathProxy","CMD","str","shift","parseFloat","ctlPtx","ctlPty","L","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","setData","transformPath","ctx","rebuildPath","create","dirty","sqrt","sin","cos","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDashOffset","ctxLineDash","setLineDash","getGlobalScale","beginPath","setLineDashOffset","restoreTransform","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","Sub","extendFrom","defaultShape","thisShape","Style","__clipPaths","RectText","invisible","zlevel","dragging","silent","culling","rectHover","progressive","beforeBrush","afterBrush","coord","animateStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","STYLE_COMMON_PROPS","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textVerticalAlign","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","method","colorStops","addColorStop","offset","styleProto","guid","Transformable","Animatable","clipPath","drift","dx","dy","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","setClipPath","zr","addSelfToZr","removeClipPath","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","handler","_h","h","isSilent","newList","l","argLen","triggerWithContext","isNotAroundZero","EPSILON","mIdentity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","invTransform","rotate","dpr","tmpTransform","sx","sy","atan2","v2","transformCoordToGlobal","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","a","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","b","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","animatingShape","pathSplitted","animator","during","done","stopAnimation","forwardToLast","time","delay","easing","count","_animateToShallow","start","objShallow","propertyCount","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","_life","_initialized","gap","onrestart","easingFuncs","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseCssFloat","cssHueToRgb","colorStr","toLowerCase","kCSSColorTable","op","ep","fname","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","deltaR","deltaG","deltaB","level","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","config","debugMode","window","parsePercent","maxValue","lastIndexOf","tmpRect","save","align","font","baseline","verticalAlign","res","adjustTextPositionOnRect","shadowColor","textShadowColor","textLines","fillText","strokeText","restore","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","truncateText","containerWidth","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","vec2","v2ApplyTransform","mathMin","mathAbs","mathMax","union","other","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","curve","bbox","min2","max2","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","idx","dashSum","nDash","cubicAt","bezierLen","tmpLen","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","roots","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","next","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","end","extremity","PI2","fromPoints","right","bottom","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","_l","_a","_b","_s","repeat","_canvasPattern","createPattern","nPoint","mathAtan2","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","_y","dispatchToElement","dropTarget","lastDropTarget","_dropTarget","__storage","isGroup","children","childAt","childCount","_doAdd","addBefore","nextSibling","storage","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","removeAll","includeChildren","tmpMat","childRect","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","drawImage","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","r0","clockwise","unitX","unitY","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","roundRectHelper","r1","r2","r3","r4","total","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","tangentAt","globalCoord","bigCanvas","ratio","groupRatio","img","selectPosition","render","eagleEyeNodeWidth","eagleEyeNodeHeight","marginTop","marginLeft","background","backgroundSize","selectWidth","selectHeight","offectLeft","offectTop","newGroup","positionX","positionY","chars","uuid","rnd","random","getMaxLineLength","getPolylineLength","lenght","NaN","orthogonalPath","lineIntersectsLine","l1","l2","startPoint","endPoint","contains","a1","b1","a2","b2","polylineIntersectsRectangle","bounds","closedPolyline","lines","tempLine","tempLine1","scorePath","score","signum","forwardPath","traslatePoints","isRevert","newPoints","point1","rotationMatrix","mReturn","translationMatrix","scaleMatrix","getEndPoint","getConnectorPoints","center","getSoltPoints","tangentRotation","collinearity","precission","determinant","enhancedRound","number","decimals","getLength","getAngle","centerPoint","outsidePoint","atan","boundRect","randomColor","arrHex","strHex","isUndefined","collinearReduction","cloneArray","template","settings","oldSettings","templateSettings","matcher","escape","noMatch","evaluate","match","escaper","escapeChar","variable","isEmpty","StackedMap","createNew","stack","arrKey","keys","removeItem","item","removeTop","escapes","'","\\","\r","\n"," "," ","load","o","newPoint","loadArray","oldX","oldY","equals","anotherPoint","near","getPoints","oType","newLine","contructor","anotherLine","endX","endY","closestX","closestY","getPoint","Xp","Yp","instance","apiList","delInstance","env","Handler","Storage","Animation","HandlerProxy","useVML","canvasSupported","painterCtors","canvas","ZRender","getInstance","registerPainter","Ctor","rendererType","vml","painter","handerProxy","getViewportRoot","stage","_needsRefresh","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","oldAddToMap","elId","getId","addRoot","delRoot","configLayer","zLevel","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventName","eventHandler","detect","ua","os","browser","firefox","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","makeEventPacket","eveType","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","EmptyProxy","displayable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","lastHovered","setCursor","mouseout","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","getDisplayList","_downel","_upel","shapeCompareFunc","timsort","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","getBoundingClientRect","clientToLocal","box","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","isDomLevel2","attachEvent","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","toUpperCase","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","isSingleCanvas","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","from","hoverLayer","getLayer","scope","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","clearColor","stl","defaultView","getComputedStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","api","Node","bpmnInfo","fromJSON","minLength","minX","minY","maxX","maxY","isIcon","relationImagePosition","cloneImagePosition","resourceId","drawText","textName","refreshText","toJSON","symbol","size","arrowHoverStyle","handles","connectionPoints","conPointsGroup","autoChangePosition","groupCurve","symbolUtil","Handle","EffectLine","ConnectionPoint","RADIUS","START_NODE","END_NODE","LEFT","RIGHT","TOP","BOTTOM","SEPERATOR","turningPoints","modifyCurve","textPoint","getTextPostion","symbolTo","effect","polyLine","createSymbol","curveLine","createHoverStyle","MOUSE_EVENT_NAMES","eveName","createAllconnectionPoint","shapeSetHandle","textPos","textPostion","textWidth","xOffset","middle","getTextRotation","sRect","eRect","sConnectorPoint","eConnectorPoint","connectionPointCreate","TYPE_CONNECTOR","conPoint","clearHandles","handleShape","isCollineaityFirst","isCollineaitySecond","symbolType","symbolSize","symbolPath","middleX","middleY","ellapsedDistance","segment","missingDistance","error","walked","rest","currentSegmentLength","segmentPercent","sPos","ePos","refreshModel","iconNode","sol","getCurvePoint","willDelCurves","cntCurve","cure","P","divide","nr","callee","multiply","q1","q_01","q_02","q_03","q0","q2","q_31","q_32","q_33","q3","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","setColor","visible","actionConnector","anotherHandle","newX","newY","deltaY","deltaX","_lastFrame","_lastFramePercent","initSymbol","curveUtil","EffectLineProto","period","__t","groupCurveAnimate","updateSymbolPositionPolyline","setAnimationPointsPolyline","undefined","setAnimationPointsBezierCurve","updateSymbolPositionBezierCurve","__p1","__p2","__cp1","__cp2","_points","accLenArr","_offsets","_length","__lastFramePercent","offsets","NORMAL_COLOR","OVER_COLOR","CONNECTED_COLOR","TYPE_FIGURE","anotherConnectionPoint","forbidEdit","opicons","STRAIGHT","JAGGED","CURVE","DEL","renderBase","renderOther","createOperation","virtualRect","isSelfComputePos","opIconInstance","rect1","iconPath","rbPoint","nodeItem","refreshPositionOther","ConnectionManager","connectionManagerExtend","LineOperations","bundleOffset","bundleGap","getTwoNodeId","arrSplit","refreshConnector","selected","isShrink","con","cons","half","arrCons","dockers","arrStartEndPoint","getStartEndPoint","unshift","refreshCons","CONNECTION","START_ID","END_ID","DOCKERS","STYLE_LINETYPE","refreshConsStraight","arrConnectResult","secondPoint","thirdPoint","upHalf","boundOffsetXY","isPositive","resultPoint","setModel","originLineType","mergeOption","countLinePos","sPosNow","posIsChange","ePosNow","newPos","Log","CLOUD_RADIUS","CLOUD_LINEWIDTH","CLOUD_STROKE_STYLE","stencilType","tempConnector","startNodeOutgoing","escapeDistance","solutions","connector2Points","sBounds","eBounds","calcPointExpression","expression","figureEscapeDistance","info","startExitPoint","endExitPoint","potentialExits","gapIndex","s0","s1","s1_1","s1_2","s2_1","s2_1_1","s2_1_2","s2_2","s2_2_1","s2_2_2","s2_3","eastExits","eastExit","s2_3_1","s2_3_2","s2_4","northExits","northExit","s2_4_1","s2_4_2","s2_5","westExits","westExit","s2_5_1","s2_5_2","s2_6","southExits","southExit","s2_6_1","s2_6_2","orthogonalSolution","solution","forwardSolutions","temp","nonIntersectionSolutions","innerLines","firstSolution","nrOfPoints","sameNrPointsSolution","solIndex","smoothCurve","groupEnd","solTurningPoints","startMiddlePoint","getMiddle","a3","a4","endMiddlePoint","solType","reducedSolution","LOG_LEVEL_NONE","LOG_LEVEL_DEBUG","LOG_LEVEL_INFO","LOG_LEVEL_ERROR","debug","title","RELATION_IMAGE","GROUP","TREE_ROOT","LINEOPERATIONICON","parentModel","extraOpt","clazzUtil","getDefaultOption","optList","Class","defaultOption","__defaultOption","ignoreParent","fieldName","fieldArray","currentRef","thisParentModel","restoreData","enableClassExtend","superCall","methodName","superApply","TYPE_DELIMITER","IS_CONTAINER","parseClassType","componentType","main","RootClass","preConstruct","proto","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","Clazz","getClass","componentTypeMain","subType","throwWhenNotFound","getClassesByMainType","hasClass","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","forceHelper","_","rep","n1","n2","curveness","oldStep","fixed","edges","pp","friction","warmUp","setFixed","setUnfixed","v12","nLen","repFact","checkNode","average","jsonArr","childArr","childNode","fishTopoflow","childShapes","isChild","elementType","relationNode","findNodeById","relationId","childs","startNodeId","endNodeId","link","nodeId","retNode","url","creatOperation","pointPosition","totalLength","connectorPosition","li","FLOW_TYPE","LINK","RECT","IMAGE","TEXT","CIRCLE","SECTOR","RING","POLYGON","POLYLINE","LINE","BEZIERCURVE","ARC","SCENE","setUserData","getUserData","isRect","isImage","isText","isCircle","getType","config_default","thread","linkHead","linkNode","pool","emptyFn","tries","_helpers","setAttr","dataset","getAttr","initPool","notice","getNode","executeLink","onerror","appendNode","createNode","free","status","setSrc","shiftNode","getFree","setNode","srcs","g","success","task","tr","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","cssText","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","pathDataToString","cmdStr","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","transformFilter","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","fontStyle","fontFamily","variant","fontVariant","fontWeight","fontSize","family","body","ex","createTextNode","offsetWidth","fromTextEl","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","to","coords","textVmlElStyle","string","urn","win","vmlInited","namespaces","zrvml","initVML","styleSheets","createStyleSheet","addRule","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","vmlViewportStyle","currentStyle","notSupportedMethods"],"mappings":"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","file":"fish-topo-flow.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoFlow\"] = factory();\n\telse\n\t\troot[\"fishTopoFlow\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(96);\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 流程对象\r\n\t * @class fish.topo.FishTopoFlow\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event click\r\n\t * 节点或者线段的click事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"click\", function(event) {\r\n\t *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dblclick\r\n\t * 节点或者线段的双击事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"dblclick\", function(event) {\r\n\t *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event create\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          this.fishTopo.on(\"create\", function(e) {\r\n\t *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n\t *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n\t *               }\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event delete\r\n\t * 节点与线段创建完毕的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点删除完毕事件\r\n\t *          this.fishTopo.on(\"delete\", function(event) {\r\n\t *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event dropDrag\r\n\t * 节点移动完成的事件\r\n\t * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          //节点移动结束事件\r\n\t            this.fishTopo.on(\"dropDrag\", function(event) {\r\n\t                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n\t            });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mousedown\r\n\t * 节点与线段鼠标按下事件\r\n\t * @param {Object} event 事件 node为节点\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          node.on(\"mousedown\", function(){\r\n\t *              node.attr(\"style\",{text:\"mousedown\"});\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseup\r\n\t * 节点与线段鼠标抬起事件\r\n\t * @param {Object} event 事件 node为节点\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          node.on(\"mouseup\", function(){\r\n\t *              node.attr(\"style\",{text:\"mouseup\"});\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseover\r\n\t * 节点与线段鼠标悬浮事件\r\n\t * @param {Object} event 事件 node为节点\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          node.on(\"mouseover\", function(){\r\n\t *              node.attr(\"style\",{text:\"mouseover\"});\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mousemove\r\n\t * 节点与线段鼠标移动事件\r\n\t * @param {Object} event 事件 node为节点\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          node.on(\"mousemove\", function(){\r\n\t *              node.attr(\"style\",{text:\"mousemove\"});\r\n\t *          });\r\n\t */\r\n\t\r\n\t/**\r\n\t * @event mouseout\r\n\t * 节点与线段鼠标离开事件\r\n\t * @param {Object} event 事件 node为节点\r\n\t *\r\n\t * **使用范例**：\r\n\t *\r\n\t *      @example\r\n\t *          node.on(\"mouseout\", function(){\r\n\t *              node.attr(\"style\",{text:\"mouseout\"});\r\n\t *          });\r\n\t */\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Minimap = __webpack_require__(58);\r\n\t    var util = __webpack_require__(59);\r\n\t    var Point = __webpack_require__(60);\r\n\t    var ExtensionAPI = __webpack_require__(62);\r\n\t    var Eventful = __webpack_require__(11);\r\n\t    var zrender = __webpack_require__(63);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var GroupNode = __webpack_require__(75);\r\n\t    var OperationNode = __webpack_require__(82);\r\n\t    var FlowConnectionManager = __webpack_require__(83);\r\n\t    var forceInstance = __webpack_require__(89);\r\n\t    var treeLayout = __webpack_require__(91);\r\n\t    var FlowUtil = __webpack_require__(92);\r\n\t    var Constants = __webpack_require__(86);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var eventTool = __webpack_require__(69);\r\n\t    var Connector = __webpack_require__(77);\r\n\t    var LineOperationManager = __webpack_require__(93);\r\n\t    var Flow = __webpack_require__(94);\r\n\t    var textContain = __webpack_require__(23);\r\n\t    var ImagePool = __webpack_require__(95);\r\n\t\r\n\t    function FishTopoFlow(dom, opts) {\r\n\t        this.id;\r\n\t        this.group;\r\n\t        this._dom = dom;\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t        this.eagleEye = false;\r\n\t        this.eagleEyeNode;\r\n\t        this.initScaleRatio;\r\n\t        this.operationNode;\r\n\t        this.selectedNode = null;\r\n\t        this.allNodes = [];\r\n\t        this.minimap;\r\n\t        this._layoutTimeout = null;\r\n\t        this._zr = zrender.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t\r\n\t        this._api = new ExtensionAPI(this);\r\n\t        this.Shape = graphic;\r\n\t        this.model = new Model({});\r\n\t        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n\t        this.model.set(Constants.MODE, \"normal\");\r\n\t        this.options = opts;\r\n\t        Eventful.call(this);\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoFlow.prototype;\r\n\t\r\n\t    fishTopoProto.forceInstance = forceInstance;\r\n\t    fishTopoProto.treeLayout = treeLayout;\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的 dom 节点\r\n\t     * @return {HTMLElement}\r\n\t     */\r\n\t    fishTopoProto.getDom = function() {\r\n\t        return this._dom;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.getZr = function() {\r\n\t        return this._zr;\r\n\t    };\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的宽度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getWidth = function() {\r\n\t        return this._zr.getWidth();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取 fishTopo 实例容器的高度。\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getHeight = function() {\r\n\t        return this._zr.getHeight();\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 当前实例是否已经被释放。\r\n\t     * @return {boolean}\r\n\t     */\r\n\t    fishTopoProto.isDisposed = function() {\r\n\t        return this._disposed;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose instance\r\n\t     */\r\n\t    fishTopoProto.dispose = function() {\r\n\t        this._disposed = true;\r\n\t\r\n\t        this._zr.dispose();\r\n\t\r\n\t        instances[this.id] = null;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     * @param {number} width 宽度\r\n\t     * @param {number} height 高度\r\n\t     */\r\n\t    fishTopoProto.resize = function() {\r\n\t        this._zr.resize();\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 初始化\r\n\t     */\r\n\t    fishTopoProto.init = function() {\r\n\t        var that = this;\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t        FlowConnectionManager.connectors = [];\r\n\t        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n\t        this._zr.on(\"mouseup\", function(e) {\r\n\t            clearSelect(e);\r\n\t        });\r\n\t        function clearSelect(e){\r\n\t            if (that.operationNode) {\r\n\t                that.group.remove(that.operationNode);\r\n\t                that.operationNode = null;\r\n\t            }\r\n\t            var shape = e.target;\r\n\t            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n\t                return;\r\n\t            }\r\n\t            if (shape && shape.connector instanceof Connector) {\r\n\t                return;\r\n\t            }\r\n\t            FlowConnectionManager.clearSelectCon();\r\n\t            if (shape && shape.operation && shape.operation == true) {\r\n\t                return;\r\n\t            }\r\n\t            LineOperationManager.hideAllLineOperation();\r\n\t        }\r\n\t        this._zr.on(\"click\", function(e) {\r\n\t            var nodeTarget = e.target;\r\n\t            var shape;\r\n\t            if(nodeTarget){\r\n\t                shape = nodeTarget.model;\r\n\t            }\r\n\t            if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(shape))) {\r\n\t                return;\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = \"click\";\r\n\t            params.target = that;\r\n\t            that._api.trigger(params.type, params);\r\n\t        });\r\n\t        this.on('conPointsGroup:click', function(argument) {\r\n\t            LineOperationManager.bindOperation(argument.lineNode);\r\n\t        });\r\n\t\r\n\t        //polyfill remove\r\n\t        if (!('remove' in Element.prototype)) {\r\n\t            Element.prototype.remove = function() {\r\n\t                if (this.parentNode) {\r\n\t                    this.parentNode.removeChild(this);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 导出json\r\n\t     * @return {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.toJson = function() {\r\n\t        return FlowUtil.toJson(this.model, this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 导入json\r\n\t     * @param  {Object} json对象\r\n\t     */\r\n\t    fishTopoProto.fromJson = function(json) {\r\n\t        this.clear();\r\n\t        var model = new Model(json);\r\n\t        this.setBackground(model.get(Constants.BACKGROUND));\r\n\t        var layoutRootNode = [];\r\n\t        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n\t        for(var i = 0; i < layoutRootNode.length; i++){\r\n\t            console.log(layoutRootNode)\r\n\t            this.layoutNode(\"tree\", {\r\n\t                \"node\": layoutRootNode[i],\r\n\t                \"type\":layoutRootNode[i].treeType\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加节点\r\n\t     * @method addNode\r\n\t     * @param {Object} node creatNode返回的对象\r\n\t     */\r\n\t    fishTopoProto.addNode = function(node) {\r\n\t        if (node instanceof GroupNode) {\r\n\t            node.setProperties({\r\n\t                shape: {\r\n\t                    width: node.getBoundingRect().width,\r\n\t                    height: node.getBoundingRect().height\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t        this.group.add(node);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空当前实例，会移除实例中所有的节点与线\r\n\t     * @method clear\r\n\t     */\r\n\t    fishTopoProto.clear = function() {\r\n\t        for (var i = 0; i < this.allNodes.length; i++) {\r\n\t            var parentZr;\r\n\t            if (this.allNodes.parent) {\r\n\t                parentZr = this.allNodes.parent;\r\n\t            } else {\r\n\t                parentZr = this._zr;\r\n\t            }\r\n\t            FlowConnectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n\t        }\r\n\t        FlowConnectionManager.connectorMap.clear();\r\n\t        this.allNodes = [];\r\n\t        this.operationNode = null;\r\n\t        this.selectedNode = null;\r\n\t        FlowConnectionManager.connectors = [];\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this.group.isBg = true;\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的小图标操作\r\n\t     * @param {string} key 小图标的名称\r\n\t     * @param {Object} options 小图标的相关参数\r\n\t     * @param {String} [options.icon] 小图标路径\r\n\t     * @param {Object} [options.lineNode] 线段实例\r\n\t     * @param {Function} [options.callback] 点击后的回调\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *                  this.fishTopo.addIcon(\"icon1\", {\r\n\t     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n\t     *                      lineNode: lineNode,\r\n\t     *                      callback: function(lineNode) {\r\n\t     *                          alert(JSON.stringify(lineNode))\r\n\t     *                      },\r\n\t     *                  });\r\n\t     */\r\n\t    fishTopoProto.addIcon = function(key, options) {\r\n\t        LineOperationManager.addIcon(key, options, this.group, this._api);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连线的默认删除操作\r\n\t     * @param  {Object} lineNode 线\r\n\t     *\r\n\t     *  **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      fishTopo.lineDefaultIcon(lineNode);\r\n\t     */\r\n\t    fishTopoProto.lineDefaultIcon = function(lineNode) {\r\n\t        this.addLineDeleteIcon(lineNode);\r\n\t        this.addLineChangeIcon(lineNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 添加线的删除图标\r\n\t     */\r\n\t    fishTopoProto.addLineDeleteIcon = function(lineNode) {\r\n\t        var that = this;\r\n\t        var parentZr;\r\n\t        if (lineNode.parent) {\r\n\t            parentZr = lineNode.parent;\r\n\t        } else {\r\n\t            parentZr = this.group;\r\n\t        }\r\n\t        //创建删除\r\n\t        var lineOperation = LineOperationManager.addIcon(\"delete\", LineOperationManager.deleteIconObj(parentZr, lineNode), parentZr, this._api);\r\n\t        if (lineOperation) {\r\n\t            lineOperation.on(\"click\", function() {\r\n\t                that._triggerDeleteEvent(lineNode);\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 添加线的切换图标\r\n\t     */\r\n\t    fishTopoProto.addLineChangeIcon = function(lineNode) {\r\n\t        var that = this;\r\n\t        var parentZr;\r\n\t        if (lineNode.parent) {\r\n\t            parentZr = lineNode.parent;\r\n\t        } else {\r\n\t            parentZr = this.group;\r\n\t        }\r\n\t        var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n\t\r\n\t        function modifyNextLineType(line) {\r\n\t            var index = zrUtil.indexOf(arrLineType, line.options.style.lineType);\r\n\t            var nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n\t            //FlowConnectionManager.setModel(line,{style:{lineType:nextLineType}});\r\n\t            var startNode = line.startNode;\r\n\t            var endNode = line.endNode;\r\n\t\r\n\t            FlowConnectionManager.deleteLine(parentZr);\r\n\t            LineOperationManager.hideAllLineOperation();\r\n\t            zrUtil.merge(line.options.style ,{lineType: nextLineType} , true);\r\n\t            var nextLine = that._createConnectorByNodes(startNode, endNode,line.options)\r\n\t            nextLine.icons = line.icons;\r\n\t            nextLine.on('click', function() {\r\n\t                LineOperationManager.bindOperation(nextLine);\r\n\t            });\r\n\t            return nextLine;\r\n\t        }\r\n\t\r\n\t        //创建切换\r\n\t        LineOperationManager.addIcon(\"change\", {\r\n\t            icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII=\",\r\n\t            width: 15,\r\n\t            height: 15,\r\n\t            lineNode: lineNode,\r\n\t            callback: function() {\r\n\t\r\n\t                var selectedLine = modifyNextLineType(FlowConnectionManager.selConnector);\r\n\t                //.  LineOperationManager.bindOperation(selectedLine);\r\n\t            }\r\n\t        }, parentZr, this._api);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 初始化 操作的虚线框\r\n\t     */\r\n\t    fishTopoProto.initOperationNode = function(node) {\r\n\t        var that = this;\r\n\t        this.operationNode = new OperationNode(node, this.group);\r\n\t\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            //拖拽开始先把 箭头图标 给隐藏\r\n\t            var arrow = e.event.target;\r\n\t            arrow.hide();\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            var connector = FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);\r\n\t            that.group.add(connector);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        // 侦听 箭头 拖拽事件\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {\r\n\t            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n\t            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n\t            var arrow = e.event.target;\r\n\t            var rEndPoint = new Point(x, y);\r\n\t            FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        //侦听 箭头 拖拽结束事件 画线\r\n\t        this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {\r\n\t            e.cancelBubble = true;\r\n\t            var x = e.event.offsetX;\r\n\t            var y = e.event.offsetY;\r\n\t            var targetNode = null;\r\n\t            //拖拽结束先把 箭头图标 给显示\r\n\t            var arrow = e.event.target;\r\n\t            arrow.show();\r\n\t            //删除临时线\r\n\t            FlowConnectionManager.removeTempConnector(that.group);\r\n\t\r\n\t            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n\t            targetNode = findHover(that.allNodes, x, y);\r\n\t\r\n\t            function isHover(node, x, y) {\r\n\t                var cx, cy;\r\n\t                return node.rectContain(x, y);\r\n\t            }\r\n\t\r\n\t            function findHover(list, x, y, excludes) {\r\n\t                for (var i = list.length - 1; i >= 0; i--) {\r\n\t                    if (isExclude(excludes, list[i]) //list[i] !== exclude\r\n\t                        // getDisplayList may include ignored item in VML mode\r\n\t                        && !list[i].ignore && isHover(list[i], x, y)) {\r\n\t                        return list[i];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            function isExclude(excludes, node) {\r\n\t                return zrUtil.indexOf(excludes, node) == -1;\r\n\t            }\r\n\t\r\n\t            //2.如果找到目标结点 则画线\r\n\t            if (targetNode && (that.selectedNode != targetNode)) {\r\n\t                var connectOptions;\r\n\t                if(e.data){\r\n\t                    connectOptions = e.data;\r\n\t                }else{\r\n\t                    connectOptions = {\r\n\t                        style: {\r\n\t                            lineType: arrow.lineType\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t                that._createConnectorByNodes(that.selectedNode, targetNode, connectOptions);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        //删除按钮点击事件\r\n\t        this.operationNode.on(OperationNode.DELETE_CLICK, function() {\r\n\t            that._triggerDeleteEvent(that.selectedNode);\r\n\t            that.removeNode(that.selectedNode);\r\n\t            if (that.selectedNode.cmsImage) {\r\n\t                that._triggerDeleteEvent(that.selectedNode.cmsImage);\r\n\t                that.removeNode(that.selectedNode.cmsImage);\r\n\t            }\r\n\t        });\r\n\t        this.group.add(this.operationNode);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 移除场景中的某个节点\r\n\t     * @param  {Object} selectedNode 待删除的节点\r\n\t     */\r\n\t    fishTopoProto.removeNode = function(selectedNode) {\r\n\t        var that = this;\r\n\t        //1.如果是子节点 内 节点  则 调用子节点的删除\r\n\t        if (selectedNode.parent) {\r\n\t            selectedNode.parent.remove(selectedNode);\r\n\t        } else {\r\n\t            that.group.remove(selectedNode);\r\n\t        }\r\n\t        //2.从allNodes数组中删除\r\n\t        for (var i = 0; i < that.allNodes.length; i++) {\r\n\t            if (selectedNode.id == that.allNodes[i].id) {\r\n\t                that.allNodes.splice(i, 1);\r\n\t            }\r\n\t        }\r\n\t        FlowConnectionManager.deleteSelectCon(selectedNode, that.group);\r\n\t        if (that.operationNode) {\r\n\t            that.group.remove(that.operationNode);\r\n\t            that.operationNode = null;\r\n\t        }\r\n\t        FlowConnectionManager.clearSelectCon();\r\n\t        LineOperationManager.hideAllLineOperation();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发delete事件\r\n\t     */\r\n\t    fishTopoProto._triggerDeleteEvent = function(target) {\r\n\t        var eventParams = {};\r\n\t        eventParams.type = \"delete\";\r\n\t        eventParams.target = target;\r\n\t        this._api.trigger(eventParams.type, eventParams);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._createConnectorByNodes = function(startNode, endNode, options) {\r\n\t        var that = this;\r\n\t        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, options, this._api);\r\n\t        if (startNode.parent && endNode.parent) {\r\n\t            endNode.parent.add(connector);\r\n\t        } else {\r\n\t            this.group.add(connector);\r\n\t        }\r\n\t\r\n\t        connector.on(\"mousedown\", zrUtil.bind(function() {\r\n\t            FlowConnectionManager.connectorForbidEdit(!this.options.linkModify);\r\n\t            this.isNode = false;\r\n\t        }, this));\r\n\t        connector.on(\"dblclick\", function() {\r\n\t            if (that.options.isAllowEdit) {\r\n\t                that.connectorEdit(this);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._triggerCreateEvent(connector);\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发创建完成事件\r\n\t     */\r\n\t    fishTopoProto._triggerCreateEvent = function(target) {\r\n\t        var eventParams = {};\r\n\t        eventParams.type = \"create\";\r\n\t        eventParams.target = target;\r\n\t        this._api.trigger(eventParams.type, eventParams);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 派发移动完成事件\r\n\t     */\r\n\t    fishTopoProto._triggerDropDragEvent = function(target) {\r\n\t        var eventParams = {};\r\n\t        eventParams.type = \"dropDrag\";\r\n\t        eventParams.target = target;\r\n\t        this._api.trigger(eventParams.type, eventParams);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 鼠标点下 将操作框 移到对应的节点上\r\n\t     * @param  {Object} node [description]\r\n\t     * @param  {Object} sX   [description]\r\n\t     * @param  {Object} sY   [description]\r\n\t     * @return {Object}      [description]\r\n\t     */\r\n\t    fishTopoProto.nodeClickHandler = function(node, sX, sY) {\r\n\t        var that = this;\r\n\t        var node = node;\r\n\t        if (node.noSelected == true) {\r\n\t            return;\r\n\t        }\r\n\t        if (node.fromCmsImage) {\r\n\t            node = node.fromCmsImage;\r\n\t        }\r\n\t        // if(node instanceof GroupNode){\r\n\t        //     node = node.childOfName(\"Rect\");\r\n\t        // }\r\n\t        this.selectedNode = node;\r\n\t        var shapeRect = util.getRect(node);\r\n\t        if (!this.operationNode) {\r\n\t            this.initOperationNode(node);\r\n\t        }\r\n\t        // 在存在子流程的情况下 需要把node也传递一下\r\n\t        this.operationNode.refreshPostion(node, shapeRect);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * flow中最外层的group移动操作\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function() {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function(e) {\r\n\t            if ((e.target&&e.target.model) || (e.target && e.target.lineType && e.target.parent) || (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic.Circle)) {\r\n\t                return;\r\n\t            } else {\r\n\t                groupDragFunction(e);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function(e) {\r\n\t                moveDrag(e);\r\n\t            };\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX);\r\n\t                var sY = (e.event.clientY - startY);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                    if (that.eagleEye == true) {\r\n\t                        that.minimap.updataSelectionPosition(nowGroupPosition, that.nowZoom);\r\n\t                    }\r\n\t\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function(e) {\r\n\t                endDrag(e);\r\n\t            };\r\n\t\r\n\t            function endDrag() {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点的移动操作\r\n\t     */\r\n\t    fishTopoProto.drag = function(node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function(e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        function groupDragFunction(e) {\r\n\t            var isMove = 0;\r\n\t            node.startX = e.event.clientX;\r\n\t            node.startY = e.event.clientY;\r\n\t            var moveFunction = function(e) {\r\n\t                moveDrag(e);\r\n\t            };\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                e.cancelBubble = true;\r\n\t                var sX = (e.event.clientX - node.startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - node.startY) / (that.nowZoom);\r\n\t                // node.startX = e.event.clientX;\r\n\t                // node.startY = e.event.clientY;\r\n\t                if ((sX != 0) || (sY != 0)) {\r\n\t                    isMove = 1;\r\n\t                }\r\n\t                // node.drift(sX, sY, e);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //放入node现有数值，用于重绘group\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                }\r\n\t                nowGroupPosition[0] = groupPositionX + sX;\r\n\t                nowGroupPosition[1] = groupPositionY + sY;\r\n\t                node.attr(\"position\", nowGroupPosition);\r\n\t                if (node.alarm) {\r\n\t                    var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                    node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                }\r\n\t                if (node.cmsImage) {\r\n\t                    var newAlarmPosition1 = [nowGroupPosition[0], nowGroupPosition[1] - 8];\r\n\t                    node.cmsImage.attr(\"position\", newAlarmPosition1);\r\n\t                }\r\n\t                if (node.fromCmsImage) {\r\n\t                    var newAlarmPosition2 = [nowGroupPosition[0], nowGroupPosition[1] + 8];\r\n\t                    node.fromCmsImage.attr(\"position\", newAlarmPosition2);\r\n\t                }\r\n\t                that.nodeClickHandler(node, e.event.clientX, e.event.clientY);\r\n\t                FlowConnectionManager.refreshLineByNode(node);\r\n\t                if (node.fromCmsImage) {\r\n\t                    FlowConnectionManager.refreshLineByNode(node.fromCmsImage);\r\n\t                }\r\n\t                // if(that.eagleEye == true){\r\n\t                //     that.openEagleEye(that.eagleEyeNode);\r\n\t                // }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function(e) {\r\n\t                endDrag(e);\r\n\t            };\r\n\t            //拖拽结束\r\n\t            function endDrag() {\r\n\t                if (node.model) {\r\n\t                    node.model.set(\"options.position\", node.position);\r\n\t                }\r\n\t\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //布局重新计算\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\r\n\t                        \"node\": node,\r\n\t                        \"type\":node.treeType\r\n\t                    });\r\n\t                }\r\n\t                if (that.forceLayoutOption && (!that.forceLayoutOption.once)) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (zrUtil.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                if (isMove == 1) {\r\n\t                    that._triggerDropDragEvent(node);\r\n\t                    if (that.eagleEye == true) {\r\n\t                        that.openEagleEye(that.eagleEyeNode);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n\t     * @param  {Object} opt 节点选项\r\n\t     * @param {Array}  [opt.position] 节点的位置 eg. [x,y]\r\n\t     * @param {Object} [opt.style] 节点的样式\r\n\t     * @param {String} [opt.style.text] 节点下方（默认）显示的文字\r\n\t     * @param {String} [opt.style.fill] 节点的填充颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {String} [opt.style.stroke] 节点的描边颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {String} [opt.style.textFont] 设置文字的字体信息 eg. '14px Microsoft YaHei'\r\n\t     * @param {String} [opt.style.textFill] 设置文字的颜色值 eg. '#ffffff'\r\n\t     * @param {String} [opt.style.textPosition] 设置文字在节点中的位置 eg. 'top','right','bottom', 'left','inside'\r\n\t     * @param {String} [opt.mergedImage] 组合并后显示的图片（组特有的属性）\r\n\t     * @param {Object} [opt.layout] 节点tree布局属性（tree布局的节点才需要）\r\n\t     * @param {Number} [opt.layout.width] 结点的子节点之间的距离\r\n\t     * @param {Number} [opt.layout.height] 结点的子节点到结点的距离\r\n\t     * @param {Object} [opt.shape] 每种形状的值不一样 eg. 'Rect' shape:{width:100,height:100}\r\n\t     * @param {Array}  [opt.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除(删除支持自定义回调方法)、直线、折线、曲线（三种默认连线支持样式修改，格式参数和creatLink方法相同）4种图标，也可以自定图标 eg.\r\n\t     * <pre>\r\n\t     *          operationIcons: [{ name: 'DEL' },\r\n\t     *              {   name: 'STRAIGHT' ,\r\n\t                        options:{\r\n\t                            symbol: { type: \"arrow\", size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t                            style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: 0}, //样式\r\n\t                            text: {\r\n\t                                text: 123,\r\n\t                                color: '#ffffff',\r\n\t                            },\r\n\t                            z:10 //z为层级，功能等同于css 的z-index\r\n\t                        }\r\n\t                    },\r\n\t     *              { name: 'JAGGED' },\r\n\t     *              { name: 'CURVE' },\r\n\t     *              {\r\n\t     *                  name: \"custom1\",\r\n\t     *                  iconPath: \"img/host.png\",\r\n\t     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n\t     *              }\r\n\t     *          ]\r\n\t     * </pre>\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的节点对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var rect = this.fishTopo.creatNode(\"Rect\", { //矩形\r\n\t     *          shape: {\r\n\t     *              width: 100,\r\n\t     *              height: 60,\r\n\t     *          },\r\n\t     *          style: {\r\n\t     *              text: \"基本矩形\",\r\n\t     *              fill: \"#167CFF\",\r\n\t     *              stroke: \"rgb(255,255,255)\",\r\n\t     *              textFont: '14px Microsoft YaHei'\r\n\t     *          },\r\n\t     *          position: [180, 100],\r\n\t     *          operationIcons: [{ name: 'DEL' },\r\n\t     *              { name: 'STRAIGHT' },\r\n\t     *              { name: 'JAGGED' },\r\n\t     *              { name: 'CURVE' },\r\n\t     *              {\r\n\t     *                  name: \"custom1\",\r\n\t     *                  iconPath: \"img/host.png\",\r\n\t     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n\t     *              }\r\n\t     *          ]\r\n\t     *      });\r\n\t     */\r\n\t    fishTopoProto.creatNode = function(type, opt, userData) {\r\n\t        var that = this;\r\n\t        //设置模型 给json序列化用\r\n\t        var model = new Model({});\r\n\t        model.set(Constants.ELEMENT_TYPE, type);\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n\t        model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n\t        if (\"draggable\" in opt) {\r\n\t            opt.isdraggable = opt.draggable;\r\n\t            delete opt.draggable;\r\n\t        }\r\n\t\r\n\t        if (!opt.z) {\r\n\t            opt.z = 1; //节点Z为1 线段为0;\r\n\t        }\r\n\t        var node = null;\r\n\t        //根据参数dom不同创建不同的节点\r\n\t        switch (type) {\r\n\t            case \"Rect\":\r\n\t                node = new this.Shape.Rect(opt);\r\n\t                break;\r\n\t            case \"Group\":\r\n\t                node = new GroupNode(opt);\r\n\t                if (opt.mergedImage) {\r\n\t                    var imageShape = new this.Shape.Image({\r\n\t                        style: {\r\n\t                            image: opt.mergedImage,\r\n\t                            // width: width,\r\n\t                            // height: height,\r\n\t                            text: opt.style.text,\r\n\t                            textPosition: 'bottom'\r\n\t                        },\r\n\t                        position: [-5000, -5000]\r\n\t\r\n\t                    });\r\n\t                    this.drag(imageShape);\r\n\t                    node.relationImage = imageShape;\r\n\t                    that.group.add(imageShape);\r\n\t                    setTimeout(function() {\r\n\t                        imageShape.hide();\r\n\t                    }, 300);\r\n\t\r\n\t                    node.on(\"dblclick\", function(e) {\r\n\t                        node.merged(e)\r\n\t                    });\r\n\t                }\r\n\t                break;\r\n\t            case \"Image\":\r\n\t                node = new this.Shape.Image(opt);\r\n\t                break;\r\n\t            case \"Text\":\r\n\t                node = new this.Shape.Text(opt);\r\n\t                break;\r\n\t            case \"Circle\":\r\n\t                node = new this.Shape.Circle(opt);\r\n\t                break;\r\n\t            case \"Sector\":\r\n\t                node = new this.Shape.Sector(opt);\r\n\t                break;\r\n\t            case \"Ring\":\r\n\t                node = new this.Shape.Ring(opt);\r\n\t                break;\r\n\t            case \"Polygon\":\r\n\t                node = new this.Shape.Polygon(opt);\r\n\t                break;\r\n\t            case \"Polyline\":\r\n\t                node = new this.Shape.Polyline(opt);\r\n\t                break;\r\n\t            case \"Line\":\r\n\t                node = new this.Shape.Line(opt);\r\n\t                break;\r\n\t            case \"BezierCurve\":\r\n\t                node = new this.Shape.BezierCurve(opt);\r\n\t                break;\r\n\t            case \"Arc\":\r\n\t                node = new this.Shape.Arc(opt);\r\n\t                break;\r\n\t        }\r\n\t        this.drag(node);\r\n\t\r\n\t        node.attr(\"operationIcons\", opt.operationIcons);\r\n\t\r\n\t        //侦听节点的click dblclick事件，选中，并派发出去\r\n\t        node.on('click', function(e) {\r\n\t            var nowNode;\r\n\t            if (node.fromCmsImage) {\r\n\t                nowNode = node.fromCmsImage;\r\n\t            } else {\r\n\t                nowNode = this;\r\n\t            }\r\n\t            that.nodeClickHandler(nowNode, e.event.clientX, e.event.clientY);\r\n\t\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = 'click';\r\n\t            params.target = nowNode;\r\n\t            that._api.trigger(params.type, params);\r\n\t\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        node.on('dblclick', function(e) {\r\n\t            var nowNode;\r\n\t            if (node.fromCmsImage) {\r\n\t                nowNode = node.fromCmsImage;\r\n\t            } else {\r\n\t                nowNode = this;\r\n\t            }\r\n\t            if (!nowNode.style || (typeof nowNode.style.isAllowEdit == \"undefined\")) {\r\n\t                if (that.options.isAllowEdit) {\r\n\t                    that.nodeEdit(nowNode);\r\n\t                }\r\n\t            } else {\r\n\t                if (nowNode.style.isAllowEdit) {\r\n\t                    that.nodeEdit(nowNode);\r\n\t                }\r\n\t            }\r\n\t            var params = {};\r\n\t            params.event = e;\r\n\t            params.type = 'dblclick';\r\n\t            params.target = node;\r\n\t            that._api.trigger(params.type, params);\r\n\t\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t\r\n\t        this.allNodes.push(node);\r\n\t        if (opt.id) {\r\n\t            model.set(Constants.ID, opt.id);\r\n\t        } else {\r\n\t            model.set(Constants.ID, util.getUUID());\r\n\t        }\r\n\t\r\n\t        node.model = model;\r\n\t\r\n\t        this._triggerCreateEvent(node);\r\n\t        return node;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据name获取节点\r\n\t     * @param  {String} name 在创建节点中  name属性设置的值\r\n\t     * @return {Object}      name对应的节点\r\n\t     */\r\n\t    fishTopoProto.childOfName = function(name) {\r\n\t        var arrResult = [];\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = FlowConnectionManager.connectors;\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenNode[i]);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n\t                arrResult.push(childrenLine[j]);\r\n\t            }\r\n\t        }\r\n\t        if (arrResult.length > 1) {\r\n\t            return arrResult;\r\n\t        } else {\r\n\t            return arrResult[0];\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });\r\n\t     * @param  {Function} cb      回调函数\r\n\t     * @param  {Object}   context 回调函数执行的上下文\r\n\t     * @return {Array}           返回查找到的对象\r\n\t     */\r\n\t    fishTopoProto.findElements = function(cb, context) {\r\n\t        var childrenNode = this.allNodes;\r\n\t        var childrenLine = FlowConnectionManager.connectors;\r\n\t        var arr = [];\r\n\t        for (var i = 0; i < childrenNode.length; i++) {\r\n\t            var child = childrenNode[i];\r\n\t            if (cb.call(context, child, i)) {\r\n\t                arr.push(child);\r\n\t            }\r\n\t        }\r\n\t        for (var j = 0; j < childrenLine.length; j++) {\r\n\t            var childL = childrenLine[j];\r\n\t            if (cb.call(context, childL, j)) {\r\n\t                arr.push(childL);\r\n\t            }\r\n\t        }\r\n\t        return arr;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置背景色  或 背景图片\r\n\t     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n\t     */\r\n\t    fishTopoProto.setBackground = function(imageUrl) {\r\n\t        var that = this;\r\n\t        if (imageUrl && imageUrl.length > 0) {\r\n\t            this.model.set(Constants.BACKGROUND, imageUrl);\r\n\t            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    that._dom.style.backgroundColor = imageUrl;\r\n\t                } else {\r\n\t                    var imageShape = new this.Shape.Rect({\r\n\t                        shape: {\r\n\t                            width: that._zr.getWidth(),\r\n\t                            height: that._zr.getHeight()\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: imageUrl\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    that._zr.add(imageShape);\r\n\t                }\r\n\t\r\n\t            } else if(imageUrl == \"gridLine\" ){\r\n\t                this.gridLineGroup = new graphic.Group();\r\n\t                this.gridLine(0.2);\r\n\t                this._zr.add(this.gridLineGroup);\r\n\t            }else{\r\n\t                if (!document.createElement('canvas').getContext) {\r\n\t                    that._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n\t                    that._dom.style.backgroundRepeat = \"repeat\";\r\n\t                } else {\r\n\t                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n\t                        position: [0, 0],\r\n\t                        scale: [1, 1],\r\n\t                        style: {\r\n\t                            x: 0,\r\n\t                            y: 0,\r\n\t                            image: imageUrl,\r\n\t                            width: this._zr.getWidth(),\r\n\t                            height: this._zr.getHeight()\r\n\t                        },\r\n\t                        cursor: 'default',\r\n\t                        z: -1\r\n\t                    });\r\n\t                    that._zr.add(imageShape1);\r\n\t                }\r\n\t\r\n\t            }\r\n\t\r\n\t        }\r\n\t\r\n\t    };\r\n\t    //背景网格线\r\n\t    fishTopoProto.gridLine = function(opacity) {\r\n\t        var pixel = 10;\r\n\t        var widthLen = parseInt(this.getWidth() / pixel);\r\n\t        for (var x = 0; x <= widthLen; x++) {\r\n\t            var lineX = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: x * pixel,\r\n\t                    y1: 0,\r\n\t                    x2: x * pixel,\r\n\t                    y2: this.getHeight()\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineX);\r\n\t        }\r\n\t\r\n\t        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n\t        for (var y = 0; y <= heightLen; y++) {\r\n\t            var lineY = new graphic.Line({\r\n\t                shape: {\r\n\t                    x1: 0,\r\n\t                    y1: y * pixel,\r\n\t                    x2: this.getWidth(),\r\n\t                    y2: y * pixel\r\n\t                },\r\n\t                style: {\r\n\t                    lineDash: [1],\r\n\t                    opacity: opacity\r\n\t                },\r\n\t                z: 0,\r\n\t                draggable: false,\r\n\t                cursor: 'default'\r\n\t            });\r\n\t            this.gridLineGroup.add(lineY);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建线段\r\n\t     * @method creatLink\r\n\t     * @param  {Object} startNode 开始节点\r\n\t     * @param  {Object} endNode   结束节点\r\n\t     * @param  {Object} options 线段选项\r\n\t     * @param {Object} [options.style] 节点的样式\r\n\t     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n\t     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n\t     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n\t     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n\t     * @param {Object} [options.symbol] 线段的箭头\r\n\t     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n\t     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n\t     * @param {Object} [options.text] 线段上的文字\r\n\t     * @param {String} [options.text.text] 线段上的文字内容\r\n\t     * @param {String} [options.text.color] 线段上的文字颜色\r\n\t     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n\t     * @param {String} [options.text.xOffset] 文字位置x偏移量\r\n\t     * @param {String} [options.pos] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n\t     * @param {String} [options.position] 指定线段位置\r\n\t     * @param {Object} [options.effect] 线上动态效果\r\n\t     * @param {String} [options.effect.show] 是否显示箭头动效\r\n\t     * @param {Number} [options.effect.period] 动效移动速度\r\n\t     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度\r\n\t     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组\r\n\t     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n\t     * @param {Object} userData 用户传递的业务数据\r\n\t     * @return {Object} 创建的线段对象\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *      var link = me.fishTopo.creatLink(startNode, endNode, {\r\n\t     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n\t     *              text: {\r\n\t     *                  text: text,\r\n\t     *                  color: '#ffffff',\r\n\t     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n\t     *                  xOffset:10, //文字位置x偏移量\r\n\t     *              },\r\n\t     *              pos:'right,left',\r\n\t     *              effect: {\r\n\t                        show: true,//是否显示箭头动效\r\n\t                        period: 6,//箭头速度\r\n\t                    },\r\n\t     *              position:{\r\n\t     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n\t     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n\t     *              }\r\n\t     *          });\r\n\t     */\r\n\t    fishTopoProto.creatLink = function(startNode, endNode, options, userData) {\r\n\t        var that = this;\r\n\t        options.isEdit = !!this.options.linkModify;\r\n\t        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, options, this._api);\r\n\t        connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n\t        connector.on(\"dblclick\", function() {\r\n\t            if (typeof this.options.text.isAllowEdit == \"undefined\") {\r\n\t                if (that.options.isAllowEdit) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            } else {\r\n\t                if (this.options.text.isAllowEdit) {\r\n\t                    that.connectorEdit(this);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            // if(this.style.isAllowEdit){\r\n\t            //     that.connectorEdit(this);\r\n\t            // }else if(that.options.isAllowEdit){\r\n\t            //     that.connectorEdit(this);\r\n\t            // }\r\n\t            // if(this.style.isAllowEdit ? this.style.isAllowEdit : that.options.isAllowEdit){\r\n\t            //     that.connectorEdit(this);\r\n\t            // }\r\n\t        });\r\n\t        return connector;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 线上文字编辑\r\n\t     */\r\n\t    fishTopoProto.connectorEdit = function(thisConnector) {\r\n\t        var that = this;\r\n\t        var lineText = thisConnector.childOfName('lineText');\r\n\t        if (!lineText) {\r\n\t            return;\r\n\t        }\r\n\t        var textarea = that.creatTextArea();\r\n\t        textarea.style.width = 1.1 * util.getRect(lineText).width * that.nowZoom + \"px\";\r\n\t        textarea.style.height = (util.getRect(lineText).height || 12) * that.nowZoom + \"px\";\r\n\t        textarea.style.border = \"1px solid #000000\";\r\n\t        textarea.innerHTML = lineText.style.text;\r\n\t        thisConnector.setStyle({text:{text:\"\"}})\r\n\t        that._dom.appendChild(textarea);\r\n\t        that._dom.style.position = \"relative\";\r\n\t        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n\t        textarea.style.lineHeight = (textRect.lineHeight || 14) + \"px\";\r\n\t        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * that.nowZoom + that.group.position[1] + \"px\";\r\n\t        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * that.nowZoom + that.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        $(textarea).on(\"keyup\", zrUtil.bind(function(e) {\r\n\t            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n\t            that.textareaResize(textRect, textarea, e);\r\n\t        }, this));\r\n\t        $(textarea).on(\"focusout\", zrUtil.bind(function() {\r\n\t            thisConnector.setStyle({\r\n\t                text: {\r\n\t                    text: textarea.value || \"\"\r\n\t                }\r\n\t            })\r\n\t            textarea.remove();\r\n\t        }, this))\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     * 节点上文字编辑\r\n\t     */\r\n\t    fishTopoProto.nodeEdit = function(thisNode) {\r\n\t        var that = this;\r\n\t        var textarea = that.creatTextArea();\r\n\t        var nodeText = thisNode.style.text;\r\n\t        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n\t        textarea.style.width = 1.2 * textRect.width * that.nowZoom + \"px\";\r\n\t        textarea.style.height = (1.2 *textRect.height||12) * that.nowZoom + \"px\";\r\n\t        var nodeRect = util.getRect(thisNode);\r\n\t        textarea.style.maxWidth = 1.2*nodeRect.width * that.nowZoom + \"px\";\r\n\t        textarea.style.lineHeight = (1.2 *textRect.lineHeight || 12) + \"px\";\r\n\t        textarea.style.border = \"1px solid #000000\";\r\n\t        textarea.innerHTML = thisNode.style.text;\r\n\t        that.setStyle(thisNode,{text:\"\"})\r\n\t        that._dom.appendChild(textarea);\r\n\t        that._dom.style.position = \"relative\";\r\n\t        var offestI = 1;\r\n\t        if (thisNode.style.textAlign == \"left\") {\r\n\t            offestI = 0;\r\n\t        }\r\n\t        if (thisNode.style.textAlign == \"right\") {\r\n\t            offestI = 2;\r\n\t        }\r\n\t        var offestP = 0;\r\n\t        if(thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\"){\r\n\t            offestP = 1;\r\n\t            textarea.style.maxWidth = 3*1.1*nodeRect.width * that.nowZoom + \"px\";\r\n\t        }\r\n\t        if(thisNode.style.textPosition && thisNode.style.textPosition == \"top\"){\r\n\t            offestP = -1;\r\n\t            textarea.style.maxWidth = 3*1.1*nodeRect.width * that.nowZoom + \"px\";\r\n\t        }\r\n\t        textarea.style.top = (nodeRect.y - textRect.height / 2 + offestP*(nodeRect.height-textRect.height / 2)) * that.nowZoom + that.group.position[1] + \"px\";\r\n\t        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * that.nowZoom + that.group.position[0] + \"px\";\r\n\t        textarea.focus();\r\n\t        textarea.select();\r\n\t        $(textarea).on(\"keyup\", zrUtil.bind(function(e) {\r\n\t            var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n\t            that.textareaResize(textRect, textarea, textarea.style.maxWidth);\r\n\t        }, this))\r\n\t        $(textarea).on(\"focusout\", zrUtil.bind(function() {\r\n\t            var text = that.handleWrap(textarea.value, textarea.style.maxWidth);\r\n\t            that.setStyle(thisNode,{text:text})\r\n\t            textarea.remove();\r\n\t        }, this))\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 创建文本域\r\n\t     */\r\n\t    fishTopoProto.creatTextArea = function() {\r\n\t        var textarea = document.createElement(\"textarea\");\r\n\t        textarea.style.position = \"absolute\";\r\n\t        textarea.style.overflow = \"hidden\";\r\n\t        textarea.style.border = \"0\";\r\n\t        textarea.style.padding = \"0\";\r\n\t        //textarea.style.resize = \"none\";\r\n\t        return textarea;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 处理textarea自动换行\r\n\t     */\r\n\t    fishTopoProto.handleWrap = function(value, width) {\r\n\t        var spanNode = document.createElement(\"span\");\r\n\t        spanNode.style.position = \"absolute\";\r\n\t        spanNode.style.overflow = \"hidden\";\r\n\t        spanNode.style.border = \"0\";\r\n\t        spanNode.style.padding = \"0\";\r\n\t        spanNode.style.left = \"0\";\r\n\t        spanNode.style.top = \"0\";\r\n\t        this._dom.appendChild(spanNode);\r\n\t        var content = value.split(\"\\n\");\r\n\t        var result = \"\";\r\n\t        $.each(content, function(i, val) {\r\n\t            var valLength = val.length;\r\n\t            if (valLength == 0) {\r\n\t                //result += \"\\n\";\r\n\t            } else {\r\n\t                var pre = \"\",\r\n\t                    innerVal, tempWidth, conWidth;\r\n\t                for (var innerI = 0; innerI < valLength; innerI++) {\r\n\t                    innerVal = val.charAt(innerI);\r\n\t                    $(spanNode).text($(spanNode).text() + innerVal);\r\n\t                    tempWidth = $(spanNode).width(); //获取添加字符后隐藏域的宽度\r\n\t                    conWidth = Number(width.substring(0, width.length - 2));\r\n\t                    if (tempWidth > conWidth) {\r\n\t                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n\t                        result += \"\\n\";\r\n\t                        $(spanNode).text(innerVal);\r\n\t                        pre = innerVal;\r\n\t                    } else if (innerI == valLength - 1) {\r\n\t                        result += pre + innerVal; //最后一个字符\r\n\t                        if(i < content.length-1){\r\n\t                            result += \"\\n\";\r\n\t                        }\r\n\t                        $(spanNode).text(\"\");\r\n\t                        pre = \"\";\r\n\t                    } else {\r\n\t                        pre += innerVal; //依次追加到pre变量中\r\n\t                    }\r\n\t\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t        this._dom.removeChild(spanNode);\r\n\t        return result;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 文本域自适应高宽\r\n\t     */\r\n\t    fishTopoProto.textareaResize = function(textRect, textarea ,width) {\r\n\t        var that = this;\r\n\t        var minWidth;\r\n\t        textarea.style.width = 0;\r\n\t        textarea.style.width = (1.1 * textRect.width) * that.nowZoom + \"px\";\r\n\t        if(width<60){\r\n\t            minWidth = width;\r\n\t        }else{\r\n\t            minWidth = 60\r\n\t        }\r\n\t        if (textRect.width <= minWidth) {\r\n\t            textarea.style.width = minWidth+\"px\";\r\n\t        }\r\n\t        textarea.style.height = \"0px\";\r\n\t        textarea.style.height = textarea.scrollHeight + 'px';\r\n\t        if (textarea.scrollHeight <= 0) {\r\n\t            textarea.style.height = \"12px\";\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setStyle\r\n\t     * 节点更改style里的属性\r\n\t     * @param {String} name 节点style里的某个属性名称\r\n\t     * @param {String} string 节点style里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //节点设置文字\r\n\t     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n\t     */\r\n\t    fishTopoProto.setStyle = function(node,options){\r\n\t        node.setStyle(options);\r\n\t        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @method setShape\r\n\t     * 节点更改shape里的属性\r\n\t     * @param {String} name 节点shape里的某个属性名称\r\n\t     * @param {String} string 节点shape里的某个属性名称对应的值\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          //矩形节点设置宽\r\n\t     *         fishtopo.setShape(node,{width:100});\r\n\t     */\r\n\t    fishTopoProto.setShape = function(node,options){\r\n\t        node.setShape(options);\r\n\t        zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 创建节点上面的警告\r\n\t     * @method creatAlarm\r\n\t     * @param  {Object} node 节点\r\n\t     * @param  {Object} opt  选项值\r\n\t     * @param  {Object} [opt.text] 警告的文字\r\n\t     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n\t     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n\t     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n\t     * @return {Object} 返回节点上的警告\r\n\t     *\r\n\t     * **使用范例**：\r\n\t     *\r\n\t     *      @example\r\n\t     *          this.fishTopo.creatAlarm(s1,{\r\n\t     *          text:\"2 W\",\r\n\t     *          textFont:\"4px Microsoft YaHei\",\r\n\t     *          textFill:\"#FFFFFF\",\r\n\t     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n\t     *      });//创建小图片和节点绑定\r\n\t     */\r\n\t    fishTopoProto.creatAlarm = function(node, opt) {\r\n\t        var group = this.creatNode(\"Group\", {\r\n\t            style: {\r\n\t                fill: 'rgba(0,0,0,0)',\r\n\t                stroke: 'rgba(0,0,0,0)'\r\n\t            }\r\n\t        });\r\n\t        group.isdraggable = false;\r\n\t        var text = this.creatNode(\"Text\", { //文字\r\n\t            style: {\r\n\t                text: opt.text,\r\n\t                textFont: opt.textFont,\r\n\t                fill: opt.textFill,\r\n\t                textBaseline: \"top\" //垂直对齐,\r\n\t            },\r\n\t            noSelected: true,\r\n\t            position: [2, 0],\r\n\t            z: 2\r\n\t        });\r\n\t        text.isdraggable = false;\r\n\t        group.add(text);\r\n\t        if (node.parent && node.parent instanceof GroupNode) {\r\n\t            node.parent.add(group);\r\n\t        } else {\r\n\t            this.group.add(group);\r\n\t        }\r\n\t        var groupWidth = group.getBoundingRect().width + 2;\r\n\t        var groupHeight = group.getBoundingRect().height + 6;\r\n\t        var points = [\r\n\t            [0, 0],\r\n\t            [groupWidth, 0],\r\n\t            [groupWidth, groupHeight],\r\n\t            [groupWidth - 3, groupHeight],\r\n\t            [groupWidth - 6, groupHeight + 3],\r\n\t            [groupWidth - 9, groupHeight],\r\n\t            [0, groupHeight],\r\n\t            [0, 0]\r\n\t        ];\r\n\t        var Polyline = this.creatNode(\"Polyline\", {\r\n\t            shape: {\r\n\t                points: points\r\n\t            },\r\n\t            style: {\r\n\t                fill: opt.textBackground,\r\n\t                stroke: opt.textBackground\r\n\t            },\r\n\t            noSelected: true,\r\n\t            z: 1\r\n\t        });\r\n\t        Polyline.isdraggable = false;\r\n\t        group.add(Polyline);\r\n\t        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width - 6), node.position[1] - group.getBoundingRect().height - 3];\r\n\t        group.attr(\"position\", groupPosition);\r\n\t        node.alarm = group;\r\n\t        //设置模型 给json序列化用\r\n\t        var model = new Model({});\r\n\t        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n\t        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n\t        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n\t        group.model = model;\r\n\t        return group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建Cms节点\r\n\t     * @method creatCmsRect\r\n\t     * @param  {Object} node 节点\r\n\t     */\r\n\t    fishTopoProto.creatCmsRect = function(node) {\r\n\t        var that = this;\r\n\t        //node.noSelected = true;\r\n\t        var width, height;\r\n\t        if (node.style) {\r\n\t            width = node.style.width || 40;\r\n\t            height = node.style.height || 48;\r\n\t        } else {\r\n\t            width = node.options.style.width || 40;\r\n\t            height = node.options.style.height || 48;\r\n\t        }\r\n\t        var rect = this.creatNode(\"Rect\", { //矩形\r\n\t            shape: {\r\n\t                width: 100 + width,\r\n\t                height: height - 8,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                isAllowEdit: true,\r\n\t                text: node.model.get(\"options.style.text\"),\r\n\t                fill: \"#FFFFFF\",\r\n\t                textFont: node.model.get(\"options.style.textFont\") || '14px Microsoft YaHei',\r\n\t                textAlign: \"left\"\r\n\t            },\r\n\t            z: 1,\r\n\t            position: [node.position[0], node.position[1] + 8],\r\n\t            draggable: node.draggable, //禁止拖动\r\n\t            operationIcons: node.operationIcons\r\n\t        });\r\n\t        var nodeText = node.childOfName('Rect');\r\n\t        nodeText.attr(\"style\", {\r\n\t            \"text\": \"\"\r\n\t        });\r\n\t        node.attr(\"z\", 2);\r\n\t        node.attr(\"draggable\", false);\r\n\t        node.operationIcons = null;\r\n\t        this.addNode(rect);\r\n\t        rect.cmsImage = node;\r\n\t        node.fromCmsImage = rect;\r\n\t        node._children[1].fromCmsImage = rect;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 自动布局\r\n\t     * @param  {String} type 节点\r\n\t     * @param  {Object} option 选项\r\n\t     * @param  {Object} [option.node] tree布局为起点的节点（只有tree布局有）\r\n\t     * @param  {String} [option.type] tree布局的类型，horizontal为横向，vertical为竖向，默认为vertical\r\n\t     * @param  {Number} [option.repulsion] 力导向布局的类型，节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n\t     * @param  {Number} [option.gravity] 力导向布局的类型，节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n\t     * @param  {Number} [option.gravity] 力导向布局的类型，边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n\t     * @param  {Number} [option.width] 力导向布局的类型, 布局画布的宽度 默认为整个画布的宽度\r\n\t     * @param  {Number} [option.height] 力导向布局的类型, 布局画布的高度 默认为整个画布的高度\r\n\t     * @param  {Boolean} [option.once] 只执行一次布局，移动节点不自动布局，默认为false（只有力导向布局有）\r\n\t     */\r\n\t    fishTopoProto.layoutNode = function(type, option) {\r\n\t        if (type == \"tree\") {\r\n\t            if (option.node.parent && option.node.parent instanceof GroupNode) {\r\n\t                option.node.parent.eachChild(function(child) {\r\n\t                    child.isdraggable = false;\r\n\t                });\r\n\t            }\r\n\t            this.treeLayout(option);\r\n\t        } else if (type == \"force\") {\r\n\t            var defaultOptions = {\r\n\t                allNodes: this.allNodes,\r\n\t                allCons: FlowConnectionManager.connectors,\r\n\t                repulsion: 100,\r\n\t                gravity: 0.1,\r\n\t                edgeLength: 30,\r\n\t                once: false,\r\n\t                width: this.getWidth(),\r\n\t                height: this.getHeight(),\r\n\t                forceLayout: null,\r\n\t                preservedPoints: {}\r\n\t            };\r\n\t\r\n\t            this.forceLayoutOption = zrUtil.defaults(defaultOptions, option, true);\r\n\t            this.forceLayoutOption.rect = new graphic.BoundingRect(0, 0, this.forceLayoutOption.width, this.forceLayoutOption.height);\r\n\t\r\n\t            this.forceInstance(this.forceLayoutOption);\r\n\t\r\n\t            this.startForceLayoutIteration(this.forceLayoutOption.forceLayout, true);\r\n\t\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 开始进行力导向迭代\r\n\t     * @param  {Object} forceLayout     [力导向对象]\r\n\t     * @param  {Boolean} layoutAnimation [是否动画]\r\n\t     * @return {void}\r\n\t     */\r\n\t    fishTopoProto.startForceLayoutIteration = function(forceLayout, layoutAnimation) {\r\n\t        var self = this;\r\n\t        (function step() {\r\n\t            forceLayout.step(function (stopped) {\r\n\t                self._layouting = !stopped;\r\n\t                if (self._layouting) {\r\n\t                    if (layoutAnimation) {\r\n\t                        self._layoutTimeout = setTimeout(step, 16)\r\n\t                    } else {\r\n\t                        step();\r\n\t                    }\r\n\t                }\r\n\t            })\r\n\t        })();\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     * 返回当前画布的数据\r\n\t     */\r\n\t    fishTopoProto.toDataURL = function(opts) {\r\n\t        return FlowUtil.toDataURL(this._zr, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     * 初始化缩放\r\n\t     */\r\n\t    fishTopoProto.initScale = function() {\r\n\t        var that = this;\r\n\t        var groupMaxWidth = that.group.getBoundingRect().width;\r\n\t        var groupMaxHeight = that.group.getBoundingRect().height;\r\n\t        var rangeWidth = that.getWidth();\r\n\t        var rangeHeight = that.getHeight();\r\n\t        var initRatio = 1,\r\n\t            pos = [];\r\n\t        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n\t            if (groupMaxWidth > rangeWidth) {\r\n\t                initRatio = rangeWidth / groupMaxWidth;\r\n\t            }\r\n\t        } else {\r\n\t            if (groupMaxHeight > rangeHeight) {\r\n\t                initRatio = rangeHeight / groupMaxHeight;\r\n\t            }\r\n\t        }\r\n\t        pos[0] = Math.abs(that.group.getBoundingRect().x) * initRatio;\r\n\t        pos[1] = Math.abs(that.group.getBoundingRect().y) * initRatio;\r\n\t        that.group.attr(\"position\", [pos[0], pos[1]]);\r\n\t        that.group.attr(\"scale\", [initRatio, initRatio]);\r\n\t        that.initScaleRatio = initRatio;\r\n\t        var distance = [pos[0], pos[1], that.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 放大或者缩小\r\n\t     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n\t     */\r\n\t    fishTopoProto.zrScale = function(type) {\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta1 = -0.07;\r\n\t                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (!isNaN(type)) {\r\n\t                var target = this.group;\r\n\t                if (target) {\r\n\t                    var zoomScale = type;\r\n\t                    this._zoom = type;\r\n\t                    this.nowZoom = type;\r\n\t                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            this._zr.on('mousewheel', zrUtil.bind(function(e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n\t                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }, this));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.zoom = function(zoomDelta, zoomX, zoomY) {\r\n\t        if (this.canScale == false) {\r\n\t            return;\r\n\t        }\r\n\t        var target = this.group;\r\n\t        if (target) {\r\n\t\r\n\t            var newZoom = this._zoom = this._zoom || 1;\r\n\t            newZoom += zoomDelta;\r\n\t\r\n\t            newZoom = Number(newZoom.toFixed(2));\r\n\t            var zoomScale = newZoom / this._zoom;\r\n\t            if (newZoom > 1.7 || newZoom < 0.3) {\r\n\t                return;\r\n\t            }\r\n\t            this._zoom = newZoom;\r\n\t\r\n\t            this.nowZoom = newZoom;\r\n\t            this.setScale(zoomX, zoomY, zoomScale);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.setScale = function(zoomX, zoomY, zoomScale) {\r\n\t        var target = this.group;\r\n\t        var pos = target.position;\r\n\t        var scale = target.scale;\r\n\t        // Keep the mouse center when scaling\r\n\t        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t        scale[0] *= zoomScale;\r\n\t        scale[1] *= zoomScale;\r\n\t        target.attr(\"position\", [pos[0], pos[1]]);\r\n\t        target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t        if (this.eagleEye == true) {\r\n\t            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 鹰眼图\r\n\t     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n\t     */\r\n\t    fishTopoProto.openEagleEye = function(eagleEyeNode) {\r\n\t        var that = this;\r\n\t        this.eagleEye = true;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        var groupPosition = zrUtil.clone(this.group.position);\r\n\t        var groupScale = zrUtil.clone(this.group.scale);\r\n\t        this.group.attr(\"position\", [0, 0]);\r\n\t        this.group.attr(\"scale\", [1, 1]);\r\n\t        var distance = this.initScale();\r\n\t        var imgSrc = this.toDataURL();\r\n\t        this.group.attr(\"position\", groupPosition);\r\n\t        this.group.attr(\"scale\", groupScale);\r\n\t        if (this.minimap) {\r\n\t            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n\t        } else {\r\n\t            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(), eagleEyeNode, distance, imgSrc);\r\n\t            setTimeout(zrUtil.bind(function() {\r\n\t                this.openEagleEye(that.eagleEyeNode)\r\n\t            }, this), 10);\r\n\t        }\r\n\t        that.minimap.selection.addEventListener(\"mousedown\", function(e) {\r\n\t            var startX = e.clientX;\r\n\t            var startY = e.clientY;\r\n\t            var minimapLeft = Number(that.minimap.selection.style.left.substring(0, that.minimap.selection.style.left.length - 2));\r\n\t            var minimapTop = Number(that.minimap.selection.style.top.substring(0, that.minimap.selection.style.top.length - 2));\r\n\t            var moveFunction = function(e) {\r\n\t                eagleEyeMove(e);\r\n\t            };\r\n\t\r\n\t            function eagleEyeMove(e) {\r\n\t                var offsetX = e.clientX - startX;\r\n\t                var offsetY = e.clientY - startY;\r\n\t                that.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n\t                that.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n\t                that.minimap.updataGroupPosition(that.group, that.nowZoom);\r\n\t            }\r\n\t\r\n\t            that.minimap.selection.addEventListener(\"mousemove\", moveFunction);\r\n\t            var upFunction = function(e) {\r\n\t                eagleEyeUp(e);\r\n\t            };\r\n\t\r\n\t            function eagleEyeUp() {\r\n\t                that.minimap.selection.removeEventListener(\"mousemove\", moveFunction);\r\n\t                that.minimap.selection.removeEventListener(\"mouseup\", moveFunction);\r\n\t            }\r\n\t\r\n\t            that.minimap.selection.addEventListener(\"mouseup\", upFunction);\r\n\t        })\r\n\t\r\n\t\r\n\t    };\r\n\t    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\t\r\n\t    // ---------对外暴露fishTopoFlow------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\t\r\n\t    /**\r\n\t     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n\t     * @class fishTopoFlow\r\n\t     * @singleton\r\n\t     */\r\n\t    var fishTopoFlow = {\r\n\t        /**\r\n\t         * 版本号\r\n\t         * @type {String}\r\n\t         */\r\n\t        version: '1.5.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 初始化dom元素为 flow对象\r\n\t     * @member fishTopoFlow\r\n\t     * @param {HTMLElement} dom  一个div元素\r\n\t     * @param {Object} opts  传递的选项参数\r\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n\t     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n\t     * @param {number} [opts.linkModify=false] 是否允许调整线段\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.init = function(dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts, {\r\n\t            type: \"flow\",\r\n\t            devicePixelRatio: 1,\r\n\t            linkModify: false,\r\n\t            isAllowEdit: false\r\n\t        });\r\n\t\r\n\t        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n\t        fishTopoFlow.init();\r\n\t        fishTopoFlow.Flow = Flow;\r\n\t        fishTopoFlow.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\t\r\n\t        return fishTopoFlow;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 获取 dom 容器上的实例。\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {HTMLElement} dom 一个div元素\r\n\t     * @return {fish.topo.FishTopoFlow}\r\n\t     */\r\n\t    fishTopoFlow.getInstanceByDom = function(dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 销毁实例，实例销毁后无法再被使用。\r\n\t     *\r\n\t     * @member fishTopoFlow\r\n\t     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n\t     */\r\n\t    fishTopoFlow.dispose = function(chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoFlow.getInstanceByDom(chart);\r\n\t        } else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t        clearTimeout(this._layoutTimeout);\r\n\t    };\r\n\t\r\n\t    //暴露出去的类\r\n\t    fishTopoFlow.util = {};\r\n\t    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n\t    zrUtil.each([\r\n\t            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n\t            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n\t            'isString', 'isObject', 'isFunction', 'extend'\r\n\t        ],\r\n\t        function(name) {\r\n\t            fishTopoFlow.util[name] = zrUtil[name];\r\n\t        }\r\n\t    );\r\n\t\r\n\t    module.exports = fishTopoFlow;\r\n\t\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var pathTool = __webpack_require__(5);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(6);\r\n\t    var colorTool = __webpack_require__(19);\r\n\t    var matrix = __webpack_require__(13);\r\n\t    var vector = __webpack_require__(14);\r\n\t    var Gradient = __webpack_require__(37);\r\n\t    var Draggable = __webpack_require__(38);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(39);\r\n\t\r\n\t    graphic.Image = __webpack_require__(40);\r\n\t\r\n\t    graphic.Text = __webpack_require__(42);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(23);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(43);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(44);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(45);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(46);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(50);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(51);\r\n\t\r\n\t    graphic.Line = __webpack_require__(53);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(54);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(55);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(56);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(57);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // In node-canvas Image can be Canvas.Image\n\t        '[object Image]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} 拷贝后的新对象\n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            }\n\t            else if (\n\t                !isBuildInObject(source)\n\t                // 是否为 dom 对象\n\t                && !isDom(source)\n\t            ) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        return source;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1\n\t               && typeof(value.nodeName) == 'string';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(25);\n\t    var transformPath = __webpack_require__(36);\n\t    var matrix = __webpack_require__(13);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var zrUtil = __webpack_require__(4);\n\t    var PathProxy = __webpack_require__(25);\n\t    var pathContain = __webpack_require__(28);\n\t\n\t    var Pattern = __webpack_require__(35);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Style = __webpack_require__(8);\n\t\n\t    var Element = __webpack_require__(9);\n\t    var RectText = __webpack_require__(22);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(10);\n\t    var Eventful = __webpack_require__(11);\n\t    var Transformable = __webpack_require__(12);\n\t    var Animatable = __webpack_require__(15);\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(13);\n\t    var vector = __webpack_require__(14);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(16);\n\t    var util = __webpack_require__(4);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(20);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n\t         * @param {boolean} [loop] 动画是否循环\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(17);\n\t    var color = __webpack_require__(19);\n\t    var util = __webpack_require__(4);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} easing\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(18);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(21);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(23);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(4);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var matrix = __webpack_require__(13);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t    var vec2 = __webpack_require__(14);\n\t    var bbox = __webpack_require__(27);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var dpr = __webpack_require__(21).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var curve = __webpack_require__(26);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var line = __webpack_require__(29);\n\t    var cubic = __webpack_require__(30);\n\t    var quadratic = __webpack_require__(31);\n\t    var arc = __webpack_require__(32);\n\t    var normalizeRadian = __webpack_require__(33).normalizeRadian;\n\t    var curve = __webpack_require__(26);\n\t\n\t    var windingLine = __webpack_require__(34);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(33).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var vec2 = __webpack_require__(14);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t    var Element = __webpack_require__(9);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * 所有子孙元素是否响应鼠标事件\n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var LRU = __webpack_require__(41);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var zrUtil = __webpack_require__(4);\n\t    var textContain = __webpack_require__(23);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(47);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(48);\n\t    var smoothBezier = __webpack_require__(49);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(14);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(47);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(52);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(26);\n\t    var vec2 = __webpack_require__(14);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\t\r\n\t        this.bigCanvas = bigCanvas;\r\n\t        this.eagleEyeNode = eagleEyeNode;\r\n\t        this.distance = distance;\r\n\t        this.imgSrc = imgSrc;\r\n\t        this.ratio;\r\n\t        this.groupRatio;\r\n\t        this.group = group;\r\n\t        this.img = document.createElement(\"img\");\r\n\t        this.selection = document.createElement('div');\r\n\t        this.groupPosition = zrUtil.clone(groupPosition);\r\n\t        this.selectPosition = [0,0];\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    Minimap.prototype.render = function() {\r\n\t        var that = this;\r\n\t        that.ratio = 0.12;\r\n\t        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.position=\"relative\";\r\n\t        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n\t        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n\t        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n\t        that.eagleEyeNode.innerHTML = \"\";\r\n\t        that.selection.style.border = \"1px solid #ff0000\";\r\n\t        that.selection.style.cursor = \"pointer\";\r\n\t        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n\t        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n\t        that.selectWidth = that.selection.style.width;\r\n\t        that.selectHeight = that.selection.style.height;\r\n\t        that.selection.style.position=\"absolute\";\r\n\t        that.selection.style.top = 0+\"px\";\r\n\t        that.selection.style.left = 0+\"px\";\r\n\t        that.eagleEyeNode.appendChild(this.selection);\r\n\t    };\r\n\t    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n\t        var that = this;\r\n\t        that.zoomScale = zoomScale;\r\n\t        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n\t        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n\t        var that = this;\r\n\t        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n\t        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n\t        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n\t        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n\t        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n\t        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n\t        var that = this;\r\n\t        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n\t        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n\t        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n\t        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n\t    };\r\n\t    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n\t        var that = this;\r\n\t        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n\t        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n\t        group.attr(\"position\",[positionX,positionY]);\r\n\t    };\r\n\t\r\n\t    module.exports = Minimap;\r\n\t\r\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 工具方法类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Point = __webpack_require__(60);\r\n\t    var Line = __webpack_require__(61);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    /**\r\n\t     * 构造类继承关系\r\n\t     *\r\n\t     * @param {Function} clazz 源类\r\n\t     * @param {Function} baseClazz 基类\r\n\t     */\r\n\t    function inherits(clazz, baseClazz) {\r\n\t        var clazzPrototype = clazz.prototype;\r\n\t\r\n\t        function F() {}\r\n\t        F.prototype = baseClazz.prototype;\r\n\t        clazz.prototype = new F();\r\n\t\r\n\t        for (var prop in clazzPrototype) {\r\n\t            clazz.prototype[prop] = clazzPrototype[prop];\r\n\t        }\r\n\t        clazz.prototype.constructor = clazz;\r\n\t        clazz.superClass = baseClazz;\r\n\t    }\r\n\t\r\n\t    function getUUID() {\r\n\t        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n\t            uuid = new Array(36),\r\n\t            rnd = 0,\r\n\t            r;\r\n\t        for (var i = 0; i < 36; i++) {\r\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n\t                uuid[i] = '-';\r\n\t            } else if (i == 14) {\r\n\t                uuid[i] = '4';\r\n\t            } else {\r\n\t                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n\t                r = rnd & 0xf;\r\n\t                rnd = rnd >> 4;\r\n\t                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\t            }\r\n\t        }\r\n\t        return \"sid-\" + uuid.join('');\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算两点之间的距离\r\n\t     *@param {Point} p1 - first {Point}\r\n\t     *@param {Point} p2 - second {Point}\r\n\t     *@return {Number} - the distance between those 2 points. It is always positive.\r\n\t     **/\r\n\t    function distance(p1, p2) {\r\n\t        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回一条折线 最长的两个点\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function getMaxLineLength(points) {\r\n\t        var m = distance(points[0], points[1]);\r\n\t        var result = [points[0], points[1]];\r\n\t        for (var i = 1; i < points.length - 1; i++) {\r\n\t\r\n\t            if (m < distance(points[i], points[i + 1])) {\r\n\t                m = distance(points[i], points[i + 1])\r\n\t                result = [points[i], points[i + 1]];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    }\r\n\t\r\n\t    /**Returns the length of a Polyline that would be created with a set of points\r\n\t     *@param {Array} v - an {Array} of {Points}\r\n\t     *@return {Number} - a positive number equal with total length*/\r\n\t    function getPolylineLength(v) {\r\n\t        var l = 0;\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            l += distance(v[i], v[i + 1]);\r\n\t        }\r\n\t\r\n\t        return l;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the max of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n\t     **/\r\n\t    function max(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m < v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the min of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n\t     *@author alex@scriptoid.com\r\n\t     **/\r\n\t    function min(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m > v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是否正交直线路径\r\n\t     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function orthogonalPath(v) {\r\n\t        if (v.length <= 1) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n\t     *and not the infinite lines from geometry\r\n\t     *@param {Line} l1 - fist line/segment\r\n\t     *@param {Line} l2 - last line/segment\r\n\t     *@return {Boolean} true - if the lines intersect or false if not\r\n\t     **/\r\n\t    function lineIntersectsLine(l1, l2) {\r\n\t        // check for two vertical lines\r\n\t        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n\t            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n\t                // then check segment bounds for overlapping\r\n\t                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n\t                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                // lines are paralel\r\n\t                false;\r\n\t        }\r\n\t        // if one line is vertical, and another line is not vertical\r\n\t        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n\t            // let assume l2 is vertical, otherwise exchange them\r\n\t            if (l1.startPoint.x == l1.endPoint.x) {\r\n\t                var l = l1;\r\n\t                l1 = l2;\r\n\t                l2 = l;\r\n\t            }\r\n\t            // finding intersection of 'infinite' lines\r\n\t            // equation of the first line is y = ax + b, second: x = c\r\n\t            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n\t            var x0 = l2.startPoint.x;\r\n\t            var y0 = a * x0 + b;\r\n\t            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t        }\r\n\t\r\n\t        // check normal case - both lines are not vertical\r\n\t        else {\r\n\t            //line equation is : y = a*x + b, b = y - a * x\r\n\t            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\t\r\n\t            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n\t            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\t\r\n\t            if (a1 == a2) { //paralel lines\r\n\t                return b1 == b2 ?\r\n\t                    // for coincide lines, check for segment bounds overlapping\r\n\t                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                    // not coincide paralel lines have no chance to intersect\r\n\t                    false;\r\n\t            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\t\r\n\t                /*\r\n\t                 * if one of the lines are vertical, then x0 is equal to their x,\r\n\t                 * otherwise:\r\n\t                 * y1 = a1 * x + b1\r\n\t                 * y2 = a2 * x + b2\r\n\t                 * => x0 = (b2 - b1) / (a1 - a2)\r\n\t                 * => y0 = a1 * x0 + b1\r\n\t                 **/\r\n\t                x0 = (b2 - b1) / (a1 - a2);\r\n\t                y0 = a1 * x0 + b1;\r\n\t                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n\t     *@param {Array} points - and {Array} of {Point}s\r\n\t     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n\t     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n\t     *\r\n\t     *@return true - if line intersects the rectangle, false - if not\r\n\t     **/\r\n\t    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\t\r\n\t\r\n\t        //get the 4 lines/segments represented by the bounds\r\n\t        var lines = [];\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\t\r\n\t        for (var k = 0; k < points.length - 1; k++) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine = new Line(points[k], points[k + 1]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var i = 0; i < lines.length; i++) {\r\n\t                if (lineIntersectsLine(tempLine, lines[i])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //check the closed figure - that is last point connected to the first\r\n\t        if (closedPolyline) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var j = 0; j < lines.length; j++) {\r\n\t                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算路径的分数\r\n\t     * Score a ortogonal path made out of Points\r\n\t     *Iterates over a set of points (minimum 3)\r\n\t     *For each 3 points (i, i+1, i+2) :\r\n\t     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n\t     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n\t     *  - if the 3rd goes back we imediatelly return -1\r\n\t     *@param {Array} v - an array of {Point}s\r\n\t     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n\t     *  The bigger the number the smooth the path is\r\n\t     **/\r\n\t    function scorePath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return -1;\r\n\t        }\r\n\t\r\n\t        var score = 0;\r\n\t        for (var i = 1; i < v.length - 1; i++) {\r\n\t            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else { //not on same vertical nor horizontal\r\n\t                score--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return score;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回数字符号（+ -)\r\n\t     * Returns the sign of a number\r\n\t     *@param {Number} x - the number\r\n\t     *@returns {Number}\r\n\t     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n\t     **/\r\n\t    function signum(x) {\r\n\t        if (x > 0)\r\n\t            return 1;\r\n\t        else if (x < 0)\r\n\t            return -1;\r\n\t        else\r\n\t            return 0;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是不是有效路径（没有回路）\r\n\t     *Tests if a vector of points is a valid path (not going back)\r\n\t     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function forwardPath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 2; i++) {\r\n\t            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t     * @param  {[type]} points [description]\r\n\t     * @param  {[type]} isRevert [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function traslatePoints(points, isRevert) {\r\n\t        var newPoints = [];\r\n\t        if (isRevert) {\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var point = points[i];\r\n\t                newPoints.push(new Point(point[0], point[1]));\r\n\t            }\r\n\t            return newPoints;\r\n\t        } else {\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point1 = points[j];\r\n\t                newPoints.push([point1.x, point1.y]);\r\n\t            }\r\n\t            return newPoints;\r\n\t        }\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    function rotationMatrix(angle) {\r\n\t        var mReturn = [\r\n\t            [Math.cos(angle), -Math.sin(angle), 0],\r\n\t            [Math.sin(angle), Math.cos(angle), 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t        return mReturn;\r\n\t    }\r\n\t\r\n\t    function translationMatrix(dx, dy) {\r\n\t        return [\r\n\t            [1, 0, dx],\r\n\t            [0, 1, dy],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    function scaleMatrix(sx, sy) {\r\n\t        if (sy == null) {\r\n\t            sy = sx;\r\n\t        }\r\n\t        return [\r\n\t            [sx, 0, 0],\r\n\t            [0, sy, 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    /** It will return the end point of a line on a given angle (clockwise).\r\n\t     * @param {Point} startPoint - the start of the line\r\n\t     * @param {Number} length - the length of the line\r\n\t     * @param {Number} angle - the angle of the line in radians\r\n\t     * @return {Point} - the endPoint of the line\r\n\t     */\r\n\t    function getEndPoint(startPoint, length, angle) {\r\n\t        var endPoint = startPoint.clone();\r\n\t        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n\t        endPoint.y -= length;\r\n\t        endPoint.transform(rotationMatrix(angle));\r\n\t        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n\t        return endPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorPoints(node) {\r\n\t        return {\r\n\t            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n\t            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n\t            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n\t            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n\t            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\t\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getSoltPoints(node) {\r\n\t        return [\r\n\t            //top\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n\t            //right\r\n\t            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n\t            //bottom\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            //left\r\n\t            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\t\r\n\t        ]\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算 p1 p2两点所连接的直线的角度\r\n\t     * @param  {[type]} p1 [description]\r\n\t     * @param  {[type]} p2 [description]\r\n\t     * @return {[type]}    [description]\r\n\t     */\r\n\t    function tangentRotation(p1, p2) {\r\n\t        return -Math.PI / 2 - Math.atan2(\r\n\t            p2.y - p1.y, p2.x - p1.x\r\n\t        );\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断3点是否在一条直线上\r\n\t     * Tests if 3 points are coliniar with matrix determinants.\r\n\t     * If the determinat of matrix\r\n\t     * /         \\\r\n\t     * | x1 y1 1 |\r\n\t     * | x2 y2 1 |\r\n\t     * | x3 y3 1 |\r\n\t     * \\         /\r\n\t     * is zero it means that the points are colinear\r\n\t     *@param {Point} p1 - first point\r\n\t     *@param {Point} p2 - second point\r\n\t     *@param {Point} p3 - third point\r\n\t     * @param {Number} precission\r\n\t     *@return {Boolean} - true if coliniar and false if not\r\n\t     *@author Alex\r\n\t     *@see http://en.wikipedia.org/wiki/Determinant\r\n\t     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n\t     **/\r\n\t    function collinearity(p1, p2, p3, precission) {\r\n\t        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\t\r\n\t        if (precission) {\r\n\t            return Math.abs(determinant) <= precission;\r\n\t        } else {\r\n\t            return determinant === 0;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 四舍五入 保存decimals的小数\r\n\t     **/\r\n\t    function enhancedRound(number, decimals) {\r\n\t        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取两点之间的长度\r\n\t     **/\r\n\t    function getLength(startPoint, endPoint) {\r\n\t        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取角度\r\n\t     * @param  {[type]} centerPoint  [description]\r\n\t     * @param  {[type]} outsidePoint [description]\r\n\t     * @param  {[type]} round        [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function getAngle(centerPoint, outsidePoint, round) {\r\n\t        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n\t        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n\t        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n\t        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n\t        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n\t        angle = -angle;\r\n\t\r\n\t        //endAngle+=90;\r\n\t        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n\t            angle += Math.PI * 2;\r\n\t        }\r\n\t        while (angle >= Math.PI * 2) {\r\n\t            angle -= Math.PI * 2;\r\n\t        }\r\n\t        if (isNaN(angle)) { //Nan\r\n\t            angle = 0; //we are at center point;\r\n\t        }\r\n\t        if (round) {\r\n\t            angle = Math.round(angle / round) * round\r\n\t        }\r\n\t        return angle;\r\n\t    }\r\n\t\r\n\t    function getRect(node) {\r\n\t        var boundingRect = node.getBoundingRect();\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t        var boundRect, cx, cy;\r\n\t        if (node instanceof graphic.Circle) {\r\n\t            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n\t            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),\r\n\t                Number(node.position[1]) - Number(boundingRect.height / 2),\r\n\t                Number(boundingRect.width), Number(boundingRect.height));\r\n\t            cx = Number(node.position[0]);\r\n\t            cy = Number(node.position[1]);\r\n\t        } else {\r\n\t            boundRect = new BoundingRect(Number(node.position[0]),\r\n\t                Number(node.position[1]),\r\n\t                Number(boundingRect.width), Number(boundingRect.height));\r\n\t            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;\r\n\t            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;\r\n\t        }\r\n\t        return {\r\n\t            x: Number(cx),\r\n\t            y: Number(cy),\r\n\t            width: Number(boundingRect.width),\r\n\t            height: Number(boundingRect.height),\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var StackedMap = {\r\n\t        createNew: function() {\r\n\t            var stack = [];\r\n\t\r\n\t            return {\r\n\t                add: function(key, value) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    arrKey.push(value)\r\n\t\r\n\t                },\r\n\t                get: function(key) {\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            return stack[i].value;\r\n\t                        }\r\n\t                    }\r\n\t                    //如果没有找到的话，则创建一个新的数组\r\n\t                    var value = [];\r\n\t                    stack.push({ key: key, value: value });\r\n\t                    return value;\r\n\t                },\r\n\t                keys: function() {\r\n\t                    var keys = [];\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        keys.push(stack[i].key);\r\n\t                    }\r\n\t                    return keys;\r\n\t                },\r\n\t                top: function() {\r\n\t                    return stack[stack.length - 1];\r\n\t                },\r\n\t                remove: function(key) {\r\n\t                    var idx = -1;\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            idx = i;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    return stack.splice(idx, 1)[0];\r\n\t                },\r\n\t                removeItem: function(key, item) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    var index = zrUtil.indexOf(arrKey, item);\r\n\t                    arrKey.splice(index, 1);\r\n\t\r\n\t                },\r\n\t                removeTop: function() {\r\n\t                    return stack.splice(stack.length - 1, 1)[0];\r\n\t                },\r\n\t                length: function() {\r\n\t                    return stack.length;\r\n\t                },\r\n\t                clear: function() {\r\n\t                    stack.splice(0, stack.length);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    function randomColor() {\r\n\t        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n\t            strHex = \"#\",\r\n\t            index;\r\n\t        for (var i = 0; i < 6; i++) {\r\n\t            index = Math.round(Math.random() * 15);\r\n\t            strHex += arrHex[index];\r\n\t        }\r\n\t        return strHex;\r\n\t    }\r\n\t\r\n\t    function isUndefined(obj) {\r\n\t        return obj === void 0;\r\n\t    }\r\n\t\r\n\t    function collinearReduction (v) {\r\n\t        var r = [];\r\n\t\r\n\t        if(v.length < 3){\r\n\t            return Point.cloneArray(v);\r\n\t        }\r\n\t\r\n\t        r.push( v[0].clone() );\r\n\t        for(var i=1; i < v.length-1; i++){\r\n\t            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n\t            {\r\n\t                continue;\r\n\t            }\r\n\t            else{\r\n\t                r.push( v[i].clone() );\r\n\t            }\r\n\t        }\r\n\t        r.push( v[v.length-1].clone() );\r\n\t\r\n\t        return r;\r\n\t    }\r\n\t\r\n\t    // By default, Underscore uses ERB-style template delimiters, change the\r\n\t    // following template settings to use alternative delimiters.\r\n\t    var templateSettings = {\r\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\r\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n\t        escape: /<%-([\\s\\S]+?)%>/g\r\n\t    };\r\n\t\r\n\t    // When customizing `templateSettings`, if you don't want to define an\r\n\t    // interpolation, evaluation or escaping regex, we need one that is\r\n\t    // guaranteed not to match.\r\n\t    var noMatch = /(.)^/;\r\n\t\r\n\t    // Certain characters need to be escaped so that they can be put into a\r\n\t    // string literal.\r\n\t    var escapes = {\r\n\t        \"'\": \"'\",\r\n\t        '\\\\': '\\\\',\r\n\t        '\\r': 'r',\r\n\t        '\\n': 'n',\r\n\t        '\\u2028': 'u2028',\r\n\t        '\\u2029': 'u2029'\r\n\t    };\r\n\t\r\n\t    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\t\r\n\t    var escapeChar = function(match) {\r\n\t        return '\\\\' + escapes[match];\r\n\t    };\r\n\t\r\n\t    // JavaScript micro-templating, similar to John Resig's implementation.\r\n\t    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n\t    // and correctly escapes quotes within interpolated code.\r\n\t    // NB: `oldSettings` only exists for backwards compatibility.\r\n\t    function template(text, settings, oldSettings) {\r\n\t        if (!settings && oldSettings) settings = oldSettings;\r\n\t        settings = settings || {};\r\n\t        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\t\r\n\t        // Combine delimiters into one regular expression via alternation.\r\n\t        var matcher = RegExp([\r\n\t            (settings.escape || noMatch).source,\r\n\t            (settings.interpolate || noMatch).source,\r\n\t            (settings.evaluate || noMatch).source\r\n\t        ].join('|') + '|$', 'g');\r\n\t\r\n\t        // Compile the template source, escaping string literals appropriately.\r\n\t        var index = 0;\r\n\t        var source = \"__p+='\";\r\n\t        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n\t            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n\t            index = offset + match.length;\r\n\t\r\n\t            if (escape) {\r\n\t                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n\t            } else if (interpolate) {\r\n\t                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n\t            } else if (evaluate) {\r\n\t                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n\t            }\r\n\t\r\n\t            // Adobe VMs need the match returned to produce the correct offest.\r\n\t            return match;\r\n\t        });\r\n\t        source += \"';\\n\";\r\n\t\r\n\t        // If a variable is not specified, place data values in local scope.\r\n\t        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\t\r\n\t        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n\t            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n\t            source + 'return __p;\\n';\r\n\t\r\n\t        try {\r\n\t            var render = new Function(settings.variable || 'obj', source);\r\n\t        } catch (e) {\r\n\t            e.source = source;\r\n\t            throw e;\r\n\t        }\r\n\t\r\n\t        var template = function(data) {\r\n\t            return render.call(this, data);\r\n\t        };\r\n\t\r\n\t        // Provide the compiled source as a convenience for precompilation.\r\n\t        var argument = settings.variable || 'obj';\r\n\t        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\t\r\n\t        return template;\r\n\t    }\r\n\t\r\n\t    function isEmpty(obj) {\r\n\t        if (obj == null) return true;\r\n\t        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n\t    }\r\n\t\r\n\t    module.exports = {\r\n\t        inherits: inherits,\r\n\t        getUUID: getUUID,\r\n\t        distance: distance,\r\n\t        getPolylineLength: getPolylineLength,\r\n\t        max: max,\r\n\t        min: min,\r\n\t        isEmpty: isEmpty,\r\n\t        orthogonalPath: orthogonalPath,\r\n\t        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n\t        scorePath: scorePath,\r\n\t        forwardPath: forwardPath,\r\n\t        traslatePoints: traslatePoints,\r\n\t        getEndPoint: getEndPoint,\r\n\t        getConnectorPoints: getConnectorPoints,\r\n\t        tangentRotation: tangentRotation,\r\n\t        collinearity: collinearity,\r\n\t        translationMatrix: translationMatrix,\r\n\t        scaleMatrix: scaleMatrix,\r\n\t        round: enhancedRound,\r\n\t        getLength: getLength,\r\n\t        getAngle: getAngle,\r\n\t        getRect: getRect,\r\n\t        StackedMap: StackedMap,\r\n\t        getMaxLineLength: getMaxLineLength,\r\n\t        randomColor: randomColor,\r\n\t        template: template,\r\n\t        isUndefined: isUndefined,\r\n\t        getSoltPoints:getSoltPoints,\r\n\t        collinearReduction: collinearReduction\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of Point\r\n\t      *\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Point}\r\n\t      * @param {Number} x The x coordinate of point.\r\n\t      * @param {Number} y The y coordinate of point.\r\n\t      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n\t      * then Point from math perspective.\r\n\t      **/\r\n\t    function Point(x, y){\r\n\t        /**The x coordinate of point*/\r\n\t        this.x = x;\r\n\t        \r\n\t        /**The y coordinate of point*/\r\n\t        this.y = y;\r\n\t        \r\n\t\r\n\t    }\r\n\t\r\n\t    /**Creates a {Point} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Point} a newly constructed Point\r\n\t     **/\r\n\t    Point.load = function(o){\r\n\t        var newPoint = new Point(Number(o.x), Number(o.y));\r\n\t        return newPoint;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Creates an array of points from an array of {JSONObject}s\r\n\t     *@param {Array} v - the array of JSONObjects\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.loadArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(Point.load(v[i]));\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Clones an array of points\r\n\t     *@param {Array} v - the array of {Point}s\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.cloneArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(v[i].clone());\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t    Point.prototype = {\r\n\t        constructor : Point,\r\n\t        \r\n\t        transform:function(matrix){\r\n\t            var oldX = this.x;\r\n\t            var oldY = this.y;\r\n\t            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n\t            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n\t        },\r\n\t        \r\n\t        /**Tests if this point is similar to other point\r\n\t         *@param {Point} anotherPoint - the other point\r\n\t         **/\r\n\t        equals:function(anotherPoint){\r\n\t            if(! (anotherPoint instanceof Point) ){\r\n\t                return false;\r\n\t            }\r\n\t            return (this.x == anotherPoint.x)\r\n\t            && (this.y == anotherPoint.y)\r\n\t        },\r\n\t\r\n\t        /**Clone current Point\r\n\t         **/\r\n\t        clone: function(){\r\n\t            var newPoint = new Point(this.x, this.y);\r\n\t            return newPoint;\r\n\t        },\r\n\t\r\n\t        /**Tests to see if a point (x, y) is within a range of current Point\r\n\t         *@param {Numeric} x - the x coordinate of tested point\r\n\t         *@param {Numeric} y - the x coordinate of tested point\r\n\t         *@param {Numeric} radius - the radius of the vicinity\r\n\t         **/\r\n\t        near:function(x, y, radius){\r\n\t            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\t\r\n\t            return (distance <= radius);\r\n\t        },\r\n\t\r\n\t        contains: function(x,y){\r\n\t            return this.x == x && this.y == y;\r\n\t        },\r\n\t\r\n\t        toString:function(){\r\n\t            return '[' + this.x + ',' + this.y + ']';\r\n\t        },\r\n\t\r\n\t        getPoints:function(){\r\n\t            return [this];\r\n\t        }\r\n\t    };\r\n\t    module.exports = Point;\r\n\t    \n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n\t      * geometrical Line\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Line}\r\n\t      * @param {Point} startPoint - starting point of the line\r\n\t      * @param {Point} endPoint - the ending point of the line\r\n\t      **/\r\n\t    function Line(startPoint, endPoint){\r\n\t        /**Starting {@link Point} of the line*/\r\n\t        this.startPoint = startPoint;\r\n\t\r\n\t        /**Ending {@link Point} of the line*/\r\n\t        this.endPoint = endPoint;\r\n\t\r\n\t        /**Serialization type*/\r\n\t        this.oType = 'Line'; //object type used for JSON deserialization\r\n\t    }\r\n\t\r\n\t    /**Creates a {Line} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Line} a newly constructed Line\r\n\t     **/\r\n\t    Line.load = function(o){\r\n\t        var newLine = new Line(\r\n\t            Point.load(o.startPoint),\r\n\t            Point.load(o.endPoint)\r\n\t        );\r\n\t\r\n\t        return newLine;\r\n\t    };\r\n\t\r\n\t    Line.prototype = {\r\n\t        contructor: Line,\r\n\t\r\n\t\r\n\t\r\n\t        clone:function(){\r\n\t            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n\t            return ret;\r\n\t        },\r\n\t\r\n\t        equals:function(anotherLine){\r\n\t            if(!anotherLine instanceof Line){\r\n\t                return false;\r\n\t            }\r\n\t            return this.startPoint.equals(anotherLine.startPoint)\r\n\t            && this.endPoint.equals(anotherLine.endPoint)\r\n\t        },\r\n\t\r\n\t        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n\t         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n\t         * @param {Number} x - the X coordinates\r\n\t         * @param {Number} y - the Y coordinates\r\n\t         **/\r\n\t        contains: function(x, y){\r\n\t            // if the point is inside rectangle bounds of the segment\r\n\t            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n\t                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n\t                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n\t                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\t\r\n\t                // check for vertical line\r\n\t                if (this.startPoint.x == this.endPoint.x) {\r\n\t                    return x == this.startPoint.x;\r\n\t                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n\t                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n\t                    var b = this.startPoint.y - a * this.startPoint.x;\r\n\t                    return y == a * x + b;\r\n\t                }\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /*\r\n\t         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n\t         *@param {Number} x - the x coordinates\r\n\t         *@param {Number} y - the y coordinates\r\n\t         *@param {Number} radius - the radius to search for\r\n\t         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t         **/\r\n\t        near:function(x,y,radius){\r\n\t\r\n\t            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n\t                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n\t                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n\t            }\r\n\t\r\n\t            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n\t                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n\t                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n\t            }\r\n\t\r\n\t\r\n\t            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n\t            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n\t            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n\t            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\t\r\n\t            /*We will compute the distance from point to the line\r\n\t             * by using the algorithm from\r\n\t             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t             * */\r\n\t\r\n\t            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n\t            var a = this.endPoint.y - this.startPoint.y;\r\n\t            var b = this.startPoint.x - this.endPoint.x;\r\n\t            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\t\r\n\t            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\t\r\n\t            //Thirdly we get coordinates of closest line's point to target point\r\n\t            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n\t            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t\r\n\t            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n\t                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\t\r\n\t            return  r;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**we need to create a new array each time, or we will affect the actual shape*/\r\n\t        getPoints:function(){\r\n\t            var points = [];\r\n\t            points.push(this.startPoint);\r\n\t            points.push(this.endPoint);\r\n\t            return points;\r\n\t        },\r\n\t\r\n\t        /**Return the {Point} corresponding the t certain t value\r\n\t         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n\t        getPoint: function(t){\r\n\t            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n\t            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\t\r\n\t            return new Point(Xp, Yp);\r\n\t        },\r\n\t\r\n\t        // /**\r\n\t        //  * Returns the middle of the line\r\n\t        //  * @return {Point} the middle point\r\n\t        //  * */\r\n\t        // getMiddle : function(){\r\n\t        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t\r\n\t        // getLength : function(){\r\n\t        //     return Util.getLength(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t        // /**\r\n\t        //  *Get bounds for this line\r\n\t        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n\t        //  **/\r\n\t        // getBounds:function(){\r\n\t        //     return Util.getBounds(this.getPoints());\r\n\t        // },\r\n\t\r\n\t        /**String representation*/\r\n\t        toString:function(){\r\n\t            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n\t        }\r\n\t    };\r\n\t    module.exports = Line;\r\n\t\r\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var apiList = [\r\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n\t        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\r\n\t    ];\r\n\t\r\n\t    function ExtensionAPI(instance) {\r\n\t        zrUtil.each(apiList, function (name) {\r\n\t            this[name] = zrUtil.bind(instance[name], instance);\r\n\t        }, this);\r\n\t    }\r\n\t\r\n\t    module.exports = ExtensionAPI;\r\n\t\r\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(10);\n\t    var env = __webpack_require__(64);\n\t\n\t    var Handler = __webpack_require__(65);\n\t    var Storage = __webpack_require__(66);\n\t    var Animation = __webpack_require__(68);\n\t    var HandlerProxy = __webpack_require__(71);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(73)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         */\n\t        resize: function() {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true; browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var Draggable = __webpack_require__(38);\n\t\n\t    var Eventful = __webpack_require__(11);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function(storage, painter, proxy) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            this.trigger('globalout', {\n\t                event: event\n\t            });\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetEl 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var env = __webpack_require__(64);\n\t\n\t    var Group = __webpack_require__(39);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(67);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var Dispatcher = __webpack_require__(69).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(70);\n\t\n\t    var Animator = __webpack_require__(16);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(11);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n\t     */\n\t    function normalizeEvent(el, e) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(69);\n\t    var zrUtil = __webpack_require__(4);\n\t    var Eventful = __webpack_require__(11);\n\t    var env = __webpack_require__(64);\n\t    var GestureMgr = __webpack_require__(72);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // 平板补充一次findHover\n\t            // this._mobileFindFixed(event);\n\t            // Trigger mousemove and mousedown\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(69);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(21);\n\t    var util = __webpack_require__(4);\n\t    var log = __webpack_require__(20);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var timsort = __webpack_require__(67);\n\t\n\t    var Layer = __webpack_require__(74);\n\t\n\t    var requestAnimationFrame = __webpack_require__(70);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n\t                    - (parseInt10(stl.paddingLeft) || 0)\n\t                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n\t                    - (parseInt10(stl.paddingTop) || 0)\n\t                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(40);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var config = __webpack_require__(21);\n\t    var Style = __webpack_require__(8);\n\t    var Pattern = __webpack_require__(35);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var Node = __webpack_require__(76);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var util = __webpack_require__(59);\r\n\t    var Connector = __webpack_require__(77);\r\n\t    //创建Node类 所有形状都继承Node\r\n\t    //\r\n\t    function GroupNode(model, api) {\r\n\t\r\n\t        Node.call(this, model, api);\r\n\t        this.bpmnInfo = {type: -1, name:\"GroupNode\" };    //节点信息\r\n\t        this.model = model;\r\n\t        var defaultOptions = {\r\n\t                shape: {\r\n\t                    width:0,\r\n\t                    height:0,\r\n\t                    r: 7\r\n\t                },\r\n\t                style: {\r\n\t                    fill: '#f9f9f9',\r\n\t                    stroke: '#bbbbbb'\r\n\t                },\r\n\t                position:[0,0]\r\n\t            };\r\n\t        this.options = zrUtil.extend(defaultOptions, model);\r\n\t        this.isdraggable = this.options.isdraggable;\r\n\t        this.max = [1024,960];\r\n\t        this.render(this.options);\r\n\t    }\r\n\t\r\n\t    GroupNode.prototype.render = function(model) {\r\n\t        var rect = new graphic.Rect({\r\n\t            shape: model.shape,\r\n\t            style: model.style\r\n\t        });\r\n\t        rect.name = \"Rect\";\r\n\t        this.add(rect);\r\n\t        this.position = model.position;\r\n\t        this.mergedImage = model.mergedImage;\r\n\t    };\r\n\t\r\n\t    GroupNode.prototype.fromJSON = function(json) {\r\n\t        // body...\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    GroupNode.prototype.rectContain = function(x, y) {\r\n\t        var rect = util.getRect(this);\r\n\t        return rect.boundingRect.contain(x,y);\r\n\t    };\r\n\t\r\n\t    GroupNode.prototype.getRect = function() {\r\n\t        // body...\r\n\t        var boundingRect = this.getBoundingRect();\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] =[-boundingRect.width/2,-boundingRect.height/2];\r\n\t        points[1] =[boundingRect.width/2,-boundingRect.height/2];\r\n\t        points[2] =[boundingRect.width/2,boundingRect.height/2];\r\n\t        points[3] =[-boundingRect.width/2,boundingRect.height/2];\r\n\t        points[4] =[-boundingRect.width/2,-boundingRect.height/2];\r\n\t\r\n\t        var boundRect = new BoundingRect(this.position[0] ,\r\n\t                                         this.position[1],\r\n\t                                         boundingRect.width, boundingRect.height);\r\n\t        return {\r\n\t            x: this.position[0]+boundingRect.width/2,\r\n\t            y: this.position[1]+boundingRect.height/2,\r\n\t            width: boundingRect.width,\r\n\t            height: boundingRect.height,\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    };\r\n\t\r\n\t    GroupNode.prototype.reDraw = function(nodeMessage,node,nowGroupPosition) {\r\n\t        //重置背景rect 的长宽\r\n\t        var minLength = this.options.shape.r;\r\n\t        this.setProperties({\r\n\t            shape:{\r\n\t                    width:minLength,\r\n\t                    height:minLength,\r\n\t                    r: minLength\r\n\t            }\r\n\t        });\r\n\t        var groupPosition = zrUtil.clone(this.position);\r\n\t        var rect = this.childOfName(\"Rect\");\r\n\t        var width = this.getBoundingRect().width;\r\n\t        var height = this.getBoundingRect().height;\r\n\t        var rx = rect.shape.x,ry = rect.shape.y;\r\n\t        //取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n\t        var minX = this._children[1].position[0],minY = this._children[1].position[1];\r\n\t        var maxX = this._children[1].position[0],maxY = this._children[1].position[1];\r\n\t        var lineNode = [];\r\n\t        var nowGroupPosition = zrUtil.clone(nodeMessage.position);\r\n\t        for(var i = 1; i<this._children.length;i++){\r\n\t            if(this._children[i] instanceof Connector || this._children[i].isIcon == true){\r\n\t                continue;\r\n\t            }else{\r\n\t                if(minX>this._children[i].position[0]){\r\n\t                    minX = this._children[i].position[0];\r\n\t                }\r\n\t                if(maxX<this._children[i].position[0]){\r\n\t                    maxX = this._children[i].position[0];\r\n\t                }\r\n\t            }\r\n\t\r\n\t        }\r\n\t        for(var j = 1; j<this._children.length;j++){\r\n\t            if(this._children[j] instanceof Connector || this._children[j].isIcon == true){\r\n\t                continue;\r\n\t            }else{\r\n\t                if(minY>this._children[j].position[1]){\r\n\t                    minY = this._children[j].position[1];\r\n\t                }\r\n\t                if(maxY<this._children[j].position[1]){\r\n\t                    maxY = this._children[j].position[1];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if(width > this.max[0]){\r\n\t            width = this.max[0]-2;\r\n\t            if(nodeMessage.position[0]>minX){\r\n\t                nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;\r\n\t            }else{\r\n\t                nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width;\r\n\t            }\r\n\t        }else{\r\n\t            //移动节点改变group中背景rect的x位置，不超过最小的值\r\n\t            rx = this.childOfName(\"Rect\").position[0]+(nodeMessage.position[0]);\r\n\t            if(rx>minX){\r\n\t                rx = minX;\r\n\t            }\r\n\t            nowGroupPosition[0] = nodeMessage.movePosition[0]+nodeMessage.moveX;\r\n\t            if(nodeMessage.position[0]>minX){\r\n\t                if(nowGroupPosition[0]>minX+this.max[0]-nodeMessage.width){\r\n\t                    nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;\r\n\t                }\r\n\t            }else{\r\n\t                if(nowGroupPosition[0] < maxX-this.max[0]+nodeMessage.width){\r\n\t                    nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if(height > this.max[1]){\r\n\t            height = this.max[1]-2;\r\n\t            if(nodeMessage.position[1]>minY){\r\n\t                nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;\r\n\t            }else{\r\n\t                nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height;\r\n\t            }\r\n\t        }else{\r\n\t            //移动节点改变group中背景rect的y位置，不超过最小的值\r\n\t            ry = this.childOfName(\"Rect\").position[1]+(nodeMessage.position[1]);\r\n\t            if(ry>minY){\r\n\t                ry = minY;\r\n\t            }\r\n\t            nowGroupPosition[1] = nodeMessage.movePosition[1]+nodeMessage.moveY;\r\n\t            if(nodeMessage.position[1]>minY){\r\n\t                if(nowGroupPosition[1]>minY+this.max[1]-nodeMessage.height){\r\n\t                    nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;\r\n\t                }\r\n\t            }else{\r\n\t                if(nowGroupPosition[1] < maxY-this.max[1]+nodeMessage.height){\r\n\t                    nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        if(node.alarm){\r\n\t            var newAlarmPosition = [nowGroupPosition[0]+node.getBoundingRect().width-(node.alarm.getBoundingRect().width-6),nowGroupPosition[1]-node.alarm.getBoundingRect().height-3];\r\n\t            node.alarm.attr(\"position\",newAlarmPosition);\r\n\t        }\r\n\t        //改变背景rect的长宽和位置\r\n\t        this.setProperties({\r\n\t            shape:{\r\n\t                width:width,\r\n\t                height:height,\r\n\t                x:rx,\r\n\t                y:ry\r\n\t            }\r\n\t        });\r\n\t\r\n\t    };\r\n\t    GroupNode.prototype.setProperties = function(opt) {\r\n\t        var rect = this.childOfName(\"Rect\");\r\n\t        rect.setShape(opt.shape);\r\n\t        rect.attr(\"style\",opt.style);\r\n\t        this.attr('position',opt.position);\r\n\t        this.attr(\"shape\",opt.shape);\r\n\t    };\r\n\t\r\n\t    //组的合并与放开\r\n\t    GroupNode.prototype.merged = function() {\r\n\t        var that = this;\r\n\t        if(!this.mergedImage){\r\n\t            return;\r\n\t        }\r\n\t        //保留group的初始位置\r\n\t        var groupPosition = zrUtil.clone(this.position);\r\n\t        //给小图片设置属性，隐藏group\r\n\t        var width = this.relationImage.getBoundingRect().width;\r\n\t        var height = this.relationImage.getBoundingRect().height;\r\n\t        //计算合并后的小图片的position\r\n\t        var relationImagePosition = [this.position[0]+this.childOfName(\"Rect\").shape.x+(this.getBoundingRect().width/2-width/2),this.position[1]+this.childOfName(\"Rect\").shape.y+(this.getBoundingRect().height/2-height/2)];\r\n\t        //将小图片的位置保留下来\r\n\t        var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n\t        this.relationImage.attr(\"style\",{image:this.mergedImage,width:width,height:height});\r\n\t        this.relationImage.attr(\"position\",relationImagePosition);\r\n\t        if(width>0&&height>0){\r\n\t            this.hide();\r\n\t            this.relationImage.show();\r\n\t        }\r\n\t\r\n\t        //双击图片放出组\r\n\t        this.relationImage.on(\"dblclick\",function(){\r\n\t            that.setProperties({\r\n\t                //设置组的位置根据小图片的偏移量来计算\r\n\t                position:[groupPosition[0]+(this.position[0]-cloneImagePosition[0]),groupPosition[1]+(this.position[1]-cloneImagePosition[1])]\r\n\t            });\r\n\t            this.hide();\r\n\t            that.show();\r\n\t        });\r\n\t        return this.relationImage;\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(GroupNode,Node);\r\n\t    module.exports = GroupNode;\r\n\t\r\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var util = __webpack_require__(59)\r\n\t    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t    function Node() {\r\n\t        this.resourceId = util.getUUID(); // 生成节点ID\r\n\t        graphic.Group.call(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.render = function() {};\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @param  {[type]} json [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    Node.prototype.getRect = function(json) {};\r\n\t\r\n\t    /**\r\n\t     * drawText\r\n\t     * @description 画一个文本\r\n\t     * @param {string} name\r\n\t     * @param {string} color\r\n\t     */\r\n\t    Node.prototype.drawText = function(name,color) {\r\n\t        var textName = this.bpmnInfo.name;\r\n\t        if(name != null){\r\n\t            textName = name;\r\n\t        }\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: textName,\r\n\t                color: color ? color : this.options.text.color,\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        //文字绘制的位置  \r\n\t        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * refreshText\r\n\t     * @description 刷新文本\r\n\t     */\r\n\t    Node.prototype.refreshText = function() {\r\n\t        var text = this.childOfName(\"Title\");\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t    };\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.toJSON = function() {};\r\n\t\r\n\t    graphic.Util.inherits(Node, graphic.Group);\r\n\t    module.exports = Node;\r\n\t\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连接线\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(59);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Node = __webpack_require__(76);\r\n\t    var symbolUtil = __webpack_require__(78);\r\n\t    var Handle = __webpack_require__(79);\r\n\t    var EffectLine = __webpack_require__(80);\r\n\t    var ConnectionPoint = __webpack_require__(81);\r\n\t    var Point = __webpack_require__(60);\r\n\t    /**\r\n\t     * 构造函数\r\n\t     * @param {[type]} options [description]\r\n\t     */\r\n\t    function Connector(options) {\r\n\t        Node.call(this);\r\n\t        if(options.model&&options.model.option&&options.model.option.resourceId){\r\n\t            this.resourceId = options.model.option.resourceId;\r\n\t        }else{\r\n\t            this.resourceId = Util.getUUID();// 生成节点ID\r\n\t        }\r\n\t        var defaultOptions = {\r\n\t            symbol: {type:\"arrow\" , size: 10, color:\"#000000\"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t            style: {lineWidth:1, stroke:\"#000000\", lineType:Connector.TYPE_STRAIGHT},    //样式\r\n\t            hoverStyle: {lineWidth:2, stroke:\"lime\"}, //移上去的样式\r\n\t            arrowHoverStyle: {fill:\"lime\"},\r\n\t            shape: {points:null, smooth:false, smoothConstraint:null},//形状\r\n\t            position: [0,0],\r\n\t            isEdit: true,  //是否可编辑\r\n\t            text: {\r\n\t                text: \"\",\r\n\t                color: '#000000', // 文本颜色\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            z: 0\r\n\t        }\r\n\t        var opt = options || {};\r\n\t        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n\t        this.model = options.model;\r\n\t        this.handles = [];\r\n\t        this.connectionPoints = [];\r\n\t        this.conPointsGroup = null;\r\n\t        this.startNode = null;\r\n\t        this.endNode = null;\r\n\t        this.autoChangePosition = false\r\n\t        this.line = null;\r\n\t        this.groupCurve = new graphic.Group();\r\n\t        this.icons = [];  // 用于存储线段上面的操作图标\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    Connector.TYPE_STRAIGHT = 'straight';\r\n\t\r\n\t    Connector.TYPE_JAGGED = 'jagged';\r\n\t\r\n\t    Connector.TYPE_CURVE = 'curve';\r\n\t\r\n\t    Connector.RADIUS = 3;\r\n\t\r\n\t    Connector.START_NODE = \"startNode\";\r\n\t\r\n\t    Connector.END_NODE = \"endNode\";\r\n\t\r\n\t    Connector.LEFT = \"left\";\r\n\t\r\n\t    Connector.RIGHT = \"right\";\r\n\t\r\n\t    Connector.TOP = \"top\";\r\n\t\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t\r\n\t    Connector.SEPERATOR = \"-\";\r\n\t    /**\r\n\t     * 重新画线，如果传空则根据turningPoints 重新画线\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    Connector.prototype.refresh = function(points) {\r\n\t        if(points) {\r\n\t            this.turningPoints = points;\r\n\t        }\r\n\t        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t        var points = Util.traslatePoints(this.turningPoints);\r\n\t\r\n\t        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n\t            this.modifyCurve(this.turningPoints);\r\n\t        } else {\r\n\t            this.line.attr('shape', {points: points});\r\n\t        }\r\n\t\r\n\t        var lineText = this.childOfName('lineText');\r\n\t        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t        if (!lineText  && this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n\t            this.add(text.text);\r\n\t            lineText = this.childOfName('lineText');\r\n\t        }\r\n\t        if (lineText) {\r\n\t            lineText.setStyle(\"text\", this.options.text.text);\r\n\t\r\n\t            var textPoint = this.getTextPostion(this.options.text);\r\n\t\r\n\t            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n\t            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n\t            // }\r\n\t\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t        }\r\n\t        var symbolTo = this.childOfName('toSymbol');\r\n\t        if(symbolTo) {\r\n\t            if(this.options.effect&&this.options.effect.show){\r\n\t                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);\r\n\t            }else{\r\n\t                symbolTo.attr('position', points[points.length -1]);\r\n\t                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));\r\n\t            }\r\n\t        }\r\n\t   };\r\n\t    /**\r\n\t     * 渲染\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.render = function() {\r\n\t        var that = this;\r\n\t        //1.创建箭头\r\n\t        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n\t        if (symbolTo) {\r\n\t            this.add(symbolTo);\r\n\t        }\r\n\t\r\n\t        //2.创建线\r\n\t        this.curveLine = new graphic.BezierCurve({\r\n\t            position: this.options.position,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.groupCurve.add(this.curveLine);\r\n\t        this.add(this.groupCurve);\r\n\t\r\n\t        this.polyLine = new graphic.Polyline({\r\n\t            position: this.options.position,\r\n\t            shape: this.options.shape,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.add(this.polyLine);\r\n\t\r\n\t        if((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n\t            this.line = this.groupCurve;\r\n\t            this.createHoverStyle(this.curveLine);\r\n\t            this.polyLine.hide();\r\n\t        }\r\n\t        else {\r\n\t            this.line = this.polyLine;\r\n\t            this.createHoverStyle(this.polyLine);\r\n\t            this.curveLine.hide();\r\n\t        }\r\n\t\r\n\t        //3.侦听线事件\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            this.line.on(eveName, zrUtil.bind(function (e) {\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"Connector:\" + eveName;\r\n\t                params.target = that;\r\n\t                this.trigger(params.type, params);\r\n\t                if(this.options.isEdit == false){return;}\r\n\t\r\n\t                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {\r\n\t                    this.createAllconnectionPoint()\r\n\t                }\r\n\t                if(this.handles.length < 1 ) {\r\n\t                    this.shapeSetHandle();\r\n\t                }\r\n\t            }, this));\r\n\t        }, this);\r\n\t\r\n\t        //3.创建调整线的连接点\r\n\t        if(this.options.isEdit) {\r\n\t            this.conPointsGroup = new graphic.Group();\r\n\t            this.add(this.conPointsGroup);\r\n\t        }\r\n\t\r\n\t        //4.创建线上文本\r\n\t        if (this.options.text.text && this.options.text.text != \"\") {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n\t            this.add(text.text);\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    //设置style\r\n\t    Connector.prototype.setStyle = function(options) {\r\n\t        if(options.color){\r\n\t            if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n\t                this.groupCurve.eachChild(function(curve) {\r\n\t                    curve.attr(\"style\",{stroke:options.color});\r\n\t                    graphic.setNormalStyle(curve, {stroke:options.color});\r\n\t                });\r\n\t            }else{\r\n\t                this.polyLine.attr(\"style\",{stroke:options.color});\r\n\t                graphic.setNormalStyle(this.polyLine, {stroke:options.color});\r\n\t            }\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                symbolTo.attr(\"style\",{fill:options.color});\r\n\t                graphic.setNormalStyle(symbolTo, {fill:options.color});\r\n\t            }\r\n\t            this.options.style.stroke = options.color;\r\n\t            this.model.set(\"options.style.stroke\", options.color);\r\n\t            this.model.set(\"options.symbol.color\", options.color);\r\n\t            this.options.symbol.color = options.color;\r\n\t        }\r\n\t\r\n\t        if(options.text){\r\n\t             var lineText = this.childOfName('lineText');\r\n\t            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t            if (!lineText  && options.text.text) {\r\n\t                var text = this.drawText(\"lineText\", options.text.text,0, 0);\r\n\t                this.add(text.text);\r\n\t                lineText = this.childOfName('lineText');\r\n\t            }\r\n\t\r\n\t            if(options.text.text || options.text.text == \"\"){\r\n\t                lineText.setStyle(\"text\", options.text.text);\r\n\t                this.options.text.text = options.text.text;\r\n\t            }\r\n\t            var textPoint = this.getTextPostion(options.text);\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t            if(options.text.textPos){\r\n\t                this.options.text.textPos = options.text.textPos;\r\n\t            }else{\r\n\t                this.options.text.textPos = 'center';\r\n\t            }\r\n\t            if(options.text.color){\r\n\t                lineText.attr(\"style\",{\r\n\t                    fill: options.text.color\r\n\t                });\r\n\t                this.options.text.color = options.text.color;\r\n\t            }\r\n\t            this.model.set(\"options.text\", options.text);\r\n\t        }\r\n\t\r\n\t        if(options.symbol){\r\n\t            if(options.symbol.type){\r\n\t                this.options.symbol.type = options.symbol.type;\r\n\t                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n\t            }\r\n\t            if(options.symbol.size){\r\n\t                this.options.symbol.size = options.symbol.size;\r\n\t                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n\t            }\r\n\t            if(options.symbol.color){\r\n\t                this.options.symbol.color = options.symbol.color;\r\n\t                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n\t            }\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                this.remove(symbolTo);\r\n\t            }\r\n\t            var symbol = this.createSymbol(\"toSymbol\",this.model.get(\"options\"))\r\n\t            if (symbol) {\r\n\t                this.add(symbol);\r\n\t            }\r\n\t            this.refresh();\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的位置\r\n\t     * @param  {Object} text {text:'', color:'', textPos:''}\r\n\t     * @return {Object}      {x,y}\r\n\t     */\r\n\t    Connector.prototype.getTextPostion = function(text) {\r\n\t        var textPostion = [];\r\n\t        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t        if(text&&text.textPos){\r\n\t            if(text.textPos == 'start'){\r\n\t                var xOffset = text.xOffset || 0;\r\n\t                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];\r\n\t            }else if(text.textPos == 'end'){\r\n\t                var points  = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length-2],this.turningPoints[this.turningPoints.length-1]]);\r\n\t                var angle = Util.getAngle(points[0],points[1]);\r\n\t                var length =  Util.distance(points[0],points[1]) - textWidth;\r\n\t                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t                textPostion = [newPoint.x,newPoint.y];\r\n\t            }else{\r\n\t                textPostion = this.middle(text);\r\n\t            }\r\n\t        }else{\r\n\t            var position = this.middle(text);\r\n\t            textPostion = [position[0]-textWidth/2,position[1]];\r\n\t        }\r\n\t\r\n\t        return textPostion;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的旋转角度\r\n\t     * @param  {Object} textPostion {x,y}\r\n\t     * @return {Number}             角度值\r\n\t     */\r\n\t    Connector.prototype.getTextRotation = function(textPostion) {\r\n\t        //计算出极坐标的角度\r\n\t        var points  = Util.getMaxLineLength(this.turningPoints);\r\n\t        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2\r\n\t        return angle;\r\n\t    };\r\n\t\r\n\t    Connector.prototype.createHoverStyle = function(el) {\r\n\t        if (this.options.hoverStyle) {\r\n\t            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}\r\n\t\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                graphic.doEnterHover(el);\r\n\t                if(symbolTo){graphic.doEnterHover(symbolTo);}\r\n\t\r\n\t                this.groupCurve.eachChild(function(line) {\r\n\t                    graphic.doEnterHover(line);\r\n\t                });\r\n\t            },this))\r\n\t              .on('mouseout', zrUtil.bind(function() {\r\n\t                graphic.doLeaveHover(el);\r\n\t                if(symbolTo){graphic.doLeaveHover(symbolTo);}\r\n\t                this.groupCurve.eachChild(function(line) {\r\n\t                    graphic.doLeaveHover(line);\r\n\t                });\r\n\t            },this));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 创建Node的连接点\r\n\t     * @private\r\n\t     *\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.createAllconnectionPoint = function() {\r\n\t        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\t\r\n\t        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连接点\r\n\t     * @private\r\n\t     * @param  {[type]} shape [description]\r\n\t     * @param  {[type]} point [description]\r\n\t     * @param  {[type]} type  [description]\r\n\t     * @return {[type]}       [description]\r\n\t     */\r\n\t    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n\t        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n\t        this.conPointsGroup.add(conPoint.shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.clearHandles = function() {\r\n\t        for (var i = 0; i < this.handles.length; i++) {\r\n\t            this.remove(this.handles[i].handleShape);\r\n\t        }\r\n\t        this.handles = [];\r\n\t        if (this.conPointsGroup) {\r\n\t            this.conPointsGroup.removeAll();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建拆线 线断的控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.shapeSetHandle = function() {\r\n\t        for(var i=1; i<this.turningPoints.length-2; i++){\r\n\t            var h;\r\n\t            var x, y;\r\n\t            //是否在一条线上\r\n\t            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);\r\n\t            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);\r\n\t            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))\r\n\t                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {\r\n\t\r\n\t                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical\r\n\t                    x = this.turningPoints[i].x;\r\n\t                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;\r\n\t\r\n\t                    h = new Handle('h',x,y,this);\r\n\t\r\n\t\r\n\t                }\r\n\t                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal\r\n\t                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;\r\n\t                    y = this.turningPoints[i].y;\r\n\t                    h =  new  Handle('v',x,y,this);\r\n\t                }\r\n\t                if (h) {\r\n\t                    this.add(h.handleShape);\r\n\t                    this.handles.push(h);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建箭头\r\n\t     * @param  {[type]} name       [description]\r\n\t     * @param  {[type]} options [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    Connector.prototype.createSymbol = function(name, options) {\r\n\t        var symbolType = options.symbol.type;\r\n\t        var symbolSize =this.options.symbol.size;\r\n\t        if (symbolType === 'none') {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        if (!zrUtil.isArray(symbolSize)) {\r\n\t            symbolSize = [symbolSize, symbolSize];\r\n\t        }\r\n\t        var symbolPath = symbolUtil.createSymbol(\r\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n\t            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z\r\n\t        );\r\n\t        symbolPath.name = name;\r\n\t\r\n\t        return symbolPath;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 绘制线段上的文本\r\n\t     * @param  {[type]} content [description]\r\n\t     * @param  {[type]} name [description]\r\n\t     * @param  {[type]} x       [description]\r\n\t     * @param  {[type]} y       [description]\r\n\t     * @param  {[type]} color   [description]\r\n\t     * @return {[type]}         [description]\r\n\t     */\r\n\t    Connector.prototype.drawText = function (name,content, x, y, color) {\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: content,\r\n\t                x: x,\r\n\t                y: y,\r\n\t                fill: color ? color : this.options.text.color,\r\n\t                textFont: this.options.text.textFont\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        text.name = name;\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的中间值\r\n\t     * @return {[type]} text\r\n\t     */\r\n\t    Connector.prototype.middle = function(text){\r\n\t\r\n\t        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){\r\n\t            var points  = Util.getMaxLineLength(this.turningPoints);\r\n\t            //如果是求线段上的文字的中间值\r\n\t            // if(text) {\r\n\t            //     //取出字的长度，计算角度，\r\n\t            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t            //     var angle = Util.getAngle(points[0],points[1]);\r\n\t            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n\t            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t            //     return [newPoint.x, newPoint.y];\r\n\t            // } else {\r\n\t            //     var middleX = (points[0].x + points[1].x)/2;\r\n\t            //     var middleY = (points[0].y + points[1].y) /2;\r\n\t            //     return [middleX, middleY];\r\n\t            // }\r\n\t            var middleX = (points[0].x + points[1].x)/2;\r\n\t            var middleY = (points[0].y + points[1].y) /2;\r\n\t            return [middleX, middleY];\r\n\t        }\r\n\t        else if(this.options.style.lineType == Connector.TYPE_JAGGED){\r\n\t\r\n\t            //find total distance\r\n\t            var distance = this.getLength();\r\n\t\r\n\t            //find between what turning points the half distance is\r\n\t            var index = -1;\r\n\t            var ellapsedDistance = 0;\r\n\t            for(var i=0; i<this.turningPoints.length-1; i++){\r\n\t                index = i;\r\n\t                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n\t                if(ellapsedDistance + segment < distance /2){\r\n\t                    ellapsedDistance += segment;\r\n\t                }\r\n\t                else{\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n\t            if(index != -1){\r\n\t                var missingDistance = distance / 2 - ellapsedDistance;\r\n\t                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)\r\n\t                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n\t                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)\r\n\t                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n\t                } else{\r\n\t                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1]\r\n\t                        + \" nr of points \" + this.turningPoints.length\r\n\t                        );\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t        else if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n\t            var t = 0.5;\r\n\t            var l = this.getLength();\r\n\t\r\n\t            var walked = 0;\r\n\t            for(var j =0; j< this.turningPoints.length-1; j++){\r\n\t                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\t            }\r\n\t\r\n\t            var rest = l * t - walked;\r\n\t            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\t\r\n\t            //find the position/ration of the middle of Polyline on current segment\r\n\t            var segmentPercent = rest / currentSegmentLength;\r\n\t\r\n\t            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n\t            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\t\r\n\t            return [Xp, Yp];\r\n\t\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * find total distance\r\n\t     * @return {Number} [description]\r\n\t     */\r\n\t    Connector.prototype.getLength = function() {\r\n\t            //find total distance\r\n\t        var distance = 0;\r\n\t        for(var i=0; i<this.turningPoints.length-1; i++){\r\n\t            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n\t        }\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 转JSON对象\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.toJSON = function() {\r\n\t\r\n\t        this.model.set(\"resourceId\", this.resourceId);\r\n\t        this.model.set(\"properties.type\", 14);\r\n\t\r\n\t        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n\t        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n\t        this.model.set(\"style.sPos\", this.sPos);\r\n\t        this.model.set(\"style.ePos\", this.ePos);\r\n\t        this.model.set(\"dockers\",this.turningPoints);\r\n\t        return this.model.option;\r\n\t    };\r\n\t\r\n\t     /**\r\n\t     * refreshModel\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.refreshModel = function() {\r\n\t        this.model.set(\"options.dockers\",this.turningPoints);\r\n\t        var icons = [];\r\n\t        for(var i = 0;i < this.icons.length;i++){\r\n\t            var iconNode = this.icons[i];\r\n\t            var option = [iconNode.key,{\r\n\t                icon:iconNode.style.image,\r\n\t                width: iconNode.style.width,\r\n\t                height: iconNode.style.height\r\n\t            }];\r\n\t            icons.push(option);\r\n\t        }\r\n\t        this.model.set(\"icons\",icons);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整曲线的形状\r\n\t     * @param  {array} points 点数组\r\n\t     * @return {void}\r\n\t     */\r\n\t    Connector.prototype.modifyCurve = function(points) {\r\n\t        var sol = this.getCurvePoint(points);\r\n\t\r\n\t        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n\t        var willDelCurves = [];\r\n\t        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {\r\n\t            willDelCurves.push(this.groupCurve.childAt(j));\r\n\t        }\r\n\t        zrUtil.each(willDelCurves, function(curve) {\r\n\t            this.groupCurve.remove(curve);\r\n\t        }, this);\r\n\t        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n\t        for (var i = 0; i < sol.length; i++) {\r\n\t            var line = this.groupCurve.childAt(i);\r\n\t            if (line) {\r\n\t                line.attr('shape', sol[i]);\r\n\t            } else {\r\n\t                var cure = new graphic.BezierCurve({\r\n\t                    position: this.options.position,\r\n\t                    style: this.options.style,\r\n\t                    shape: sol[i],\r\n\t                    z: this.options.z\r\n\t                });\r\n\t                this.groupCurve.add(cure);\r\n\t                this.createHoverStyle(cure);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据传入的点数组计算曲线的点\r\n\t     * @param  {array} P 点数组\r\n\t     * @return {object}        曲线的点数组\r\n\t     */\r\n\t    Connector.prototype.getCurvePoint = function(P) {\r\n\t        var n = P.length;\r\n\t        var sol = [];\r\n\t        if (n === 3) {\r\n\t            sol.push({x1: P[0].x,\r\n\t                   y1: P[0].y,\r\n\t                   cpx1: P[1].x,\r\n\t                   cpy1: P[1].y,\r\n\t                   x2: P[2].x,\r\n\t                   y2: P[2].y\r\n\t                });\r\n\t            return sol;\r\n\t        }\r\n\t        else if (n === 4) {\r\n\t            sol.push({x1: P[0].x,\r\n\t                   y1: P[0].y,\r\n\t                   cpx1: P[1].x,\r\n\t                   cpy1: P[1].y,\r\n\t                   cpx2: P[2].x,\r\n\t                   cpy2: P[2].y,\r\n\t                   x2: P[3].x,\r\n\t                   y2: P[3].y\r\n\t                });\r\n\t            return sol;\r\n\t        }\r\n\t\r\n\t        /**Computes factorial\r\n\t         * @param {Number} k the number\r\n\t         * */\r\n\t        function fact(k){\r\n\t            if(k===0 || k===1){\r\n\t                return 1;\r\n\t            }\r\n\t            else{\r\n\t                return k * fact(k-1);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        /**Computes Bernstain*/\r\n\t        function B(i,n,u){\r\n\t            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);\r\n\t        }\r\n\t\r\n\t        /**Computes the sum between two point\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function sum(p1, p2){\r\n\t            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n\t        }\r\n\t\r\n\t        /**Computes the difference between first {Point} and second {Point}\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function minus(p1, p2){\r\n\t            return new Point(p1.x - p2.x, p1.y - p2.y);\r\n\t        }\r\n\t\r\n\t        /**Computes the division of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function divide(p, nr){\r\n\t            if(nr == 0){\r\n\t                throw \"Division by zero not allowed (yet :) \" + this.callee ;\r\n\t            }\r\n\t            return new Point(p.x/nr, p.y/nr);\r\n\t        }\r\n\t\r\n\t        /**Computes the multiplication of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function multiply(p, nr){\r\n\t            return new Point (p.x * nr, p.y * nr);\r\n\t        }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        /*\r\n\t         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n\t         *but otherwise we will get division by zero\r\n\t         */\r\n\t        var k = [0,0,0];\r\n\t\r\n\t        var j;\r\n\t        for(j=0;j<=n-3;j++){\r\n\t            k.push(j);\r\n\t        }\r\n\t\r\n\t        k.push(n-3, n-3);\r\n\t\r\n\t\r\n\t\r\n\t        for(i=1; i<=n-3; i++){\r\n\t            //q1 - compute start point\r\n\t            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);\r\n\t\r\n\t            //q0 - compute 1st controll point\r\n\t            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);\r\n\t            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);\r\n\t            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );\r\n\t            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\t\r\n\t            //q2 - compute 2nd controll point\r\n\t            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );\r\n\t\r\n\t            //q3 - compute end point\r\n\t            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);\r\n\t            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);\r\n\t            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );\r\n\t            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\t\r\n\t            //store solution\r\n\t            //\r\n\t            sol.push({x1: q0.x,\r\n\t                   y1: q0.y,\r\n\t                   cpx1: q1.x,\r\n\t                   cpy1: q1.y,\r\n\t                   cpx2: q2.x,\r\n\t                   cpy2: q2.y,\r\n\t                   x2: q3.x,\r\n\t                   y2: q3.y\r\n\t                });\r\n\t        }\r\n\t\r\n\t        return sol;\r\n\t    };\r\n\t\r\n\t\r\n\t    Util.inherits(Connector,Node);\r\n\t\r\n\t    module.exports = Connector;\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    /**\r\n\t     * Triangle shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Triangle = graphic.extendShape({\r\n\t        type: 'triangle',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy + height);\r\n\t            path.lineTo(cx - width, cy + height);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t    /**\r\n\t     * Diamond shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Diamond = graphic.extendShape({\r\n\t        type: 'diamond',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy);\r\n\t            path.lineTo(cx, cy + height);\r\n\t            path.lineTo(cx - width, cy);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Pin shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Pin = graphic.extendShape({\r\n\t        type: 'pin',\r\n\t        shape: {\r\n\t            // x, y on the cusp\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (path, shape) {\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var w = shape.width / 5 * 3;\r\n\t            // Height must be larger than width\r\n\t            var h = Math.max(w, shape.height);\r\n\t            var r = w / 2;\r\n\t\r\n\t            // Dist on y with tangent point and circle center\r\n\t            var dy = r * r / (h - r);\r\n\t            var cy = y - h + r + dy;\r\n\t            var angle = Math.asin(dy / r);\r\n\t            // Dist on x with tangent point and circle center\r\n\t            var dx = Math.cos(angle) * r;\r\n\t\r\n\t            var tanX = Math.sin(angle);\r\n\t            var tanY = Math.cos(angle);\r\n\t\r\n\t            path.arc(\r\n\t                x, cy, r,\r\n\t                Math.PI - angle,\r\n\t                Math.PI * 2 + angle\r\n\t            );\r\n\t\r\n\t            var cpLen = r * 0.6;\r\n\t            var cpLen2 = r * 0.7;\r\n\t            path.bezierCurveTo(\r\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x, y - cpLen2,\r\n\t                x, y\r\n\t            );\r\n\t            path.bezierCurveTo(\r\n\t                x, y - cpLen2,\r\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x - dx, cy + dy\r\n\t            );\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Arrow shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Arrow = graphic.extendShape({\r\n\t\r\n\t        type: 'arrow',\r\n\t\r\n\t        shape: {\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var height = shape.height;\r\n\t            var width = shape.width;\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var dx = width / 3 * 2;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.lineTo(x + dx, y + height);\r\n\t            ctx.lineTo(x, y + height / 4 * 3);\r\n\t            ctx.lineTo(x - dx, y + height);\r\n\t            ctx.lineTo(x, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Map of path contructors\r\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\r\n\t     */\r\n\t    var symbolCtors = {\r\n\t        line: graphic.Line,\r\n\t\r\n\t        rect: graphic.Rect,\r\n\t\r\n\t        roundRect: graphic.Rect,\r\n\t\r\n\t        square: graphic.Rect,\r\n\t\r\n\t        circle: graphic.Circle,\r\n\t\r\n\t        diamond: Diamond,\r\n\t\r\n\t        pin: Pin,\r\n\t\r\n\t        arrow: Arrow,\r\n\t\r\n\t        triangle: Triangle\r\n\t    };\r\n\t\r\n\t    var symbolShapeMakers = {\r\n\t\r\n\t        line: function (x, y, w, h, shape) {\r\n\t            // FIXME\r\n\t            shape.x1 = x;\r\n\t            shape.y1 = y + h / 2;\r\n\t            shape.x2 = x + w;\r\n\t            shape.y2 = y + h / 2;\r\n\t        },\r\n\t\r\n\t        rect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        roundRect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t            shape.r = Math.min(w, h) / 4;\r\n\t        },\r\n\t\r\n\t        square: function (x, y, w, h, shape) {\r\n\t            var size = Math.min(w, h);\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = size;\r\n\t            shape.height = size;\r\n\t        },\r\n\t\r\n\t        circle: function (x, y, w, h, shape) {\r\n\t            // Put circle in the center of square\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.r = Math.min(w, h) / 2;\r\n\t        },\r\n\t\r\n\t        diamond: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        pin: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        arrow: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        triangle: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolBuildProxies = {};\r\n\t    for (var name in symbolCtors) {\r\n\t        symbolBuildProxies[name] = new symbolCtors[name]();\r\n\t    }\r\n\t\r\n\t    var Symbol = graphic.extendShape({\r\n\t\r\n\t        type: 'symbol',\r\n\t\r\n\t        shape: {\r\n\t            symbolType: '',\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        beforeBrush: function () {\r\n\t            var style = this.style;\r\n\t            var shape = this.shape;\r\n\t            // FIXME\r\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n\t                style.textPosition = ['50%', '40%'];\r\n\t                style.textAlign = 'center';\r\n\t                style.textVerticalAlign = 'middle';\r\n\t            }\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var symbolType = shape.symbolType;\r\n\t            var proxySymbol = symbolBuildProxies[symbolType];\r\n\t            if (shape.symbolType !== 'none') {\r\n\t                if (!proxySymbol) {\r\n\t                    // Default rect\r\n\t                    symbolType = 'rect';\r\n\t                    proxySymbol = symbolBuildProxies[symbolType];\r\n\t                }\r\n\t                symbolShapeMakers[symbolType](\r\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n\t                );\r\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n\t    var symbolPathSetColor = function (color) {\r\n\t        if (this.type !== 'image') {\r\n\t            var symbolStyle = this.style;\r\n\t            var symbolShape = this.shape;\r\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\r\n\t                symbolStyle.stroke = color;\r\n\t            }\r\n\t            else if (this.__isEmptyBrush) {\r\n\t                symbolStyle.stroke = color;\r\n\t                symbolStyle.fill = '#fff';\r\n\t            }\r\n\t            else {\r\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n\t                symbolStyle.fill && (symbolStyle.fill = color);\r\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n\t            }\r\n\t            this.dirty();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolUtil = {\r\n\t        /**\r\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n\t         * @param {string} symbolType\r\n\t         * @param {number} x\r\n\t         * @param {number} y\r\n\t         * @param {number} w\r\n\t         * @param {number} h\r\n\t         * @param {number} z\r\n\t         * @param {string} color\r\n\t         */\r\n\t        createSymbol: function (symbolType, x, y, w, h, color, z) {\r\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\r\n\t            if (isEmpty) {\r\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n\t            }\r\n\t            var symbolPath;\r\n\t\r\n\t            if (symbolType.indexOf('image://') === 0) {\r\n\t                symbolPath = new graphic.Image({\r\n\t                    style: {\r\n\t                        image: symbolType.slice(8),\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t            else if (symbolType.indexOf('path://') === 0) {\r\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));\r\n\t            }\r\n\t            else {\r\n\t                symbolPath = new Symbol({\r\n\t                    shape: {\r\n\t                        symbolType: symbolType,\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t\r\n\t            symbolPath.__isEmptyBrush = isEmpty;\r\n\t\r\n\t            symbolPath.setColor = symbolPathSetColor;\r\n\t\r\n\t            symbolPath.setColor(color);\r\n\t\r\n\t            return symbolPath;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = symbolUtil;\r\n\t\r\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 画句柄\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Util = __webpack_require__(59);\r\n\t    function Handle(type, x, y, connector){\r\n\t        this.type = type;\r\n\t\r\n\t        this.x = x;\r\n\t\r\n\t        this.y = y;\r\n\t\r\n\t        this.visible = true;\r\n\t\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.handleShape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: x,\r\n\t                cy: y,\r\n\t                r: Handle.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: \"rgb(0,255,0)\",\r\n\t                stroke:\"rgb(0,0,0)\"\r\n\t            },\r\n\t            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n\t            draggable:true\r\n\t        });\r\n\t\r\n\t        var that = this;\r\n\t        this.handleShape.on(\"drag\", function(e) {\r\n\t            that.actionConnector(e.offsetX,e.offsetY);\r\n\t        });\r\n\t       // return this.circle;\r\n\t    }\r\n\t\r\n\t    Handle.RADIUS = 4;\r\n\t\r\n\t    Handle.prototype = {\r\n\t\r\n\t        constructor : Handle,\r\n\t\r\n\t        equals : function(anotherHandle){\r\n\t            if(!anotherHandle instanceof Handle){\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            return this.type == anotherHandle.type\r\n\t            && this.x == anotherHandle.x\r\n\t            && this.y == anotherHandle.y\r\n\t            && this.visible == anotherHandle.visible;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 移动句柄\r\n\t         * @param  {[type]} newX [description]\r\n\t         * @param  {[type]} newY [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        actionConnector: function(newX, newY){\r\n\t            switch(this.type){\r\n\t                case 'v':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n\t                            && this.connector.turningPoints[i].y == this.y\r\n\t                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n\t                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n\t                        {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaY = newY - this.y;\r\n\t                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\t\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.y = newY;  //将句柄新的位置赋值给y\r\n\t\r\n\t                    break;\r\n\t\r\n\t                case 'h':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n\t                            && this.connector.turningPoints[i].x == this.x\r\n\t                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n\t                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n\t                            {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaX = newX-this.x;\r\n\t                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.x = newX; //将句柄新的位置赋值给x\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t           //. this.shape.updateMiddleText();\r\n\t        }\r\n\t    };\r\n\t    module.exports = Handle;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线动态效果\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var curveUtil = __webpack_require__(26);\r\n\t    var symbolUtil = __webpack_require__(78);\r\n\t\r\n\t    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n\t        this._lastFrame = 0;\r\n\t        this._lastFramePercent = 0;\r\n\t        this.symbol = symbol;\r\n\t        this.groupCurve = groupCurve;\r\n\t        this.initSymbol(options, polyLine);\r\n\t    }\r\n\t    var EffectLineProto = EffectLine.prototype;\r\n\t\r\n\t    EffectLineProto.initSymbol = function(options, polyLine) {\r\n\t        var that = this;\r\n\t        this.symbol.z2 = 100;\r\n\t        this.symbol.culling = true;\r\n\t        var period = options.effect.period * 1000;\r\n\t        this.symbol.__t = 0;\r\n\t        this.symbol.stopAnimation();\r\n\t        if ((options.style.lineType == \"curve\")) {\r\n\t            if (this.groupCurve) {\r\n\t                var i = 0;\r\n\t                period = period / this.groupCurve._children.length;\r\n\t                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n\t            }\r\n\t\r\n\t        } else {\r\n\t            this.symbol.animate('', true)\r\n\t                .when(period, {\r\n\t                    __t: 1\r\n\t                })\r\n\t                .delay(0)\r\n\t                .during(function() {\r\n\t                    that.updateSymbolPositionPolyline();\r\n\t                })\r\n\t                .start();\r\n\t            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n\t        var that = this;\r\n\t        if (curveLine == undefined) {\r\n\t            curveLine = this.groupCurve._children[0];\r\n\t            i = 0;\r\n\t        }\r\n\t        var points;\r\n\t        var pos = curveLine.shape;\r\n\t        points = [\r\n\t            [pos.x1, pos.y1],\r\n\t            [pos.x2, pos.y2],\r\n\t            [pos.cpx1, pos.cpy1],\r\n\t            [pos.cpx2, pos.cpy2]\r\n\t        ];\r\n\t        this.setAnimationPointsBezierCurve(points);\r\n\t        this.symbol.animate('')\r\n\t            .when(period, {\r\n\t                __t: 1\r\n\t            })\r\n\t            .delay(0)\r\n\t            .during(function() {\r\n\t                that.updateSymbolPositionBezierCurve();\r\n\t            })\r\n\t            .done(function() {\r\n\t                that.symbol.__t = 0;\r\n\t                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n\t            })\r\n\t            .start();\r\n\t\r\n\t    };\r\n\t\r\n\t\r\n\t    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n\t        this.symbol.__p1 = points[0];\r\n\t        this.symbol.__p2 = points[1];\r\n\t        this.symbol.__cp1 = points[2] || [\r\n\t            (points[0][0] + points[1][0]) / 2,\r\n\t            (points[0][1] + points[1][1]) / 2\r\n\t        ];\r\n\t        this.symbol.__cp2 = points[3];\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n\t        var p1 = this.symbol.__p1;\r\n\t        var p2 = this.symbol.__p2;\r\n\t        var cp1 = this.symbol.__cp1;\r\n\t        var cp2 = this.symbol.__cp2;\r\n\t        var t = this.symbol.__t;\r\n\t        var pos = this.symbol.position;\r\n\t        var tx, ty;\r\n\t        if (cp2[0] != undefined) {\r\n\t            var cubicAt = curveUtil.cubicAt;\r\n\t            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n\t            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t        } else {\r\n\t            var quadraticAt = curveUtil.quadraticAt;\r\n\t            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n\t            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n\t            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n\t            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n\t        }\r\n\t        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\t\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n\t        this._points = points;\r\n\t        var accLenArr = [0];\r\n\t        var len = 0;\r\n\t        for (var i = 1; i < points.length; i++) {\r\n\t            var p1 = points[i - 1];\r\n\t            var p2 = points[i];\r\n\t            len += vec2.dist(p1, p2);\r\n\t            accLenArr.push(len);\r\n\t        }\r\n\t        if (len === 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        for (var j = 0; j < accLenArr.length; j++) {\r\n\t            accLenArr[j] /= len;\r\n\t        }\r\n\t        this._offsets = accLenArr;\r\n\t        this._length = len;\r\n\t        this.symbol._lastFrame = 0;\r\n\t        this.symbol.__lastFramePercent = 0;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n\t        var t = this.symbol.__t;\r\n\t        var points = this._points;\r\n\t        var offsets = this._offsets;\r\n\t        var len = points.length;\r\n\t\r\n\t        if (!offsets) {\r\n\t            // Has length 0\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var lastFrame = this._lastFrame;\r\n\t        var frame;\r\n\t\r\n\t        if (t < this._lastFramePercent) {\r\n\t            // Start from the next frame\r\n\t            // PENDING start from lastFrame ?\r\n\t            var start = Math.min(lastFrame + 1, len - 1);\r\n\t            for (frame = start; frame >= 0; frame--) {\r\n\t                if (offsets[frame] <= t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            // PENDING really need to do this ?\r\n\t            frame = Math.min(frame, len - 2);\r\n\t        } else {\r\n\t            for (var frame = lastFrame; frame < len; frame++) {\r\n\t                if (offsets[frame] > t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            frame = Math.min(frame - 1, len - 2);\r\n\t        }\r\n\t        vec2.lerp(\r\n\t            this.symbol.position, points[frame], points[frame + 1],\r\n\t            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n\t        );\r\n\t\r\n\t        this._lastFrame = frame;\r\n\t        this._lastFramePercent = t;\r\n\t        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n\t        this.symbol.rotation = angle - Math.PI / 2;\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t    module.exports = EffectLine;\r\n\t\r\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 控制点\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Util = __webpack_require__(59);\r\n\t    function ConnectionPoint(connector, point, type, options){\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.point = point.clone();\r\n\t\r\n\t        this.type = type;\r\n\t\r\n\t        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\t\r\n\t        this.oType = 'ConnectionPoint';\r\n\t\r\n\t        this.shape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: this.point.x,\r\n\t                cy: this.point.y,\r\n\t                r: ConnectionPoint.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this.color,\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : options.z + 2  //节点Z为1 线段为0;\r\n\t        });\r\n\t        this.shape.type =  this.type;\r\n\t\r\n\t        this.shape.connector = connector;\r\n\t        //return this.circle;\r\n\t    }\r\n\t\r\n\t    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\t\r\n\t    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\t\r\n\t    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\t\r\n\t    ConnectionPoint.RADIUS = 4;\r\n\t\r\n\t    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\t\r\n\t    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\t\r\n\t    ConnectionPoint.prototype = {\r\n\t\r\n\t        constructor : ConnectionPoint,\r\n\t\r\n\t        equals : function(anotherConnectionPoint){\r\n\t            return this.point.equals(anotherConnectionPoint.point)\r\n\t            && this.connector == anotherConnectionPoint.connector\r\n\t            && this.type == anotherConnectionPoint.type\r\n\t            && this.color == anotherConnectionPoint.color\r\n\t            && this.radius == anotherConnectionPoint.radius;\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t    module.exports = ConnectionPoint;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 选中节点后，出现的操作框及按钮\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Node = __webpack_require__(76);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Connector = __webpack_require__(77);\r\n\t    var env = __webpack_require__(64);\r\n\t\r\n\t    function OperationNode(node, zr, forbidEdit) {\r\n\t        Node.call(this);\r\n\t        this.node = node;\r\n\t        this.zr = zr;\r\n\t        this.forbidEdit = forbidEdit; //\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    //事件\r\n\t    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n\t    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n\t    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n\t    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n\t\r\n\t    if(!env.canvasSupported) {\r\n\t        //内置操作图标的图像\r\n\t        OperationNode.opicons = {\r\n\t            STRAIGHT: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',\r\n\t            JAGGED: 'M96.046,13.604H84.213c-1.104,0-2,0.896-2,2v42.188H38.314v-10.77c0-0.715-0.381-1.375-1-1.732c-0.619-0.357-1.382-0.355-2,0L2.954,63.977c-0.619,0.357-1,1.018-1,1.732s0.381,1.375,1,1.732l32.36,18.687c0.309,0.179,0.655,0.268,1,0.268s0.69-0.089,1-0.268c0.619-0.357,1-1.018,1-1.732V73.625h57.732c1.104,0,2-0.896,2-2V15.604C98.046,14.5,97.151,13.604,96.046,13.604z',\r\n\t            CURVE: 'M510.536,268.098c13.541,0,27.078-5.207,37.347-15.6c20.379-20.625,20.18-53.866-0.445-74.245L414.167,46.57c-9.905-9.786-23.325-15.244-37.215-15.154c-13.923,0.083-27.244,5.695-37.03,15.599l-129.912,131.48c-20.379,20.625-20.18,53.866,0.445,74.245c20.625,20.379,53.866,20.18,74.245-0.445l40.618-41.108c0.021,0.464,0.029,0.927,0.062,1.394c4.178,59.008,4.668,119.832,16.633,177.931c23.937,116.232,103.705,191.961,191.489,264.024c47.292,38.823,79.66,94.122,98.601,151.673c9.765,29.669,14.714,77.115,17.215,107.157c2.261,27.161,25.08,47.978,52.333,47.709l1.061-0.01c30.228-0.298,53.81-26.211,51.306-56.336c-2.921-35.15-8.858-89.828-20.925-127.49c-16.283-50.821-40.016-99.463-74.766-140.245c-33.993-39.892-75.456-72.403-113.338-108.373c-47.091-44.713-84.977-95.161-98.006-159.719c-10.541-52.231-12.789-105.215-16.461-158.562l43.118,42.604C483.87,263.053,497.205,268.098,510.536,268.098z',\r\n\t            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'\r\n\t        };\r\n\t    }else{\r\n\t        OperationNode.opicons = {\r\n\t            STRAIGHT: 'data:image/png;base64,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',\r\n\t            JAGGED: 'data:image/png;base64,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',\r\n\t            CURVE: 'data:image/png;base64,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',\r\n\t            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'\r\n\t        };\r\n\t    }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t    OperationNode.prototype.render = function() {\r\n\t        this.renderBase();\r\n\t        if (!this.forbidEdit) {\r\n\t            this.renderOther();\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderBase = function() {\r\n\t        this.createOperation();\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.createOperation = function() {\r\n\t        var me = this;\r\n\t        this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n\t        this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n\t        this.add(this.virtualRect);\r\n\t\r\n\t\r\n\t\r\n\t        if (this.node.operationIcons) {\r\n\t            zrUtil.each(this.node.operationIcons, function(item) {\r\n\t                //检查是否是内置图标\r\n\t                var opIconInstance = null;\r\n\t                if (OperationNode.opicons[item.name + \"\"]) {\r\n\t\r\n\t                    if (this.forbidEdit) {\r\n\t                        return;\r\n\t                    }\r\n\t                    if (item.name == \"DEL\") {\r\n\t                        //垃圾桶\r\n\t                        var rect1 = { x: 0, y: 0, width: 10, height: 15 };\r\n\t                        opIconInstance = graphic.makePath(OperationNode.opicons[item.name + \"\"], { style: { fill: '#000000' },z:me.node.z+1 }, rect1);\r\n\t                        if(item.callback){\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                e.data = item;\r\n\t                                e.node = me.node;  // 将所附的节点也传递出去\r\n\t                                if (item.callback) {\r\n\t                                    item.callback(e);\r\n\t                                }\r\n\t                            });\r\n\t                        }else{\r\n\t                            opIconInstance.on(\"click\", function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.target = this;\r\n\t                                params.type = OperationNode.DELETE_CLICK;\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        }\r\n\t\r\n\t\r\n\t                    } else {\r\n\t                        if(!env.canvasSupported){\r\n\t                            var rect = { x: 0, y: 0, width: 15, height: 15 };\r\n\t                            opIconInstance = graphic.makePath(OperationNode.opicons[item.name + \"\"], { style: { fill: '#000000' },draggable:true,z:me.node.z+1,lineType: Connector[\"TYPE_\" + item.name] }, rect);\r\n\t                        }else{\r\n\t                            var imageUrl = document.createElement('img');\r\n\t                            imageUrl.src = OperationNode.opicons[item.name + \"\"];\r\n\t                            opIconInstance = new graphic.Image({\r\n\t                                style: {\r\n\t                                    image:imageUrl,\r\n\t                                    cursor: 'default',\r\n\t                                    width:15,\r\n\t                                    height:15\r\n\t                                },\r\n\t                                draggable: true,\r\n\t                                z: me.node.z+1, //zIndex 置于最高\r\n\t                                lineType: Connector[\"TYPE_\" + item.name] //区分不同的线段\r\n\t                            });\r\n\t                        }\r\n\t\r\n\t                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n\t                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n\t                            opIconInstance.on(eveName, function(e) {\r\n\t                                var params = {};\r\n\t                                params.event = e;\r\n\t                                params.data = item.options\r\n\t                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n\t                                me.trigger(params.type, params);\r\n\t                            });\r\n\t                        });\r\n\t                    }\r\n\t\r\n\t                } else {\r\n\t                    //用户自定义的图标放在这里，用户传进来的图标只能响应click事件，其它事件暂不支持\r\n\t                    opIconInstance = new graphic.Image({\r\n\t                        style: {\r\n\t                            image: item.iconPath,\r\n\t                            width: item.width || 15,\r\n\t                            height: item.height || 15\r\n\t                        },\r\n\t                        z:me.node.z+1 //zIndex 置于最高\r\n\t                    });\r\n\t                    opIconInstance.on(\"click\", function(e) {\r\n\t                        e.data = item;\r\n\t                        e.node = me.node;  // 将所附的节点也传递出去\r\n\t                        if (item.callback) {\r\n\t                            item.callback(e);\r\n\t                        }\r\n\t\r\n\t                        //todo 用户自定图标click事件是否要派发到外面\r\n\t                    });\r\n\t                }\r\n\t                opIconInstance.name = item.name;\r\n\t                me.add(opIconInstance);\r\n\t            });\r\n\t        }\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n\t        var me = this;\r\n\t        var i = 0;\r\n\t        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n\t        //1.定位虚框\r\n\t        this.virtualRect.setShape({ points: nodeRect.points });\r\n\t        //2.定位每个小图标\r\n\t        this.eachChild(function(nodeItem) {\r\n\t            if (!nodeItem.isSelfComputePos) {\r\n\t                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n\t                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this.refreshPositionOther(node,nodeRect);\r\n\t    };\r\n\t\r\n\t    OperationNode.prototype.renderOther = function() {\r\n\t        //留给扩展使用\r\n\t    };\r\n\t    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n\t        //留给扩展使用\r\n\t        //3.定位整个operationNode\r\n\t        if (node.parent && node.parent.isBg && node.parent.isBg == true) {\r\n\t            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n\t        } else {\r\n\t            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+node.shape.x, nodeRect.y + node.parent.position[1]+node.shape.y])\r\n\t        }\r\n\t    };\r\n\t    zrUtil.inherits(OperationNode, Node);\r\n\t    module.exports = OperationNode;\r\n\t\r\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * flow连线管理类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t\tvar zrUtil = __webpack_require__(4);\r\n\t\tvar ConnectionManager = __webpack_require__(84);\r\n\t\tvar Connector = __webpack_require__(77);\r\n\t    var Util = __webpack_require__(59);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Point = __webpack_require__(60);\r\n\t    var Constants = __webpack_require__(86);\r\n\t    var Model = __webpack_require__(87);\r\n\t    var Log = __webpack_require__(85);\r\n\t\tvar connectionManagerExtend = {\r\n\t        LineOperations:[],\r\n\t        bundleOffset: 30,\r\n\t        bundleGap: 20,\r\n\t        connectorMap: Util.StackedMap.createNew(),\r\n\t        /**\r\n\t         * 创建连线\r\n\t         * @param  {[type]} startNode [开始节点]\r\n\t         * @param  {[type]} endNode   [结束节点]\r\n\t         * @param  {[type]} options      [类型]\r\n\t         * @param {[type]} [api] [description]\r\n\t         * @return {[type]}           [返回连线]\r\n\t         */\r\n\t        connectorCreate:function(startNode,endNode,options, api){\r\n\t            var that = this;\r\n\t            var model = options.model;\r\n\t            //1.创建线段\r\n\t            var connector = new Connector(options);\r\n\t            connector.startNode = startNode;\r\n\t            connector.endNode = endNode;\r\n\t            if(options.autoChangePosition){\r\n\t                connector.autoChangePosition = options.autoChangePosition;\r\n\t            }\r\n\t            if (options.pos) {\r\n\t                var pos = options.pos.split(\",\");\r\n\t                connector.sPos = pos[0];\r\n\t                connector.ePos = pos[1];\r\n\t            };\r\n\t            this.connectors.push(connector);\r\n\t\r\n\t            var key = this.getTwoNodeId(startNode,endNode);\r\n\t            this.connectorMap.add(key, connector);\r\n\t\r\n\t            if(connector.conPointsGroup) {\r\n\t                connector.conPointsGroup.on(\"click\", function(e) {\r\n\t                    var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n\t                    var connector = e.target.connector;\r\n\t                    if (arrSplit[0] === Connector.START_NODE) {\r\n\t                        connector.sPos = arrSplit[1];\r\n\t                    } else if (arrSplit[0] === Connector.END_NODE){\r\n\t                        connector.ePos = arrSplit[1];\r\n\t                    };\r\n\t                    that.refreshConnector(connector,true);\r\n\t                    e.cancelBubble = true;\r\n\t                    var params = {};\r\n\t                    params.event = e;\r\n\t                    params.type = \"conPointsGroup:click\";\r\n\t                    params.lineNode = that.selConnector;\r\n\t                    api.trigger(params.type, params);\r\n\t                });\r\n\t            }\r\n\t\r\n\t\r\n\t            var MOUSE_EVENT_NAMES = [ 'click', 'dblclick'];\r\n\t            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t                connector.on(\"Connector:\" + eveName, function(e) {\r\n\t\r\n\t                    var selected = e.target;\r\n\t\r\n\t                    if ( that.selConnector !== selected) {\r\n\t                        that.selConnector &&  that.refreshConnector(that.selConnector);\r\n\t                        that.selConnector = selected;\r\n\t                    };\r\n\t                    e.cancelBubble = true;\r\n\t                    var params = {};\r\n\t                    params.event = e;\r\n\t                    params.type = eveName;\r\n\t                    params.target = that.selConnector;\r\n\t                    api.trigger(params.type, params);\r\n\t                });\r\n\t            });\r\n\t\r\n\t\r\n\t\r\n\t            //双击收紧为一条线\r\n\t            connector.line.on(\"dblclick\", function(e) {\r\n\t                if(connector.options.isShrink == false){return;}\r\n\t                var con = this.parent;\r\n\t                var startNode = con.startNode;\r\n\t                var endNode = con.endNode;\r\n\t                //1.获取所有的线段\r\n\t                var key = that.getTwoNodeId(startNode,endNode);\r\n\t                var cons = that.connectorMap.get(key);\r\n\t                if (cons.length == 1) {return};\r\n\t                //2.判断线是否处于隐藏状态\r\n\t\r\n\t                //2.将除中间的一条线进行隐藏\r\n\t                var half = parseInt(cons.length / 2);\r\n\t                for (var i = 0; i < cons.length; i++) {\r\n\t                    if (i != (half )) {\r\n\t                        if (cons[i].ignore) {\r\n\t                            cons[i].show();\r\n\t                        } else {\r\n\t                         cons[i].hide();\r\n\t                        }\r\n\t                    };\r\n\t\r\n\t                };\r\n\t\r\n\t                      //  that.refreshConnector(this.parent,true);\r\n\t                //alert(\"abc\");\r\n\t            });\r\n\t\r\n\t            this.bundleOffset = options.bundleOffset || this.bundleOffset;\r\n\t            this.bundleGap = options.bundleGap || this.bundleGap;\r\n\t            //2. 获取这个key对应的线段数组\r\n\t            var arrCons = this.connectorMap.get(key);\r\n\t            if (arrCons.length == 1) {\r\n\t                //两个节点只有一个连线的情况\r\n\t                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n\t                var dockers = options.dockers;\r\n\t                if (dockers && dockers.length >= 2) {\r\n\t                    var points = Point.loadArray(dockers);\r\n\t                    connector.refresh(points);\r\n\t                } else {\r\n\t                    if(options.position&&options.position.points){\r\n\t                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t                        var points = options.position.points;\r\n\t                        points.unshift(arrStartEndPoint[0]);\r\n\t                        points.push(arrStartEndPoint[1]);\r\n\t                        connector.refresh(points);\r\n\t                    }else{\r\n\t                        this.refreshConnector(arrCons[0],true);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t            else if (arrCons.length > 1) {\r\n\t                //两个节点有多个连线的情况\r\n\t                this.refreshCons(arrCons);\r\n\t            };\r\n\t\r\n\t            //3.设置模型\r\n\t            var model = new Model({});\r\n\t            model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n\t            model.set(Constants.START_ID, startNode.model.get(Constants.ID));\r\n\t            model.set(Constants.END_ID, endNode.model.get(Constants.ID));\r\n\t            model.set(Constants.OPTIONS, zrUtil.clone(options));\r\n\t            model.set(Constants.DOCKERS, connector.turningPoints);\r\n\t            model.set(Constants.STYLE_LINETYPE, options.style.lineType);\r\n\t            connector.model = model;\r\n\t            return connector;\r\n\t        },\r\n\t\r\n\t        getTwoNodeId: function(startNode,endNode) {\r\n\t            return startNode.id + \",\" + endNode.id;\r\n\t        },\r\n\t        //处理多条线段\r\n\t        refreshCons: function(arrCons) {\r\n\t            //如果是折线的话\r\n\t            if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED ) {\r\n\t                for (var i = 0; i < arrCons.length; i++) {\r\n\t                    this.refreshConnector(arrCons[i],true);\r\n\t                };\r\n\t            } else{\r\n\t                this.refreshConsStraight(arrCons);\r\n\t            };\r\n\t        },\r\n\t\r\n\t        //处理多条线段(直线)\r\n\t        refreshConsStraight: function(arrCons) {\r\n\t            var half = parseInt(arrCons.length / 2);\r\n\t            var arrConnectResult = []\r\n\t\r\n\t            var startNode = arrCons[0].startNode;\r\n\t            var endNode = arrCons[0].endNode;\r\n\t            var sRect = Util.getRect(startNode).boundingRect;\r\n\t            var eRect = Util.getRect(endNode).boundingRect;\r\n\t            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t            var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t\r\n\t            if (!arrCons[0].sPos || !arrCons[0].ePos) {\r\n\t                if (sRect.x < eRect.x) {\r\n\t                    arrCons[0].sPos = \"right\";\r\n\t                    arrCons[0].ePos = \"left\";\r\n\t                } else {\r\n\t                    arrCons[0].sPos = \"left\";\r\n\t                    arrCons[0].ePos = \"right\";\r\n\t                }\r\n\t            }\r\n\t            var startPoint = sConnectorPoint[arrCons[0].sPos];\r\n\t            var endPoint = eConnectorPoint[arrCons[0].ePos];\r\n\t            var angle = Math.atan2(endPoint.y - startPoint.y , endPoint.x - startPoint.x);\r\n\t            for (var i = half; i >= 1; i--) {\r\n\t                var points = [];\r\n\t                points.push(startPoint);  //\r\n\t               // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n\t               // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n\t                var secondPoint = startPoint.clone();\r\n\t\r\n\t                //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t                secondPoint.transform(Util.translationMatrix(0, this.bundleGap* i));\r\n\t                //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n\t                //\r\n\t                //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t\r\n\t                //从极坐标计算出直角坐标\r\n\t                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t\r\n\t\r\n\t                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t                points.push(secondPoint);\r\n\t\r\n\t                var thirdPoint = endPoint.clone();\r\n\t                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t\r\n\t\r\n\t\r\n\t                thirdPoint.transform(Util.translationMatrix(0, this.bundleGap*i));\r\n\t                //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n\t                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t                //\r\n\t                //直角坐标 x, 和 y, 计算出极坐标\r\n\t\r\n\t                //从极坐标计算出直角坐标\r\n\t                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t\r\n\t                points.push(thirdPoint);\r\n\t\r\n\t                points.push(endPoint);\r\n\t                arrConnectResult.push(points);\r\n\t            };\r\n\t\r\n\t            arrConnectResult.push([startPoint, endPoint]);\r\n\t\r\n\t            var upHalf =  Math.ceil(arrCons.length / 2);\r\n\t            for (var i = 1; i < upHalf; i++) {\r\n\t                var points = [];\r\n\t                points.push(startPoint);\r\n\t                var secondPoint = startPoint.clone();\r\n\t                //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n\t                secondPoint.transform(Util.translationMatrix(0, - this.bundleGap* i));\r\n\t                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n\t                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\t                points.push(secondPoint);\r\n\t\r\n\t                var thirdPoint = endPoint.clone();\r\n\t                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\t                thirdPoint.transform(Util.translationMatrix(0, - this.bundleGap*i));\r\n\t                //从极坐标计算出直角坐标\r\n\t                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n\t                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\t                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n\t                points.push(thirdPoint);\r\n\t\r\n\t                points.push(endPoint);\r\n\t                arrConnectResult.push(points);\r\n\t           };\r\n\t\r\n\t\r\n\t           for (var i = 0; i < arrConnectResult.length; i++) {\r\n\t               arrCons[i].refresh(arrConnectResult[i]);\r\n\t           };\r\n\t\r\n\t        },\r\n\t        boundOffsetXY: function(point, isPositive) {\r\n\t            var resultPoint = point.clone();\r\n\t            //直角坐标 x, 和 y, 计算出极坐标\r\n\t            var angle = Math.atan2(resultPoint.y , resultPoint.x);\r\n\t            var r = Math.sqrt( Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n\t            if(isPositive) {\r\n\t                r = r + this.bundleOffset;\r\n\t            } else {\r\n\t                r = r - this.bundleOffset;\r\n\t            }\r\n\t\r\n\t\r\n\t            //从极坐标计算出直角坐标\r\n\t            resultPoint.x = r * Math.cos(angle);\r\n\t            resultPoint.y = r * Math.sin(angle);\r\n\t            return resultPoint;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置线段的模型数据  (类型 文字)\r\n\t         * @param {[type]} connector [description]\r\n\t         * @param {[type]} option    [description]\r\n\t         */\r\n\t        setModel: function(connector, option) {\r\n\t            var originLineType =  connector.model.get(\"style.lineType\");\r\n\t            connector.model.mergeOption(option);\r\n\t            zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n\t            if (originLineType !== option.style.lineType) {\r\n\t                this.refreshConnector(connector, true);\r\n\t            };\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t         * 刷新连接线\r\n\t         * @param  {[type]} node [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        refreshLineByNode: function(node) {\r\n\t            // 判断这个节点是否有多条线段\r\n\t            var keys = this.connectorMap.keys();\r\n\t            for (var i = 0; i < keys.length; i++) {\r\n\t                var key = keys[i];\r\n\t                if (key.indexOf(node.id) != -1) {\r\n\t                    var arrCons = this.connectorMap.get(key);\r\n\t                    this.countLinePos(arrCons)\r\n\t                    if (arrCons.length == 1 ) {\r\n\t                        //两个节点只有一个连线的情况\r\n\t                        this.refreshConnector(arrCons[0],true);\r\n\t                    }\r\n\t                    else if (arrCons.length > 1) {\r\n\t                        //两个节点有多个连线的情况\r\n\t                        this.refreshCons(arrCons);\r\n\t                    };\r\n\t                };\r\n\t            };\r\n\t        },\r\n\t        countLinePos:function(arrCons){\r\n\t            var that = this;\r\n\t            $.each(arrCons,function(i,n){\r\n\t                if(n.autoChangePosition == true){\r\n\t                    var startNode = n.startNode;\r\n\t                    var endNode = n.endNode;\r\n\t                    var sRect = Util.getRect(startNode).boundingRect;\r\n\t                    var eRect = Util.getRect(endNode).boundingRect;\r\n\t                    var sPos = n.sPos;\r\n\t                    var ePos = n.ePos;\r\n\t                    var sPosNow = that.posIsChange(sPos,sRect,eRect,\"startNode\");\r\n\t                    var ePosNow = that.posIsChange(ePos,sRect,eRect,\"endNode\");\r\n\t                    if(sPos != sPosNow || ePos != ePosNow){\r\n\t                        n.sPos = sPosNow;\r\n\t                        n.ePos = ePosNow;\r\n\t                        n.options.pos = [sPosNow,ePosNow];\r\n\t                        n.model.set(\"options.pos\",[sPosNow,ePosNow]);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        },\r\n\t        posIsChange:function(pos,sRect,eRect,nodeType){\r\n\t            var newPos\r\n\t            if(pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1 ){\r\n\t                if(sRect.y + sRect.height < eRect.y){\r\n\t                    if(nodeType == \"startNode\"){\r\n\t                        newPos=pos.replace(/(top|bottom)/g,\"bottom\");\r\n\t                    }else{\r\n\t                        newPos=pos.replace(/(top|bottom)/g,\"top\");\r\n\t                    }\r\n\t                }else if(eRect.y + eRect.height < sRect.y){\r\n\t                    if(nodeType == \"endNode\"){\r\n\t                        newPos=pos.replace(/(top|bottom)/g,\"bottom\");\r\n\t                    }else{\r\n\t                        newPos=pos.replace(/(top|bottom)/g,\"top\");\r\n\t                    }\r\n\t                }else{\r\n\t                    newPos = pos;\r\n\t                }\r\n\t            }else if(pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1){\r\n\t                if(sRect.x + sRect.width < eRect.x){\r\n\t                    if(nodeType == \"startNode\"){\r\n\t                        newPos=pos.replace(/(right|left)/g,\"right\");\r\n\t                    }else{\r\n\t                        newPos=pos.replace(/(right|left)/g,\"left\");\r\n\t                    }\r\n\t                }else if(eRect.x + eRect.width < sRect.x){\r\n\t                    if(nodeType == \"endNode\"){\r\n\t                        newPos=pos.replace(/(right|left)/g,\"right\");\r\n\t                    }else{\r\n\t                        newPos=pos.replace(/(right|left)/g,\"left\");\r\n\t                    }\r\n\t                }else{\r\n\t                    newPos = pos;\r\n\t                }\r\n\t            }else{\r\n\t                newPos = pos;\r\n\t            }\r\n\t            return newPos;\r\n\t        }\r\n\t\t}\r\n\t\r\n\t\tvar FlowConnectionManager = zrUtil.extend(ConnectionManager, connectionManagerExtend)\r\n\t\tmodule.exports = FlowConnectionManager;\r\n\t\r\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线管理类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Node = __webpack_require__(76);\r\n\t    var Util = __webpack_require__(59);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Point = __webpack_require__(60);\r\n\t    var Connector = __webpack_require__(77);\r\n\t    var Log = __webpack_require__(85);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var ConnectionManager = {\r\n\t\r\n\t        CLOUD_RADIUS: 12,\r\n\t        CLOUD_LINEWIDTH: 3,\r\n\t        CLOUD_STROKE_STYLE: \"rgba(255, 153, 0, 0.8)\", //orange\r\n\t        stencilType : \"SequenceFlow\",\r\n\t        connectors: [],\r\n\t        selConnector: null,\r\n\t        tempConnector: null,\r\n\t\r\n\t\r\n\t\r\n\t        /**\r\n\t         * 设置线的不可编辑\r\n\t         * @param  {[type]} forbidEdit [description]\r\n\t         * @return {[type]}            [description]\r\n\t         */\r\n\t        connectorForbidEdit:function(forbidEdit){\r\n\t            var that = this;\r\n\t            for(var i = 0;i < this.connectors.length;i++){\r\n\t                this.connectors[i].options.isEdit = !forbidEdit;\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t         * 清空连接线\r\n\t         * @return {[type]} [description]\r\n\t         */\r\n\t        clearSelectCon: function() {\r\n\t            if (ConnectionManager.selConnector != null) {\r\n\t                this.refreshConnector(this.selConnector);\r\n\t            }\r\n\t        },\r\n\t        /**\r\n\t         * 删除连接线\r\n\t         * @return {[type]} [description]\r\n\t         */\r\n\t        deleteSelectCon:function(node,_zr){\r\n\t            var deleteLine= [];\r\n\t            for(var i = 0; i < this.connectors.length; i++){\r\n\t                if(this.connectors[i].startNode == node || this.connectors[i].endNode == node){\r\n\t                    //1.将线 所联的startNode的outgoing数据删除\r\n\t                    var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n\t                    index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n\t                    if(index != -1) {\r\n\t                        startNodeOutgoing.splice(index,1);\r\n\t                    }\r\n\t                    //2.从_zr上删除\r\n\t                    _zr.remove(this.connectors[i]);\r\n\t                    this.connectors.splice(i, 1);\r\n\t                    i--;\r\n\t                    this.selConnector = null;\r\n\t\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t        /**\r\n\t         * 删除选定的线\r\n\t         * @return {[type]} [description]\r\n\t         */\r\n\t        deleteLine:function(_zr){\r\n\t            //1.将线 所联的startNode的outgoing数据删除\r\n\t            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n\t            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n\t            if(index != -1) {\r\n\t                startNodeOutgoing.splice(index,1);\r\n\t            }\r\n\t\r\n\t            if (this.connectorMap) {\r\n\t                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);\r\n\t                this.connectorMap.removeItem(key, this.selConnector);\r\n\t            }\r\n\t\r\n\t            //2.从_zr上删除\r\n\t            _zr.remove(this.selConnector);\r\n\t\r\n\t\r\n\t            //3.从线数据中删除\r\n\t            var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n\t            if(index != -1) {\r\n\t                this.connectors.splice(index,1);\r\n\t            }\r\n\t            this.selConnector = null;\r\n\t        },\r\n\t        /**\r\n\t         * 重新画线\r\n\t         * @param  {[type]} connector          [description]\r\n\t         * @param  {[type]} force\r\n\t         * @return {[type]}                    [description]\r\n\t         */\r\n\t        refreshConnector: function (connector, force) {\r\n\t            // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n\t            if( force || (!connector.turningPoints) || (connector.turningPoints.length < 2))\r\n\t            {\r\n\t                if (connector.model && connector.model.get(\"style.lineType\")) { connector.options.style.lineType = connector.model.get(\"style.lineType\");}\r\n\t                var arrStartEndPoint = this.getStartEndPoint(connector);\r\n\t                var escapeDistance = null;\r\n\t                if(connector.options.position&&connector.options.position.escapeDistance){\r\n\t                    escapeDistance = connector.options.position.escapeDistance;\r\n\t                }\r\n\t                var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0], arrStartEndPoint[1],\r\n\t                    arrStartEndPoint[2], arrStartEndPoint[3],escapeDistance);  // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t\r\n\t                connector.refresh(solutions[0][2]);\r\n\t            }\r\n\t\r\n\t            connector.clearHandles();  //清空handle\r\n\t        },\r\n\t\r\n\t\r\n\t        getStartEndPoint: function(connector) {\r\n\t            var startNode = connector.startNode;\r\n\t            var endNode = connector.endNode;\r\n\t\r\n\t            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n\t            var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(sRect.y) + Number(sRect.height)];\r\n\t\r\n\t            var eRect = endNode.getRect? endNode.getRect().boundingRect : Util.getRect(endNode).boundingRect;\r\n\t            var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];\r\n\t\r\n\t\r\n\t            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t            var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t            if (!connector.sPos || !connector.ePos) {\r\n\t                if (sRect.x < eRect.x) {\r\n\t                    connector.sPos = \"right\";\r\n\t                    connector.ePos = \"left\";\r\n\t                } else {\r\n\t                    connector.sPos = \"left\";\r\n\t                    connector.ePos = \"right\";\r\n\t                }\r\n\t            }\r\n\t            var startPoint =  this.calcPointExpression(connector.sPos, sConnectorPoint);\r\n\t            var endPoint =  this.calcPointExpression(connector.ePos, eConnectorPoint);\r\n\t            return [startPoint, endPoint,sBounds, eBounds];\r\n\t        },\r\n\t\r\n\t        calcPointExpression: function(pos, point) {\r\n\t            var variable = {top:point.top.x,\r\n\t                left: point.left.y,\r\n\t                right:point.right.y,\r\n\t                bottom:point.bottom.x,\r\n\t                center:point.center.x\r\n\t            };\r\n\t\r\n\t            var expression =  \"<% print(\" + pos + \") %>\";\r\n\t            var val = parseInt(Util.template(expression)(variable));\r\n\t            if (pos.indexOf(\"top\")!= -1) {\r\n\t                return new Point(val, point.top.y);\r\n\t            } else if (pos.indexOf(\"left\")!= -1) {\r\n\t                return new Point(point.left.x, val);\r\n\t            } else if (pos.indexOf(\"right\")!= -1) {\r\n\t                return new Point(point.right.x, val);\r\n\t            } else if (pos.indexOf(\"bottom\")!= -1) {\r\n\t                return new Point(val, point.bottom.y);\r\n\t            } else if (pos.indexOf(\"center\")!= -1) {\r\n\t                return new Point(val, point.bottom.y);\r\n\t            }else {\r\n\t                throw new Error(\"pos参数错误\");\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 创建或修改临时线\r\n\t         * @param  {[type]} startNode             [description]\r\n\t         * @param  {[type]} rEndPoint             [description]\r\n\t         * @param  {[type]} lineType [description]\r\n\t         * @return {[type]}                       [description]\r\n\t         */\r\n\t        manageTempConnector: function(startNode, rEndPoint, lineType) {\r\n\t\r\n\t            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n\t\r\n\t            var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n\t            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t\r\n\t            if (!ConnectionManager.tempConnector) {\r\n\t                ConnectionManager.tempConnector = new Connector({isEdit: false, style: {lineType:lineType}});\r\n\t            }\r\n\t\r\n\t            var connector =  ConnectionManager.tempConnector;\r\n\t            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\t            if (sRect.x < rEndPoint.x) {\r\n\t                connector.sPos = \"right\";\r\n\t                connector.ePos = \"left\";\r\n\t            } else {\r\n\t                connector.sPos = \"left\";\r\n\t                connector.ePos = \"right\";\r\n\t            }\r\n\t\r\n\t            connector.options.style.lineType = lineType;\r\n\t            var solutions = this.connector2Points(lineType, sConnectorPoint[connector.sPos], rEndPoint,\r\n\t                sBounds, null);  // TYPE_STRAIGHT TYPE_JAGGED\r\n\t\r\n\t            connector.refresh(solutions[0][2]);\r\n\t            return connector;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 删除临时线\r\n\t         * @param  {[type]} zr             [description]\r\n\t         */\r\n\t        removeTempConnector: function(zr) {\r\n\t            if (ConnectionManager.tempConnector) {\r\n\t                zr.remove(ConnectionManager.tempConnector);\r\n\t                ConnectionManager.tempConnector = null;\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t         * 算出 两个节点 指定两个点如何联线\r\n\t         * @param  {[type]} type       [description]\r\n\t         * @param  {[type]} startPoint [description]\r\n\t         * @param  {[type]} endPoint   [description]\r\n\t         * @param  {[type]} sBounds    [description]\r\n\t         * @param  {[type]} eBounds    [description]\r\n\t         * @return {[type]}            [description]\r\n\t         */\r\n\t        connector2Points: function(type,  startPoint, endPoint, sBounds, eBounds ,escapeDistance){\r\n\t            var  figureEscapeDistance = [30, 30];\r\n\t            if (escapeDistance) {\r\n\t                if (!zrUtil.isArray(escapeDistance)) {\r\n\t                    figureEscapeDistance = [escapeDistance, escapeDistance];\r\n\t                } else {\r\n\t                    figureEscapeDistance = escapeDistance;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            Log.group(\"connectionManager: connector2Points\");\r\n\t\r\n\t\r\n\t            Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint + \", \" + sBounds + \", \" + eBounds + ')');\r\n\t            var solutions = [];\r\n\t\r\n\t\r\n\t\r\n\t            switch(type){\r\n\t                case Connector.TYPE_STRAIGHT:  //直线\r\n\t                    var points = [startPoint.clone(), endPoint.clone()];\r\n\t                    solutions.push( ['straight', 'straight', points] );\r\n\t                    break;\r\n\t\r\n\t                case Connector.TYPE_CURVE:  //曲线\r\n\t\r\n\t                case Connector.TYPE_JAGGED:    //折线\r\n\t                    var startExitPoint = null;\r\n\t                    var endExitPoint = null;\r\n\t\r\n\t                    //find start exit point  寻找开始出口\r\n\t                    if(sBounds != null){\r\n\t                        var potentialExits = [];\r\n\t\r\n\t                        potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n\t                        potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n\t                        potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n\t                        potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\t\r\n\t                        //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n\t                        startExitPoint = potentialExits[0];\r\n\t                        for(var i=1; i < potentialExits.length; i++){\r\n\t                            if(Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint, startExitPoint)){\r\n\t                                startExitPoint = potentialExits[i];\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t\r\n\t                    //find end exit point  寻找结束出口\r\n\t                    if(eBounds != null){\r\n\t                        var potentialExits = [];\r\n\t\r\n\t                        potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n\t                        potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n\t                        potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n\t                        potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\t\r\n\t                        //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n\t                        endExitPoint = potentialExits[0];\r\n\t                        for(var i=1; i < potentialExits.length; i++){\r\n\t                            if(Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint, endExitPoint)){\r\n\t                                endExitPoint = potentialExits[i];\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                    //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n\t                    var s = [startPoint];\r\n\t                    var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n\t                    if(startExitPoint){\r\n\t                        s.push(startExitPoint);\r\n\t                        gapIndex = 1;\r\n\t                    }\r\n\t                    if(endExitPoint){\r\n\t                        s.push(endExitPoint);\r\n\t                    }\r\n\t                    s.push(endPoint);\r\n\t\r\n\t\r\n\t\r\n\t                    //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n\t                    var s0 = Point.cloneArray(s);\r\n\t                    solutions.push(['s0', 's0', s0]);\r\n\t\r\n\t\r\n\t\r\n\t                    //S1   S1 解决方案  只有一个折点\r\n\t                    var s1 = Point.cloneArray(s);\r\n\t\r\n\t                    //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n\t                    var s1_1 = Point.cloneArray(s1);\r\n\t                    s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x , s1_1[gapIndex+1].y) );\r\n\t                    solutions.push(['s1', 's1_1', s1_1]);\r\n\t\r\n\t                    //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n\t                    var s1_2 = Point.cloneArray(s1);\r\n\t                    s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex+1].x , s1_2[gapIndex].y) );\r\n\t                    solutions.push(['s1', 's1_2', s1_2]);\r\n\t\r\n\t\r\n\t                    //S2  S2 解决方案  添加两个折点\r\n\t\r\n\t                    //Variant I   s2_1方案\r\n\t                    var s2_1 = Point.cloneArray(s);\r\n\t                    var s2_1_1 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex].y);\r\n\t                    var s2_1_2 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex+1].y);\r\n\t                    s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n\t                    solutions.push(['s2', 's2_1', s2_1]);\r\n\t\r\n\t\r\n\t                    //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n\t                    //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n\t                    var s2_2 = Point.cloneArray(s);\r\n\t                    var s2_2_1 = new Point( s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2 );\r\n\t                    var s2_2_2 = new Point( s2_2[gapIndex+1].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2);\r\n\t                    s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n\t                    solutions.push(['s2', 's2_2', s2_2]);\r\n\t\r\n\t\r\n\t                    //Variant III\r\n\t                    var s2_3 = Point.cloneArray(s);\r\n\t                    //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n\t                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                    var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex+1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                    if(sBounds){\r\n\t                        eastExits.push(sBounds[2] + 20);\r\n\t                    }\r\n\t\r\n\t                    if(eBounds){\r\n\t                        eastExits.push(eBounds[2] + 20);\r\n\t                    }\r\n\t\r\n\t                    var eastExit = Util.max(eastExits);\r\n\t                    var s2_3_1 = new Point( eastExit, s2_3[gapIndex].y );\r\n\t                    var s2_3_2 = new Point( eastExit, s2_3[gapIndex+1].y );\r\n\t                    s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n\t                    solutions.push(['s2', 's2_3', s2_3]);\r\n\t\r\n\t\r\n\t                    //Variant IV  s2_4方案\r\n\t                    var s2_4 = Point.cloneArray(s);\r\n\t                    //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n\t                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                    var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex+1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                    if(sBounds){\r\n\t                        northExits.push(sBounds[1] - 20);\r\n\t                    }\r\n\t\r\n\t                    if(eBounds){\r\n\t                        northExits.push(eBounds[1] - 20);\r\n\t                    }\r\n\t\r\n\t                    var northExit = Util.min(northExits);\r\n\t                    var s2_4_1 = new Point( s2_4[gapIndex].x, northExit);\r\n\t                    var s2_4_2 = new Point( s2_4[gapIndex+1].x, northExit);\r\n\t                    s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n\t                    solutions.push(['s2', 's2_4', s2_4]);\r\n\t\r\n\t\r\n\t                    //Variant V\r\n\t                    var s2_5 = Point.cloneArray(s);\r\n\t                    //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n\t                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                    var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex+1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                    if(sBounds){\r\n\t                        westExits.push(sBounds[0] - 20);\r\n\t                    }\r\n\t\r\n\t                    if(eBounds){\r\n\t                        westExits.push(eBounds[0] - 20);\r\n\t                    }\r\n\t\r\n\t                    var westExit = Util.min(westExits);\r\n\t                    var s2_5_1 = new Point( westExit, s2_5[gapIndex].y);\r\n\t                    var s2_5_2 = new Point( westExit, s2_5[gapIndex+1].y);\r\n\t                    s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n\t                    solutions.push(['s2', 's2_5', s2_5]);\r\n\t\r\n\t\r\n\t                    //Variant VI\r\n\t                    var s2_6 = Point.cloneArray(s);\r\n\t                    //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n\t                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\t\r\n\t                    var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex+1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\t\r\n\t                    if(sBounds){\r\n\t                        southExits.push(sBounds[3] + 20);\r\n\t                    }\r\n\t\r\n\t                    if(eBounds){\r\n\t                        southExits.push(eBounds[3] + 20);\r\n\t                    }\r\n\t\r\n\t                    var southExit = Util.max(southExits);\r\n\t                    var s2_6_1 = new Point( s2_6[gapIndex].x, southExit);\r\n\t                    var s2_6_2 = new Point( s2_6[gapIndex+1].x, southExit);\r\n\t                    s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n\t                    solutions.push(['s2', 's2_6', s2_6]);\r\n\t\r\n\t\r\n\t\r\n\t                    //FILTER solutions\r\n\t\r\n\t                    /*Algorithm\r\n\t                     * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n\t                     * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n\t                     * 2. remove all solutions that go backward (we will not need them ever)\r\n\t                     * 3. remove all solutions with intersections\r\n\t                     * 4. pick first class of solutions with same nr of points (ex: 2)\r\n\t                     * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n\t                     * (not interesteted) sort by length :p\r\n\t                     */\r\n\t\r\n\t                    //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n\t                    if(true){\r\n\t                        Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n\t                        var orthogonalSolution = [];\r\n\t                        for(var l=0; l<solutions.length; l++){\r\n\t                            var solution = solutions[l][2];\r\n\t                            if(Util.orthogonalPath(solution)){\r\n\t                                orthogonalSolution.push(solutions[l]);\r\n\t                            }\r\n\t                        }\r\n\t                        solutions = orthogonalSolution;\r\n\t                        Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n\t                    }\r\n\t\r\n\t                    //2. filter backward solutions  过滤 倒退的方案\r\n\t                    if(true){\r\n\t                        //do not allow start and end points to coincide - ignore them\r\n\t                        if(startPoint.equals(endPoint)){\r\n\t                            Log.info(\"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\");\r\n\t                        }\r\n\t                        else{\r\n\t                            Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n\t                            var forwardSolutions = [];\r\n\t                            var temp = '';\r\n\t                            for(var l=0; l<solutions.length; l++){\r\n\t                                var solution = solutions[l][2];\r\n\t                                if(Util.forwardPath(solution)){\r\n\t                                    forwardSolutions.push(solutions[l]);\r\n\t                                }\r\n\t                                else{\r\n\t                                    temp = temp +  \"\\n\\t\" + solution;\r\n\t                                }\r\n\t                            }\r\n\t                            solutions = forwardSolutions;\r\n\t                            Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n\t                            if(solutions.length == 0){\r\n\t                                Log.info(\"Discarded solutions: \" + temp);\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t\r\n\t                    //3. Filter non intersecting solutions  去除没有交集()的方案\r\n\t                    if(true){\r\n\t                        Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n\t                        var nonIntersectionSolutions = []\r\n\t                        for(var l=0; l<solutions.length; l++){\r\n\t                            var solution = solutions[l][2];\r\n\t                            //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n\t                            var intersect = false;\r\n\t\r\n\t                            var innerLines = solution.slice(); //just a shallow copy\r\n\t\r\n\t                            /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n\t                             *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n\t                            if(eBounds || sBounds){\r\n\t                                //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n\t                                innerLines = innerLines.slice(1, innerLines.length - 1);\r\n\t                                //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n\t                            }\r\n\t\r\n\t\r\n\t\r\n\t                            //now test for intersection\r\n\t                            if(sBounds){\r\n\t                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n\t                            }\r\n\t                            if(eBounds){\r\n\t                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n\t                            }\r\n\t\r\n\t                            if(!intersect){\r\n\t                                nonIntersectionSolutions.push(solutions[l]);\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n\t                        if(nonIntersectionSolutions.length != 0){\r\n\t                            //reasign to solutions\r\n\t                            solutions = nonIntersectionSolutions;\r\n\t                        }\r\n\t\r\n\t                        Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n\t                    }\r\n\t\r\n\t\r\n\t                    //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n\t                    if(true){\r\n\t                        Log.info(\"Get first class of solutions with same nr of points\");\r\n\t                        if(solutions.length == 0){\r\n\t                            Log.info(\"This is not possible\");\r\n\t                        }\r\n\t\r\n\t                        var firstSolution = solutions[0][2]; //pick first solution\r\n\t                        var nrOfPoints = firstSolution.length;\r\n\t                        var sameNrPointsSolution = [];\r\n\t\r\n\t                        for(var l=0; l<solutions.length; l++){\r\n\t                            var solution = solutions[l][2];\r\n\t                            if(solution.length == nrOfPoints){\r\n\t                                sameNrPointsSolution.push(solutions[l]);\r\n\t                            }\r\n\t                        }\r\n\t\r\n\t                        solutions = sameNrPointsSolution;\r\n\t                    }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t                    /*5.  计算路径分数 ，取最分数高的\r\n\t                     Pick the first solution with 90 degree angles (less turnarounds)\r\n\t                     *in case we have more than one solution in our class\r\n\t                     */\r\n\t                    if(true){\r\n\t                        Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n\t                        var solIndex = 0;\r\n\t                        for(var l=0; l<solutions.length; l++){\r\n\t                            var solution = solutions[l][2];\r\n\t                            if(Util.scorePath( solutions[solIndex][2] ) < Util.scorePath( solutions[l][2] ) ){\r\n\t                                solIndex = l;\r\n\t                            }\r\n\t                        }\r\n\t                        solutions = [solutions[solIndex]];\r\n\t                    }\r\n\t\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t\r\n\t            //SMOOTHING curve\r\n\t            if(type === Connector.TYPE_CURVE){\r\n\t                this.smoothCurve(solutions);\r\n\t            }\r\n\t            //END SMOOTHING curve\r\n\t\r\n\t            Log.groupEnd();\r\n\t\r\n\t            return solutions;\r\n\t        },\r\n\t\r\n\t        smoothCurve: function(solutions){\r\n\t            var option = 3;\r\n\t\r\n\t            switch(option){\r\n\t                case 0:\r\n\t                    //do nothing\r\n\t                    break;\r\n\t\r\n\t                case 1: //add intermediate points\r\n\t                    //Add the middle point for start and end segment so that we \"force\" the\r\n\t                    //curve to both come \"perpendicular\" on bounds and also make the curve\r\n\t                    //\"flee\" more from bounds (on exit)\r\n\t                    for(var s=0; s<solutions.length; s++){\r\n\t                        var solTurningPoints = solutions[s][2];\r\n\t\r\n\t                        //first segment\r\n\t                        var a1 = solTurningPoints[0];\r\n\t                        var a2 = solTurningPoints[1];\r\n\t                        var startMiddlePoint = Util.getMiddle(a1, a2);\r\n\t                        solTurningPoints.splice(1,0, startMiddlePoint);\r\n\t\r\n\t                        //last segment\r\n\t                        var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n\t                        var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n\t                        var endMiddlePoint = Util.getMiddle(a3, a4);\r\n\t                        solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n\t                    }\r\n\t                    break;\r\n\t\r\n\t                case 2: //remove points\r\n\t                    for(var s=0; s<solutions.length; s++){\r\n\t                        var solType= solutions[s][0];\r\n\t                        if(solType == 's1' || solType == 's2'){\r\n\t                            var solTurningPoints = solutions[s][2];\r\n\t                            solTurningPoints.splice(1,1);\r\n\t                            solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n\t                        }\r\n\t                    }\r\n\t                    break;\r\n\t\r\n\t                case 3:\r\n\t                    /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n\t                     * on organic solutions >:D*/\r\n\t                    for(var s=0; s<solutions.length; s++){\r\n\t                        var solType= solutions[s][0];\r\n\t                        if(solType == 's1'){\r\n\t                            var solTurningPoints = solutions[s][2];\r\n\t                            var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n\t                            solutions[s][2] = reducedSolution;\r\n\t                        }\r\n\t                    }\r\n\t                    break;\r\n\t            }//end switch\r\n\t\r\n\t        }\r\n\t    };\r\n\t    module.exports = ConnectionManager;\r\n\t\r\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * 日志类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t\r\n\t    var Log  = {\r\n\t        LOG_LEVEL_NONE  : 0,\r\n\t\r\n\t        LOG_LEVEL_DEBUG : 1,\r\n\t\r\n\t        LOG_LEVEL_INFO : 2,\r\n\t\r\n\t        LOG_LEVEL_ERROR : 3,\r\n\t\r\n\t        level : this.LOG_LEVEL_ERROR,\r\n\t        \r\n\t        /**\r\n\t        * The less important of all messages\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        debug: function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n\t                    \r\n\t                    //in FF is debug\r\n\t                    if(typeof console.debug == 'function'){\r\n\t                        console.debug(message);\r\n\t                    }\r\n\t                    else{//TODO: in IE is log\r\n\t    //                    console.info(message);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t\r\n\t        /**\r\n\t        * The commonly used log message\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        info : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_INFO){\r\n\t                    console.info(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t        * The worse kind of message. Usually a crash\r\n\t        * @param {String} message - the message to be logged\r\n\t        **/\r\n\t        error : function (message){\r\n\t            if(typeof console !== 'undefined'){\r\n\t                if(this.level <= this.LOG_LEVEL_ERROR){\r\n\t                    console.error(message);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *Start grouping the log messages\r\n\t         *@param {String} title - the title of the group\r\n\t         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n\t         **/\r\n\t        group : function(title){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){           \r\n\t                    /**If we do not test for group() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.group === 'function'){\r\n\t                        console.group(title);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**Ends current message grouping*/\r\n\t        groupEnd : function(){\r\n\t            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n\t                if(typeof console !== 'undefined'){\r\n\t                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n\t                     *as Opera has it's own console...which does not have a group() function*/\r\n\t                    if(typeof console.groupEnd === 'function'){\r\n\t                        console.groupEnd();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n\t    Log.level = Log.LOG_LEVEL_ERROR; \r\n\t    //Log.level = Log.LOG_LEVEL_ERROR;\r\n\t    //Log.level = Log.LOG_LEVEL_NONE;\r\n\t    module.exports = Log;\r\n\t    \r\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * 常量定义\r\n\t */\r\n\t\r\n\t\tmodule.exports = \t{\r\n\t\t\tELEMENT_TYPE: \"elementType\",\r\n\t\t\tMODE: \"mode\",\r\n\t\t\tBACKGROUND: \"backgroud\",\r\n\t\t\tOPTIONS: \"options\",\r\n\t\t\tUSERDATA: \"userData\",\r\n\t\t\tID: \"id\",\r\n\t\t\tSTART_ID: \"startNodeId\",\r\n\t\t\tEND_ID: \"endNodeId\",\r\n\t\t\tALARM: \"Alarm\",\r\n\t\t\tRELATIONID:\"relationId\",\r\n\t\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\t\tGROUP: \"Group\",\r\n\t\t\tCONNECTION: \"connection\",\r\n\t\t\tCHILDS: \"childs\",\r\n\t\t\tTREE_ROOT: \"treeRoot\",\r\n\t\t\tDOCKERS:\"options.dockers\",\r\n\t\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t\t};\r\n\t\r\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 节点等的模型\r\n\t * 里面存的数据用来处理序列化和反序列化\r\n\t * @class fish.topo.model\r\n\t */\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var clazzUtil = __webpack_require__(88);\r\n\t\r\n\t    function Model(option, parentModel,  extraOpt) {\r\n\t        this.parentModel = parentModel;\r\n\t        this.option = option;\r\n\t\r\n\t        // Simple optimization\r\n\t        if (this.init) {\r\n\t            if (arguments.length <= 3) {\r\n\t                this.init(option, parentModel,  extraOpt);\r\n\t            }\r\n\t            else {\r\n\t                this.init.apply(this, arguments);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Model.prototype = {\r\n\t\r\n\t        constructor: Model,\r\n\t\r\n\t        /**\r\n\t         * Model 的初始化函数\r\n\t         * @private\r\n\t         * @param {Object} option\r\n\t         */\r\n\t        init: function (option) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        mergeOption: function (option) {\r\n\t            zrUtil.merge(this.option, option, true);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 获取model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.get(\"options.text\");\r\n\t         */\r\n\t        get: function (path, ignoreParent) {\r\n\t            if (!path) {\r\n\t                return this.option;\r\n\t            }\r\n\t\r\n\t            if (typeof path === 'string') {\r\n\t                path = path.split('.');\r\n\t            }\r\n\t\r\n\t            var obj = this.option;\r\n\t            var parentModel = this.parentModel;\r\n\t            for (var i = 0; i < path.length; i++) {\r\n\t                // obj could be number/string/... (like 0)\r\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n\t                if (obj == null) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (obj == null && parentModel && !ignoreParent) {\r\n\t                obj = parentModel.get(path);\r\n\t            }\r\n\t            return obj;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @param {String} value 所需要设置的值\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.set(\"options.text\",\"例子\");\r\n\t         */\r\n\t        set: function (path, value) {\r\n\t            var obj = this.option;\r\n\t\r\n\t            if (path.indexOf(\".\") == -1) {\r\n\t                obj[path] = value;\r\n\t            } else {\r\n\t                var fieldArray  = path.split('.');\r\n\t                var n = fieldArray.length;\r\n\t                var currentRef = obj;\r\n\t                var fieldName;\r\n\t\r\n\t                for (var i = 0; i < n - 1; i++) {\r\n\t                    fieldName = fieldArray[i];\r\n\t                    if(currentRef[fieldName] == null) {\r\n\t                        currentRef[fieldName] = {};\r\n\t                    }\r\n\t                    currentRef = currentRef[fieldName];\r\n\t                }\r\n\t                fieldName = fieldArray[n-1];\r\n\t                currentRef[fieldName] = value;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getShallow: function (key, ignoreParent) {\r\n\t            var option = this.option;\r\n\t            var val = option && option[key];\r\n\t            var parentModel = this.parentModel;\r\n\t            if (val == null && parentModel && !ignoreParent) {\r\n\t                val = parentModel.getShallow(key);\r\n\t            }\r\n\t            return val;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getModel: function (path, parentModel) {\r\n\t            var obj = this.get(path, true);\r\n\t            var thisParentModel = this.parentModel;\r\n\t            var model = new Model(\r\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n\t            );\r\n\t            return model;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *清空model的option\r\n\t         * @private\r\n\t         */\r\n\t        isEmpty: function () {\r\n\t            return this.option == null;\r\n\t        },\r\n\t\r\n\t        restoreData: function () {},\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        clone: function () {\r\n\t            var Ctor = this.constructor;\r\n\t            return new Ctor(zrUtil.clone(this.option));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Enable Model.extend.\r\n\t    clazzUtil.enableClassExtend(Model);\r\n\t\r\n\t    module.exports = Model;\r\n\t\r\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var clazz = {};\r\n\t\r\n\t    var TYPE_DELIMITER = '.';\r\n\t    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n\t    /**\r\n\t     * @public\r\n\t     */\r\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\r\n\t        var ret = {main: '', sub: ''};\r\n\t        if (componentType) {\r\n\t            componentType = componentType.split(TYPE_DELIMITER);\r\n\t            ret.main = componentType[0] || '';\r\n\t            ret.sub = componentType[1] || '';\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n\t     */\r\n\t    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n\t        RootClass.extend = function (proto) {\r\n\t            var ExtendedClass = function () {\r\n\t                preConstruct && preConstruct.apply(this, arguments);\r\n\t                RootClass.apply(this, arguments);\r\n\t            };\r\n\t\r\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\t\r\n\t            ExtendedClass.extend = this.extend;\r\n\t            ExtendedClass.superCall = superCall;\r\n\t            ExtendedClass.superApply = superApply;\r\n\t            zrUtil.inherits(ExtendedClass, this);\r\n\t            ExtendedClass.superClass = this;\r\n\t\r\n\t            return ExtendedClass;\r\n\t        };\r\n\t    };\r\n\t\r\n\t    // superCall should have class info, which can not be fetch from 'this'.\r\n\t    // Consider this case:\r\n\t    // class A has method f,\r\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\r\n\t    // class C inherits class B, do not overrides method f,\r\n\t    // then when method of class C is called, dead loop occured.\r\n\t    function superCall(context, methodName) {\r\n\t        var args = zrUtil.slice(arguments, 2);\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    function superApply(context, methodName, args) {\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} entity\r\n\t     * @param {Object} options\r\n\t     * @param {boolean} [options.registerWhenExtend]\r\n\t     * @public\r\n\t     */\r\n\t    clazz.enableClassManagement = function (entity, options) {\r\n\t        options = options || {};\r\n\t\r\n\t        /**\r\n\t         * Component model classes\r\n\t         * key: componentType,\r\n\t         * value:\r\n\t         *     componentClass, when componentType is 'xxx'\r\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n\t         * @type {Object}\r\n\t         */\r\n\t        var storage = {};\r\n\t\r\n\t        entity.registerClass = function (Clazz, componentType) {\r\n\t            if (componentType) {\r\n\t                componentType = parseClassType(componentType);\r\n\t\r\n\t                if (!componentType.sub) {\r\n\t                    if (storage[componentType.main]) {\r\n\t                        //已经注册过了，直接返回\r\n\t                        return;\r\n\t                    }\r\n\t                    storage[componentType.main] = Clazz;\r\n\t                }\r\n\t                else if (componentType.sub !== IS_CONTAINER) {\r\n\t                    var container = makeContainer(componentType);\r\n\t                    container[componentType.sub] = Clazz;\r\n\t                }\r\n\t            }\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n\t            var Clazz = storage[componentTypeMain];\r\n\t\r\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\r\n\t                Clazz = subType ? Clazz[subType] : null;\r\n\t            }\r\n\t\r\n\t            if (throwWhenNotFound && !Clazz) {\r\n\t                throw new Error(\r\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n\t                );\r\n\t            }\r\n\t\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClassesByMainType = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t\r\n\t            var result = [];\r\n\t            var obj = storage[componentType.main];\r\n\t\r\n\t            if (obj && obj[IS_CONTAINER]) {\r\n\t                zrUtil.each(obj, function (o, type) {\r\n\t                    type !== IS_CONTAINER && result.push(o);\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                result.push(obj);\r\n\t            }\r\n\t\r\n\t            return result;\r\n\t        };\r\n\t\r\n\t        entity.hasClass = function (componentType) {\r\n\t            // Just consider componentType.main.\r\n\t            componentType = parseClassType(componentType);\r\n\t            return !!storage[componentType.main];\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n\t         */\r\n\t        entity.getAllClassMainTypes = function () {\r\n\t            var types = [];\r\n\t            zrUtil.each(storage, function (obj, type) {\r\n\t                types.push(type);\r\n\t            });\r\n\t            return types;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * If a main type is container and has sub types\r\n\t         * @param  {string}  componentType\r\n\t         * @return {boolean}\r\n\t         */\r\n\t        entity.hasSubTypes = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t            var obj = storage[componentType.main];\r\n\t            return obj && obj[IS_CONTAINER];\r\n\t        };\r\n\t\r\n\t        entity.parseClassType = parseClassType;\r\n\t\r\n\t        function makeContainer(componentType) {\r\n\t            var container = storage[componentType.main];\r\n\t            if (!container || !container[IS_CONTAINER]) {\r\n\t                container = storage[componentType.main] = {};\r\n\t                container[IS_CONTAINER] = true;\r\n\t            }\r\n\t            return container;\r\n\t        }\r\n\t\r\n\t        if (options.registerWhenExtend) {\r\n\t            var originalExtend = entity.extend;\r\n\t            if (originalExtend) {\r\n\t                entity.extend = function (proto) {\r\n\t                    var ExtendedClass = originalExtend.call(this, proto);\r\n\t                    return entity.registerClass(ExtendedClass, proto.type);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return entity;\r\n\t    };\r\n\t\r\n\t    module.exports = clazz;\r\n\t\r\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var forceHelper = __webpack_require__(90);\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    var Util = __webpack_require__(59);\r\n\t    var ConnectionManager = __webpack_require__(84);\r\n\t\r\n\t    /**\r\n\t     * 力导向布局\r\n\t     * @param  {[type]} allNodes   [所有节点]\r\n\t     * @param  {[type]} allCons    [所有线]\r\n\t     * @param  {[type]} repulsion  [节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远。]\r\n\t     * @param  {[type]} edgeLength [边的两个节点之间的距离，这个距离也会受 repulsion。]\r\n\t     * @param  {[type]} gravity    [节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    module.exports = function(forceLayoutOption) {\r\n\t        var repulsion = forceLayoutOption.repulsion || 100;\r\n\t        var gravity = forceLayoutOption.gravity || 0.1;\r\n\t        var edgeLength = forceLayoutOption.edgeLength || 30;\r\n\t        var preservedPoints = forceLayoutOption.preservedPoints || {};\r\n\t        var allNodes = this.forceLayoutOption.allNodes;\r\n\t        var allCons = this.forceLayoutOption.allCons;\r\n\t        var rect = this.forceLayoutOption.rect;\r\n\t        var nodes = _.map(allNodes, function(node, idx) {\r\n\t            var rep = repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n\t            return {\r\n\t                w: rep,\r\n\t                rep: rep,\r\n\t                p: null\r\n\t            };\r\n\t        });\r\n\t\r\n\t        var edges = _.map(allCons, function(con, idx) {\r\n\t            con.n1 = con.startNode;\r\n\t            con.n2 = con.endNode;\r\n\t            con.d = edgeLength;\r\n\t            con.curveness = 0;\r\n\t            return {\r\n\t                n1: con.startNode,\r\n\t                n2: con.endNode,\r\n\t                d: edgeLength,\r\n\t                curveness: 0\r\n\t            };\r\n\t        });\r\n\t\r\n\t        var forceInstance = forceHelper(allNodes, allCons, {\r\n\t            rect: rect,\r\n\t            gravity: gravity\r\n\t        });\r\n\t        var oldStep = forceInstance.step;\r\n\t        forceInstance.step = function(cb) {\r\n\t            for (var i = 0, l = allNodes.length; i < l; i++) {\r\n\t                if (nodes[i].fixed) {\r\n\t                    // Write back to layout instance\r\n\t                    vec2.copy(nodes[i].p, nodes[i].position);\r\n\t                }\r\n\t            }\r\n\t            oldStep(function(allNodes, allCons, stopped) {\r\n\t                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n\t                    if (!allNodes[i].fixed) {\r\n\t                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n\t                    }\r\n\t                    preservedPoints[i] = allNodes[i].p;\r\n\t                }\r\n\t                for (var i = 0, l = allCons.length; i < l; i++) {\r\n\t                    // var e = allCons[i];\r\n\t                    // var p1 = e.n1.p;\r\n\t                    // var p2 = e.n2.p;\r\n\t                    // var points = [p1, p2];\r\n\t                    // if (e.curveness > 0) {\r\n\t                    //     points.push([\r\n\t                    //         (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,\r\n\t                    //         (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness\r\n\t                    //     ]);\r\n\t                    // }\r\n\t                    // var newPoints = Util.traslatePoints(points, true);\r\n\t                    // e.refresh(newPoints);\r\n\t                    ConnectionManager.refreshConnector(allCons[i], true);\r\n\t                }\r\n\t                // Update layout\r\n\t\r\n\t                cb && cb(stopped);\r\n\t            });\r\n\t        };\r\n\t        forceLayoutOption.forceLayout = forceInstance;\r\n\t        forceLayoutOption.preservedPoints = preservedPoints;\r\n\t        // Step to get the layout\r\n\t        forceInstance.step();\r\n\t    }\r\n\t\r\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var scaleAndAdd = vec2.scaleAndAdd;\r\n\t\r\n\t    // function adjacentNode(n, e) {\r\n\t    //     return e.n1 === n ? e.n2 : e.n1;\r\n\t    // }\r\n\t\r\n\t    module.exports = function (nodes, edges, opts) {\r\n\t        var rect = opts.rect;\r\n\t        var width = rect.width;\r\n\t        var height = rect.height;\r\n\t        var center = [rect.x + width / 2, rect.y + height / 2];\r\n\t        // var scale = opts.scale || 1;\r\n\t        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\t\r\n\t        // for (var i = 0; i < edges.length; i++) {\r\n\t        //     var e = edges[i];\r\n\t        //     var n1 = e.n1;\r\n\t        //     var n2 = e.n2;\r\n\t        //     n1.edges = n1.edges || [];\r\n\t        //     n2.edges = n2.edges || [];\r\n\t        //     n1.edges.push(e);\r\n\t        //     n2.edges.push(e);\r\n\t        // }\r\n\t        // Init position\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t            var n = nodes[i];\r\n\t            if (!n.p) {\r\n\t                // Use the position from first adjecent node with defined position\r\n\t                // Or use a random position\r\n\t                // From d3\r\n\t                // if (n.edges) {\r\n\t                //     var j = -1;\r\n\t                //     while (++j < n.edges.length) {\r\n\t                //         var e = n.edges[j];\r\n\t                //         var other = adjacentNode(n, e);\r\n\t                //         if (other.p) {\r\n\t                //             n.p = vec2.clone(other.p);\r\n\t                //             break;\r\n\t                //         }\r\n\t                //     }\r\n\t                // }\r\n\t                // if (!n.p) {\r\n\t                    n.p = vec2.create(\r\n\t                        width * (Math.random() - 0.5) + center[0],\r\n\t                        height * (Math.random() - 0.5) + center[1]\r\n\t                    );\r\n\t                // }\r\n\t            }\r\n\t            n.pp = vec2.clone(n.p);\r\n\t            n.edges = null;\r\n\t        }\r\n\t\r\n\t        // Formula in 'Graph Drawing by Force-directed Placement'\r\n\t        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n\t        // var k2 = k * k;\r\n\t\r\n\t        var friction = 0.6;\r\n\t\r\n\t        return {\r\n\t            warmUp: function () {\r\n\t                friction = 0.5;\r\n\t            },\r\n\t\r\n\t            setFixed: function (idx) {\r\n\t                nodes[idx].fixed = true;\r\n\t            },\r\n\t\r\n\t            setUnfixed: function (idx) {\r\n\t                nodes[idx].fixed = false;\r\n\t            },\r\n\t\r\n\t            step: function (cb) {\r\n\t                var v12 = [];\r\n\t                var nLen = nodes.length;\r\n\t                for (var i = 0; i < edges.length; i++) {\r\n\t                    var e = edges[i];\r\n\t                    var n1 = e.n1;\r\n\t                    var n2 = e.n2;\r\n\t\r\n\t                    vec2.sub(v12, n2.p, n1.p);\r\n\t                    var d = vec2.len(v12) - e.d;\r\n\t                    var w = n2.w / (n1.w + n2.w);\r\n\t                    vec2.normalize(v12, v12);\r\n\t\r\n\t                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n\t                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n\t                }\r\n\t                // Gravity\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v12, center, n.p);\r\n\t                        // var d = vec2.len(v12);\r\n\t                        // vec2.scale(v12, v12, 1 / d);\r\n\t                        // var gravityFactor = gravity;\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                // Repulsive\r\n\t                // PENDING\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n1 = nodes[i];\r\n\t                    for (var j = i + 1; j < nLen; j++) {\r\n\t                        var n2 = nodes[j];\r\n\t                        vec2.sub(v12, n2.p, n1.p);\r\n\t                        var d = vec2.len(v12);\r\n\t                        if (d === 0) {\r\n\t                            // Random repulse\r\n\t                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n\t                            d = 1;\r\n\t                        }\r\n\t                        var repFact = (n1.rep + n2.rep) / d / d;\r\n\t                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n\t                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n\t                    }\r\n\t                }\r\n\t                var v = [];\r\n\t                for (var i = 0; i < nLen; i++) {\r\n\t                    var n = nodes[i];\r\n\t                    if (!n.fixed) {\r\n\t                        vec2.sub(v, n.p, n.pp);\r\n\t                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n\t                        vec2.copy(n.pp, n.p);\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                friction = friction * 0.992;\r\n\t\r\n\t                cb && cb(nodes, edges, friction < 0.01);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var ConnectionManager = __webpack_require__(83);\r\n\t    module.exports = function (option) {\r\n\t        function checkNode(dom){\r\n\t            dom.treeType = option.type;\r\n\t            dom.model.set(\"options.treeType\",option.type);\r\n\t            //1、根据连线  找出起始节点 所有的子结节\r\n\t            var childrenNode = [];\r\n\t            for(var i = 0;i < ConnectionManager.connectors.length; i++){\r\n\t                if(ConnectionManager.connectors[i].startNode == dom){\r\n\t                    childrenNode.push(ConnectionManager.connectors[i].endNode);\r\n\t                }\r\n\t            };\r\n\t            if(childrenNode.length > 0){\r\n\t\r\n\t\r\n\t                // 2. 遍历子结点\r\n\t                for(var m = 0;m < childrenNode.length;m++){\r\n\t                    childrenNode[m].treeType = option.type;\r\n\t                    var x,y;\r\n\t                    if(option.type == \"horizontal\"){\r\n\t                        var average =dom.layout.height;\r\n\t                        // 2.1 父结点 如果圆形 作不同的处理\r\n\t                        if(dom instanceof graphic.Circle){\r\n\t                            //2.2 子节点 如果是圆形  vv\r\n\t                            if(childrenNode[m] instanceof graphic.Circle){\r\n\t                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m;\r\n\t                                x = dom.position[0]+dom.layout.width;\r\n\t                            }else if(childrenNode[m] instanceof graphic.Image){\r\n\t                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;\r\n\t                                x = dom.position[0]+dom.layout.width-childrenNode[m].style.width/2\r\n\t                            }else{\r\n\t                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;\r\n\t                                x = dom.position[0]+dom.layout.width-childrenNode[m].shape.width/2\r\n\t                            }\r\n\t\r\n\t                        }else{\r\n\t                            if(childrenNode[m] instanceof graphic.Circle){\r\n\t                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m;\r\n\t                                x = dom.position[0]+dom.shape.width/2+dom.layout.width;\r\n\t                            }else if(childrenNode[m] instanceof graphic.Image){\r\n\t                                y = dom.position[1]+dom.style.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;\r\n\t                                x = dom.position[0]+dom.style.width/2+dom.layout.width-childrenNode[m].style.width/2\r\n\t                            }else{\r\n\t                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;\r\n\t                                x = dom.position[0]+dom.shape.width/2+dom.layout.width-childrenNode[m].shape.width/2\r\n\t                            }\r\n\t                        }\r\n\t                    }else{\r\n\t                        var average =dom.layout.width;\r\n\t                        // 2.1 父结点 如果圆形 作不同的处理\r\n\t                        if(dom instanceof graphic.Circle){\r\n\t                            //2.2 子节点 如果是圆形  vv\r\n\t                            if(childrenNode[m] instanceof graphic.Circle){\r\n\t                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m;\r\n\t                                y = dom.position[1]+dom.layout.height;\r\n\t                            }else if(childrenNode[m] instanceof graphic.Image){\r\n\t                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;\r\n\t                                y = dom.position[1]+dom.layout.height-childrenNode[m].style.height/2\r\n\t                            }else{\r\n\t                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;\r\n\t                                y = dom.position[1]+dom.layout.height-childrenNode[m].shape.height/2\r\n\t                            }\r\n\t\r\n\t                        }else{\r\n\t                            if(childrenNode[m] instanceof graphic.Circle){\r\n\t                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m;\r\n\t                                y = dom.position[1]+dom.shape.height/2+dom.layout.height;\r\n\t                            }else if(childrenNode[m] instanceof graphic.Image){\r\n\t                                x = dom.position[0]+dom.style.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;\r\n\t                                y = dom.position[1]+dom.style.height/2+dom.layout.height-childrenNode[m].style.height/2\r\n\t                            }else{\r\n\t                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;\r\n\t                                y = dom.position[1]+dom.shape.height/2+dom.layout.height-childrenNode[m].shape.height/2\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t\r\n\t                    childrenNode[m].attr(\"position\", [x,y]);\r\n\t                }\r\n\t                // 3. 节点位置变化，刷新线\r\n\t                ConnectionManager.refreshLineByNode(dom);\r\n\t            }\r\n\t            // 4.递归 子节点\r\n\t            for(var j = 0;j < childrenNode.length;j++){\r\n\t                checkNode(childrenNode[j]);\r\n\t            }\r\n\t        }\r\n\t        checkNode(option.node);\r\n\t    }\r\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow工具类\r\n\t */\r\n\t\r\n\t    var Model = __webpack_require__(87);\r\n\t    var Constants = __webpack_require__(86);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var GroupNode = __webpack_require__(75);\r\n\t    var Connector = __webpack_require__(77);\r\n\t    /**\r\n\t     * 根据结点数组 导出JSON格式的数据\r\n\t     *\r\n\t     * @param {Array} model 总的模型\r\n\t     * @return {JSON} JSON格式的数据\r\n\t     */\r\n\t    function toJson(model, group) {\r\n\t        var jsonArr = [];\r\n\t        group.eachChild(function(node) {\r\n\t            if (node.model) {\r\n\t                //如果是组的话\r\n\t                if (node instanceof GroupNode) {\r\n\t                    var childArr = [];\r\n\t                    node.eachChild(function(childNode) {\r\n\t                        if (childNode.model) {\r\n\t                            childArr.push(childNode.model.option);\r\n\t                        };\r\n\t                    });\r\n\t                    node.model.set(Constants.CHILDS, childArr);\r\n\t                };\r\n\t                if (node instanceof Connector) {\r\n\t                    node.refreshModel();\r\n\t                };\r\n\t                jsonArr.push(node.model.option);\r\n\t\r\n\t            }\r\n\t\r\n\t\r\n\t        })\r\n\t        model.set(Constants.CHILDS, jsonArr);\r\n\t        return model.option;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据 JSON 生成节点\r\n\t     * @param  {[type]} fishTopoflow [description]\r\n\t     * @param  {[type]} json         [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {\r\n\t        // 1.清空画布\r\n\t\r\n\t        var connectors = [];\r\n\t        // 2.先创建节点  遍历形状 获取模型\r\n\t\r\n\t\r\n\t        for (var i = 0; i < childShapes.length; i++) {\r\n\t            var shape = childShapes[i];\r\n\t            if (shape.elementType === Constants.CONNECTION) {\r\n\t                connectors.push(shape);\r\n\t            }\r\n\t            else if (shape.elementType === Constants.ALARM) {\r\n\t                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);\r\n\t                fishTopoflow.creatAlarm(relationNode, shape.options);\r\n\t            }\r\n\t            else if (shape.elementType === Constants.GROUP) {\r\n\t                shape.options.id = shape.id;\r\n\t                var group = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);\r\n\t                fromJson(fishTopoflow, group, shape.childs, true, layoutRootNode);\r\n\t\r\n\t                fishTopoflow.addNode(group);\r\n\t\r\n\t\r\n\t            }\r\n\t            else {\r\n\t                // 将模型中的id 传递给创建的节点\r\n\t                shape.options.id = shape.id;\r\n\t                var node = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(node);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(node);\r\n\t                }\r\n\t\r\n\t                if (shape.options.layout) {\r\n\t                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n\t                        var node = findNodeById(group, shape.id)\r\n\t                        layoutRootNode.push(node);\r\n\t                          //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n\t                    };\r\n\t                };\r\n\t\r\n\t            };\r\n\t\r\n\t\r\n\t\r\n\t        };\r\n\t\r\n\t        // 3. 再创建线\r\n\t        for(var i = 0, len = connectors.length; i < len; i++) {\r\n\t            var line = connectors[i];\r\n\t            var startNode = findNodeById(group, line.startNodeId);\r\n\t            var endNode = findNodeById(group, line.endNodeId);\r\n\t            if (startNode && endNode) {\r\n\t                var link = fishTopoflow.creatLink(startNode,endNode,line.options,line.userData);\r\n\t                if (isChild) {\r\n\t                    group.add(link);\r\n\t                } else {\r\n\t                    fishTopoflow.addNode(link);\r\n\t                }\r\n\t                // 为了 线上点击之后显示那些附加的小图标\r\n\t                link.on(\"click\",function(){\r\n\t                    for(var i = 0;i < line.icons.length;i++){\r\n\t                        if (line.icons[i][0] == 'delete') {\r\n\t                            fishTopoflow.addLineDeleteIcon(link);\r\n\t                        }else if(line.icons[i][0] == 'change'){\r\n\t                            fishTopoflow.addLineChangeIcon(link);\r\n\t                        }else{\r\n\t                            fishTopoflow.addIcon(line.icons[i][0],{\r\n\t                                icon:line.icons[i][1].icon,\r\n\t                                width: line.icons[i][1].width,\r\n\t                                height: line.icons[i][1].height,\r\n\t                                lineNode:link\r\n\t                            })\r\n\t                        }\r\n\t\r\n\t                    }\r\n\t                })\r\n\t\r\n\t            };\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 根据id在group中查找\r\n\t     * @param  {[type]} group  [description]\r\n\t     * @param  {[type]} nodeId [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function findNodeById (group, nodeId) {\r\n\t        var retNode = null;\r\n\t        group.eachChild(function(node) {\r\n\t            if (node.model && node.model.get(Constants.ID) === nodeId) {\r\n\t                retNode = node;\r\n\t            };\r\n\t        })\r\n\t        return retNode;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Get canvas which has all thing rendered\r\n\t     * @param {Object} opts\r\n\t     * @param {string} [opts.backgroundColor]\r\n\t     */\r\n\t    function getRenderedCanvas(zr, opts) {\r\n\t        opts = opts || {};\r\n\t        opts.pixelRatio = opts.pixelRatio || 1;\r\n\t        opts.backgroundColor = opts.backgroundColor\r\n\t            || \"#FFFFFF\";\r\n\t        var list = zr.storage.getDisplayList();\r\n\t        // Stop animations\r\n\t        zrUtil.each(list, function (el) {\r\n\t            el.stopAnimation(true);\r\n\t        });\r\n\t        return zr.painter.getRenderedCanvas(opts);\r\n\t    }\r\n\t\r\n\t    function toDataURL (zr, opts) {\r\n\t        opts = opts || {};\r\n\t        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n\t            'image/' + (opts && opts.type || 'png')\r\n\t        );\r\n\t        return url;\r\n\t    }\r\n\t\r\n\t\r\n\t    function initNodeEvent (node, api) {\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t\r\n\t\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            node.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = eveName;\r\n\t                params.target = node;\r\n\t                api.trigger(eveName, params);\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t\r\n\t    module.exports = {\r\n\t        toJson: toJson,\r\n\t        fromJson: fromJson,\r\n\t        toDataURL:toDataURL\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线操作类\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t\tvar Node = __webpack_require__(76);\r\n\t\tvar Util = __webpack_require__(59);\r\n\t\tvar graphic = __webpack_require__(3);\r\n\t    var Point = __webpack_require__(60);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var ConnectionManager = __webpack_require__(84);\r\n\t    var LineOperationManager = {\r\n\t        LineOperations:[],\r\n\t        isEdit:true,\r\n\t        creatOperation:function(key,obj,api){\r\n\t            var lineOperation = new graphic.Image({\r\n\t                style: {\r\n\t                    image:obj.icon,\r\n\t                    width: obj.width||15,\r\n\t                    height: obj.height||15\r\n\t                }\r\n\t            });\r\n\t            lineOperation.key = key;\r\n\t            lineOperation.operation = true;\r\n\t            lineOperation.hide();\r\n\t            obj.lineNode.icons.push(lineOperation);\r\n\t            LineOperationManager.LineOperations.push(lineOperation);\r\n\t\r\n\t            //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n\t            lineOperation.on(\"click\",function(e){\r\n\t                if(obj.callback){\r\n\t                    obj.callback(obj.lineNode);\r\n\t                } else {\r\n\t                    var params = {};\r\n\t                    params.event = e;\r\n\t                    params.type = \"click\";\r\n\t                    params.elementType = \"LineOperationIcon\";\r\n\t                    api.trigger(params.type, params);\r\n\t                }\r\n\t\r\n\t            });\r\n\t            return lineOperation;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 计算小图标的位置，并显示\r\n\t         * @param  {[type]} connector [description]\r\n\t         * @return {[type]}           [description]\r\n\t         */\r\n\t        bindOperation:function(connector){\r\n\t            if(LineOperationManager.isEdit == false){return;}\r\n\t            var pointPosition = connector.middle();\r\n\t            var length = [];\r\n\t            for(var j = 0; j < connector.icons.length; j++){\r\n\t                length.push(connector.icons[j].style.width);\r\n\t            }\r\n\t            var totalLength = 0;\r\n\t            for(var m = 0; m < connector.icons.length; m++){\r\n\t                    totalLength += length[m]+10;\r\n\t            }\r\n\t            for(var i = 0; i < connector.icons.length; i++){\r\n\t                var connectorPosition = 0;\r\n\t                for(var k = 0; k < i; k++){\r\n\t                    connectorPosition += length[k]+10;\r\n\t                }\r\n\t                connector.icons[i].attr(\"position\",[pointPosition[0]+connectorPosition-totalLength/2,pointPosition[1]+5]);\r\n\t                connector.icons[i].show();\r\n\t            }\r\n\t        },\r\n\t\r\n\t        hideAllLineOperation: function() {\r\n\t            for (var li = 0; li < LineOperationManager.LineOperations.length; li++) {\r\n\t                var icon =  LineOperationManager.LineOperations[li];\r\n\t                icon.hide();\r\n\t            }\r\n\t        },\r\n\t\r\n\t        addIcon: function(key, obj, zr, api) {\r\n\t            //判断是小图标否存在 ，存在则直接返回\r\n\t            if(obj.lineNode.icons){\r\n\t                for (var i = 0; i < obj.lineNode.icons.length; i++) {\r\n\t                    if (obj.lineNode.icons[i].key == key) {\r\n\t                        LineOperationManager.bindOperation(obj.lineNode);\r\n\t                        return;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            var lineOperation = LineOperationManager.creatOperation(key, obj, api);\r\n\t            zr.add(lineOperation);\r\n\t            LineOperationManager.bindOperation(obj.lineNode);\r\n\t            return lineOperation;\r\n\t        },\r\n\t\r\n\t        deleteIconObj: function(parentZr,lineNode) {\r\n\t            return {\r\n\t                icon:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=\",\r\n\t                width: 12,\r\n\t                height: 14,\r\n\t                lineNode:lineNode,\r\n\t                callback:function(e) {\r\n\t                    for(var i = 0; i<lineNode.icons.length;i++){\r\n\t                        parentZr.remove(lineNode.icons[i])\r\n\t                    }\r\n\t                    ConnectionManager.deleteLine(parentZr);\r\n\t                    LineOperationManager.hideAllLineOperation();\r\n\t                    e.cancelBubble = true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t\tmodule.exports = LineOperationManager;\r\n\t\r\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Flow静态方法类\r\n\t * @class fish.topo.FishTopoFlow.Flow\r\n\t */\r\n\t\r\n\t\r\n\t    var Constants = __webpack_require__(86);\r\n\t    var Flow = {\r\n\t        FLOW_TYPE: \"elementType\",\r\n\t        LINK: \"connection\",\r\n\t        RECT: \"Rect\",\r\n\t        Group: 'Group',\r\n\t        IMAGE: 'Image',\r\n\t        TEXT: 'Text',\r\n\t        CIRCLE: 'Circle',\r\n\t        SECTOR: 'Sector',\r\n\t        RING: 'Ring',\r\n\t        POLYGON: 'Polygon',\r\n\t        POLYLINE: 'Polyline',\r\n\t        LINE: 'Line',\r\n\t        BEZIERCURVE: 'Beziercurve',\r\n\t        ARC: 'Arc',\r\n\t        SCENE:'scene',\r\n\t\r\n\t        /**\r\n\t         * @method setUserData\r\n\t         * 设置用户数据\r\n\t         * @param {Object} node 需要设置数据的节点\r\n\t         * @param {Object} obj 数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //设置自定义数据\r\n\t         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n\t         */\r\n\t        setUserData: function(node, obj) {\r\n\t            node.model.set(Constants.USERDATA, obj);\r\n\t        },\r\n\t        /**\r\n\t         * 获取设置的用户数据\r\n\t         * @param {Object} node 需要获取数据的节点\r\n\t         * @return {String}      数据\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取自定义数据\r\n\t         *      this.fishTopo.Flow.getUserData(rect);\r\n\t         */\r\n\t        getUserData: function(node) {\r\n\t            return node.model.get(Constants.USERDATA);\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是连线\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是连线\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n\t         */\r\n\t        isLink: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.LINK;\r\n\t        },\r\n\t        /**\r\n\t         * 判断是否是节点\r\n\t         * @param {Object} model 对象的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n\t         */\r\n\t\r\n\t        isNode: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            var isNode;\r\n\t            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n\t                isNode = true;\r\n\t            }else{\r\n\t                isNode = false;\r\n\t            }\r\n\t            return isNode;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 判断节点是否是矩形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是矩形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n\t         */\r\n\t        isRect: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return  elementType == Flow.RECT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是图片节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是图片节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n\t         */\r\n\t        isImage: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.IMAGE;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是文字节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是文字节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n\t         */\r\n\t        isText: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.TEXT;\r\n\t        },\r\n\t        /**\r\n\t         * 判断节点是否是圆形节点\r\n\t         * @param {Object} model 节点的model\r\n\t         * @return {Boolean}      是 否\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //判断是否是圆形节点\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n\t         */\r\n\t        isCircle: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType == Flow.CIRCLE;\r\n\t        },\r\n\t        /**\r\n\t         * 获取节点的类型\r\n\t         * @param {Object} model 节点的model\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *      //获取节点类型\r\n\t         *      var nodeModel = e.target.model;\r\n\t         *      return this.fishTopo.Flow.getType(nodeModel);\r\n\t         */\r\n\t        getType: function(model) {\r\n\t            var elementType = model.get(Flow.FLOW_TYPE);\r\n\t            return elementType;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = Flow;\r\n\t\r\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports) {\n\n\t\r\n\t    //单例\r\n\t    var instance = null;\r\n\t    var emptyFn = function() {};\r\n\t    //初始默认配置\r\n\t    var config_default = {\r\n\t        //线程池\"线程\"数量\r\n\t        thread: 5,\r\n\t        //图片加载失败重试次数\r\n\t        //重试2次，加上原有的一次，总共是3次\r\n\t        \"tries\": 2\r\n\t    };\r\n\t    //工具\r\n\t    var _helpers = {\r\n\t        //设置dom属性\r\n\t        setAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.dataset[name] = value;\r\n\t                    return value;\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name, value) {\r\n\t                    dom.setAttribute(\"data-\" + name, value);\r\n\t                    return value;\r\n\t                };\r\n\t            }\r\n\t        }()),\r\n\t        //获取dom属性\r\n\t        getAttr: (function() {\r\n\t            var img = new Image();\r\n\t            //判断浏览器是否支持HTML5 dataset\r\n\t            if (img.dataset) {\r\n\t                return function(dom, name) {\r\n\t                    if(!dom.dataset[name]){\r\n\t                        return dom.getAttribute(\"data-\" + name);\r\n\t                    }else{\r\n\t                        return dom.dataset[name];\r\n\t                    }\r\n\t                };\r\n\t            } else {\r\n\t                return function(dom, name) {\r\n\t                    return dom.getAttribute(\"data-\" + name);\r\n\t                };\r\n\t            }\r\n\t        }())\r\n\t    };\r\n\t    /**\r\n\t     * 构造方法\r\n\t     * @param max 最大连接数。数值。\r\n\t     */\r\n\t    function ImagePool(max) {\r\n\t        //最大并发数量\r\n\t        this.max = max || config_default.thread;\r\n\t        this.linkHead = null;\r\n\t        this.linkNode = null;\r\n\t        //加载池\r\n\t        //[{img: dom,free: true, node: node}]\r\n\t        //node\r\n\t        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n\t        this.pool = [];\r\n\t    }\r\n\t    /**\r\n\t     * 初始化\r\n\t     */\r\n\t    ImagePool.prototype.initPool = function() {\r\n\t        var i, img, obj, _s;\r\n\t        _s = this;\r\n\t        for (i = 0; i < this.max; i++) {\r\n\t            obj = {};\r\n\t            img = new Image();\r\n\t            _helpers.setAttr(img, \"id\", i);\r\n\t            img.onload = function() {\r\n\t                var id, src;\r\n\t                //回调\r\n\t                _s.notice(_s.getNode(this), \"success\", this);\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            img.onerror = function() {\r\n\t                var node = _s.getNode(this);\r\n\t                //判断尝试次数\r\n\t                if (node.tries < config_default.tries) {\r\n\t                    node.tries = node.tries+1;\r\n\t                    //再次追加到任务链表末尾\r\n\t                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n\t                } else {\r\n\t                    //error回调\r\n\t                    //node.options.error.call(null, this.src);\r\n\t                    _s.notice(node, \"error\", this);\r\n\t                }\r\n\t                //处理任务\r\n\t                _s.executeLink(this);\r\n\t            };\r\n\t            obj.img = img;\r\n\t            obj.free = true;\r\n\t            this.pool.push(obj);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 回调封装\r\n\t     * @param node 节点。对象。\r\n\t     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n\t     * @param img 图片。\r\n\t     */\r\n\t    ImagePool.prototype.notice = function(node, status, img) {\r\n\t        node.notice(status, img);\r\n\t    };\r\n\t    /**\r\n\t     * 处理链表任务\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.executeLink = function(dom) {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //加载下一个图片\r\n\t            this.setSrc(dom, this.linkHead);\r\n\t            //去除链表头\r\n\t            this.shiftNode();\r\n\t        } else {\r\n\t            //设置自身状态为空闲\r\n\t            this.status(dom, true);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取空闲\"线程\"\r\n\t     */\r\n\t    ImagePool.prototype.getFree = function() {\r\n\t        var length, i;\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                return this.pool[i];\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    };\r\n\t    /**\r\n\t     * 封装src属性设置\r\n\t     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setSrc = function(dom, node) {\r\n\t        //设置池中的\"线程\"为非空闲状态\r\n\t        this.status(dom, false);\r\n\t        //关联节点\r\n\t        this.setNode(dom, node);\r\n\t        //加载图片\r\n\t        dom.src = node.src;\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"状态\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n\t     */\r\n\t    ImagePool.prototype.status = function(dom, status) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].free = status;\r\n\t        }\r\n\t        \r\n\t        //空闲状态，清除关联的节点\r\n\t        if (status) {\r\n\t            this.pool[id].node = null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 更新池中的\"线程\"的关联节点\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.setNode = function(dom, node) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            this.pool[id].node = node;\r\n\t            return this.pool[id].node === node;\r\n\t        }\r\n\t        \r\n\t    };\r\n\t    /**\r\n\t     * 获取池中的\"线程\"的关联节点\r\n\t     * @param dom 图像dom对象。对象。\r\n\t     */\r\n\t    ImagePool.prototype.getNode = function(dom) {\r\n\t        var id = _helpers.getAttr(dom, \"id\");\r\n\t        if(id){\r\n\t            return this.pool[id].node;\r\n\t        }\r\n\t        \r\n\t    };\r\n\t    /**\r\n\t     * 对外接口，加载图片\r\n\t     * @param src 可以是src字符串，也可以是src字符串数组。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     */\r\n\t    ImagePool.prototype.load = function(src, options) {\r\n\t        var srcs = [],\r\n\t            free = null,\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            //只初始化一次回调策略\r\n\t            notice = (function() {\r\n\t                if (options.once) {\r\n\t                    return function(status, img) {\r\n\t                        var g = this.group,\r\n\t                            o = this.options;\r\n\t                        //记录\r\n\t                        g[status].push(img);\r\n\t                        //判断改组是否全部处理完成\r\n\t                        if (g.success.length + g.error.length === g.count) {\r\n\t                            //异步\r\n\t                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n\t                            setTimeout(function() {\r\n\t                                o.success.call(null, g.success, g.error, g.count);\r\n\t                            }, 1);\r\n\t                        }\r\n\t                    };\r\n\t                } else {\r\n\t                    return function(status, img) {\r\n\t                        var o = this.options;\r\n\t                        //直接回调\r\n\t                        setTimeout(function() {\r\n\t                            o[status].call(null, img);\r\n\t                        }, 1);\r\n\t                    };\r\n\t                }\r\n\t            }()),\r\n\t            group = {\r\n\t                count: 0,\r\n\t                success: [],\r\n\t                error: []\r\n\t            },\r\n\t            node = null;\r\n\t        options = options || {};\r\n\t        options.success = options.success || emptyFn;\r\n\t        options.error = options.error || emptyFn;\r\n\t        srcs = srcs.concat(src);\r\n\t        //设置组元素个数\r\n\t        group.count = srcs.length;\r\n\t        //遍历需要加载的图片\r\n\t        for (i = 0, length = srcs.length; i < length; i++) {\r\n\t            //创建节点\r\n\t            node = this.createNode(srcs[i], options, notice, group);\r\n\t            //判断线程池是否有空闲\r\n\t            free = this.getFree();\r\n\t            if (free) {\r\n\t                //有空闲，则立即加载图片\r\n\t                this.setSrc(free.img, node);\r\n\t            } else {\r\n\t                //没有空闲，将任务添加到链表\r\n\t                this.appendNode(node);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 获取内部状态信息\r\n\t     * @returns {{}}\r\n\t     */\r\n\t    ImagePool.prototype.info = function() {\r\n\t        var info = {},\r\n\t            length = 0,\r\n\t            i = 0,\r\n\t            node = null;\r\n\t        //线程\r\n\t        info.thread = {};\r\n\t        //线程总数量\r\n\t        info.thread.count = this.pool.length;\r\n\t        //空闲线程数量\r\n\t        info.thread.free = 0;\r\n\t        //任务\r\n\t        info.task = {};\r\n\t        //待处理任务数量\r\n\t        info.task.count = 0;\r\n\t        //获取空闲\"线程\"数量\r\n\t        for (i = 0, length = this.pool.length; i < length; i++) {\r\n\t            if (this.pool[i].free) {\r\n\t                info.thread.free = info.thread.free + 1;\r\n\t            }\r\n\t        }\r\n\t        //获取任务数量(任务链长度)\r\n\t        node = this.linkHead;\r\n\t        if (node) {\r\n\t            info.task.count = info.task.count + 1;\r\n\t            while (node.next) {\r\n\t                info.task.count = info.task.count + 1;\r\n\t                node = node.next;\r\n\t            }\r\n\t        }\r\n\t        return info;\r\n\t    };\r\n\t    /**\r\n\t     * 创建节点\r\n\t     * @param src 图片路径。字符串。\r\n\t     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n\t     * @param notice 回调策略。 函数。\r\n\t     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n\t     * @param tr 出错重试次数。数值。默认为0。\r\n\t     * @returns {{}}\r\n\t     */\r\n\t    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n\t        var node = {};\r\n\t        node.src = src;\r\n\t        node.options = options;\r\n\t        node.notice = notice;\r\n\t        node.group = group;\r\n\t        node.tries = tr || 0;\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t     * 向任务链表末尾追加节点\r\n\t     * @param node 节点。对象。\r\n\t     */\r\n\t    ImagePool.prototype.appendNode = function(node) {\r\n\t        //判断链表是否为空\r\n\t        if (!this.linkHead) {\r\n\t            this.linkHead = node;\r\n\t            this.linkNode = node;\r\n\t        } else {\r\n\t            this.linkNode.next = node;\r\n\t            this.linkNode = node;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 删除链表头\r\n\t     */\r\n\t    ImagePool.prototype.shiftNode = function() {\r\n\t        //判断链表是否存在节点\r\n\t        if (this.linkHead) {\r\n\t            //修改链表头\r\n\t            this.linkHead = this.linkHead.next || null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 导出对外接口\r\n\t     * @param max 最大连接数。数值。\r\n\t     * @returns {{load: Function, info: Function}}\r\n\t     */\r\n\t    var initImagePool = function(max) {\r\n\t        if (!instance) {\r\n\t            instance = new ImagePool(max);\r\n\t            instance.initPool();\r\n\t        }\r\n\t        return {\r\n\t            /**\r\n\t             * 加载图片\r\n\t             */\r\n\t            load: function() {\r\n\t                instance.load.apply(instance, arguments);\r\n\t            },\r\n\t            /**\r\n\t             * 内部信息\r\n\t             * @returns {*|any|void}\r\n\t             */\r\n\t            info: function() {\r\n\t                return instance.info.call(instance);\r\n\t            }\r\n\t        };\r\n\t    };\r\n\t\r\n\t    module.exports = { initImagePool: initImagePool }\r\n\t\r\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(97);\n\t    __webpack_require__(63).registerPainter('vml', __webpack_require__(99));\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(64).canvasSupported) {\n\t    var vec2 = __webpack_require__(14);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var colorTool = __webpack_require__(19);\n\t    var textContain = __webpack_require__(23);\n\t    var RectText = __webpack_require__(22);\n\t    var Displayable = __webpack_require__(7);\n\t    var ZImage = __webpack_require__(40);\n\t    var Text = __webpack_require__(42);\n\t    var Path = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    var vmlCore = __webpack_require__(98);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z 的取值范围为 [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-10) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-10) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    // 不 round 会非常慢\n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path;\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t        var text = style.text;\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var fontStyle = getFontStyle(style.textFont);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        var baseline = style.textBaseline;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t        if (verticalAlign) {\n\t            switch (verticalAlign) {\n\t                case 'middle':\n\t                    y -= textRect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    y -= textRect.height;\n\t                    break;\n\t                // 'top'\n\t            }\n\t            // Ignore baseline\n\t            baseline = 'top';\n\t        }\n\t\n\t        var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        switch (baseline) {\n\t            case 'hanging':\n\t            case 'top':\n\t                y += fontSize / 1.75;\n\t                break;\n\t            case 'middle':\n\t                break;\n\t            default:\n\t            // case null:\n\t            // case 'alphabetic':\n\t            // case 'ideographic':\n\t            // case 'bottom':\n\t                y -= fontSize / 2.25;\n\t                break;\n\t        }\n\t        switch (align) {\n\t            case 'left':\n\t                break;\n\t            case 'center':\n\t                x -= textRect.width / 2;\n\t                break;\n\t            case 'right':\n\t                x -= textRect.width;\n\t                break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            // 这里是在前面 appendChild 保证顺序的前提下\n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: fromTextEl ? style.fill : style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: fromTextEl ? style.stroke : style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(64).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(20);\n\t    var vmlCore = __webpack_require__(98);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToMap.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function () {\n\t            var width = this._getWidth();\n\t            var height = this._getHeight();\n\t\n\t            if (this._width != width && this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            this.root.removeChild(this.vmlViewport);\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f6a3121777ab2b67d7a6\n **/","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-flow/lib/FishTopoFlow.js');\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.flow.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * 流程对象\r\n * @class fish.topo.FishTopoFlow\r\n */\r\n\r\n/**\r\n * @event click\r\n * 节点或者线段的click事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"click\", function(event) {\r\n *              console.log(\"点击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dblclick\r\n * 节点或者线段的双击事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"dblclick\", function(event) {\r\n *              console.log(\"双击的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event create\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          this.fishTopo.on(\"create\", function(e) {\r\n *               if (me.fishTopo.Flow.isLink(e.target.model)) {\r\n *                  console.log(\"线段创建完毕：\" + e.target.model);\r\n *               }\r\n *          });\r\n */\r\n\r\n/**\r\n * @event delete\r\n * 节点与线段创建完毕的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点删除完毕事件\r\n *          this.fishTopo.on(\"delete\", function(event) {\r\n *              console.log(\"删除的是：\" + event.target.model.get('elementType'));\r\n *          });\r\n */\r\n\r\n/**\r\n * @event dropDrag\r\n * 节点移动完成的事件\r\n * @param {Object} event 事件 event.target为目标对象 event.target.model为目标对象的业务数据\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          //节点移动结束事件\r\n            this.fishTopo.on(\"dropDrag\", function(event) {\r\n                console.log(\"移动的节点是：\"+event.target.model.get('elementType'));\r\n            });\r\n */\r\n\r\n/**\r\n * @event mousedown\r\n * 节点与线段鼠标按下事件\r\n * @param {Object} event 事件 node为节点\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          node.on(\"mousedown\", function(){\r\n *              node.attr(\"style\",{text:\"mousedown\"});\r\n *          });\r\n */\r\n\r\n/**\r\n * @event mouseup\r\n * 节点与线段鼠标抬起事件\r\n * @param {Object} event 事件 node为节点\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          node.on(\"mouseup\", function(){\r\n *              node.attr(\"style\",{text:\"mouseup\"});\r\n *          });\r\n */\r\n\r\n/**\r\n * @event mouseover\r\n * 节点与线段鼠标悬浮事件\r\n * @param {Object} event 事件 node为节点\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          node.on(\"mouseover\", function(){\r\n *              node.attr(\"style\",{text:\"mouseover\"});\r\n *          });\r\n */\r\n\r\n/**\r\n * @event mousemove\r\n * 节点与线段鼠标移动事件\r\n * @param {Object} event 事件 node为节点\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          node.on(\"mousemove\", function(){\r\n *              node.attr(\"style\",{text:\"mousemove\"});\r\n *          });\r\n */\r\n\r\n/**\r\n * @event mouseout\r\n * 节点与线段鼠标离开事件\r\n * @param {Object} event 事件 node为节点\r\n *\r\n * **使用范例**：\r\n *\r\n *      @example\r\n *          node.on(\"mouseout\", function(){\r\n *              node.attr(\"style\",{text:\"mouseout\"});\r\n *          });\r\n */\r\n\r\n\r\n\r\n\r\n\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var Minimap = require(\"../../fish-topo-core/lib/minimap.js\");\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var Point = require(\"../../fish-topo-core/lib/Point.js\");\r\n    var ExtensionAPI = require('./ExtensionApi');\r\n    var Eventful = require('zrender/lib/mixin/Eventful');\r\n    var zrender = require('zrender/lib/zrender');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var GroupNode = require(\"./node/GroupNode.js\");\r\n    var OperationNode = require(\"../../fish-topo-core/lib/manager/OperationNode.js\");\r\n    var FlowConnectionManager = require(\"./manager/FlowConnectionManager.js\");\r\n    var forceInstance = require(\"./layout/forceLayout.js\");\r\n    var treeLayout = require(\"./layout/treeLayout.js\");\r\n    var FlowUtil = require(\"./util/FlowUtil.js\");\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var Model = require(\"../../fish-topo-core/lib/model.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n    var Connector = require(\"../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var LineOperationManager = require(\"../../fish-topo-core/lib/manager/LineOperationManager.js\");\r\n    var Flow = require(\"./Flow.js\");\r\n    var textContain = require('zrender/lib/contain/text');\r\n    var ImagePool = require(\"../../fish-topo-core/lib/ImagePool.js\");\r\n\r\n    function FishTopoFlow(dom, opts) {\r\n        this.id;\r\n        this.group;\r\n        this._dom = dom;\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n        this.eagleEye = false;\r\n        this.eagleEyeNode;\r\n        this.initScaleRatio;\r\n        this.operationNode;\r\n        this.selectedNode = null;\r\n        this.allNodes = [];\r\n        this.minimap;\r\n        this._layoutTimeout = null;\r\n        this._zr = zrender.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n\r\n        this._api = new ExtensionAPI(this);\r\n        this.Shape = graphic;\r\n        this.model = new Model({});\r\n        this.model.set(Constants.ELEMENT_TYPE, \"scene\");\r\n        this.model.set(Constants.MODE, \"normal\");\r\n        this.options = opts;\r\n        Eventful.call(this);\r\n    }\r\n\r\n    var fishTopoProto = FishTopoFlow.prototype;\r\n\r\n    fishTopoProto.forceInstance = forceInstance;\r\n    fishTopoProto.treeLayout = treeLayout;\r\n    /**\r\n     * 获取 fishTopo 实例容器的 dom 节点\r\n     * @return {HTMLElement}\r\n     */\r\n    fishTopoProto.getDom = function() {\r\n        return this._dom;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.getZr = function() {\r\n        return this._zr;\r\n    };\r\n    /**\r\n     * 获取 fishTopo 实例容器的宽度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getWidth = function() {\r\n        return this._zr.getWidth();\r\n    };\r\n\r\n    /**\r\n     * 获取 fishTopo 实例容器的高度。\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getHeight = function() {\r\n        return this._zr.getHeight();\r\n    };\r\n\r\n\r\n    /**\r\n     * 当前实例是否已经被释放。\r\n     * @return {boolean}\r\n     */\r\n    fishTopoProto.isDisposed = function() {\r\n        return this._disposed;\r\n    };\r\n\r\n    /**\r\n     * Dispose instance\r\n     */\r\n    fishTopoProto.dispose = function() {\r\n        this._disposed = true;\r\n\r\n        this._zr.dispose();\r\n\r\n        instances[this.id] = null;\r\n    };\r\n\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     * @param {number} width 宽度\r\n     * @param {number} height 高度\r\n     */\r\n    fishTopoProto.resize = function() {\r\n        this._zr.resize();\r\n\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 初始化\r\n     */\r\n    fishTopoProto.init = function() {\r\n        var that = this;\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n        FlowConnectionManager.connectors = [];\r\n        //mouseup 会在各个node或线的click事件之点执行  在选中节点或线前 先清空选中效果\r\n        this._zr.on(\"mouseup\", function(e) {\r\n            clearSelect(e);\r\n        });\r\n        function clearSelect(e){\r\n            if (that.operationNode) {\r\n                that.group.remove(that.operationNode);\r\n                that.operationNode = null;\r\n            }\r\n            var shape = e.target;\r\n            if (shape && shape.model && Flow.isLink(shape.model)) {\r\n                return;\r\n            }\r\n            if (shape && shape.connector instanceof Connector) {\r\n                return;\r\n            }\r\n            FlowConnectionManager.clearSelectCon();\r\n            if (shape && shape.operation && shape.operation == true) {\r\n                return;\r\n            }\r\n            LineOperationManager.hideAllLineOperation();\r\n        }\r\n        this._zr.on(\"click\", function(e) {\r\n            var nodeTarget = e.target;\r\n            var shape;\r\n            if(nodeTarget){\r\n                shape = nodeTarget.model;\r\n            }\r\n            if ((nodeTarget && shape && Flow.isLink(shape)) || (nodeTarget && shape && Flow.isNode(shape))) {\r\n                return;\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = \"click\";\r\n            params.target = that;\r\n            that._api.trigger(params.type, params);\r\n        });\r\n        this.on('conPointsGroup:click', function(argument) {\r\n            LineOperationManager.bindOperation(argument.lineNode);\r\n        });\r\n\r\n        //polyfill remove\r\n        if (!('remove' in Element.prototype)) {\r\n            Element.prototype.remove = function() {\r\n                if (this.parentNode) {\r\n                    this.parentNode.removeChild(this);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 导出json\r\n     * @return {Object} json对象\r\n     */\r\n    fishTopoProto.toJson = function() {\r\n        return FlowUtil.toJson(this.model, this.group);\r\n    };\r\n\r\n    /**\r\n     * 导入json\r\n     * @param  {Object} json对象\r\n     */\r\n    fishTopoProto.fromJson = function(json) {\r\n        this.clear();\r\n        var model = new Model(json);\r\n        this.setBackground(model.get(Constants.BACKGROUND));\r\n        var layoutRootNode = [];\r\n        FlowUtil.fromJson(this, this.group, model.get(Constants.CHILDS), false, layoutRootNode);\r\n        for(var i = 0; i < layoutRootNode.length; i++){\r\n            console.log(layoutRootNode)\r\n            this.layoutNode(\"tree\", {\r\n                \"node\": layoutRootNode[i],\r\n                \"type\":layoutRootNode[i].treeType\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 添加节点\r\n     * @method addNode\r\n     * @param {Object} node creatNode返回的对象\r\n     */\r\n    fishTopoProto.addNode = function(node) {\r\n        if (node instanceof GroupNode) {\r\n            node.setProperties({\r\n                shape: {\r\n                    width: node.getBoundingRect().width,\r\n                    height: node.getBoundingRect().height\r\n                }\r\n            });\r\n        }\r\n        this.group.add(node);\r\n    };\r\n\r\n    /**\r\n     * 清空当前实例，会移除实例中所有的节点与线\r\n     * @method clear\r\n     */\r\n    fishTopoProto.clear = function() {\r\n        for (var i = 0; i < this.allNodes.length; i++) {\r\n            var parentZr;\r\n            if (this.allNodes.parent) {\r\n                parentZr = this.allNodes.parent;\r\n            } else {\r\n                parentZr = this._zr;\r\n            }\r\n            FlowConnectionManager.deleteSelectCon(this.allNodes[i], parentZr)\r\n        }\r\n        FlowConnectionManager.connectorMap.clear();\r\n        this.allNodes = [];\r\n        this.operationNode = null;\r\n        this.selectedNode = null;\r\n        FlowConnectionManager.connectors = [];\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this.group.isBg = true;\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的小图标操作\r\n     * @param {string} key 小图标的名称\r\n     * @param {Object} options 小图标的相关参数\r\n     * @param {String} [options.icon] 小图标路径\r\n     * @param {Object} [options.lineNode] 线段实例\r\n     * @param {Function} [options.callback] 点击后的回调\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *                  this.fishTopo.addIcon(\"icon1\", {\r\n     *                      icon: \"https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo_top_ca79a146.png\",\r\n     *                      lineNode: lineNode,\r\n     *                      callback: function(lineNode) {\r\n     *                          alert(JSON.stringify(lineNode))\r\n     *                      },\r\n     *                  });\r\n     */\r\n    fishTopoProto.addIcon = function(key, options) {\r\n        LineOperationManager.addIcon(key, options, this.group, this._api);\r\n    };\r\n\r\n    /**\r\n     * 创建连线的默认删除操作\r\n     * @param  {Object} lineNode 线\r\n     *\r\n     *  **使用范例**：\r\n     *\r\n     *      @example\r\n     *      fishTopo.lineDefaultIcon(lineNode);\r\n     */\r\n    fishTopoProto.lineDefaultIcon = function(lineNode) {\r\n        this.addLineDeleteIcon(lineNode);\r\n        this.addLineChangeIcon(lineNode);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 添加线的删除图标\r\n     */\r\n    fishTopoProto.addLineDeleteIcon = function(lineNode) {\r\n        var that = this;\r\n        var parentZr;\r\n        if (lineNode.parent) {\r\n            parentZr = lineNode.parent;\r\n        } else {\r\n            parentZr = this.group;\r\n        }\r\n        //创建删除\r\n        var lineOperation = LineOperationManager.addIcon(\"delete\", LineOperationManager.deleteIconObj(parentZr, lineNode), parentZr, this._api);\r\n        if (lineOperation) {\r\n            lineOperation.on(\"click\", function() {\r\n                that._triggerDeleteEvent(lineNode);\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 添加线的切换图标\r\n     */\r\n    fishTopoProto.addLineChangeIcon = function(lineNode) {\r\n        var that = this;\r\n        var parentZr;\r\n        if (lineNode.parent) {\r\n            parentZr = lineNode.parent;\r\n        } else {\r\n            parentZr = this.group;\r\n        }\r\n        var arrLineType = [Connector.TYPE_STRAIGHT, Connector.TYPE_JAGGED, Connector.TYPE_CURVE];\r\n\r\n        function modifyNextLineType(line) {\r\n            var index = zrUtil.indexOf(arrLineType, line.options.style.lineType);\r\n            var nextLineType = arrLineType[(index + 1) % arrLineType.length];\r\n            //FlowConnectionManager.setModel(line,{style:{lineType:nextLineType}});\r\n            var startNode = line.startNode;\r\n            var endNode = line.endNode;\r\n\r\n            FlowConnectionManager.deleteLine(parentZr);\r\n            LineOperationManager.hideAllLineOperation();\r\n            zrUtil.merge(line.options.style ,{lineType: nextLineType} , true);\r\n            var nextLine = that._createConnectorByNodes(startNode, endNode,line.options)\r\n            nextLine.icons = line.icons;\r\n            nextLine.on('click', function() {\r\n                LineOperationManager.bindOperation(nextLine);\r\n            });\r\n            return nextLine;\r\n        }\r\n\r\n        //创建切换\r\n        LineOperationManager.addIcon(\"change\", {\r\n            icon: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAPBAMAAAD9gUllAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAqUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoTzogAAAAOdFJOUwD+CC3uuR7gVXeeFEnMRIEDJwAAAGRJREFUCNdjYOCZwIAA7YuUQADM1nQsDQWBBBBnoSAYiBiAOGeROWwLIzpAYANEE7JpDBtQKAiYqQCmlI1BYOFqMMfcBQQERcEGmkBMFwwAcWzLQcBRCuwItTQQWD4JybQ5DAwAO74b0S83OyMAAAAASUVORK5CYII=\",\r\n            width: 15,\r\n            height: 15,\r\n            lineNode: lineNode,\r\n            callback: function() {\r\n\r\n                var selectedLine = modifyNextLineType(FlowConnectionManager.selConnector);\r\n                //.  LineOperationManager.bindOperation(selectedLine);\r\n            }\r\n        }, parentZr, this._api);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 初始化 操作的虚线框\r\n     */\r\n    fishTopoProto.initOperationNode = function(node) {\r\n        var that = this;\r\n        this.operationNode = new OperationNode(node, this.group);\r\n\r\n        this.operationNode.on(OperationNode.ARROW_DRAGSTART, function(e) {\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            //拖拽开始先把 箭头图标 给隐藏\r\n            var arrow = e.event.target;\r\n            arrow.hide();\r\n            var rEndPoint = new Point(x, y);\r\n            var connector = FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);\r\n            that.group.add(connector);\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        // 侦听 箭头 拖拽事件\r\n        this.operationNode.on(OperationNode.ARROW_DRAG, function(e) {\r\n            var x = (e.event.offsetX - that.group.position[0]) / that.nowZoom;\r\n            var y = (e.event.offsetY - that.group.position[1]) / that.nowZoom;\r\n            var arrow = e.event.target;\r\n            var rEndPoint = new Point(x, y);\r\n            FlowConnectionManager.manageTempConnector(that.selectedNode, rEndPoint, arrow.lineType);\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        //侦听 箭头 拖拽结束事件 画线\r\n        this.operationNode.on(OperationNode.ARROW_DRAGEND, function(e) {\r\n            e.cancelBubble = true;\r\n            var x = e.event.offsetX;\r\n            var y = e.event.offsetY;\r\n            var targetNode = null;\r\n            //拖拽结束先把 箭头图标 给显示\r\n            var arrow = e.event.target;\r\n            arrow.show();\r\n            //删除临时线\r\n            FlowConnectionManager.removeTempConnector(that.group);\r\n\r\n            //1.如果是子节点 内 节点拖拽 则 增加排除子节点的参数\r\n            targetNode = findHover(that.allNodes, x, y);\r\n\r\n            function isHover(node, x, y) {\r\n                var cx, cy;\r\n                return node.rectContain(x, y);\r\n            }\r\n\r\n            function findHover(list, x, y, excludes) {\r\n                for (var i = list.length - 1; i >= 0; i--) {\r\n                    if (isExclude(excludes, list[i]) //list[i] !== exclude\r\n                        // getDisplayList may include ignored item in VML mode\r\n                        && !list[i].ignore && isHover(list[i], x, y)) {\r\n                        return list[i];\r\n                    }\r\n                }\r\n            }\r\n\r\n            function isExclude(excludes, node) {\r\n                return zrUtil.indexOf(excludes, node) == -1;\r\n            }\r\n\r\n            //2.如果找到目标结点 则画线\r\n            if (targetNode && (that.selectedNode != targetNode)) {\r\n                var connectOptions;\r\n                if(e.data){\r\n                    connectOptions = e.data;\r\n                }else{\r\n                    connectOptions = {\r\n                        style: {\r\n                            lineType: arrow.lineType\r\n                        }\r\n                    }\r\n                }\r\n                that._createConnectorByNodes(that.selectedNode, targetNode, connectOptions);\r\n            }\r\n        });\r\n\r\n        //删除按钮点击事件\r\n        this.operationNode.on(OperationNode.DELETE_CLICK, function() {\r\n            that._triggerDeleteEvent(that.selectedNode);\r\n            that.removeNode(that.selectedNode);\r\n            if (that.selectedNode.cmsImage) {\r\n                that._triggerDeleteEvent(that.selectedNode.cmsImage);\r\n                that.removeNode(that.selectedNode.cmsImage);\r\n            }\r\n        });\r\n        this.group.add(this.operationNode);\r\n    };\r\n\r\n    /**\r\n     * 移除场景中的某个节点\r\n     * @param  {Object} selectedNode 待删除的节点\r\n     */\r\n    fishTopoProto.removeNode = function(selectedNode) {\r\n        var that = this;\r\n        //1.如果是子节点 内 节点  则 调用子节点的删除\r\n        if (selectedNode.parent) {\r\n            selectedNode.parent.remove(selectedNode);\r\n        } else {\r\n            that.group.remove(selectedNode);\r\n        }\r\n        //2.从allNodes数组中删除\r\n        for (var i = 0; i < that.allNodes.length; i++) {\r\n            if (selectedNode.id == that.allNodes[i].id) {\r\n                that.allNodes.splice(i, 1);\r\n            }\r\n        }\r\n        FlowConnectionManager.deleteSelectCon(selectedNode, that.group);\r\n        if (that.operationNode) {\r\n            that.group.remove(that.operationNode);\r\n            that.operationNode = null;\r\n        }\r\n        FlowConnectionManager.clearSelectCon();\r\n        LineOperationManager.hideAllLineOperation();\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发delete事件\r\n     */\r\n    fishTopoProto._triggerDeleteEvent = function(target) {\r\n        var eventParams = {};\r\n        eventParams.type = \"delete\";\r\n        eventParams.target = target;\r\n        this._api.trigger(eventParams.type, eventParams);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto._createConnectorByNodes = function(startNode, endNode, options) {\r\n        var that = this;\r\n        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, options, this._api);\r\n        if (startNode.parent && endNode.parent) {\r\n            endNode.parent.add(connector);\r\n        } else {\r\n            this.group.add(connector);\r\n        }\r\n\r\n        connector.on(\"mousedown\", zrUtil.bind(function() {\r\n            FlowConnectionManager.connectorForbidEdit(!this.options.linkModify);\r\n            this.isNode = false;\r\n        }, this));\r\n        connector.on(\"dblclick\", function() {\r\n            if (that.options.isAllowEdit) {\r\n                that.connectorEdit(this);\r\n            }\r\n        });\r\n\r\n        this._triggerCreateEvent(connector);\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发创建完成事件\r\n     */\r\n    fishTopoProto._triggerCreateEvent = function(target) {\r\n        var eventParams = {};\r\n        eventParams.type = \"create\";\r\n        eventParams.target = target;\r\n        this._api.trigger(eventParams.type, eventParams);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 派发移动完成事件\r\n     */\r\n    fishTopoProto._triggerDropDragEvent = function(target) {\r\n        var eventParams = {};\r\n        eventParams.type = \"dropDrag\";\r\n        eventParams.target = target;\r\n        this._api.trigger(eventParams.type, eventParams);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 鼠标点下 将操作框 移到对应的节点上\r\n     * @param  {Object} node [description]\r\n     * @param  {Object} sX   [description]\r\n     * @param  {Object} sY   [description]\r\n     * @return {Object}      [description]\r\n     */\r\n    fishTopoProto.nodeClickHandler = function(node, sX, sY) {\r\n        var that = this;\r\n        var node = node;\r\n        if (node.noSelected == true) {\r\n            return;\r\n        }\r\n        if (node.fromCmsImage) {\r\n            node = node.fromCmsImage;\r\n        }\r\n        // if(node instanceof GroupNode){\r\n        //     node = node.childOfName(\"Rect\");\r\n        // }\r\n        this.selectedNode = node;\r\n        var shapeRect = util.getRect(node);\r\n        if (!this.operationNode) {\r\n            this.initOperationNode(node);\r\n        }\r\n        // 在存在子流程的情况下 需要把node也传递一下\r\n        this.operationNode.refreshPostion(node, shapeRect);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * flow中最外层的group移动操作\r\n     */\r\n    fishTopoProto.groupDrag = function() {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function(e) {\r\n            if ((e.target&&e.target.model) || (e.target && e.target.lineType && e.target.parent) || (e.target && e.target.connector instanceof Connector) || (e.target && e.target instanceof graphic.Circle)) {\r\n                return;\r\n            } else {\r\n                groupDragFunction(e);\r\n            }\r\n        });\r\n\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function(e) {\r\n                moveDrag(e);\r\n            };\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX);\r\n                var sY = (e.event.clientY - startY);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                    if (that.eagleEye == true) {\r\n                        that.minimap.updataSelectionPosition(nowGroupPosition, that.nowZoom);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function(e) {\r\n                endDrag(e);\r\n            };\r\n\r\n            function endDrag() {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 节点的移动操作\r\n     */\r\n    fishTopoProto.drag = function(node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function(e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        function groupDragFunction(e) {\r\n            var isMove = 0;\r\n            node.startX = e.event.clientX;\r\n            node.startY = e.event.clientY;\r\n            var moveFunction = function(e) {\r\n                moveDrag(e);\r\n            };\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n\r\n            function moveDrag(e) {\r\n                e.cancelBubble = true;\r\n                var sX = (e.event.clientX - node.startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - node.startY) / (that.nowZoom);\r\n                // node.startX = e.event.clientX;\r\n                // node.startY = e.event.clientY;\r\n                if ((sX != 0) || (sY != 0)) {\r\n                    isMove = 1;\r\n                }\r\n                // node.drift(sX, sY, e);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //放入node现有数值，用于重绘group\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                }\r\n                nowGroupPosition[0] = groupPositionX + sX;\r\n                nowGroupPosition[1] = groupPositionY + sY;\r\n                node.attr(\"position\", nowGroupPosition);\r\n                if (node.alarm) {\r\n                    var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                    node.alarm.attr(\"position\", newAlarmPosition);\r\n                }\r\n                if (node.cmsImage) {\r\n                    var newAlarmPosition1 = [nowGroupPosition[0], nowGroupPosition[1] - 8];\r\n                    node.cmsImage.attr(\"position\", newAlarmPosition1);\r\n                }\r\n                if (node.fromCmsImage) {\r\n                    var newAlarmPosition2 = [nowGroupPosition[0], nowGroupPosition[1] + 8];\r\n                    node.fromCmsImage.attr(\"position\", newAlarmPosition2);\r\n                }\r\n                that.nodeClickHandler(node, e.event.clientX, e.event.clientY);\r\n                FlowConnectionManager.refreshLineByNode(node);\r\n                if (node.fromCmsImage) {\r\n                    FlowConnectionManager.refreshLineByNode(node.fromCmsImage);\r\n                }\r\n                // if(that.eagleEye == true){\r\n                //     that.openEagleEye(that.eagleEyeNode);\r\n                // }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function(e) {\r\n                endDrag(e);\r\n            };\r\n            //拖拽结束\r\n            function endDrag() {\r\n                if (node.model) {\r\n                    node.model.set(\"options.position\", node.position);\r\n                }\r\n\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //布局重新计算\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\r\n                        \"node\": node,\r\n                        \"type\":node.treeType\r\n                    });\r\n                }\r\n                if (that.forceLayoutOption && (!that.forceLayoutOption.once)) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (zrUtil.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                if (isMove == 1) {\r\n                    that._triggerDropDragEvent(node);\r\n                    if (that.eagleEye == true) {\r\n                        that.openEagleEye(that.eagleEyeNode);\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建节点\r\n     * @param  {String} type 类型 eg. 'Rect'、'Circle'、'Image'、'Group'、'Text'等\r\n     * @param  {Object} opt 节点选项\r\n     * @param {Array}  [opt.position] 节点的位置 eg. [x,y]\r\n     * @param {Object} [opt.style] 节点的样式\r\n     * @param {String} [opt.style.text] 节点下方（默认）显示的文字\r\n     * @param {String} [opt.style.fill] 节点的填充颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {String} [opt.style.stroke] 节点的描边颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {String} [opt.style.textFont] 设置文字的字体信息 eg. '14px Microsoft YaHei'\r\n     * @param {String} [opt.style.textFill] 设置文字的颜色值 eg. '#ffffff'\r\n     * @param {String} [opt.style.textPosition] 设置文字在节点中的位置 eg. 'top','right','bottom', 'left','inside'\r\n     * @param {String} [opt.mergedImage] 组合并后显示的图片（组特有的属性）\r\n     * @param {Object} [opt.layout] 节点tree布局属性（tree布局的节点才需要）\r\n     * @param {Number} [opt.layout.width] 结点的子节点之间的距离\r\n     * @param {Number} [opt.layout.height] 结点的子节点到结点的距离\r\n     * @param {Object} [opt.shape] 每种形状的值不一样 eg. 'Rect' shape:{width:100,height:100}\r\n     * @param {Array}  [opt.operationIcons] 设置选中节点时 显示的操作小图标， 默认提供了 删除(删除支持自定义回调方法)、直线、折线、曲线（三种默认连线支持样式修改，格式参数和creatLink方法相同）4种图标，也可以自定图标 eg.\r\n     * <pre>\r\n     *          operationIcons: [{ name: 'DEL' },\r\n     *              {   name: 'STRAIGHT' ,\r\n                        options:{\r\n                            symbol: { type: \"arrow\", size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n                            style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: 0}, //样式\r\n                            text: {\r\n                                text: 123,\r\n                                color: '#ffffff',\r\n                            },\r\n                            z:10 //z为层级，功能等同于css 的z-index\r\n                        }\r\n                    },\r\n     *              { name: 'JAGGED' },\r\n     *              { name: 'CURVE' },\r\n     *              {\r\n     *                  name: \"custom1\",\r\n     *                  iconPath: \"img/host.png\",\r\n     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n     *              }\r\n     *          ]\r\n     * </pre>\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的节点对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var rect = this.fishTopo.creatNode(\"Rect\", { //矩形\r\n     *          shape: {\r\n     *              width: 100,\r\n     *              height: 60,\r\n     *          },\r\n     *          style: {\r\n     *              text: \"基本矩形\",\r\n     *              fill: \"#167CFF\",\r\n     *              stroke: \"rgb(255,255,255)\",\r\n     *              textFont: '14px Microsoft YaHei'\r\n     *          },\r\n     *          position: [180, 100],\r\n     *          operationIcons: [{ name: 'DEL' },\r\n     *              { name: 'STRAIGHT' },\r\n     *              { name: 'JAGGED' },\r\n     *              { name: 'CURVE' },\r\n     *              {\r\n     *                  name: \"custom1\",\r\n     *                  iconPath: \"img/host.png\",\r\n     *                  callback: function(e) { alert(e.data.name + \" clicked\") }  //e.node是当前的节点\r\n     *              }\r\n     *          ]\r\n     *      });\r\n     */\r\n    fishTopoProto.creatNode = function(type, opt, userData) {\r\n        var that = this;\r\n        //设置模型 给json序列化用\r\n        var model = new Model({});\r\n        model.set(Constants.ELEMENT_TYPE, type);\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n        model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n        if (\"draggable\" in opt) {\r\n            opt.isdraggable = opt.draggable;\r\n            delete opt.draggable;\r\n        }\r\n\r\n        if (!opt.z) {\r\n            opt.z = 1; //节点Z为1 线段为0;\r\n        }\r\n        var node = null;\r\n        //根据参数dom不同创建不同的节点\r\n        switch (type) {\r\n            case \"Rect\":\r\n                node = new this.Shape.Rect(opt);\r\n                break;\r\n            case \"Group\":\r\n                node = new GroupNode(opt);\r\n                if (opt.mergedImage) {\r\n                    var imageShape = new this.Shape.Image({\r\n                        style: {\r\n                            image: opt.mergedImage,\r\n                            // width: width,\r\n                            // height: height,\r\n                            text: opt.style.text,\r\n                            textPosition: 'bottom'\r\n                        },\r\n                        position: [-5000, -5000]\r\n\r\n                    });\r\n                    this.drag(imageShape);\r\n                    node.relationImage = imageShape;\r\n                    that.group.add(imageShape);\r\n                    setTimeout(function() {\r\n                        imageShape.hide();\r\n                    }, 300);\r\n\r\n                    node.on(\"dblclick\", function(e) {\r\n                        node.merged(e)\r\n                    });\r\n                }\r\n                break;\r\n            case \"Image\":\r\n                node = new this.Shape.Image(opt);\r\n                break;\r\n            case \"Text\":\r\n                node = new this.Shape.Text(opt);\r\n                break;\r\n            case \"Circle\":\r\n                node = new this.Shape.Circle(opt);\r\n                break;\r\n            case \"Sector\":\r\n                node = new this.Shape.Sector(opt);\r\n                break;\r\n            case \"Ring\":\r\n                node = new this.Shape.Ring(opt);\r\n                break;\r\n            case \"Polygon\":\r\n                node = new this.Shape.Polygon(opt);\r\n                break;\r\n            case \"Polyline\":\r\n                node = new this.Shape.Polyline(opt);\r\n                break;\r\n            case \"Line\":\r\n                node = new this.Shape.Line(opt);\r\n                break;\r\n            case \"BezierCurve\":\r\n                node = new this.Shape.BezierCurve(opt);\r\n                break;\r\n            case \"Arc\":\r\n                node = new this.Shape.Arc(opt);\r\n                break;\r\n        }\r\n        this.drag(node);\r\n\r\n        node.attr(\"operationIcons\", opt.operationIcons);\r\n\r\n        //侦听节点的click dblclick事件，选中，并派发出去\r\n        node.on('click', function(e) {\r\n            var nowNode;\r\n            if (node.fromCmsImage) {\r\n                nowNode = node.fromCmsImage;\r\n            } else {\r\n                nowNode = this;\r\n            }\r\n            that.nodeClickHandler(nowNode, e.event.clientX, e.event.clientY);\r\n\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = 'click';\r\n            params.target = nowNode;\r\n            that._api.trigger(params.type, params);\r\n\r\n            e.cancelBubble = true;\r\n        });\r\n        node.on('dblclick', function(e) {\r\n            var nowNode;\r\n            if (node.fromCmsImage) {\r\n                nowNode = node.fromCmsImage;\r\n            } else {\r\n                nowNode = this;\r\n            }\r\n            if (!nowNode.style || (typeof nowNode.style.isAllowEdit == \"undefined\")) {\r\n                if (that.options.isAllowEdit) {\r\n                    that.nodeEdit(nowNode);\r\n                }\r\n            } else {\r\n                if (nowNode.style.isAllowEdit) {\r\n                    that.nodeEdit(nowNode);\r\n                }\r\n            }\r\n            var params = {};\r\n            params.event = e;\r\n            params.type = 'dblclick';\r\n            params.target = node;\r\n            that._api.trigger(params.type, params);\r\n\r\n            e.cancelBubble = true;\r\n        });\r\n\r\n        this.allNodes.push(node);\r\n        if (opt.id) {\r\n            model.set(Constants.ID, opt.id);\r\n        } else {\r\n            model.set(Constants.ID, util.getUUID());\r\n        }\r\n\r\n        node.model = model;\r\n\r\n        this._triggerCreateEvent(node);\r\n        return node;\r\n    };\r\n\r\n    /**\r\n     * 根据name获取节点\r\n     * @param  {String} name 在创建节点中  name属性设置的值\r\n     * @return {Object}      name对应的节点\r\n     */\r\n    fishTopoProto.childOfName = function(name) {\r\n        var arrResult = [];\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = FlowConnectionManager.connectors;\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            if (childrenNode[i].model.get(\"options.name\") && childrenNode[i].model.get(\"options.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            } else if (childrenNode[i].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenNode[i]);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            if (childrenLine[j].model.get(\"options.name\") && childrenLine[j].model.get(\"options.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            } else if (childrenLine[j].model.get(\"userData.name\") == name) {\r\n                arrResult.push(childrenLine[j]);\r\n            }\r\n        }\r\n        if (arrResult.length > 1) {\r\n            return arrResult;\r\n        } else {\r\n            return arrResult[0];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 查找场景中的对象   例如: x坐标大于100的节点 findElements(function(e){ return e.position[0] > 100; });\r\n     * @param  {Function} cb      回调函数\r\n     * @param  {Object}   context 回调函数执行的上下文\r\n     * @return {Array}           返回查找到的对象\r\n     */\r\n    fishTopoProto.findElements = function(cb, context) {\r\n        var childrenNode = this.allNodes;\r\n        var childrenLine = FlowConnectionManager.connectors;\r\n        var arr = [];\r\n        for (var i = 0; i < childrenNode.length; i++) {\r\n            var child = childrenNode[i];\r\n            if (cb.call(context, child, i)) {\r\n                arr.push(child);\r\n            }\r\n        }\r\n        for (var j = 0; j < childrenLine.length; j++) {\r\n            var childL = childrenLine[j];\r\n            if (cb.call(context, childL, j)) {\r\n                arr.push(childL);\r\n            }\r\n        }\r\n        return arr;\r\n    };\r\n\r\n    /**\r\n     * 设置背景色  或 背景图片\r\n     * @param {string} imageUrl 背景色  或 背景图片 eg. 'img/bg.jpg'，为‘gridLine’时网格背景\r\n     */\r\n    fishTopoProto.setBackground = function(imageUrl) {\r\n        var that = this;\r\n        if (imageUrl && imageUrl.length > 0) {\r\n            this.model.set(Constants.BACKGROUND, imageUrl);\r\n            if (imageUrl.substr(0, 1) == \"#\" || imageUrl.substr(0, 4) == \"rgba\") { //如果是颜色创建rect为背景\r\n                if (!document.createElement('canvas').getContext) {\r\n                    that._dom.style.backgroundColor = imageUrl;\r\n                } else {\r\n                    var imageShape = new this.Shape.Rect({\r\n                        shape: {\r\n                            width: that._zr.getWidth(),\r\n                            height: that._zr.getHeight()\r\n                        },\r\n                        style: {\r\n                            fill: imageUrl\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    that._zr.add(imageShape);\r\n                }\r\n\r\n            } else if(imageUrl == \"gridLine\" ){\r\n                this.gridLineGroup = new graphic.Group();\r\n                this.gridLine(0.2);\r\n                this._zr.add(this.gridLineGroup);\r\n            }else{\r\n                if (!document.createElement('canvas').getContext) {\r\n                    that._dom.style.backgroundImage = \"url(\" + imageUrl + \")\";\r\n                    that._dom.style.backgroundRepeat = \"repeat\";\r\n                } else {\r\n                    var imageShape1 = new this.Shape.Image({ //如果是图片创建image为背景\r\n                        position: [0, 0],\r\n                        scale: [1, 1],\r\n                        style: {\r\n                            x: 0,\r\n                            y: 0,\r\n                            image: imageUrl,\r\n                            width: this._zr.getWidth(),\r\n                            height: this._zr.getHeight()\r\n                        },\r\n                        cursor: 'default',\r\n                        z: -1\r\n                    });\r\n                    that._zr.add(imageShape1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n    };\r\n    //背景网格线\r\n    fishTopoProto.gridLine = function(opacity) {\r\n        var pixel = 10;\r\n        var widthLen = parseInt(this.getWidth() / pixel);\r\n        for (var x = 0; x <= widthLen; x++) {\r\n            var lineX = new graphic.Line({\r\n                shape: {\r\n                    x1: x * pixel,\r\n                    y1: 0,\r\n                    x2: x * pixel,\r\n                    y2: this.getHeight()\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineX);\r\n        }\r\n\r\n        var heightLen = parseInt(this.getHeight() / pixel, pixel);\r\n        for (var y = 0; y <= heightLen; y++) {\r\n            var lineY = new graphic.Line({\r\n                shape: {\r\n                    x1: 0,\r\n                    y1: y * pixel,\r\n                    x2: this.getWidth(),\r\n                    y2: y * pixel\r\n                },\r\n                style: {\r\n                    lineDash: [1],\r\n                    opacity: opacity\r\n                },\r\n                z: 0,\r\n                draggable: false,\r\n                cursor: 'default'\r\n            });\r\n            this.gridLineGroup.add(lineY);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建线段\r\n     * @method creatLink\r\n     * @param  {Object} startNode 开始节点\r\n     * @param  {Object} endNode   结束节点\r\n     * @param  {Object} options 线段选项\r\n     * @param {Object} [options.style] 节点的样式\r\n     * @param {Number} [options.style.lineWidth=1] 线段的宽度\r\n     * @param {String} [options.style.lineType='straight'] 线段的类型 eg. 'straight', 'jagged','curve'\r\n     * @param {String} [options.style.stroke=\"#000000\"] 线段的颜色值 eg. '#157cff'  'rgb(122,122,122)'\r\n     * @param {Array}  [options.style.lineDash] 虚线的间隔 eg. [3,3]\r\n     * @param {Object} [options.symbol] 线段的箭头\r\n     * @param {String} [options.symbol.type='arrow'] 线段的箭头的类型 可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     * @param {Number} [options.symbol.size=10] 线段的箭头的尺寸\r\n     * @param {String} [options.symbol.color='#000000'] 线段的箭头的颜色\r\n     * @param {Object} [options.text] 线段上的文字\r\n     * @param {String} [options.text.text] 线段上的文字内容\r\n     * @param {String} [options.text.color] 线段上的文字颜色\r\n     * @param {String} [options.text.textPos] 文字位置可选值 'start','center','end',默认值为center\r\n     * @param {String} [options.text.xOffset] 文字位置x偏移量\r\n     * @param {String} [options.pos] 指定线段起始与终止 在节点的什么位置 默认值为'left,right'  可取值四个方向top,bottom,left,right 方向可加偏移量如如 \"left+10,top\"\r\n     * @param {String} [options.position] 指定线段位置\r\n     * @param {Object} [options.effect] 线上动态效果\r\n     * @param {String} [options.effect.show] 是否显示箭头动效\r\n     * @param {Number} [options.effect.period] 动效移动速度\r\n     * @param {String} [options.position.escapeDistance] 指定线段第一条折线的长度，最后一条折线的长度\r\n     * @param {String} [options.position.points] 不使用自动计算 指定连线的折点位置数组\r\n     * @param {Boolean} [options.autoChangePosition] 连线的连接点随node移动自动切换位置，默认为flase\r\n     * @param {Object} userData 用户传递的业务数据\r\n     * @return {Object} 创建的线段对象\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *      var link = me.fishTopo.creatLink(startNode, endNode, {\r\n     *              symbol: { type: 'arrow', size: 10, color: \"rgb(0,200,255)\" }, //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n     *              style: { lineWidth: 3, stroke: \"rgb(0,200,255)\", lineDash: [3,3], lineType: \"jagged\"  }, //样式\r\n     *              text: {\r\n     *                  text: text,\r\n     *                  color: '#ffffff',\r\n     *                  textPos:textPos,//文字位置可选值 'start','center','end',默认值为center\r\n     *                  xOffset:10, //文字位置x偏移量\r\n     *              },\r\n     *              pos:'right,left',\r\n     *              effect: {\r\n                        show: true,//是否显示箭头动效\r\n                        period: 6,//箭头速度\r\n                    },\r\n     *              position:{\r\n     *                    escapeDistance:[50,30],  //第一条折线的长度，最后一条折线的长度\r\n     *                    points:[\"x1,y1\",\"x2,y2\"]  不使用自动计算 指定连线的位置数组\r\n     *              }\r\n     *          });\r\n     */\r\n    fishTopoProto.creatLink = function(startNode, endNode, options, userData) {\r\n        var that = this;\r\n        options.isEdit = !!this.options.linkModify;\r\n        var connector = FlowConnectionManager.connectorCreate(startNode, endNode, options, this._api);\r\n        connector.model.set(Constants.USERDATA, zrUtil.clone(userData));\r\n        connector.on(\"dblclick\", function() {\r\n            if (typeof this.options.text.isAllowEdit == \"undefined\") {\r\n                if (that.options.isAllowEdit) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            } else {\r\n                if (this.options.text.isAllowEdit) {\r\n                    that.connectorEdit(this);\r\n                }\r\n            }\r\n\r\n            // if(this.style.isAllowEdit){\r\n            //     that.connectorEdit(this);\r\n            // }else if(that.options.isAllowEdit){\r\n            //     that.connectorEdit(this);\r\n            // }\r\n            // if(this.style.isAllowEdit ? this.style.isAllowEdit : that.options.isAllowEdit){\r\n            //     that.connectorEdit(this);\r\n            // }\r\n        });\r\n        return connector;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 线上文字编辑\r\n     */\r\n    fishTopoProto.connectorEdit = function(thisConnector) {\r\n        var that = this;\r\n        var lineText = thisConnector.childOfName('lineText');\r\n        if (!lineText) {\r\n            return;\r\n        }\r\n        var textarea = that.creatTextArea();\r\n        textarea.style.width = 1.1 * util.getRect(lineText).width * that.nowZoom + \"px\";\r\n        textarea.style.height = (util.getRect(lineText).height || 12) * that.nowZoom + \"px\";\r\n        textarea.style.border = \"1px solid #000000\";\r\n        textarea.innerHTML = lineText.style.text;\r\n        thisConnector.setStyle({text:{text:\"\"}})\r\n        that._dom.appendChild(textarea);\r\n        that._dom.style.position = \"relative\";\r\n        var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n        textarea.style.lineHeight = (textRect.lineHeight || 14) + \"px\";\r\n        textarea.style.top = (lineText.position[1] - util.getRect(lineText).height) * that.nowZoom + that.group.position[1] + \"px\";\r\n        textarea.style.left = (lineText.position[0] - 0.05 * util.getRect(lineText).width) * that.nowZoom + that.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        $(textarea).on(\"keyup\", zrUtil.bind(function(e) {\r\n            var textRect = textContain.getBoundingRect(lineText.style.text, lineText.style.textFont);\r\n            that.textareaResize(textRect, textarea, e);\r\n        }, this));\r\n        $(textarea).on(\"focusout\", zrUtil.bind(function() {\r\n            thisConnector.setStyle({\r\n                text: {\r\n                    text: textarea.value || \"\"\r\n                }\r\n            })\r\n            textarea.remove();\r\n        }, this))\r\n    };\r\n    /**\r\n     * @private\r\n     * 节点上文字编辑\r\n     */\r\n    fishTopoProto.nodeEdit = function(thisNode) {\r\n        var that = this;\r\n        var textarea = that.creatTextArea();\r\n        var nodeText = thisNode.style.text;\r\n        var textRect = textContain.getBoundingRect(nodeText, thisNode.style.textFont);\r\n        textarea.style.width = 1.2 * textRect.width * that.nowZoom + \"px\";\r\n        textarea.style.height = (1.2 *textRect.height||12) * that.nowZoom + \"px\";\r\n        var nodeRect = util.getRect(thisNode);\r\n        textarea.style.maxWidth = 1.2*nodeRect.width * that.nowZoom + \"px\";\r\n        textarea.style.lineHeight = (1.2 *textRect.lineHeight || 12) + \"px\";\r\n        textarea.style.border = \"1px solid #000000\";\r\n        textarea.innerHTML = thisNode.style.text;\r\n        that.setStyle(thisNode,{text:\"\"})\r\n        that._dom.appendChild(textarea);\r\n        that._dom.style.position = \"relative\";\r\n        var offestI = 1;\r\n        if (thisNode.style.textAlign == \"left\") {\r\n            offestI = 0;\r\n        }\r\n        if (thisNode.style.textAlign == \"right\") {\r\n            offestI = 2;\r\n        }\r\n        var offestP = 0;\r\n        if(thisNode.style.textPosition && thisNode.style.textPosition == \"bottom\"){\r\n            offestP = 1;\r\n            textarea.style.maxWidth = 3*1.1*nodeRect.width * that.nowZoom + \"px\";\r\n        }\r\n        if(thisNode.style.textPosition && thisNode.style.textPosition == \"top\"){\r\n            offestP = -1;\r\n            textarea.style.maxWidth = 3*1.1*nodeRect.width * that.nowZoom + \"px\";\r\n        }\r\n        textarea.style.top = (nodeRect.y - textRect.height / 2 + offestP*(nodeRect.height-textRect.height / 2)) * that.nowZoom + that.group.position[1] + \"px\";\r\n        textarea.style.left = (nodeRect.x - offestI * textRect.width / 2 - 0.05 * textRect.width) * that.nowZoom + that.group.position[0] + \"px\";\r\n        textarea.focus();\r\n        textarea.select();\r\n        $(textarea).on(\"keyup\", zrUtil.bind(function(e) {\r\n            var textRect = textContain.getBoundingRect(textarea.value, thisNode.style.textFont);\r\n            that.textareaResize(textRect, textarea, textarea.style.maxWidth);\r\n        }, this))\r\n        $(textarea).on(\"focusout\", zrUtil.bind(function() {\r\n            var text = that.handleWrap(textarea.value, textarea.style.maxWidth);\r\n            that.setStyle(thisNode,{text:text})\r\n            textarea.remove();\r\n        }, this))\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 创建文本域\r\n     */\r\n    fishTopoProto.creatTextArea = function() {\r\n        var textarea = document.createElement(\"textarea\");\r\n        textarea.style.position = \"absolute\";\r\n        textarea.style.overflow = \"hidden\";\r\n        textarea.style.border = \"0\";\r\n        textarea.style.padding = \"0\";\r\n        //textarea.style.resize = \"none\";\r\n        return textarea;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 处理textarea自动换行\r\n     */\r\n    fishTopoProto.handleWrap = function(value, width) {\r\n        var spanNode = document.createElement(\"span\");\r\n        spanNode.style.position = \"absolute\";\r\n        spanNode.style.overflow = \"hidden\";\r\n        spanNode.style.border = \"0\";\r\n        spanNode.style.padding = \"0\";\r\n        spanNode.style.left = \"0\";\r\n        spanNode.style.top = \"0\";\r\n        this._dom.appendChild(spanNode);\r\n        var content = value.split(\"\\n\");\r\n        var result = \"\";\r\n        $.each(content, function(i, val) {\r\n            var valLength = val.length;\r\n            if (valLength == 0) {\r\n                //result += \"\\n\";\r\n            } else {\r\n                var pre = \"\",\r\n                    innerVal, tempWidth, conWidth;\r\n                for (var innerI = 0; innerI < valLength; innerI++) {\r\n                    innerVal = val.charAt(innerI);\r\n                    $(spanNode).text($(spanNode).text() + innerVal);\r\n                    tempWidth = $(spanNode).width(); //获取添加字符后隐藏域的宽度\r\n                    conWidth = Number(width.substring(0, width.length - 2));\r\n                    if (tempWidth > conWidth) {\r\n                        result += pre; //如果追加字符后隐藏域宽度大于TextArea宽度，则表明该字符为下一行字符，\r\n                        result += \"\\n\";\r\n                        $(spanNode).text(innerVal);\r\n                        pre = innerVal;\r\n                    } else if (innerI == valLength - 1) {\r\n                        result += pre + innerVal; //最后一个字符\r\n                        if(i < content.length-1){\r\n                            result += \"\\n\";\r\n                        }\r\n                        $(spanNode).text(\"\");\r\n                        pre = \"\";\r\n                    } else {\r\n                        pre += innerVal; //依次追加到pre变量中\r\n                    }\r\n\r\n                }\r\n            }\r\n        });\r\n        this._dom.removeChild(spanNode);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 文本域自适应高宽\r\n     */\r\n    fishTopoProto.textareaResize = function(textRect, textarea ,width) {\r\n        var that = this;\r\n        var minWidth;\r\n        textarea.style.width = 0;\r\n        textarea.style.width = (1.1 * textRect.width) * that.nowZoom + \"px\";\r\n        if(width<60){\r\n            minWidth = width;\r\n        }else{\r\n            minWidth = 60\r\n        }\r\n        if (textRect.width <= minWidth) {\r\n            textarea.style.width = minWidth+\"px\";\r\n        }\r\n        textarea.style.height = \"0px\";\r\n        textarea.style.height = textarea.scrollHeight + 'px';\r\n        if (textarea.scrollHeight <= 0) {\r\n            textarea.style.height = \"12px\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method setStyle\r\n     * 节点更改style里的属性\r\n     * @param {String} name 节点style里的某个属性名称\r\n     * @param {String} string 节点style里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //节点设置文字\r\n     *         fishtopo.setStyle(node,{text:\"例子\"});\r\n     */\r\n    fishTopoProto.setStyle = function(node,options){\r\n        node.setStyle(options);\r\n        zrUtil.merge(node.model.get(\"options.style\"), options, true);\r\n    }\r\n\r\n    /**\r\n     * @method setShape\r\n     * 节点更改shape里的属性\r\n     * @param {String} name 节点shape里的某个属性名称\r\n     * @param {String} string 节点shape里的某个属性名称对应的值\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          //矩形节点设置宽\r\n     *         fishtopo.setShape(node,{width:100});\r\n     */\r\n    fishTopoProto.setShape = function(node,options){\r\n        node.setShape(options);\r\n        zrUtil.merge(node.model.get(\"options.shape\"), options, true);\r\n    }\r\n\r\n    /**\r\n     * 创建节点上面的警告\r\n     * @method creatAlarm\r\n     * @param  {Object} node 节点\r\n     * @param  {Object} opt  选项值\r\n     * @param  {Object} [opt.text] 警告的文字\r\n     * @param  {Object} [opt.textFont] 警告的文字的字体\r\n     * @param  {Object} [opt.textFill] 警告的文字的颜色\r\n     * @param  {Object} [opt.textBackground] 警告的背景的颜色\r\n     * @return {Object} 返回节点上的警告\r\n     *\r\n     * **使用范例**：\r\n     *\r\n     *      @example\r\n     *          this.fishTopo.creatAlarm(s1,{\r\n     *          text:\"2 W\",\r\n     *          textFont:\"4px Microsoft YaHei\",\r\n     *          textFill:\"#FFFFFF\",\r\n     *          textBackground:\"rgba(255,0,0,0.6)\"\r\n     *      });//创建小图片和节点绑定\r\n     */\r\n    fishTopoProto.creatAlarm = function(node, opt) {\r\n        var group = this.creatNode(\"Group\", {\r\n            style: {\r\n                fill: 'rgba(0,0,0,0)',\r\n                stroke: 'rgba(0,0,0,0)'\r\n            }\r\n        });\r\n        group.isdraggable = false;\r\n        var text = this.creatNode(\"Text\", { //文字\r\n            style: {\r\n                text: opt.text,\r\n                textFont: opt.textFont,\r\n                fill: opt.textFill,\r\n                textBaseline: \"top\" //垂直对齐,\r\n            },\r\n            noSelected: true,\r\n            position: [2, 0],\r\n            z: 2\r\n        });\r\n        text.isdraggable = false;\r\n        group.add(text);\r\n        if (node.parent && node.parent instanceof GroupNode) {\r\n            node.parent.add(group);\r\n        } else {\r\n            this.group.add(group);\r\n        }\r\n        var groupWidth = group.getBoundingRect().width + 2;\r\n        var groupHeight = group.getBoundingRect().height + 6;\r\n        var points = [\r\n            [0, 0],\r\n            [groupWidth, 0],\r\n            [groupWidth, groupHeight],\r\n            [groupWidth - 3, groupHeight],\r\n            [groupWidth - 6, groupHeight + 3],\r\n            [groupWidth - 9, groupHeight],\r\n            [0, groupHeight],\r\n            [0, 0]\r\n        ];\r\n        var Polyline = this.creatNode(\"Polyline\", {\r\n            shape: {\r\n                points: points\r\n            },\r\n            style: {\r\n                fill: opt.textBackground,\r\n                stroke: opt.textBackground\r\n            },\r\n            noSelected: true,\r\n            z: 1\r\n        });\r\n        Polyline.isdraggable = false;\r\n        group.add(Polyline);\r\n        var groupPosition = [node.position[0] + node.getBoundingRect().width - (group.getBoundingRect().width - 6), node.position[1] - group.getBoundingRect().height - 3];\r\n        group.attr(\"position\", groupPosition);\r\n        node.alarm = group;\r\n        //设置模型 给json序列化用\r\n        var model = new Model({});\r\n        model.set(Constants.ELEMENT_TYPE, Constants.ALARM);\r\n        model.set(Constants.OPTIONS, zrUtil.clone(opt));\r\n        model.set(Constants.RELATIONID, node.model.get(Constants.ID));\r\n        group.model = model;\r\n        return group;\r\n    };\r\n\r\n    /**\r\n     * 创建Cms节点\r\n     * @method creatCmsRect\r\n     * @param  {Object} node 节点\r\n     */\r\n    fishTopoProto.creatCmsRect = function(node) {\r\n        var that = this;\r\n        //node.noSelected = true;\r\n        var width, height;\r\n        if (node.style) {\r\n            width = node.style.width || 40;\r\n            height = node.style.height || 48;\r\n        } else {\r\n            width = node.options.style.width || 40;\r\n            height = node.options.style.height || 48;\r\n        }\r\n        var rect = this.creatNode(\"Rect\", { //矩形\r\n            shape: {\r\n                width: 100 + width,\r\n                height: height - 8,\r\n                r: 5\r\n            },\r\n            style: {\r\n                isAllowEdit: true,\r\n                text: node.model.get(\"options.style.text\"),\r\n                fill: \"#FFFFFF\",\r\n                textFont: node.model.get(\"options.style.textFont\") || '14px Microsoft YaHei',\r\n                textAlign: \"left\"\r\n            },\r\n            z: 1,\r\n            position: [node.position[0], node.position[1] + 8],\r\n            draggable: node.draggable, //禁止拖动\r\n            operationIcons: node.operationIcons\r\n        });\r\n        var nodeText = node.childOfName('Rect');\r\n        nodeText.attr(\"style\", {\r\n            \"text\": \"\"\r\n        });\r\n        node.attr(\"z\", 2);\r\n        node.attr(\"draggable\", false);\r\n        node.operationIcons = null;\r\n        this.addNode(rect);\r\n        rect.cmsImage = node;\r\n        node.fromCmsImage = rect;\r\n        node._children[1].fromCmsImage = rect;\r\n    };\r\n\r\n    /**\r\n     * 自动布局\r\n     * @param  {String} type 节点\r\n     * @param  {Object} option 选项\r\n     * @param  {Object} [option.node] tree布局为起点的节点（只有tree布局有）\r\n     * @param  {String} [option.type] tree布局的类型，horizontal为横向，vertical为竖向，默认为vertical\r\n     * @param  {Number} [option.repulsion] 力导向布局的类型，节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远，默认为100\r\n     * @param  {Number} [option.gravity] 力导向布局的类型，节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。默认为0.1\r\n     * @param  {Number} [option.gravity] 力导向布局的类型，边的两个节点之间的距离，这个距离也会受 repulsion。 默认为30\r\n     * @param  {Number} [option.width] 力导向布局的类型, 布局画布的宽度 默认为整个画布的宽度\r\n     * @param  {Number} [option.height] 力导向布局的类型, 布局画布的高度 默认为整个画布的高度\r\n     * @param  {Boolean} [option.once] 只执行一次布局，移动节点不自动布局，默认为false（只有力导向布局有）\r\n     */\r\n    fishTopoProto.layoutNode = function(type, option) {\r\n        if (type == \"tree\") {\r\n            if (option.node.parent && option.node.parent instanceof GroupNode) {\r\n                option.node.parent.eachChild(function(child) {\r\n                    child.isdraggable = false;\r\n                });\r\n            }\r\n            this.treeLayout(option);\r\n        } else if (type == \"force\") {\r\n            var defaultOptions = {\r\n                allNodes: this.allNodes,\r\n                allCons: FlowConnectionManager.connectors,\r\n                repulsion: 100,\r\n                gravity: 0.1,\r\n                edgeLength: 30,\r\n                once: false,\r\n                width: this.getWidth(),\r\n                height: this.getHeight(),\r\n                forceLayout: null,\r\n                preservedPoints: {}\r\n            };\r\n\r\n            this.forceLayoutOption = zrUtil.defaults(defaultOptions, option, true);\r\n            this.forceLayoutOption.rect = new graphic.BoundingRect(0, 0, this.forceLayoutOption.width, this.forceLayoutOption.height);\r\n\r\n            this.forceInstance(this.forceLayoutOption);\r\n\r\n            this.startForceLayoutIteration(this.forceLayoutOption.forceLayout, true);\r\n\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 开始进行力导向迭代\r\n     * @param  {Object} forceLayout     [力导向对象]\r\n     * @param  {Boolean} layoutAnimation [是否动画]\r\n     * @return {void}\r\n     */\r\n    fishTopoProto.startForceLayoutIteration = function(forceLayout, layoutAnimation) {\r\n        var self = this;\r\n        (function step() {\r\n            forceLayout.step(function (stopped) {\r\n                self._layouting = !stopped;\r\n                if (self._layouting) {\r\n                    if (layoutAnimation) {\r\n                        self._layoutTimeout = setTimeout(step, 16)\r\n                    } else {\r\n                        step();\r\n                    }\r\n                }\r\n            })\r\n        })();\r\n    };\r\n    /**\r\n     * @private\r\n     * 返回当前画布的数据\r\n     */\r\n    fishTopoProto.toDataURL = function(opts) {\r\n        return FlowUtil.toDataURL(this._zr, opts);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * 初始化缩放\r\n     */\r\n    fishTopoProto.initScale = function() {\r\n        var that = this;\r\n        var groupMaxWidth = that.group.getBoundingRect().width;\r\n        var groupMaxHeight = that.group.getBoundingRect().height;\r\n        var rangeWidth = that.getWidth();\r\n        var rangeHeight = that.getHeight();\r\n        var initRatio = 1,\r\n            pos = [];\r\n        if (groupMaxWidth / groupMaxHeight > rangeWidth / rangeHeight) {\r\n            if (groupMaxWidth > rangeWidth) {\r\n                initRatio = rangeWidth / groupMaxWidth;\r\n            }\r\n        } else {\r\n            if (groupMaxHeight > rangeHeight) {\r\n                initRatio = rangeHeight / groupMaxHeight;\r\n            }\r\n        }\r\n        pos[0] = Math.abs(that.group.getBoundingRect().x) * initRatio;\r\n        pos[1] = Math.abs(that.group.getBoundingRect().y) * initRatio;\r\n        that.group.attr(\"position\", [pos[0], pos[1]]);\r\n        that.group.attr(\"scale\", [initRatio, initRatio]);\r\n        that.initScaleRatio = initRatio;\r\n        var distance = [pos[0], pos[1], that.initScaleRatio, groupMaxWidth, groupMaxHeight];\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 放大或者缩小\r\n     * @param  {String|Number} type 当为字符串时 \"enlarge\"放大  \"narrowing\"缩小  当为数值时 缩放的比例  建议0.3-1.7\r\n     */\r\n    fishTopoProto.zrScale = function(type) {\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta1 = -0.07;\r\n                this.zoom(zoomDelta1, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (!isNaN(type)) {\r\n                var target = this.group;\r\n                if (target) {\r\n                    var zoomScale = type;\r\n                    this._zoom = type;\r\n                    this.nowZoom = type;\r\n                    this.setScale(this._zr.getWidth() / 2, this._zr.getHeight() / 2, zoomScale);\r\n                }\r\n            }\r\n        } else {\r\n            this._zr.on('mousewheel', zrUtil.bind(function(e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 0.07 : -0.07;\r\n                this.zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }, this));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.zoom = function(zoomDelta, zoomX, zoomY) {\r\n        if (this.canScale == false) {\r\n            return;\r\n        }\r\n        var target = this.group;\r\n        if (target) {\r\n\r\n            var newZoom = this._zoom = this._zoom || 1;\r\n            newZoom += zoomDelta;\r\n\r\n            newZoom = Number(newZoom.toFixed(2));\r\n            var zoomScale = newZoom / this._zoom;\r\n            if (newZoom > 1.7 || newZoom < 0.3) {\r\n                return;\r\n            }\r\n            this._zoom = newZoom;\r\n\r\n            this.nowZoom = newZoom;\r\n            this.setScale(zoomX, zoomY, zoomScale);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    fishTopoProto.setScale = function(zoomX, zoomY, zoomScale) {\r\n        var target = this.group;\r\n        var pos = target.position;\r\n        var scale = target.scale;\r\n        // Keep the mouse center when scaling\r\n        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n        scale[0] *= zoomScale;\r\n        scale[1] *= zoomScale;\r\n        target.attr(\"position\", [pos[0], pos[1]]);\r\n        target.attr(\"scale\", [scale[0], scale[1]]);\r\n        if (this.eagleEye == true) {\r\n            this.minimap.updataSelection(pos[0], pos[1], zoomScale, this.nowZoom);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 鹰眼图\r\n     * @param  {HTMLElement} eagleEyeNode 显示鹰眼图的div元素\r\n     */\r\n    fishTopoProto.openEagleEye = function(eagleEyeNode) {\r\n        var that = this;\r\n        this.eagleEye = true;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        var groupPosition = zrUtil.clone(this.group.position);\r\n        var groupScale = zrUtil.clone(this.group.scale);\r\n        this.group.attr(\"position\", [0, 0]);\r\n        this.group.attr(\"scale\", [1, 1]);\r\n        var distance = this.initScale();\r\n        var imgSrc = this.toDataURL();\r\n        this.group.attr(\"position\", groupPosition);\r\n        this.group.attr(\"scale\", groupScale);\r\n        if (this.minimap) {\r\n            this.minimap.updataMap(imgSrc, this.group.getBoundingRect());\r\n        } else {\r\n            this.minimap = new Minimap(this, this.group.position, this.group.getBoundingRect(), eagleEyeNode, distance, imgSrc);\r\n            setTimeout(zrUtil.bind(function() {\r\n                this.openEagleEye(that.eagleEyeNode)\r\n            }, this), 10);\r\n        }\r\n        that.minimap.selection.addEventListener(\"mousedown\", function(e) {\r\n            var startX = e.clientX;\r\n            var startY = e.clientY;\r\n            var minimapLeft = Number(that.minimap.selection.style.left.substring(0, that.minimap.selection.style.left.length - 2));\r\n            var minimapTop = Number(that.minimap.selection.style.top.substring(0, that.minimap.selection.style.top.length - 2));\r\n            var moveFunction = function(e) {\r\n                eagleEyeMove(e);\r\n            };\r\n\r\n            function eagleEyeMove(e) {\r\n                var offsetX = e.clientX - startX;\r\n                var offsetY = e.clientY - startY;\r\n                that.minimap.selection.style.left = minimapLeft + offsetX + \"px\";\r\n                that.minimap.selection.style.top = minimapTop + offsetY + \"px\";\r\n                that.minimap.updataGroupPosition(that.group, that.nowZoom);\r\n            }\r\n\r\n            that.minimap.selection.addEventListener(\"mousemove\", moveFunction);\r\n            var upFunction = function(e) {\r\n                eagleEyeUp(e);\r\n            };\r\n\r\n            function eagleEyeUp() {\r\n                that.minimap.selection.removeEventListener(\"mousemove\", moveFunction);\r\n                that.minimap.selection.removeEventListener(\"mouseup\", moveFunction);\r\n            }\r\n\r\n            that.minimap.selection.addEventListener(\"mouseup\", upFunction);\r\n        })\r\n\r\n\r\n    };\r\n    zrUtil.mixin(FishTopoFlow, Eventful);\r\n\r\n    // ---------对外暴露fishTopoFlow------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoFlow_instance_';\r\n\r\n    /**\r\n     * fishTopoFlow全局对象，如果是amd方式加载，则直接返回\r\n     * @class fishTopoFlow\r\n     * @singleton\r\n     */\r\n    var fishTopoFlow = {\r\n        /**\r\n         * 版本号\r\n         * @type {String}\r\n         */\r\n        version: '1.5.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 初始化dom元素为 flow对象\r\n     * @member fishTopoFlow\r\n     * @param {HTMLElement} dom  一个div元素\r\n     * @param {Object} opts  传递的选项参数\r\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg' or 'vml'\r\n     * @param {number} [opts.devicePixelRatio=1] retina 屏幕优化\r\n     * @param {number} [opts.linkModify=false] 是否允许调整线段\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.init = function(dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        zrUtil.defaults(opts, {\r\n            type: \"flow\",\r\n            devicePixelRatio: 1,\r\n            linkModify: false,\r\n            isAllowEdit: false\r\n        });\r\n\r\n        var fishTopoFlow = new FishTopoFlow(dom, opts);\r\n        fishTopoFlow.init();\r\n        fishTopoFlow.Flow = Flow;\r\n        fishTopoFlow.id = 'ft_' + idBase++;\r\n        instances[fishTopoFlow.id] = fishTopoFlow;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoFlow.id);\r\n\r\n        return fishTopoFlow;\r\n    };\r\n\r\n\r\n    /**\r\n     * 获取 dom 容器上的实例。\r\n     * @member fishTopoFlow\r\n     * @param  {HTMLElement} dom 一个div元素\r\n     * @return {fish.topo.FishTopoFlow}\r\n     */\r\n    fishTopoFlow.getInstanceByDom = function(dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * 销毁实例，实例销毁后无法再被使用。\r\n     *\r\n     * @member fishTopoFlow\r\n     * @param  {Object|string} chart fishTopoBpmn实例 或 fishTopoBpmn的id\r\n     */\r\n    fishTopoFlow.dispose = function(chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoFlow.getInstanceByDom(chart);\r\n        } else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoFlow) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n        clearTimeout(this._layoutTimeout);\r\n    };\r\n\r\n    //暴露出去的类\r\n    fishTopoFlow.util = {};\r\n    fishTopoFlow.util['initImagePool'] = ImagePool.initImagePool;\r\n    zrUtil.each([\r\n            'map', 'each', 'filter', 'indexOf', 'inherits',\r\n            'reduce', 'filter', 'bind', 'curry', 'isArray',\r\n            'isString', 'isObject', 'isFunction', 'extend'\r\n        ],\r\n        function(name) {\r\n            fishTopoFlow.util[name] = zrUtil[name];\r\n        }\r\n    );\r\n\r\n    module.exports = fishTopoFlow;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/FishTopoFlow.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/graphic.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // In node-canvas Image can be Canvas.Image\n        '[object Image]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * @param {*} source\n     * @return {*} 拷贝后的新对象\n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n            else if (\n                !isBuildInObject(source)\n                // 是否为 dom 对象\n                && !isDom(source)\n            ) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        return source;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1\n               && typeof(value.nodeName) == 'string';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/util.js\n ** module id = 4\n ** module chunks = 0\n **/","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/path.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Path.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Displayable.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Style.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Element.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/guid.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Eventful.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Transformable.js\n ** module id = 12\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/matrix.js\n ** module id = 13\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/vector.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Animatable.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animator.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Clip.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/easing.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/color.js\n ** module id = 19\n ** module chunks = 0\n **/","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/log.js\n ** module id = 20\n ** module chunks = 0\n **/","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/config.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/mixin/RectText.js\n ** module id = 22\n ** module chunks = 0\n **/","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/text.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n\n    module.exports = BoundingRect;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/BoundingRect.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/PathProxy.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/curve.js\n ** module id = 26\n ** module chunks = 0\n **/","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/bbox.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/path.js\n ** module id = 28\n ** module chunks = 0\n **/","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/line.js\n ** module id = 29\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/cubic.js\n ** module id = 30\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/quadratic.js\n ** module id = 31\n ** module chunks = 0\n **/","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/arc.js\n ** module id = 32\n ** module chunks = 0\n **/","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/util.js\n ** module id = 33\n ** module chunks = 0\n **/","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/windingLine.js\n ** module id = 34\n ** module chunks = 0\n **/","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Pattern.js\n ** module id = 35\n ** module chunks = 0\n **/","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/transformPath.js\n ** module id = 36\n ** module chunks = 0\n **/","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Gradient.js\n ** module id = 37\n ** module chunks = 0\n **/","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Draggable.js\n ** module id = 38\n ** module chunks = 0\n **/","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/container/Group.js\n ** module id = 39\n ** module chunks = 0\n **/","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Image.js\n ** module id = 40\n ** module chunks = 0\n **/","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/LRU.js\n ** module id = 41\n ** module chunks = 0\n **/","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Text.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Circle.js\n ** module id = 43\n ** module chunks = 0\n **/","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Sector.js\n ** module id = 44\n ** module chunks = 0\n **/","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Ring.js\n ** module id = 45\n ** module chunks = 0\n **/","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polygon.js\n ** module id = 46\n ** module chunks = 0\n **/","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/poly.js\n ** module id = 47\n ** module chunks = 0\n **/","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothSpline.js\n ** module id = 48\n ** module chunks = 0\n **/","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothBezier.js\n ** module id = 49\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polyline.js\n ** module id = 50\n ** module chunks = 0\n **/","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Rect.js\n ** module id = 51\n ** module chunks = 0\n **/","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/roundRect.js\n ** module id = 52\n ** module chunks = 0\n **/","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Line.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/BezierCurve.js\n ** module id = 54\n ** module chunks = 0\n **/","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Arc.js\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/LinearGradient.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/RadialGradient.js\n ** module id = 57\n ** module chunks = 0\n **/","\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    function Minimap(bigCanvas,groupPosition, group,eagleEyeNode,distance,imgSrc) {\r\n\r\n        this.bigCanvas = bigCanvas;\r\n        this.eagleEyeNode = eagleEyeNode;\r\n        this.distance = distance;\r\n        this.imgSrc = imgSrc;\r\n        this.ratio;\r\n        this.groupRatio;\r\n        this.group = group;\r\n        this.img = document.createElement(\"img\");\r\n        this.selection = document.createElement('div');\r\n        this.groupPosition = zrUtil.clone(groupPosition);\r\n        this.selectPosition = [0,0];\r\n        this.render();\r\n    }\r\n\r\n    Minimap.prototype.render = function() {\r\n        var that = this;\r\n        that.ratio = 0.12;\r\n        var eagleEyeNodeWidth = that.group.width  * that.ratio;\r\n        var eagleEyeNodeHeight = that.group.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.position=\"relative\";\r\n        that.eagleEyeNode.style.background = \"url(\"+that.imgSrc+\") no-repeat\";\r\n        that.eagleEyeNode.style.backgroundSize = eagleEyeNodeWidth/(that.group.width*that.distance[2]/that.bigCanvas.getWidth())+\"px\";\r\n        that.backgroundSize = zrUtil.clone(that.eagleEyeNode.style.backgroundSize);\r\n        that.eagleEyeNode.innerHTML = \"\";\r\n        that.selection.style.border = \"1px solid #ff0000\";\r\n        that.selection.style.cursor = \"pointer\";\r\n        that.selection.style.width = that.bigCanvas.getWidth()/that.group.width*eagleEyeNodeWidth+\"px\";\r\n        that.selection.style.height = that.bigCanvas.getHeight()/that.group.height*eagleEyeNodeHeight+\"px\";\r\n        that.selectWidth = that.selection.style.width;\r\n        that.selectHeight = that.selection.style.height;\r\n        that.selection.style.position=\"absolute\";\r\n        that.selection.style.top = 0+\"px\";\r\n        that.selection.style.left = 0+\"px\";\r\n        that.eagleEyeNode.appendChild(this.selection);\r\n    };\r\n    Minimap.prototype.updataSelection = function(offectLeft,offectTop,zoomScale,nowZoom){\r\n        var that = this;\r\n        that.zoomScale = zoomScale;\r\n        this.selection.style.width = this.selection.style.width.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        this.selection.style.height = this.selection.style.height.replace(\"px\",\"\")/zoomScale+\"px\";\r\n        that.selectPosition[0] = zrUtil.clone(offectLeft)*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(offectTop)*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataMap = function(imgSrc,newGroup){\r\n        var that = this;\r\n        that.eagleEyeNode.style.backgroundImage = \"url(\"+imgSrc+\")\";\r\n        var eagleEyeNodeWidth = newGroup.width  * that.ratio;\r\n        var eagleEyeNodeHeight = newGroup.height  * that.ratio;\r\n        that.eagleEyeNode.style.width = eagleEyeNodeWidth+\"px\";\r\n        that.eagleEyeNode.style.height = eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginTop = -eagleEyeNodeHeight+\"px\";\r\n        that.eagleEyeNode.style.marginLeft = that.bigCanvas.getWidth()-eagleEyeNodeWidth+\"px\";\r\n    };\r\n    Minimap.prototype.updataSelectionPosition = function(nowGroupPosition,nowZoom){\r\n        var that = this;\r\n        that.selectPosition[0] = zrUtil.clone(nowGroupPosition[0])*that.ratio/nowZoom;\r\n        that.selectPosition[1] = zrUtil.clone(nowGroupPosition[1])*that.ratio/nowZoom;\r\n        this.selection.style.left = -that.selectPosition[0]+\"px\";\r\n        this.selection.style.top = -that.selectPosition[1]+\"px\";\r\n    };\r\n    Minimap.prototype.updataGroupPosition = function(group,nowZoom){\r\n        var that = this;\r\n        var positionX = -Number(that.selection.style.left.substring(0,that.selection.style.left.length-2))/that.ratio*nowZoom;\r\n        var positionY = -Number(that.selection.style.top.substring(0,that.selection.style.top.length-2))/that.ratio*nowZoom;\r\n        group.attr(\"position\",[positionX,positionY]);\r\n    };\r\n\r\n    module.exports = Minimap;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/minimap.js\n ** module id = 58\n ** module chunks = 0\n **/","/**\r\n * 工具方法类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Point = require(\"./Point.js\");\r\n    var Line = require(\"./LineStruct.js\");\r\n    var graphic = require(\"./graphic.js\");\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    /**\r\n     * 构造类继承关系\r\n     *\r\n     * @param {Function} clazz 源类\r\n     * @param {Function} baseClazz 基类\r\n     */\r\n    function inherits(clazz, baseClazz) {\r\n        var clazzPrototype = clazz.prototype;\r\n\r\n        function F() {}\r\n        F.prototype = baseClazz.prototype;\r\n        clazz.prototype = new F();\r\n\r\n        for (var prop in clazzPrototype) {\r\n            clazz.prototype[prop] = clazzPrototype[prop];\r\n        }\r\n        clazz.prototype.constructor = clazz;\r\n        clazz.superClass = baseClazz;\r\n    }\r\n\r\n    function getUUID() {\r\n        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n            uuid = new Array(36),\r\n            rnd = 0,\r\n            r;\r\n        for (var i = 0; i < 36; i++) {\r\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n                uuid[i] = '-';\r\n            } else if (i == 14) {\r\n                uuid[i] = '4';\r\n            } else {\r\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n                r = rnd & 0xf;\r\n                rnd = rnd >> 4;\r\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n            }\r\n        }\r\n        return \"sid-\" + uuid.join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算两点之间的距离\r\n     *@param {Point} p1 - first {Point}\r\n     *@param {Point} p2 - second {Point}\r\n     *@return {Number} - the distance between those 2 points. It is always positive.\r\n     **/\r\n    function distance(p1, p2) {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 返回一条折线 最长的两个点\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function getMaxLineLength(points) {\r\n        var m = distance(points[0], points[1]);\r\n        var result = [points[0], points[1]];\r\n        for (var i = 1; i < points.length - 1; i++) {\r\n\r\n            if (m < distance(points[i], points[i + 1])) {\r\n                m = distance(points[i], points[i + 1])\r\n                result = [points[i], points[i + 1]];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**Returns the length of a Polyline that would be created with a set of points\r\n     *@param {Array} v - an {Array} of {Points}\r\n     *@return {Number} - a positive number equal with total length*/\r\n    function getPolylineLength(v) {\r\n        var l = 0;\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            l += distance(v[i], v[i + 1]);\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n\r\n    /**Returns the max of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n     **/\r\n    function max(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m < v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n\r\n    /**Returns the min of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n     *@author alex@scriptoid.com\r\n     **/\r\n    function min(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m > v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是否正交直线路径\r\n     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function orthogonalPath(v) {\r\n        if (v.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n     *and not the infinite lines from geometry\r\n     *@param {Line} l1 - fist line/segment\r\n     *@param {Line} l2 - last line/segment\r\n     *@return {Boolean} true - if the lines intersect or false if not\r\n     **/\r\n    function lineIntersectsLine(l1, l2) {\r\n        // check for two vertical lines\r\n        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n                // then check segment bounds for overlapping\r\n                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                // lines are paralel\r\n                false;\r\n        }\r\n        // if one line is vertical, and another line is not vertical\r\n        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n            // let assume l2 is vertical, otherwise exchange them\r\n            if (l1.startPoint.x == l1.endPoint.x) {\r\n                var l = l1;\r\n                l1 = l2;\r\n                l2 = l;\r\n            }\r\n            // finding intersection of 'infinite' lines\r\n            // equation of the first line is y = ax + b, second: x = c\r\n            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n            var x0 = l2.startPoint.x;\r\n            var y0 = a * x0 + b;\r\n            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n        }\r\n\r\n        // check normal case - both lines are not vertical\r\n        else {\r\n            //line equation is : y = a*x + b, b = y - a * x\r\n            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\r\n            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\r\n            if (a1 == a2) { //paralel lines\r\n                return b1 == b2 ?\r\n                    // for coincide lines, check for segment bounds overlapping\r\n                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                    // not coincide paralel lines have no chance to intersect\r\n                    false;\r\n            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\r\n                /*\r\n                 * if one of the lines are vertical, then x0 is equal to their x,\r\n                 * otherwise:\r\n                 * y1 = a1 * x + b1\r\n                 * y2 = a2 * x + b2\r\n                 * => x0 = (b2 - b1) / (a1 - a2)\r\n                 * => y0 = a1 * x0 + b1\r\n                 **/\r\n                x0 = (b2 - b1) / (a1 - a2);\r\n                y0 = a1 * x0 + b1;\r\n                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n     *@param {Array} points - and {Array} of {Point}s\r\n     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n     *\r\n     *@return true - if line intersects the rectangle, false - if not\r\n     **/\r\n    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\r\n\r\n        //get the 4 lines/segments represented by the bounds\r\n        var lines = [];\r\n        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\r\n        for (var k = 0; k < points.length - 1; k++) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine = new Line(points[k], points[k + 1]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var i = 0; i < lines.length; i++) {\r\n                if (lineIntersectsLine(tempLine, lines[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check the closed figure - that is last point connected to the first\r\n        if (closedPolyline) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var j = 0; j < lines.length; j++) {\r\n                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 计算路径的分数\r\n     * Score a ortogonal path made out of Points\r\n     *Iterates over a set of points (minimum 3)\r\n     *For each 3 points (i, i+1, i+2) :\r\n     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n     *  - if the 3rd goes back we imediatelly return -1\r\n     *@param {Array} v - an array of {Point}s\r\n     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n     *  The bigger the number the smooth the path is\r\n     **/\r\n    function scorePath(v) {\r\n        if (v.length <= 2) {\r\n            return -1;\r\n        }\r\n\r\n        var score = 0;\r\n        for (var i = 1; i < v.length - 1; i++) {\r\n            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else { //not on same vertical nor horizontal\r\n                score--;\r\n            }\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * 返回数字符号（+ -)\r\n     * Returns the sign of a number\r\n     *@param {Number} x - the number\r\n     *@returns {Number}\r\n     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n     **/\r\n    function signum(x) {\r\n        if (x > 0)\r\n            return 1;\r\n        else if (x < 0)\r\n            return -1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是不是有效路径（没有回路）\r\n     *Tests if a vector of points is a valid path (not going back)\r\n     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function forwardPath(v) {\r\n        if (v.length <= 2) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 2; i++) {\r\n            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n     * @param  {[type]} points [description]\r\n     * @param  {[type]} isRevert [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function traslatePoints(points, isRevert) {\r\n        var newPoints = [];\r\n        if (isRevert) {\r\n            for (var i = 0; i < points.length; i++) {\r\n                var point = points[i];\r\n                newPoints.push(new Point(point[0], point[1]));\r\n            }\r\n            return newPoints;\r\n        } else {\r\n            for (var j = 0; j < points.length; j++) {\r\n                var point1 = points[j];\r\n                newPoints.push([point1.x, point1.y]);\r\n            }\r\n            return newPoints;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function rotationMatrix(angle) {\r\n        var mReturn = [\r\n            [Math.cos(angle), -Math.sin(angle), 0],\r\n            [Math.sin(angle), Math.cos(angle), 0],\r\n            [0, 0, 1]\r\n        ];\r\n        return mReturn;\r\n    }\r\n\r\n    function translationMatrix(dx, dy) {\r\n        return [\r\n            [1, 0, dx],\r\n            [0, 1, dy],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    function scaleMatrix(sx, sy) {\r\n        if (sy == null) {\r\n            sy = sx;\r\n        }\r\n        return [\r\n            [sx, 0, 0],\r\n            [0, sy, 0],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    /** It will return the end point of a line on a given angle (clockwise).\r\n     * @param {Point} startPoint - the start of the line\r\n     * @param {Number} length - the length of the line\r\n     * @param {Number} angle - the angle of the line in radians\r\n     * @return {Point} - the endPoint of the line\r\n     */\r\n    function getEndPoint(startPoint, length, angle) {\r\n        var endPoint = startPoint.clone();\r\n        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n        endPoint.y -= length;\r\n        endPoint.transform(rotationMatrix(angle));\r\n        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n        return endPoint;\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorPoints(node) {\r\n        return {\r\n            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getSoltPoints(node) {\r\n        return [\r\n            //top\r\n            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n            //right\r\n            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n            //bottom\r\n            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            //left\r\n            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * 计算 p1 p2两点所连接的直线的角度\r\n     * @param  {[type]} p1 [description]\r\n     * @param  {[type]} p2 [description]\r\n     * @return {[type]}    [description]\r\n     */\r\n    function tangentRotation(p1, p2) {\r\n        return -Math.PI / 2 - Math.atan2(\r\n            p2.y - p1.y, p2.x - p1.x\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 判断3点是否在一条直线上\r\n     * Tests if 3 points are coliniar with matrix determinants.\r\n     * If the determinat of matrix\r\n     * /         \\\r\n     * | x1 y1 1 |\r\n     * | x2 y2 1 |\r\n     * | x3 y3 1 |\r\n     * \\         /\r\n     * is zero it means that the points are colinear\r\n     *@param {Point} p1 - first point\r\n     *@param {Point} p2 - second point\r\n     *@param {Point} p3 - third point\r\n     * @param {Number} precission\r\n     *@return {Boolean} - true if coliniar and false if not\r\n     *@author Alex\r\n     *@see http://en.wikipedia.org/wiki/Determinant\r\n     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n     **/\r\n    function collinearity(p1, p2, p3, precission) {\r\n        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\r\n        if (precission) {\r\n            return Math.abs(determinant) <= precission;\r\n        } else {\r\n            return determinant === 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 四舍五入 保存decimals的小数\r\n     **/\r\n    function enhancedRound(number, decimals) {\r\n        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n    }\r\n\r\n    /**\r\n     * 获取两点之间的长度\r\n     **/\r\n    function getLength(startPoint, endPoint) {\r\n        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 获取角度\r\n     * @param  {[type]} centerPoint  [description]\r\n     * @param  {[type]} outsidePoint [description]\r\n     * @param  {[type]} round        [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function getAngle(centerPoint, outsidePoint, round) {\r\n        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n        angle = -angle;\r\n\r\n        //endAngle+=90;\r\n        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n            angle += Math.PI * 2;\r\n        }\r\n        while (angle >= Math.PI * 2) {\r\n            angle -= Math.PI * 2;\r\n        }\r\n        if (isNaN(angle)) { //Nan\r\n            angle = 0; //we are at center point;\r\n        }\r\n        if (round) {\r\n            angle = Math.round(angle / round) * round\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    function getRect(node) {\r\n        var boundingRect = node.getBoundingRect();\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n        var boundRect, cx, cy;\r\n        if (node instanceof graphic.Circle) {\r\n            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),\r\n                Number(node.position[1]) - Number(boundingRect.height / 2),\r\n                Number(boundingRect.width), Number(boundingRect.height));\r\n            cx = Number(node.position[0]);\r\n            cy = Number(node.position[1]);\r\n        } else {\r\n            boundRect = new BoundingRect(Number(node.position[0]),\r\n                Number(node.position[1]),\r\n                Number(boundingRect.width), Number(boundingRect.height));\r\n            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;\r\n            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;\r\n        }\r\n        return {\r\n            x: Number(cx),\r\n            y: Number(cy),\r\n            width: Number(boundingRect.width),\r\n            height: Number(boundingRect.height),\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    }\r\n\r\n    var StackedMap = {\r\n        createNew: function() {\r\n            var stack = [];\r\n\r\n            return {\r\n                add: function(key, value) {\r\n                    var arrKey = this.get(key);\r\n                    arrKey.push(value)\r\n\r\n                },\r\n                get: function(key) {\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            return stack[i].value;\r\n                        }\r\n                    }\r\n                    //如果没有找到的话，则创建一个新的数组\r\n                    var value = [];\r\n                    stack.push({ key: key, value: value });\r\n                    return value;\r\n                },\r\n                keys: function() {\r\n                    var keys = [];\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        keys.push(stack[i].key);\r\n                    }\r\n                    return keys;\r\n                },\r\n                top: function() {\r\n                    return stack[stack.length - 1];\r\n                },\r\n                remove: function(key) {\r\n                    var idx = -1;\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            idx = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return stack.splice(idx, 1)[0];\r\n                },\r\n                removeItem: function(key, item) {\r\n                    var arrKey = this.get(key);\r\n                    var index = zrUtil.indexOf(arrKey, item);\r\n                    arrKey.splice(index, 1);\r\n\r\n                },\r\n                removeTop: function() {\r\n                    return stack.splice(stack.length - 1, 1)[0];\r\n                },\r\n                length: function() {\r\n                    return stack.length;\r\n                },\r\n                clear: function() {\r\n                    stack.splice(0, stack.length);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function randomColor() {\r\n        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n            strHex = \"#\",\r\n            index;\r\n        for (var i = 0; i < 6; i++) {\r\n            index = Math.round(Math.random() * 15);\r\n            strHex += arrHex[index];\r\n        }\r\n        return strHex;\r\n    }\r\n\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n    function collinearReduction (v) {\r\n        var r = [];\r\n\r\n        if(v.length < 3){\r\n            return Point.cloneArray(v);\r\n        }\r\n\r\n        r.push( v[0].clone() );\r\n        for(var i=1; i < v.length-1; i++){\r\n            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                r.push( v[i].clone() );\r\n            }\r\n        }\r\n        r.push( v[v.length-1].clone() );\r\n\r\n        return r;\r\n    }\r\n\r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n        \"'\": \"'\",\r\n        '\\\\': '\\\\',\r\n        '\\r': 'r',\r\n        '\\n': 'n',\r\n        '\\u2028': 'u2028',\r\n        '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\r\n    var escapeChar = function(match) {\r\n        return '\\\\' + escapes[match];\r\n    };\r\n\r\n    // JavaScript micro-templating, similar to John Resig's implementation.\r\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n    // and correctly escapes quotes within interpolated code.\r\n    // NB: `oldSettings` only exists for backwards compatibility.\r\n    function template(text, settings, oldSettings) {\r\n        if (!settings && oldSettings) settings = oldSettings;\r\n        settings = settings || {};\r\n        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n            (settings.escape || noMatch).source,\r\n            (settings.interpolate || noMatch).source,\r\n            (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n            index = offset + match.length;\r\n\r\n            if (escape) {\r\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n            } else if (interpolate) {\r\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n            } else if (evaluate) {\r\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n            }\r\n\r\n            // Adobe VMs need the match returned to produce the correct offest.\r\n            return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n            source + 'return __p;\\n';\r\n\r\n        try {\r\n            var render = new Function(settings.variable || 'obj', source);\r\n        } catch (e) {\r\n            e.source = source;\r\n            throw e;\r\n        }\r\n\r\n        var template = function(data) {\r\n            return render.call(this, data);\r\n        };\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        if (obj == null) return true;\r\n        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n    }\r\n\r\n    module.exports = {\r\n        inherits: inherits,\r\n        getUUID: getUUID,\r\n        distance: distance,\r\n        getPolylineLength: getPolylineLength,\r\n        max: max,\r\n        min: min,\r\n        isEmpty: isEmpty,\r\n        orthogonalPath: orthogonalPath,\r\n        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n        scorePath: scorePath,\r\n        forwardPath: forwardPath,\r\n        traslatePoints: traslatePoints,\r\n        getEndPoint: getEndPoint,\r\n        getConnectorPoints: getConnectorPoints,\r\n        tangentRotation: tangentRotation,\r\n        collinearity: collinearity,\r\n        translationMatrix: translationMatrix,\r\n        scaleMatrix: scaleMatrix,\r\n        round: enhancedRound,\r\n        getLength: getLength,\r\n        getAngle: getAngle,\r\n        getRect: getRect,\r\n        StackedMap: StackedMap,\r\n        getMaxLineLength: getMaxLineLength,\r\n        randomColor: randomColor,\r\n        template: template,\r\n        isUndefined: isUndefined,\r\n        getSoltPoints:getSoltPoints,\r\n        collinearReduction: collinearReduction\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/util.js\n ** module id = 59\n ** module chunks = 0\n **/","\r\n\r\n    /**\r\n      * Creates an instance of Point\r\n      *\r\n      *\r\n      * @constructor\r\n      * @this {Point}\r\n      * @param {Number} x The x coordinate of point.\r\n      * @param {Number} y The y coordinate of point.\r\n      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n      * then Point from math perspective.\r\n      **/\r\n    function Point(x, y){\r\n        /**The x coordinate of point*/\r\n        this.x = x;\r\n        \r\n        /**The y coordinate of point*/\r\n        this.y = y;\r\n        \r\n\r\n    }\r\n\r\n    /**Creates a {Point} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Point} a newly constructed Point\r\n     **/\r\n    Point.load = function(o){\r\n        var newPoint = new Point(Number(o.x), Number(o.y));\r\n        return newPoint;\r\n    };\r\n\r\n\r\n    /**Creates an array of points from an array of {JSONObject}s\r\n     *@param {Array} v - the array of JSONObjects\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.loadArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(Point.load(v[i]));\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n\r\n    /**Clones an array of points\r\n     *@param {Array} v - the array of {Point}s\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.cloneArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(v[i].clone());\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n    Point.prototype = {\r\n        constructor : Point,\r\n        \r\n        transform:function(matrix){\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n        },\r\n        \r\n        /**Tests if this point is similar to other point\r\n         *@param {Point} anotherPoint - the other point\r\n         **/\r\n        equals:function(anotherPoint){\r\n            if(! (anotherPoint instanceof Point) ){\r\n                return false;\r\n            }\r\n            return (this.x == anotherPoint.x)\r\n            && (this.y == anotherPoint.y)\r\n        },\r\n\r\n        /**Clone current Point\r\n         **/\r\n        clone: function(){\r\n            var newPoint = new Point(this.x, this.y);\r\n            return newPoint;\r\n        },\r\n\r\n        /**Tests to see if a point (x, y) is within a range of current Point\r\n         *@param {Numeric} x - the x coordinate of tested point\r\n         *@param {Numeric} y - the x coordinate of tested point\r\n         *@param {Numeric} radius - the radius of the vicinity\r\n         **/\r\n        near:function(x, y, radius){\r\n            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\r\n            return (distance <= radius);\r\n        },\r\n\r\n        contains: function(x,y){\r\n            return this.x == x && this.y == y;\r\n        },\r\n\r\n        toString:function(){\r\n            return '[' + this.x + ',' + this.y + ']';\r\n        },\r\n\r\n        getPoints:function(){\r\n            return [this];\r\n        }\r\n    };\r\n    module.exports = Point;\r\n    \n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Point.js\n ** module id = 60\n ** module chunks = 0\n **/","\r\n\r\n    /**\r\n      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n      * geometrical Line\r\n      *\r\n      * @constructor\r\n      * @this {Line}\r\n      * @param {Point} startPoint - starting point of the line\r\n      * @param {Point} endPoint - the ending point of the line\r\n      **/\r\n    function Line(startPoint, endPoint){\r\n        /**Starting {@link Point} of the line*/\r\n        this.startPoint = startPoint;\r\n\r\n        /**Ending {@link Point} of the line*/\r\n        this.endPoint = endPoint;\r\n\r\n        /**Serialization type*/\r\n        this.oType = 'Line'; //object type used for JSON deserialization\r\n    }\r\n\r\n    /**Creates a {Line} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Line} a newly constructed Line\r\n     **/\r\n    Line.load = function(o){\r\n        var newLine = new Line(\r\n            Point.load(o.startPoint),\r\n            Point.load(o.endPoint)\r\n        );\r\n\r\n        return newLine;\r\n    };\r\n\r\n    Line.prototype = {\r\n        contructor: Line,\r\n\r\n\r\n\r\n        clone:function(){\r\n            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n            return ret;\r\n        },\r\n\r\n        equals:function(anotherLine){\r\n            if(!anotherLine instanceof Line){\r\n                return false;\r\n            }\r\n            return this.startPoint.equals(anotherLine.startPoint)\r\n            && this.endPoint.equals(anotherLine.endPoint)\r\n        },\r\n\r\n        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n         * @param {Number} x - the X coordinates\r\n         * @param {Number} y - the Y coordinates\r\n         **/\r\n        contains: function(x, y){\r\n            // if the point is inside rectangle bounds of the segment\r\n            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\r\n                // check for vertical line\r\n                if (this.startPoint.x == this.endPoint.x) {\r\n                    return x == this.startPoint.x;\r\n                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n                    var b = this.startPoint.y - a * this.startPoint.x;\r\n                    return y == a * x + b;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        /*\r\n         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n         *@param {Number} x - the x coordinates\r\n         *@param {Number} y - the y coordinates\r\n         *@param {Number} radius - the radius to search for\r\n         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n         **/\r\n        near:function(x,y,radius){\r\n\r\n            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n            }\r\n\r\n            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n            }\r\n\r\n\r\n            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\r\n            /*We will compute the distance from point to the line\r\n             * by using the algorithm from\r\n             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n             * */\r\n\r\n            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n            var a = this.endPoint.y - this.startPoint.y;\r\n            var b = this.startPoint.x - this.endPoint.x;\r\n            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\r\n            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\r\n            //Thirdly we get coordinates of closest line's point to target point\r\n            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\r\n            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\r\n            return  r;\r\n\r\n        },\r\n\r\n        /**we need to create a new array each time, or we will affect the actual shape*/\r\n        getPoints:function(){\r\n            var points = [];\r\n            points.push(this.startPoint);\r\n            points.push(this.endPoint);\r\n            return points;\r\n        },\r\n\r\n        /**Return the {Point} corresponding the t certain t value\r\n         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n        getPoint: function(t){\r\n            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\r\n            return new Point(Xp, Yp);\r\n        },\r\n\r\n        // /**\r\n        //  * Returns the middle of the line\r\n        //  * @return {Point} the middle point\r\n        //  * */\r\n        // getMiddle : function(){\r\n        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n\r\n        // getLength : function(){\r\n        //     return Util.getLength(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n        // /**\r\n        //  *Get bounds for this line\r\n        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n        //  **/\r\n        // getBounds:function(){\r\n        //     return Util.getBounds(this.getPoints());\r\n        // },\r\n\r\n        /**String representation*/\r\n        toString:function(){\r\n            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n        }\r\n    };\r\n    module.exports = Line;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/LineStruct.js\n ** module id = 61\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var apiList = [\r\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'\r\n    ];\r\n\r\n    function ExtensionAPI(instance) {\r\n        zrUtil.each(apiList, function (name) {\r\n            this[name] = zrUtil.bind(instance[name], instance);\r\n        }, this);\r\n    }\r\n\r\n    module.exports = ExtensionAPI;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/ExtensionApi.js\n ** module id = 62\n ** module chunks = 0\n **/","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         */\n        resize: function() {\n            this.painter.resize();\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/zrender.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true; browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/env.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function(storage, painter, proxy) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            this.trigger('globalout', {\n                event: event\n            });\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetEl 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Handler.js\n ** module id = 65\n ** module chunks = 0\n **/","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Storage.js\n ** module id = 66\n ** module chunks = 0\n **/","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/timsort.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animation.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n     */\n    function normalizeEvent(el, e) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/event.js\n ** module id = 69\n ** module chunks = 0\n **/","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/requestAnimationFrame.js\n ** module id = 70\n ** module chunks = 0\n **/","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n\n            event = normalizeEvent(this.dom, event);\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // 平板补充一次findHover\n            // this._mobileFindFixed(event);\n            // Trigger mousemove and mousedown\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/dom/HandlerProxy.js\n ** module id = 71\n ** module chunks = 0\n **/","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/GestureMgr.js\n ** module id = 72\n ** module chunks = 0\n **/","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        opts = opts || {};\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n                    - (parseInt10(stl.paddingLeft) || 0)\n                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n                    - (parseInt10(stl.paddingTop) || 0)\n                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Painter.js\n ** module id = 73\n ** module chunks = 0\n **/","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Layer.js\n ** module id = 74\n ** module chunks = 0\n **/","\r\n    var Node = require(\"../../../fish-topo-core/lib/Node\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require(\"../../../fish-topo-core/lib/util.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    //创建Node类 所有形状都继承Node\r\n    //\r\n    function GroupNode(model, api) {\r\n\r\n        Node.call(this, model, api);\r\n        this.bpmnInfo = {type: -1, name:\"GroupNode\" };    //节点信息\r\n        this.model = model;\r\n        var defaultOptions = {\r\n                shape: {\r\n                    width:0,\r\n                    height:0,\r\n                    r: 7\r\n                },\r\n                style: {\r\n                    fill: '#f9f9f9',\r\n                    stroke: '#bbbbbb'\r\n                },\r\n                position:[0,0]\r\n            };\r\n        this.options = zrUtil.extend(defaultOptions, model);\r\n        this.isdraggable = this.options.isdraggable;\r\n        this.max = [1024,960];\r\n        this.render(this.options);\r\n    }\r\n\r\n    GroupNode.prototype.render = function(model) {\r\n        var rect = new graphic.Rect({\r\n            shape: model.shape,\r\n            style: model.style\r\n        });\r\n        rect.name = \"Rect\";\r\n        this.add(rect);\r\n        this.position = model.position;\r\n        this.mergedImage = model.mergedImage;\r\n    };\r\n\r\n    GroupNode.prototype.fromJSON = function(json) {\r\n        // body...\r\n\r\n\r\n    };\r\n\r\n    GroupNode.prototype.rectContain = function(x, y) {\r\n        var rect = util.getRect(this);\r\n        return rect.boundingRect.contain(x,y);\r\n    };\r\n\r\n    GroupNode.prototype.getRect = function() {\r\n        // body...\r\n        var boundingRect = this.getBoundingRect();\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] =[-boundingRect.width/2,-boundingRect.height/2];\r\n        points[1] =[boundingRect.width/2,-boundingRect.height/2];\r\n        points[2] =[boundingRect.width/2,boundingRect.height/2];\r\n        points[3] =[-boundingRect.width/2,boundingRect.height/2];\r\n        points[4] =[-boundingRect.width/2,-boundingRect.height/2];\r\n\r\n        var boundRect = new BoundingRect(this.position[0] ,\r\n                                         this.position[1],\r\n                                         boundingRect.width, boundingRect.height);\r\n        return {\r\n            x: this.position[0]+boundingRect.width/2,\r\n            y: this.position[1]+boundingRect.height/2,\r\n            width: boundingRect.width,\r\n            height: boundingRect.height,\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    };\r\n\r\n    GroupNode.prototype.reDraw = function(nodeMessage,node,nowGroupPosition) {\r\n        //重置背景rect 的长宽\r\n        var minLength = this.options.shape.r;\r\n        this.setProperties({\r\n            shape:{\r\n                    width:minLength,\r\n                    height:minLength,\r\n                    r: minLength\r\n            }\r\n        });\r\n        var groupPosition = zrUtil.clone(this.position);\r\n        var rect = this.childOfName(\"Rect\");\r\n        var width = this.getBoundingRect().width;\r\n        var height = this.getBoundingRect().height;\r\n        var rx = rect.shape.x,ry = rect.shape.y;\r\n        //取group中所有节点最靠上边和最高左边的值，不包括背景rect的值\r\n        var minX = this._children[1].position[0],minY = this._children[1].position[1];\r\n        var maxX = this._children[1].position[0],maxY = this._children[1].position[1];\r\n        var lineNode = [];\r\n        var nowGroupPosition = zrUtil.clone(nodeMessage.position);\r\n        for(var i = 1; i<this._children.length;i++){\r\n            if(this._children[i] instanceof Connector || this._children[i].isIcon == true){\r\n                continue;\r\n            }else{\r\n                if(minX>this._children[i].position[0]){\r\n                    minX = this._children[i].position[0];\r\n                }\r\n                if(maxX<this._children[i].position[0]){\r\n                    maxX = this._children[i].position[0];\r\n                }\r\n            }\r\n\r\n        }\r\n        for(var j = 1; j<this._children.length;j++){\r\n            if(this._children[j] instanceof Connector || this._children[j].isIcon == true){\r\n                continue;\r\n            }else{\r\n                if(minY>this._children[j].position[1]){\r\n                    minY = this._children[j].position[1];\r\n                }\r\n                if(maxY<this._children[j].position[1]){\r\n                    maxY = this._children[j].position[1];\r\n                }\r\n            }\r\n        }\r\n        if(width > this.max[0]){\r\n            width = this.max[0]-2;\r\n            if(nodeMessage.position[0]>minX){\r\n                nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;\r\n            }else{\r\n                nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width;\r\n            }\r\n        }else{\r\n            //移动节点改变group中背景rect的x位置，不超过最小的值\r\n            rx = this.childOfName(\"Rect\").position[0]+(nodeMessage.position[0]);\r\n            if(rx>minX){\r\n                rx = minX;\r\n            }\r\n            nowGroupPosition[0] = nodeMessage.movePosition[0]+nodeMessage.moveX;\r\n            if(nodeMessage.position[0]>minX){\r\n                if(nowGroupPosition[0]>minX+this.max[0]-nodeMessage.width){\r\n                    nowGroupPosition[0] = minX+this.max[0]-nodeMessage.width;\r\n                }\r\n            }else{\r\n                if(nowGroupPosition[0] < maxX-this.max[0]+nodeMessage.width){\r\n                    nowGroupPosition[0] = maxX-this.max[0]+nodeMessage.width\r\n                }\r\n            }\r\n        }\r\n        if(height > this.max[1]){\r\n            height = this.max[1]-2;\r\n            if(nodeMessage.position[1]>minY){\r\n                nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;\r\n            }else{\r\n                nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height;\r\n            }\r\n        }else{\r\n            //移动节点改变group中背景rect的y位置，不超过最小的值\r\n            ry = this.childOfName(\"Rect\").position[1]+(nodeMessage.position[1]);\r\n            if(ry>minY){\r\n                ry = minY;\r\n            }\r\n            nowGroupPosition[1] = nodeMessage.movePosition[1]+nodeMessage.moveY;\r\n            if(nodeMessage.position[1]>minY){\r\n                if(nowGroupPosition[1]>minY+this.max[1]-nodeMessage.height){\r\n                    nowGroupPosition[1] = minY+this.max[1]-nodeMessage.height;\r\n                }\r\n            }else{\r\n                if(nowGroupPosition[1] < maxY-this.max[1]+nodeMessage.height){\r\n                    nowGroupPosition[1] = maxY-this.max[1]+nodeMessage.height\r\n                }\r\n            }\r\n        }\r\n        if(node.alarm){\r\n            var newAlarmPosition = [nowGroupPosition[0]+node.getBoundingRect().width-(node.alarm.getBoundingRect().width-6),nowGroupPosition[1]-node.alarm.getBoundingRect().height-3];\r\n            node.alarm.attr(\"position\",newAlarmPosition);\r\n        }\r\n        //改变背景rect的长宽和位置\r\n        this.setProperties({\r\n            shape:{\r\n                width:width,\r\n                height:height,\r\n                x:rx,\r\n                y:ry\r\n            }\r\n        });\r\n\r\n    };\r\n    GroupNode.prototype.setProperties = function(opt) {\r\n        var rect = this.childOfName(\"Rect\");\r\n        rect.setShape(opt.shape);\r\n        rect.attr(\"style\",opt.style);\r\n        this.attr('position',opt.position);\r\n        this.attr(\"shape\",opt.shape);\r\n    };\r\n\r\n    //组的合并与放开\r\n    GroupNode.prototype.merged = function() {\r\n        var that = this;\r\n        if(!this.mergedImage){\r\n            return;\r\n        }\r\n        //保留group的初始位置\r\n        var groupPosition = zrUtil.clone(this.position);\r\n        //给小图片设置属性，隐藏group\r\n        var width = this.relationImage.getBoundingRect().width;\r\n        var height = this.relationImage.getBoundingRect().height;\r\n        //计算合并后的小图片的position\r\n        var relationImagePosition = [this.position[0]+this.childOfName(\"Rect\").shape.x+(this.getBoundingRect().width/2-width/2),this.position[1]+this.childOfName(\"Rect\").shape.y+(this.getBoundingRect().height/2-height/2)];\r\n        //将小图片的位置保留下来\r\n        var cloneImagePosition = zrUtil.clone(relationImagePosition);\r\n        this.relationImage.attr(\"style\",{image:this.mergedImage,width:width,height:height});\r\n        this.relationImage.attr(\"position\",relationImagePosition);\r\n        if(width>0&&height>0){\r\n            this.hide();\r\n            this.relationImage.show();\r\n        }\r\n\r\n        //双击图片放出组\r\n        this.relationImage.on(\"dblclick\",function(){\r\n            that.setProperties({\r\n                //设置组的位置根据小图片的偏移量来计算\r\n                position:[groupPosition[0]+(this.position[0]-cloneImagePosition[0]),groupPosition[1]+(this.position[1]-cloneImagePosition[1])]\r\n            });\r\n            this.hide();\r\n            that.show();\r\n        });\r\n        return this.relationImage;\r\n    };\r\n\r\n    zrUtil.inherits(GroupNode,Node);\r\n    module.exports = GroupNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/node/GroupNode.js\n ** module id = 75\n ** module chunks = 0\n **/","\r\n    var graphic = require('./graphic');\r\n    var util = require(\"./util.js\")\r\n    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n    function Node() {\r\n        this.resourceId = util.getUUID(); // 生成节点ID\r\n        graphic.Group.call(this);\r\n    }\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.render = function() {};\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @param  {[type]} json [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    Node.prototype.getRect = function(json) {};\r\n\r\n    /**\r\n     * drawText\r\n     * @description 画一个文本\r\n     * @param {string} name\r\n     * @param {string} color\r\n     */\r\n    Node.prototype.drawText = function(name,color) {\r\n        var textName = this.bpmnInfo.name;\r\n        if(name != null){\r\n            textName = name;\r\n        }\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: textName,\r\n                color: color ? color : this.options.text.color,\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            zlevel: 20\r\n        });\r\n        //文字绘制的位置  \r\n        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n    /**\r\n     * refreshText\r\n     * @description 刷新文本\r\n     */\r\n    Node.prototype.refreshText = function() {\r\n        var text = this.childOfName(\"Title\");\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n    };\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.toJSON = function() {};\r\n\r\n    graphic.Util.inherits(Node, graphic.Group);\r\n    module.exports = Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Node.js\n ** module id = 76\n ** module chunks = 0\n **/","/**\r\n * 连接线\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require(\"../util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Node = require(\"../Node.js\");\r\n    var symbolUtil = require(\"./Symbol.js\");\r\n    var Handle = require(\"./Handle.js\");\r\n    var EffectLine = require(\"./EffectLine.js\");\r\n    var ConnectionPoint = require(\"./ConnectionPoint.js\");\r\n    var Point = require(\"../Point.js\");\r\n    /**\r\n     * 构造函数\r\n     * @param {[type]} options [description]\r\n     */\r\n    function Connector(options) {\r\n        Node.call(this);\r\n        if(options.model&&options.model.option&&options.model.option.resourceId){\r\n            this.resourceId = options.model.option.resourceId;\r\n        }else{\r\n            this.resourceId = Util.getUUID();// 生成节点ID\r\n        }\r\n        var defaultOptions = {\r\n            symbol: {type:\"arrow\" , size: 10, color:\"#000000\"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n            style: {lineWidth:1, stroke:\"#000000\", lineType:Connector.TYPE_STRAIGHT},    //样式\r\n            hoverStyle: {lineWidth:2, stroke:\"lime\"}, //移上去的样式\r\n            arrowHoverStyle: {fill:\"lime\"},\r\n            shape: {points:null, smooth:false, smoothConstraint:null},//形状\r\n            position: [0,0],\r\n            isEdit: true,  //是否可编辑\r\n            text: {\r\n                text: \"\",\r\n                color: '#000000', // 文本颜色\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            z: 0\r\n        }\r\n        var opt = options || {};\r\n        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n        this.model = options.model;\r\n        this.handles = [];\r\n        this.connectionPoints = [];\r\n        this.conPointsGroup = null;\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n        this.autoChangePosition = false\r\n        this.line = null;\r\n        this.groupCurve = new graphic.Group();\r\n        this.icons = [];  // 用于存储线段上面的操作图标\r\n        this.render();\r\n    }\r\n\r\n    Connector.TYPE_STRAIGHT = 'straight';\r\n\r\n    Connector.TYPE_JAGGED = 'jagged';\r\n\r\n    Connector.TYPE_CURVE = 'curve';\r\n\r\n    Connector.RADIUS = 3;\r\n\r\n    Connector.START_NODE = \"startNode\";\r\n\r\n    Connector.END_NODE = \"endNode\";\r\n\r\n    Connector.LEFT = \"left\";\r\n\r\n    Connector.RIGHT = \"right\";\r\n\r\n    Connector.TOP = \"top\";\r\n\r\n    Connector.BOTTOM = \"bottom\";\r\n\r\n    Connector.BOTTOM = \"bottom\";\r\n\r\n    Connector.SEPERATOR = \"-\";\r\n    /**\r\n     * 重新画线，如果传空则根据turningPoints 重新画线\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Connector.prototype.refresh = function(points) {\r\n        if(points) {\r\n            this.turningPoints = points;\r\n        }\r\n        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n        var points = Util.traslatePoints(this.turningPoints);\r\n\r\n        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n            this.modifyCurve(this.turningPoints);\r\n        } else {\r\n            this.line.attr('shape', {points: points});\r\n        }\r\n\r\n        var lineText = this.childOfName('lineText');\r\n        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n        if (!lineText  && this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n            this.add(text.text);\r\n            lineText = this.childOfName('lineText');\r\n        }\r\n        if (lineText) {\r\n            lineText.setStyle(\"text\", this.options.text.text);\r\n\r\n            var textPoint = this.getTextPostion(this.options.text);\r\n\r\n            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n            // }\r\n\r\n            lineText.attr(\"position\", textPoint);\r\n        }\r\n        var symbolTo = this.childOfName('toSymbol');\r\n        if(symbolTo) {\r\n            if(this.options.effect&&this.options.effect.show){\r\n                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);\r\n            }else{\r\n                symbolTo.attr('position', points[points.length -1]);\r\n                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));\r\n            }\r\n        }\r\n   };\r\n    /**\r\n     * 渲染\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.render = function() {\r\n        var that = this;\r\n        //1.创建箭头\r\n        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n        if (symbolTo) {\r\n            this.add(symbolTo);\r\n        }\r\n\r\n        //2.创建线\r\n        this.curveLine = new graphic.BezierCurve({\r\n            position: this.options.position,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.groupCurve.add(this.curveLine);\r\n        this.add(this.groupCurve);\r\n\r\n        this.polyLine = new graphic.Polyline({\r\n            position: this.options.position,\r\n            shape: this.options.shape,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.add(this.polyLine);\r\n\r\n        if((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n            this.line = this.groupCurve;\r\n            this.createHoverStyle(this.curveLine);\r\n            this.polyLine.hide();\r\n        }\r\n        else {\r\n            this.line = this.polyLine;\r\n            this.createHoverStyle(this.polyLine);\r\n            this.curveLine.hide();\r\n        }\r\n\r\n        //3.侦听线事件\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            this.line.on(eveName, zrUtil.bind(function (e) {\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"Connector:\" + eveName;\r\n                params.target = that;\r\n                this.trigger(params.type, params);\r\n                if(this.options.isEdit == false){return;}\r\n\r\n                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {\r\n                    this.createAllconnectionPoint()\r\n                }\r\n                if(this.handles.length < 1 ) {\r\n                    this.shapeSetHandle();\r\n                }\r\n            }, this));\r\n        }, this);\r\n\r\n        //3.创建调整线的连接点\r\n        if(this.options.isEdit) {\r\n            this.conPointsGroup = new graphic.Group();\r\n            this.add(this.conPointsGroup);\r\n        }\r\n\r\n        //4.创建线上文本\r\n        if (this.options.text.text && this.options.text.text != \"\") {\r\n            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n            this.add(text.text);\r\n        }\r\n\r\n\r\n    };\r\n\r\n    //设置style\r\n    Connector.prototype.setStyle = function(options) {\r\n        if(options.color){\r\n            if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n                this.groupCurve.eachChild(function(curve) {\r\n                    curve.attr(\"style\",{stroke:options.color});\r\n                    graphic.setNormalStyle(curve, {stroke:options.color});\r\n                });\r\n            }else{\r\n                this.polyLine.attr(\"style\",{stroke:options.color});\r\n                graphic.setNormalStyle(this.polyLine, {stroke:options.color});\r\n            }\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                symbolTo.attr(\"style\",{fill:options.color});\r\n                graphic.setNormalStyle(symbolTo, {fill:options.color});\r\n            }\r\n            this.options.style.stroke = options.color;\r\n            this.model.set(\"options.style.stroke\", options.color);\r\n            this.model.set(\"options.symbol.color\", options.color);\r\n            this.options.symbol.color = options.color;\r\n        }\r\n\r\n        if(options.text){\r\n             var lineText = this.childOfName('lineText');\r\n            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n            if (!lineText  && options.text.text) {\r\n                var text = this.drawText(\"lineText\", options.text.text,0, 0);\r\n                this.add(text.text);\r\n                lineText = this.childOfName('lineText');\r\n            }\r\n\r\n            if(options.text.text || options.text.text == \"\"){\r\n                lineText.setStyle(\"text\", options.text.text);\r\n                this.options.text.text = options.text.text;\r\n            }\r\n            var textPoint = this.getTextPostion(options.text);\r\n            lineText.attr(\"position\", textPoint);\r\n            if(options.text.textPos){\r\n                this.options.text.textPos = options.text.textPos;\r\n            }else{\r\n                this.options.text.textPos = 'center';\r\n            }\r\n            if(options.text.color){\r\n                lineText.attr(\"style\",{\r\n                    fill: options.text.color\r\n                });\r\n                this.options.text.color = options.text.color;\r\n            }\r\n            this.model.set(\"options.text\", options.text);\r\n        }\r\n\r\n        if(options.symbol){\r\n            if(options.symbol.type){\r\n                this.options.symbol.type = options.symbol.type;\r\n                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n            }\r\n            if(options.symbol.size){\r\n                this.options.symbol.size = options.symbol.size;\r\n                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n            }\r\n            if(options.symbol.color){\r\n                this.options.symbol.color = options.symbol.color;\r\n                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n            }\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                this.remove(symbolTo);\r\n            }\r\n            var symbol = this.createSymbol(\"toSymbol\",this.model.get(\"options\"))\r\n            if (symbol) {\r\n                this.add(symbol);\r\n            }\r\n            this.refresh();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 获取线段的位置\r\n     * @param  {Object} text {text:'', color:'', textPos:''}\r\n     * @return {Object}      {x,y}\r\n     */\r\n    Connector.prototype.getTextPostion = function(text) {\r\n        var textPostion = [];\r\n        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n        if(text&&text.textPos){\r\n            if(text.textPos == 'start'){\r\n                var xOffset = text.xOffset || 0;\r\n                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];\r\n            }else if(text.textPos == 'end'){\r\n                var points  = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length-2],this.turningPoints[this.turningPoints.length-1]]);\r\n                var angle = Util.getAngle(points[0],points[1]);\r\n                var length =  Util.distance(points[0],points[1]) - textWidth;\r\n                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n                textPostion = [newPoint.x,newPoint.y];\r\n            }else{\r\n                textPostion = this.middle(text);\r\n            }\r\n        }else{\r\n            var position = this.middle(text);\r\n            textPostion = [position[0]-textWidth/2,position[1]];\r\n        }\r\n\r\n        return textPostion;\r\n    };\r\n\r\n    /**\r\n     * 获取线段的旋转角度\r\n     * @param  {Object} textPostion {x,y}\r\n     * @return {Number}             角度值\r\n     */\r\n    Connector.prototype.getTextRotation = function(textPostion) {\r\n        //计算出极坐标的角度\r\n        var points  = Util.getMaxLineLength(this.turningPoints);\r\n        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2\r\n        return angle;\r\n    };\r\n\r\n    Connector.prototype.createHoverStyle = function(el) {\r\n        if (this.options.hoverStyle) {\r\n            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}\r\n\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                graphic.doEnterHover(el);\r\n                if(symbolTo){graphic.doEnterHover(symbolTo);}\r\n\r\n                this.groupCurve.eachChild(function(line) {\r\n                    graphic.doEnterHover(line);\r\n                });\r\n            },this))\r\n              .on('mouseout', zrUtil.bind(function() {\r\n                graphic.doLeaveHover(el);\r\n                if(symbolTo){graphic.doLeaveHover(symbolTo);}\r\n                this.groupCurve.eachChild(function(line) {\r\n                    graphic.doLeaveHover(line);\r\n                });\r\n            },this));\r\n        }\r\n    };\r\n    /**\r\n     * 创建Node的连接点\r\n     * @private\r\n     *\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.createAllconnectionPoint = function() {\r\n        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\r\n        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n    };\r\n\r\n    /**\r\n     * 创建连接点\r\n     * @private\r\n     * @param  {[type]} shape [description]\r\n     * @param  {[type]} point [description]\r\n     * @param  {[type]} type  [description]\r\n     * @return {[type]}       [description]\r\n     */\r\n    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n        this.conPointsGroup.add(conPoint.shape);\r\n    };\r\n\r\n    /**\r\n     * 清空控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.clearHandles = function() {\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            this.remove(this.handles[i].handleShape);\r\n        }\r\n        this.handles = [];\r\n        if (this.conPointsGroup) {\r\n            this.conPointsGroup.removeAll();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建拆线 线断的控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.shapeSetHandle = function() {\r\n        for(var i=1; i<this.turningPoints.length-2; i++){\r\n            var h;\r\n            var x, y;\r\n            //是否在一条线上\r\n            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);\r\n            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);\r\n            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))\r\n                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {\r\n\r\n                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical\r\n                    x = this.turningPoints[i].x;\r\n                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;\r\n\r\n                    h = new Handle('h',x,y,this);\r\n\r\n\r\n                }\r\n                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal\r\n                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;\r\n                    y = this.turningPoints[i].y;\r\n                    h =  new  Handle('v',x,y,this);\r\n                }\r\n                if (h) {\r\n                    this.add(h.handleShape);\r\n                    this.handles.push(h);\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 创建箭头\r\n     * @param  {[type]} name       [description]\r\n     * @param  {[type]} options [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    Connector.prototype.createSymbol = function(name, options) {\r\n        var symbolType = options.symbol.type;\r\n        var symbolSize =this.options.symbol.size;\r\n        if (symbolType === 'none') {\r\n            return;\r\n        }\r\n\r\n        if (!zrUtil.isArray(symbolSize)) {\r\n            symbolSize = [symbolSize, symbolSize];\r\n        }\r\n        var symbolPath = symbolUtil.createSymbol(\r\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z\r\n        );\r\n        symbolPath.name = name;\r\n\r\n        return symbolPath;\r\n    };\r\n\r\n    /**\r\n     * 绘制线段上的文本\r\n     * @param  {[type]} content [description]\r\n     * @param  {[type]} name [description]\r\n     * @param  {[type]} x       [description]\r\n     * @param  {[type]} y       [description]\r\n     * @param  {[type]} color   [description]\r\n     * @return {[type]}         [description]\r\n     */\r\n    Connector.prototype.drawText = function (name,content, x, y, color) {\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: content,\r\n                x: x,\r\n                y: y,\r\n                fill: color ? color : this.options.text.color,\r\n                textFont: this.options.text.textFont\r\n            },\r\n            zlevel: 20\r\n        });\r\n        text.name = name;\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 获取线段的中间值\r\n     * @return {[type]} text\r\n     */\r\n    Connector.prototype.middle = function(text){\r\n\r\n        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){\r\n            var points  = Util.getMaxLineLength(this.turningPoints);\r\n            //如果是求线段上的文字的中间值\r\n            // if(text) {\r\n            //     //取出字的长度，计算角度，\r\n            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n            //     var angle = Util.getAngle(points[0],points[1]);\r\n            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n            //     return [newPoint.x, newPoint.y];\r\n            // } else {\r\n            //     var middleX = (points[0].x + points[1].x)/2;\r\n            //     var middleY = (points[0].y + points[1].y) /2;\r\n            //     return [middleX, middleY];\r\n            // }\r\n            var middleX = (points[0].x + points[1].x)/2;\r\n            var middleY = (points[0].y + points[1].y) /2;\r\n            return [middleX, middleY];\r\n        }\r\n        else if(this.options.style.lineType == Connector.TYPE_JAGGED){\r\n\r\n            //find total distance\r\n            var distance = this.getLength();\r\n\r\n            //find between what turning points the half distance is\r\n            var index = -1;\r\n            var ellapsedDistance = 0;\r\n            for(var i=0; i<this.turningPoints.length-1; i++){\r\n                index = i;\r\n                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n                if(ellapsedDistance + segment < distance /2){\r\n                    ellapsedDistance += segment;\r\n                }\r\n                else{\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n            if(index != -1){\r\n                var missingDistance = distance / 2 - ellapsedDistance;\r\n                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)\r\n                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)\r\n                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n                } else{\r\n                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1]\r\n                        + \" nr of points \" + this.turningPoints.length\r\n                        );\r\n                }\r\n\r\n            }\r\n        }\r\n        else if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n            var t = 0.5;\r\n            var l = this.getLength();\r\n\r\n            var walked = 0;\r\n            for(var j =0; j< this.turningPoints.length-1; j++){\r\n                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){\r\n                    break;\r\n                }\r\n\r\n                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n            }\r\n\r\n            var rest = l * t - walked;\r\n            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\r\n            //find the position/ration of the middle of Polyline on current segment\r\n            var segmentPercent = rest / currentSegmentLength;\r\n\r\n            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\r\n            return [Xp, Yp];\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * find total distance\r\n     * @return {Number} [description]\r\n     */\r\n    Connector.prototype.getLength = function() {\r\n            //find total distance\r\n        var distance = 0;\r\n        for(var i=0; i<this.turningPoints.length-1; i++){\r\n            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n        }\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 转JSON对象\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.toJSON = function() {\r\n\r\n        this.model.set(\"resourceId\", this.resourceId);\r\n        this.model.set(\"properties.type\", 14);\r\n\r\n        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n        this.model.set(\"style.sPos\", this.sPos);\r\n        this.model.set(\"style.ePos\", this.ePos);\r\n        this.model.set(\"dockers\",this.turningPoints);\r\n        return this.model.option;\r\n    };\r\n\r\n     /**\r\n     * refreshModel\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.refreshModel = function() {\r\n        this.model.set(\"options.dockers\",this.turningPoints);\r\n        var icons = [];\r\n        for(var i = 0;i < this.icons.length;i++){\r\n            var iconNode = this.icons[i];\r\n            var option = [iconNode.key,{\r\n                icon:iconNode.style.image,\r\n                width: iconNode.style.width,\r\n                height: iconNode.style.height\r\n            }];\r\n            icons.push(option);\r\n        }\r\n        this.model.set(\"icons\",icons);\r\n    };\r\n\r\n    /**\r\n     * 调整曲线的形状\r\n     * @param  {array} points 点数组\r\n     * @return {void}\r\n     */\r\n    Connector.prototype.modifyCurve = function(points) {\r\n        var sol = this.getCurvePoint(points);\r\n\r\n        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n        var willDelCurves = [];\r\n        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {\r\n            willDelCurves.push(this.groupCurve.childAt(j));\r\n        }\r\n        zrUtil.each(willDelCurves, function(curve) {\r\n            this.groupCurve.remove(curve);\r\n        }, this);\r\n        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n        for (var i = 0; i < sol.length; i++) {\r\n            var line = this.groupCurve.childAt(i);\r\n            if (line) {\r\n                line.attr('shape', sol[i]);\r\n            } else {\r\n                var cure = new graphic.BezierCurve({\r\n                    position: this.options.position,\r\n                    style: this.options.style,\r\n                    shape: sol[i],\r\n                    z: this.options.z\r\n                });\r\n                this.groupCurve.add(cure);\r\n                this.createHoverStyle(cure);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据传入的点数组计算曲线的点\r\n     * @param  {array} P 点数组\r\n     * @return {object}        曲线的点数组\r\n     */\r\n    Connector.prototype.getCurvePoint = function(P) {\r\n        var n = P.length;\r\n        var sol = [];\r\n        if (n === 3) {\r\n            sol.push({x1: P[0].x,\r\n                   y1: P[0].y,\r\n                   cpx1: P[1].x,\r\n                   cpy1: P[1].y,\r\n                   x2: P[2].x,\r\n                   y2: P[2].y\r\n                });\r\n            return sol;\r\n        }\r\n        else if (n === 4) {\r\n            sol.push({x1: P[0].x,\r\n                   y1: P[0].y,\r\n                   cpx1: P[1].x,\r\n                   cpy1: P[1].y,\r\n                   cpx2: P[2].x,\r\n                   cpy2: P[2].y,\r\n                   x2: P[3].x,\r\n                   y2: P[3].y\r\n                });\r\n            return sol;\r\n        }\r\n\r\n        /**Computes factorial\r\n         * @param {Number} k the number\r\n         * */\r\n        function fact(k){\r\n            if(k===0 || k===1){\r\n                return 1;\r\n            }\r\n            else{\r\n                return k * fact(k-1);\r\n            }\r\n        }\r\n\r\n        /**Computes Bernstain*/\r\n        function B(i,n,u){\r\n            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);\r\n        }\r\n\r\n        /**Computes the sum between two point\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function sum(p1, p2){\r\n            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n        }\r\n\r\n        /**Computes the difference between first {Point} and second {Point}\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function minus(p1, p2){\r\n            return new Point(p1.x - p2.x, p1.y - p2.y);\r\n        }\r\n\r\n        /**Computes the division of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function divide(p, nr){\r\n            if(nr == 0){\r\n                throw \"Division by zero not allowed (yet :) \" + this.callee ;\r\n            }\r\n            return new Point(p.x/nr, p.y/nr);\r\n        }\r\n\r\n        /**Computes the multiplication of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function multiply(p, nr){\r\n            return new Point (p.x * nr, p.y * nr);\r\n        }\r\n\r\n\r\n\r\n\r\n        /*\r\n         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n         *but otherwise we will get division by zero\r\n         */\r\n        var k = [0,0,0];\r\n\r\n        var j;\r\n        for(j=0;j<=n-3;j++){\r\n            k.push(j);\r\n        }\r\n\r\n        k.push(n-3, n-3);\r\n\r\n\r\n\r\n        for(i=1; i<=n-3; i++){\r\n            //q1 - compute start point\r\n            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);\r\n\r\n            //q0 - compute 1st controll point\r\n            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);\r\n            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);\r\n            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );\r\n            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\r\n            //q2 - compute 2nd controll point\r\n            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );\r\n\r\n            //q3 - compute end point\r\n            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);\r\n            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);\r\n            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );\r\n            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\r\n            //store solution\r\n            //\r\n            sol.push({x1: q0.x,\r\n                   y1: q0.y,\r\n                   cpx1: q1.x,\r\n                   cpy1: q1.y,\r\n                   cpx2: q2.x,\r\n                   cpy2: q2.y,\r\n                   x2: q3.x,\r\n                   y2: q3.y\r\n                });\r\n        }\r\n\r\n        return sol;\r\n    };\r\n\r\n\r\n    Util.inherits(Connector,Node);\r\n\r\n    module.exports = Connector;\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Connector.js\n ** module id = 77\n ** module chunks = 0\n **/","'use strict';\n// Symbol factory\r\n\r\n\r\n    var graphic = require('../graphic');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    /**\r\n     * Triangle shape\r\n     * @inner\r\n     */\r\n    var Triangle = graphic.extendShape({\r\n        type: 'triangle',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy + height);\r\n            path.lineTo(cx - width, cy + height);\r\n            path.closePath();\r\n        }\r\n    });\r\n    /**\r\n     * Diamond shape\r\n     * @inner\r\n     */\r\n    var Diamond = graphic.extendShape({\r\n        type: 'diamond',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy);\r\n            path.lineTo(cx, cy + height);\r\n            path.lineTo(cx - width, cy);\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Pin shape\r\n     * @inner\r\n     */\r\n    var Pin = graphic.extendShape({\r\n        type: 'pin',\r\n        shape: {\r\n            // x, y on the cusp\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (path, shape) {\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var w = shape.width / 5 * 3;\r\n            // Height must be larger than width\r\n            var h = Math.max(w, shape.height);\r\n            var r = w / 2;\r\n\r\n            // Dist on y with tangent point and circle center\r\n            var dy = r * r / (h - r);\r\n            var cy = y - h + r + dy;\r\n            var angle = Math.asin(dy / r);\r\n            // Dist on x with tangent point and circle center\r\n            var dx = Math.cos(angle) * r;\r\n\r\n            var tanX = Math.sin(angle);\r\n            var tanY = Math.cos(angle);\r\n\r\n            path.arc(\r\n                x, cy, r,\r\n                Math.PI - angle,\r\n                Math.PI * 2 + angle\r\n            );\r\n\r\n            var cpLen = r * 0.6;\r\n            var cpLen2 = r * 0.7;\r\n            path.bezierCurveTo(\r\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x, y - cpLen2,\r\n                x, y\r\n            );\r\n            path.bezierCurveTo(\r\n                x, y - cpLen2,\r\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x - dx, cy + dy\r\n            );\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Arrow shape\r\n     * @inner\r\n     */\r\n    var Arrow = graphic.extendShape({\r\n\r\n        type: 'arrow',\r\n\r\n        shape: {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var height = shape.height;\r\n            var width = shape.width;\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var dx = width / 3 * 2;\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + dx, y + height);\r\n            ctx.lineTo(x, y + height / 4 * 3);\r\n            ctx.lineTo(x - dx, y + height);\r\n            ctx.lineTo(x, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Map of path contructors\r\n     * @type {Object.<string, module:zrender/graphic/Path>}\r\n     */\r\n    var symbolCtors = {\r\n        line: graphic.Line,\r\n\r\n        rect: graphic.Rect,\r\n\r\n        roundRect: graphic.Rect,\r\n\r\n        square: graphic.Rect,\r\n\r\n        circle: graphic.Circle,\r\n\r\n        diamond: Diamond,\r\n\r\n        pin: Pin,\r\n\r\n        arrow: Arrow,\r\n\r\n        triangle: Triangle\r\n    };\r\n\r\n    var symbolShapeMakers = {\r\n\r\n        line: function (x, y, w, h, shape) {\r\n            // FIXME\r\n            shape.x1 = x;\r\n            shape.y1 = y + h / 2;\r\n            shape.x2 = x + w;\r\n            shape.y2 = y + h / 2;\r\n        },\r\n\r\n        rect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        roundRect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n            shape.r = Math.min(w, h) / 4;\r\n        },\r\n\r\n        square: function (x, y, w, h, shape) {\r\n            var size = Math.min(w, h);\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = size;\r\n            shape.height = size;\r\n        },\r\n\r\n        circle: function (x, y, w, h, shape) {\r\n            // Put circle in the center of square\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.r = Math.min(w, h) / 2;\r\n        },\r\n\r\n        diamond: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        pin: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        arrow: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        triangle: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        }\r\n    };\r\n\r\n    var symbolBuildProxies = {};\r\n    for (var name in symbolCtors) {\r\n        symbolBuildProxies[name] = new symbolCtors[name]();\r\n    }\r\n\r\n    var Symbol = graphic.extendShape({\r\n\r\n        type: 'symbol',\r\n\r\n        shape: {\r\n            symbolType: '',\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        beforeBrush: function () {\r\n            var style = this.style;\r\n            var shape = this.shape;\r\n            // FIXME\r\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n                style.textPosition = ['50%', '40%'];\r\n                style.textAlign = 'center';\r\n                style.textVerticalAlign = 'middle';\r\n            }\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var symbolType = shape.symbolType;\r\n            var proxySymbol = symbolBuildProxies[symbolType];\r\n            if (shape.symbolType !== 'none') {\r\n                if (!proxySymbol) {\r\n                    // Default rect\r\n                    symbolType = 'rect';\r\n                    proxySymbol = symbolBuildProxies[symbolType];\r\n                }\r\n                symbolShapeMakers[symbolType](\r\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n                );\r\n                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n    var symbolPathSetColor = function (color) {\r\n        if (this.type !== 'image') {\r\n            var symbolStyle = this.style;\r\n            var symbolShape = this.shape;\r\n            if (symbolShape && symbolShape.symbolType === 'line') {\r\n                symbolStyle.stroke = color;\r\n            }\r\n            else if (this.__isEmptyBrush) {\r\n                symbolStyle.stroke = color;\r\n                symbolStyle.fill = '#fff';\r\n            }\r\n            else {\r\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n                symbolStyle.fill && (symbolStyle.fill = color);\r\n                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n            }\r\n            this.dirty();\r\n        }\r\n    };\r\n\r\n    var symbolUtil = {\r\n        /**\r\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n         * @param {string} symbolType\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {number} w\r\n         * @param {number} h\r\n         * @param {number} z\r\n         * @param {string} color\r\n         */\r\n        createSymbol: function (symbolType, x, y, w, h, color, z) {\r\n            var isEmpty = symbolType.indexOf('empty') === 0;\r\n            if (isEmpty) {\r\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n            }\r\n            var symbolPath;\r\n\r\n            if (symbolType.indexOf('image://') === 0) {\r\n                symbolPath = new graphic.Image({\r\n                    style: {\r\n                        image: symbolType.slice(8),\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n            else if (symbolType.indexOf('path://') === 0) {\r\n                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));\r\n            }\r\n            else {\r\n                symbolPath = new Symbol({\r\n                    shape: {\r\n                        symbolType: symbolType,\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n\r\n            symbolPath.__isEmptyBrush = isEmpty;\r\n\r\n            symbolPath.setColor = symbolPathSetColor;\r\n\r\n            symbolPath.setColor(color);\r\n\r\n            return symbolPath;\r\n        }\r\n    };\r\n\r\n    module.exports = symbolUtil;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Symbol.js\n ** module id = 78\n ** module chunks = 0\n **/","/**\r\n * 画句柄\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function Handle(type, x, y, connector){\r\n        this.type = type;\r\n\r\n        this.x = x;\r\n\r\n        this.y = y;\r\n\r\n        this.visible = true;\r\n\r\n        this.connector = connector;\r\n\r\n        this.handleShape = new graphic.Circle({\r\n            shape: {\r\n                cx: x,\r\n                cy: y,\r\n                r: Handle.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: \"rgb(0,255,0)\",\r\n                stroke:\"rgb(0,0,0)\"\r\n            },\r\n            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n            draggable:true\r\n        });\r\n\r\n        var that = this;\r\n        this.handleShape.on(\"drag\", function(e) {\r\n            that.actionConnector(e.offsetX,e.offsetY);\r\n        });\r\n       // return this.circle;\r\n    }\r\n\r\n    Handle.RADIUS = 4;\r\n\r\n    Handle.prototype = {\r\n\r\n        constructor : Handle,\r\n\r\n        equals : function(anotherHandle){\r\n            if(!anotherHandle instanceof Handle){\r\n                return false;\r\n            }\r\n\r\n            return this.type == anotherHandle.type\r\n            && this.x == anotherHandle.x\r\n            && this.y == anotherHandle.y\r\n            && this.visible == anotherHandle.visible;\r\n        },\r\n\r\n        /**\r\n         * 移动句柄\r\n         * @param  {[type]} newX [description]\r\n         * @param  {[type]} newY [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        actionConnector: function(newX, newY){\r\n            switch(this.type){\r\n                case 'v':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n                            && this.connector.turningPoints[i].y == this.y\r\n                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n                        {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaY = newY - this.y;\r\n                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.y = newY;  //将句柄新的位置赋值给y\r\n\r\n                    break;\r\n\r\n                case 'h':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n                            && this.connector.turningPoints[i].x == this.x\r\n                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n                            {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaX = newX-this.x;\r\n                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.x = newX; //将句柄新的位置赋值给x\r\n\r\n                    break;\r\n            }\r\n           //. this.shape.updateMiddleText();\r\n        }\r\n    };\r\n    module.exports = Handle;\r\n\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Handle.js\n ** module id = 79\n ** module chunks = 0\n **/","/**\r\n * 连线动态效果\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var curveUtil = require('zrender/lib/core/curve');\r\n    var symbolUtil = require('./Symbol.js');\r\n\r\n    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n        this._lastFrame = 0;\r\n        this._lastFramePercent = 0;\r\n        this.symbol = symbol;\r\n        this.groupCurve = groupCurve;\r\n        this.initSymbol(options, polyLine);\r\n    }\r\n    var EffectLineProto = EffectLine.prototype;\r\n\r\n    EffectLineProto.initSymbol = function(options, polyLine) {\r\n        var that = this;\r\n        this.symbol.z2 = 100;\r\n        this.symbol.culling = true;\r\n        var period = options.effect.period * 1000;\r\n        this.symbol.__t = 0;\r\n        this.symbol.stopAnimation();\r\n        if ((options.style.lineType == \"curve\")) {\r\n            if (this.groupCurve) {\r\n                var i = 0;\r\n                period = period / this.groupCurve._children.length;\r\n                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n            }\r\n\r\n        } else {\r\n            this.symbol.animate('', true)\r\n                .when(period, {\r\n                    __t: 1\r\n                })\r\n                .delay(0)\r\n                .during(function() {\r\n                    that.updateSymbolPositionPolyline();\r\n                })\r\n                .start();\r\n            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n        }\r\n\r\n    };\r\n\r\n    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n        var that = this;\r\n        if (curveLine == undefined) {\r\n            curveLine = this.groupCurve._children[0];\r\n            i = 0;\r\n        }\r\n        var points;\r\n        var pos = curveLine.shape;\r\n        points = [\r\n            [pos.x1, pos.y1],\r\n            [pos.x2, pos.y2],\r\n            [pos.cpx1, pos.cpy1],\r\n            [pos.cpx2, pos.cpy2]\r\n        ];\r\n        this.setAnimationPointsBezierCurve(points);\r\n        this.symbol.animate('')\r\n            .when(period, {\r\n                __t: 1\r\n            })\r\n            .delay(0)\r\n            .during(function() {\r\n                that.updateSymbolPositionBezierCurve();\r\n            })\r\n            .done(function() {\r\n                that.symbol.__t = 0;\r\n                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n            })\r\n            .start();\r\n\r\n    };\r\n\r\n\r\n    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n        this.symbol.__p1 = points[0];\r\n        this.symbol.__p2 = points[1];\r\n        this.symbol.__cp1 = points[2] || [\r\n            (points[0][0] + points[1][0]) / 2,\r\n            (points[0][1] + points[1][1]) / 2\r\n        ];\r\n        this.symbol.__cp2 = points[3];\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n        var p1 = this.symbol.__p1;\r\n        var p2 = this.symbol.__p2;\r\n        var cp1 = this.symbol.__cp1;\r\n        var cp2 = this.symbol.__cp2;\r\n        var t = this.symbol.__t;\r\n        var pos = this.symbol.position;\r\n        var tx, ty;\r\n        if (cp2[0] != undefined) {\r\n            var cubicAt = curveUtil.cubicAt;\r\n            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n            // Tangent\r\n            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n        } else {\r\n            var quadraticAt = curveUtil.quadraticAt;\r\n            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n            // Tangent\r\n            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n        }\r\n        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\r\n        this.symbol.ignore = false;\r\n    };\r\n\r\n    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n        this._points = points;\r\n        var accLenArr = [0];\r\n        var len = 0;\r\n        for (var i = 1; i < points.length; i++) {\r\n            var p1 = points[i - 1];\r\n            var p2 = points[i];\r\n            len += vec2.dist(p1, p2);\r\n            accLenArr.push(len);\r\n        }\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        for (var j = 0; j < accLenArr.length; j++) {\r\n            accLenArr[j] /= len;\r\n        }\r\n        this._offsets = accLenArr;\r\n        this._length = len;\r\n        this.symbol._lastFrame = 0;\r\n        this.symbol.__lastFramePercent = 0;\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n        var t = this.symbol.__t;\r\n        var points = this._points;\r\n        var offsets = this._offsets;\r\n        var len = points.length;\r\n\r\n        if (!offsets) {\r\n            // Has length 0\r\n            return;\r\n        }\r\n\r\n        var lastFrame = this._lastFrame;\r\n        var frame;\r\n\r\n        if (t < this._lastFramePercent) {\r\n            // Start from the next frame\r\n            // PENDING start from lastFrame ?\r\n            var start = Math.min(lastFrame + 1, len - 1);\r\n            for (frame = start; frame >= 0; frame--) {\r\n                if (offsets[frame] <= t) {\r\n                    break;\r\n                }\r\n            }\r\n            // PENDING really need to do this ?\r\n            frame = Math.min(frame, len - 2);\r\n        } else {\r\n            for (var frame = lastFrame; frame < len; frame++) {\r\n                if (offsets[frame] > t) {\r\n                    break;\r\n                }\r\n            }\r\n            frame = Math.min(frame - 1, len - 2);\r\n        }\r\n        vec2.lerp(\r\n            this.symbol.position, points[frame], points[frame + 1],\r\n            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n        );\r\n\r\n        this._lastFrame = frame;\r\n        this._lastFramePercent = t;\r\n        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n        this.symbol.rotation = angle - Math.PI / 2;\r\n        this.symbol.ignore = false;\r\n    };\r\n    module.exports = EffectLine;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/EffectLine.js\n ** module id = 80\n ** module chunks = 0\n **/","/**\r\n * 控制点\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function ConnectionPoint(connector, point, type, options){\r\n        this.connector = connector;\r\n\r\n        this.point = point.clone();\r\n\r\n        this.type = type;\r\n\r\n        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\r\n        this.oType = 'ConnectionPoint';\r\n\r\n        this.shape = new graphic.Circle({\r\n            shape: {\r\n                cx: this.point.x,\r\n                cy: this.point.y,\r\n                r: ConnectionPoint.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: this.color,\r\n                stroke:'#000000'\r\n            },\r\n            z : options.z + 2  //节点Z为1 线段为0;\r\n        });\r\n        this.shape.type =  this.type;\r\n\r\n        this.shape.connector = connector;\r\n        //return this.circle;\r\n    }\r\n\r\n    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\r\n    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\r\n    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\r\n    ConnectionPoint.RADIUS = 4;\r\n\r\n    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\r\n    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\r\n    ConnectionPoint.prototype = {\r\n\r\n        constructor : ConnectionPoint,\r\n\r\n        equals : function(anotherConnectionPoint){\r\n            return this.point.equals(anotherConnectionPoint.point)\r\n            && this.connector == anotherConnectionPoint.connector\r\n            && this.type == anotherConnectionPoint.type\r\n            && this.color == anotherConnectionPoint.color\r\n            && this.radius == anotherConnectionPoint.radius;\r\n        }\r\n\r\n\r\n    };\r\n    module.exports = ConnectionPoint;\r\n\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/ConnectionPoint.js\n ** module id = 81\n ** module chunks = 0\n **/","/**\r\n * 选中节点后，出现的操作框及按钮\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Node = require(\"../Node\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var env = require('zrender/lib/core/env');\r\n\r\n    function OperationNode(node, zr, forbidEdit) {\r\n        Node.call(this);\r\n        this.node = node;\r\n        this.zr = zr;\r\n        this.forbidEdit = forbidEdit; //\r\n        this.render();\r\n    }\r\n\r\n    //事件\r\n    OperationNode.ARROW_DRAGEND = \"OperationNode:dragendArrow\";\r\n    OperationNode.ARROW_DRAG = \"OperationNode:dragArrow\";\r\n    OperationNode.ARROW_DRAGSTART = \"OperationNode:dragstartArrow\";\r\n    OperationNode.DELETE_CLICK = \"OperationNode:deleteClick\";\r\n\r\n    if(!env.canvasSupported) {\r\n        //内置操作图标的图像\r\n        OperationNode.opicons = {\r\n            STRAIGHT: 'M13.961,2.309c-0.051-0.122-0.148-0.22-0.27-0.27L13.5,2h-5C8.224,2,8,2.224,8,2.5S8.224,3,8.5,3h3.793L2.146,13.146c-0.195,0.195-0.195,0.512,0,0.707s0.512,0.195,0.707,0L13,3.707V7.5C13,7.776,13.225,8,13.5,8S14,7.776,14,7.5v-5L13.961,2.309z',\r\n            JAGGED: 'M96.046,13.604H84.213c-1.104,0-2,0.896-2,2v42.188H38.314v-10.77c0-0.715-0.381-1.375-1-1.732c-0.619-0.357-1.382-0.355-2,0L2.954,63.977c-0.619,0.357-1,1.018-1,1.732s0.381,1.375,1,1.732l32.36,18.687c0.309,0.179,0.655,0.268,1,0.268s0.69-0.089,1-0.268c0.619-0.357,1-1.018,1-1.732V73.625h57.732c1.104,0,2-0.896,2-2V15.604C98.046,14.5,97.151,13.604,96.046,13.604z',\r\n            CURVE: 'M510.536,268.098c13.541,0,27.078-5.207,37.347-15.6c20.379-20.625,20.18-53.866-0.445-74.245L414.167,46.57c-9.905-9.786-23.325-15.244-37.215-15.154c-13.923,0.083-27.244,5.695-37.03,15.599l-129.912,131.48c-20.379,20.625-20.18,53.866,0.445,74.245c20.625,20.379,53.866,20.18,74.245-0.445l40.618-41.108c0.021,0.464,0.029,0.927,0.062,1.394c4.178,59.008,4.668,119.832,16.633,177.931c23.937,116.232,103.705,191.961,191.489,264.024c47.292,38.823,79.66,94.122,98.601,151.673c9.765,29.669,14.714,77.115,17.215,107.157c2.261,27.161,25.08,47.978,52.333,47.709l1.061-0.01c30.228-0.298,53.81-26.211,51.306-56.336c-2.921-35.15-8.858-89.828-20.925-127.49c-16.283-50.821-40.016-99.463-74.766-140.245c-33.993-39.892-75.456-72.403-113.338-108.373c-47.091-44.713-84.977-95.161-98.006-159.719c-10.541-52.231-12.789-105.215-16.461-158.562l43.118,42.604C483.87,263.053,497.205,268.098,510.536,268.098z',\r\n            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'\r\n        };\r\n    }else{\r\n        OperationNode.opicons = {\r\n            STRAIGHT: 'data:image/png;base64,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',\r\n            JAGGED: 'data:image/png;base64,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',\r\n            CURVE: 'data:image/png;base64,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',\r\n            DEL: 'M73.641,45.957l-0.021,0.252c0,0.032,0.021,0.06,0.021,0.088c0,0.065-0.022,0.126-0.026,0.191l-2.685,54.878H70.91c-0.231,4.304-5.166,10.81-31.748,10.81c-26.58,0-31.509-6.506-31.746-10.81H7.41L4.731,46.488c-0.009-0.06-0.028-0.126-0.028-0.191c0-0.032,0.01-0.06,0.01-0.088l-0.01-0.252h0.028c0.099-0.466,0.364-0.919,0.784-1.353c3.439,3.477,17.191,4.051,33.646,4.051s30.221-0.574,33.642-4.051c0.426,0.434,0.711,0.887,0.784,1.353H73.641z M78.335,25.102v6.407c0,1.316-1.34,2.567-3.715,3.696c-6.266,2.936-19.777,4.975-35.459,4.975c-15.666,0-29.189-2.039-35.442-4.975C1.33,34.075,0,32.825,0,31.509v-6.407c0-3.374,8.681-6.286,21.359-7.724V3.929c0-2.16,1.768-3.929,3.93-3.929h26.314c2.164,0,3.938,1.773,3.938,3.938v13.296C68.98,18.606,78.333,21.611,78.335,25.102z M48.416,11.395c0-2.348-0.321-4.27-0.715-4.27c-0.393,0-2.641,0-4.979,0h-8.545c-2.352,0-4.592,0-4.989,0c-0.388,0-0.714,1.922-0.714,4.27v5.367l1.083-0.065c3.067-0.173,6.286-0.27,9.595-0.271c3.202,0,6.292,0.098,9.264,0.252V11.395z'\r\n        };\r\n    }\r\n\r\n\r\n\r\n\r\n    OperationNode.prototype.render = function() {\r\n        this.renderBase();\r\n        if (!this.forbidEdit) {\r\n            this.renderOther();\r\n        }\r\n\r\n    };\r\n\r\n    OperationNode.prototype.renderBase = function() {\r\n        this.createOperation();\r\n    };\r\n\r\n    OperationNode.prototype.createOperation = function() {\r\n        var me = this;\r\n        this.virtualRect = new graphic.Polyline({ style: { lineDash: [2] } });\r\n        this.virtualRect.isSelfComputePos = true;  // 自己计算位置\r\n        this.add(this.virtualRect);\r\n\r\n\r\n\r\n        if (this.node.operationIcons) {\r\n            zrUtil.each(this.node.operationIcons, function(item) {\r\n                //检查是否是内置图标\r\n                var opIconInstance = null;\r\n                if (OperationNode.opicons[item.name + \"\"]) {\r\n\r\n                    if (this.forbidEdit) {\r\n                        return;\r\n                    }\r\n                    if (item.name == \"DEL\") {\r\n                        //垃圾桶\r\n                        var rect1 = { x: 0, y: 0, width: 10, height: 15 };\r\n                        opIconInstance = graphic.makePath(OperationNode.opicons[item.name + \"\"], { style: { fill: '#000000' },z:me.node.z+1 }, rect1);\r\n                        if(item.callback){\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                e.data = item;\r\n                                e.node = me.node;  // 将所附的节点也传递出去\r\n                                if (item.callback) {\r\n                                    item.callback(e);\r\n                                }\r\n                            });\r\n                        }else{\r\n                            opIconInstance.on(\"click\", function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.target = this;\r\n                                params.type = OperationNode.DELETE_CLICK;\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        }\r\n\r\n\r\n                    } else {\r\n                        if(!env.canvasSupported){\r\n                            var rect = { x: 0, y: 0, width: 15, height: 15 };\r\n                            opIconInstance = graphic.makePath(OperationNode.opicons[item.name + \"\"], { style: { fill: '#000000' },draggable:true,z:me.node.z+1,lineType: Connector[\"TYPE_\" + item.name] }, rect);\r\n                        }else{\r\n                            var imageUrl = document.createElement('img');\r\n                            imageUrl.src = OperationNode.opicons[item.name + \"\"];\r\n                            opIconInstance = new graphic.Image({\r\n                                style: {\r\n                                    image:imageUrl,\r\n                                    cursor: 'default',\r\n                                    width:15,\r\n                                    height:15\r\n                                },\r\n                                draggable: true,\r\n                                z: me.node.z+1, //zIndex 置于最高\r\n                                lineType: Connector[\"TYPE_\" + item.name] //区分不同的线段\r\n                            });\r\n                        }\r\n\r\n                        var MOUSE_EVENT_NAMES = ['dragstart', 'drag', 'dragend'];\r\n                        zrUtil.each(MOUSE_EVENT_NAMES, function(eveName) {\r\n                            opIconInstance.on(eveName, function(e) {\r\n                                var params = {};\r\n                                params.event = e;\r\n                                params.data = item.options\r\n                                params.type = \"OperationNode:\" + eveName + \"Arrow\";\r\n                                me.trigger(params.type, params);\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                } else {\r\n                    //用户自定义的图标放在这里，用户传进来的图标只能响应click事件，其它事件暂不支持\r\n                    opIconInstance = new graphic.Image({\r\n                        style: {\r\n                            image: item.iconPath,\r\n                            width: item.width || 15,\r\n                            height: item.height || 15\r\n                        },\r\n                        z:me.node.z+1 //zIndex 置于最高\r\n                    });\r\n                    opIconInstance.on(\"click\", function(e) {\r\n                        e.data = item;\r\n                        e.node = me.node;  // 将所附的节点也传递出去\r\n                        if (item.callback) {\r\n                            item.callback(e);\r\n                        }\r\n\r\n                        //todo 用户自定图标click事件是否要派发到外面\r\n                    });\r\n                }\r\n                opIconInstance.name = item.name;\r\n                me.add(opIconInstance);\r\n            });\r\n        }\r\n    };\r\n\r\n    OperationNode.prototype.refreshPostion = function(node,nodeRect) {\r\n        var me = this;\r\n        var i = 0;\r\n        var rbPoint = nodeRect.points[2]; //取右下角坐标\r\n        //1.定位虚框\r\n        this.virtualRect.setShape({ points: nodeRect.points });\r\n        //2.定位每个小图标\r\n        this.eachChild(function(nodeItem) {\r\n            if (!nodeItem.isSelfComputePos) {\r\n                // 8px是第一个操作按钮图标的距离 靠太近不好看    20px是每个图标的间隔  10px是图标向偏的距离\r\n                nodeItem.attr(\"position\", [rbPoint[0] + 8 + (i++ * 20), rbPoint[1] - 10]);\r\n            }\r\n        });\r\n\r\n        this.refreshPositionOther(node,nodeRect);\r\n    };\r\n\r\n    OperationNode.prototype.renderOther = function() {\r\n        //留给扩展使用\r\n    };\r\n    OperationNode.prototype.refreshPositionOther = function(node,nodeRect) {\r\n        //留给扩展使用\r\n        //3.定位整个operationNode\r\n        if (node.parent && node.parent.isBg && node.parent.isBg == true) {\r\n            this.attr(\"position\", [nodeRect.x, nodeRect.y])\r\n        } else {\r\n            this.attr(\"position\", [nodeRect.x + node.parent.position[0]+node.shape.x, nodeRect.y + node.parent.position[1]+node.shape.y])\r\n        }\r\n    };\r\n    zrUtil.inherits(OperationNode, Node);\r\n    module.exports = OperationNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/manager/OperationNode.js\n ** module id = 82\n ** module chunks = 0\n **/","/**\r\n * flow连线管理类\r\n * @author miao.cunzhi\r\n */\r\n\r\n\tvar zrUtil = require('zrender/lib/core/util');\r\n\tvar ConnectionManager = require(\"../../../fish-topo-core/lib/manager/ConnectionManager.js\");\r\n\tvar Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    var Util = require('../../../fish-topo-core/lib/util');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var Point = require(\"../../../fish-topo-core/lib/Point.js\");\r\n    var Constants = require(\"../util/FlowConstants.js\");\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var Log = require(\"../../../fish-topo-core/lib/Log.js\");\r\n\tvar connectionManagerExtend = {\r\n        LineOperations:[],\r\n        bundleOffset: 30,\r\n        bundleGap: 20,\r\n        connectorMap: Util.StackedMap.createNew(),\r\n        /**\r\n         * 创建连线\r\n         * @param  {[type]} startNode [开始节点]\r\n         * @param  {[type]} endNode   [结束节点]\r\n         * @param  {[type]} options      [类型]\r\n         * @param {[type]} [api] [description]\r\n         * @return {[type]}           [返回连线]\r\n         */\r\n        connectorCreate:function(startNode,endNode,options, api){\r\n            var that = this;\r\n            var model = options.model;\r\n            //1.创建线段\r\n            var connector = new Connector(options);\r\n            connector.startNode = startNode;\r\n            connector.endNode = endNode;\r\n            if(options.autoChangePosition){\r\n                connector.autoChangePosition = options.autoChangePosition;\r\n            }\r\n            if (options.pos) {\r\n                var pos = options.pos.split(\",\");\r\n                connector.sPos = pos[0];\r\n                connector.ePos = pos[1];\r\n            };\r\n            this.connectors.push(connector);\r\n\r\n            var key = this.getTwoNodeId(startNode,endNode);\r\n            this.connectorMap.add(key, connector);\r\n\r\n            if(connector.conPointsGroup) {\r\n                connector.conPointsGroup.on(\"click\", function(e) {\r\n                    var arrSplit = e.target.type.split(Connector.SEPERATOR);\r\n                    var connector = e.target.connector;\r\n                    if (arrSplit[0] === Connector.START_NODE) {\r\n                        connector.sPos = arrSplit[1];\r\n                    } else if (arrSplit[0] === Connector.END_NODE){\r\n                        connector.ePos = arrSplit[1];\r\n                    };\r\n                    that.refreshConnector(connector,true);\r\n                    e.cancelBubble = true;\r\n                    var params = {};\r\n                    params.event = e;\r\n                    params.type = \"conPointsGroup:click\";\r\n                    params.lineNode = that.selConnector;\r\n                    api.trigger(params.type, params);\r\n                });\r\n            }\r\n\r\n\r\n            var MOUSE_EVENT_NAMES = [ 'click', 'dblclick'];\r\n            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n                connector.on(\"Connector:\" + eveName, function(e) {\r\n\r\n                    var selected = e.target;\r\n\r\n                    if ( that.selConnector !== selected) {\r\n                        that.selConnector &&  that.refreshConnector(that.selConnector);\r\n                        that.selConnector = selected;\r\n                    };\r\n                    e.cancelBubble = true;\r\n                    var params = {};\r\n                    params.event = e;\r\n                    params.type = eveName;\r\n                    params.target = that.selConnector;\r\n                    api.trigger(params.type, params);\r\n                });\r\n            });\r\n\r\n\r\n\r\n            //双击收紧为一条线\r\n            connector.line.on(\"dblclick\", function(e) {\r\n                if(connector.options.isShrink == false){return;}\r\n                var con = this.parent;\r\n                var startNode = con.startNode;\r\n                var endNode = con.endNode;\r\n                //1.获取所有的线段\r\n                var key = that.getTwoNodeId(startNode,endNode);\r\n                var cons = that.connectorMap.get(key);\r\n                if (cons.length == 1) {return};\r\n                //2.判断线是否处于隐藏状态\r\n\r\n                //2.将除中间的一条线进行隐藏\r\n                var half = parseInt(cons.length / 2);\r\n                for (var i = 0; i < cons.length; i++) {\r\n                    if (i != (half )) {\r\n                        if (cons[i].ignore) {\r\n                            cons[i].show();\r\n                        } else {\r\n                         cons[i].hide();\r\n                        }\r\n                    };\r\n\r\n                };\r\n\r\n                      //  that.refreshConnector(this.parent,true);\r\n                //alert(\"abc\");\r\n            });\r\n\r\n            this.bundleOffset = options.bundleOffset || this.bundleOffset;\r\n            this.bundleGap = options.bundleGap || this.bundleGap;\r\n            //2. 获取这个key对应的线段数组\r\n            var arrCons = this.connectorMap.get(key);\r\n            if (arrCons.length == 1) {\r\n                //两个节点只有一个连线的情况\r\n                //判断一下 model里有没有dockers，如果有则调用构造point数组  或者调用refreshConnector计算如何画线\r\n                var dockers = options.dockers;\r\n                if (dockers && dockers.length >= 2) {\r\n                    var points = Point.loadArray(dockers);\r\n                    connector.refresh(points);\r\n                } else {\r\n                    if(options.position&&options.position.points){\r\n                        var arrStartEndPoint = this.getStartEndPoint(connector);\r\n                        var points = options.position.points;\r\n                        points.unshift(arrStartEndPoint[0]);\r\n                        points.push(arrStartEndPoint[1]);\r\n                        connector.refresh(points);\r\n                    }else{\r\n                        this.refreshConnector(arrCons[0],true);\r\n                    }\r\n                }\r\n\r\n            }\r\n            else if (arrCons.length > 1) {\r\n                //两个节点有多个连线的情况\r\n                this.refreshCons(arrCons);\r\n            };\r\n\r\n            //3.设置模型\r\n            var model = new Model({});\r\n            model.set(Constants.ELEMENT_TYPE, Constants.CONNECTION);\r\n            model.set(Constants.START_ID, startNode.model.get(Constants.ID));\r\n            model.set(Constants.END_ID, endNode.model.get(Constants.ID));\r\n            model.set(Constants.OPTIONS, zrUtil.clone(options));\r\n            model.set(Constants.DOCKERS, connector.turningPoints);\r\n            model.set(Constants.STYLE_LINETYPE, options.style.lineType);\r\n            connector.model = model;\r\n            return connector;\r\n        },\r\n\r\n        getTwoNodeId: function(startNode,endNode) {\r\n            return startNode.id + \",\" + endNode.id;\r\n        },\r\n        //处理多条线段\r\n        refreshCons: function(arrCons) {\r\n            //如果是折线的话\r\n            if (arrCons[0].options.style.lineType == Connector.TYPE_JAGGED ) {\r\n                for (var i = 0; i < arrCons.length; i++) {\r\n                    this.refreshConnector(arrCons[i],true);\r\n                };\r\n            } else{\r\n                this.refreshConsStraight(arrCons);\r\n            };\r\n        },\r\n\r\n        //处理多条线段(直线)\r\n        refreshConsStraight: function(arrCons) {\r\n            var half = parseInt(arrCons.length / 2);\r\n            var arrConnectResult = []\r\n\r\n            var startNode = arrCons[0].startNode;\r\n            var endNode = arrCons[0].endNode;\r\n            var sRect = Util.getRect(startNode).boundingRect;\r\n            var eRect = Util.getRect(endNode).boundingRect;\r\n            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n            var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n\r\n            if (!arrCons[0].sPos || !arrCons[0].ePos) {\r\n                if (sRect.x < eRect.x) {\r\n                    arrCons[0].sPos = \"right\";\r\n                    arrCons[0].ePos = \"left\";\r\n                } else {\r\n                    arrCons[0].sPos = \"left\";\r\n                    arrCons[0].ePos = \"right\";\r\n                }\r\n            }\r\n            var startPoint = sConnectorPoint[arrCons[0].sPos];\r\n            var endPoint = eConnectorPoint[arrCons[0].ePos];\r\n            var angle = Math.atan2(endPoint.y - startPoint.y , endPoint.x - startPoint.x);\r\n            for (var i = half; i >= 1; i--) {\r\n                var points = [];\r\n                points.push(startPoint);  //\r\n               // points.push(new Point(startPoint.x + bundleOffset , startPoint.y + i * bundleGap));\r\n               // points.push(new Point(endPoint.x - bundleOffset , startPoint.y + i * bundleGap)); //startPoint.x + bundleOffset\r\n                var secondPoint = startPoint.clone();\r\n\r\n                //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n                secondPoint.transform(Util.translationMatrix(0, this.bundleGap* i));\r\n                //secondPoint = this.boundOffsetXY(secondPoint, true);\r\n                //\r\n                //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n\r\n                //从极坐标计算出直角坐标\r\n                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n\r\n\r\n\r\n                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n                points.push(secondPoint);\r\n\r\n                var thirdPoint = endPoint.clone();\r\n                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n\r\n\r\n\r\n                thirdPoint.transform(Util.translationMatrix(0, this.bundleGap*i));\r\n                //thirdPoint = this.boundOffsetXY(thirdPoint, false);\r\n                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n                //\r\n                //直角坐标 x, 和 y, 计算出极坐标\r\n\r\n                //从极坐标计算出直角坐标\r\n                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n\r\n                points.push(thirdPoint);\r\n\r\n                points.push(endPoint);\r\n                arrConnectResult.push(points);\r\n            };\r\n\r\n            arrConnectResult.push([startPoint, endPoint]);\r\n\r\n            var upHalf =  Math.ceil(arrCons.length / 2);\r\n            for (var i = 1; i < upHalf; i++) {\r\n                var points = [];\r\n                points.push(startPoint);\r\n                var secondPoint = startPoint.clone();\r\n                //secondPoint.x =  secondPoint.x + this.bundleOffset;\r\n                secondPoint.transform(Util.translationMatrix(0, - this.bundleGap* i));\r\n                secondPoint.x =  secondPoint.x + this.bundleOffset * Math.cos(angle);\r\n                secondPoint.y =  secondPoint.y + this.bundleOffset * Math.sin(angle);\r\n                points.push(secondPoint);\r\n\r\n                var thirdPoint = endPoint.clone();\r\n                //thirdPoint.x =  thirdPoint.x - this.bundleOffset;\r\n                thirdPoint.transform(Util.translationMatrix(0, - this.bundleGap*i));\r\n                //从极坐标计算出直角坐标\r\n                thirdPoint.x =  thirdPoint.x - this.bundleOffset * Math.cos(angle);\r\n                thirdPoint.y =  thirdPoint.y - this.bundleOffset * Math.sin(angle);\r\n                //secondPoint.transform(Util.scaleMatrix(0.5));\r\n                points.push(thirdPoint);\r\n\r\n                points.push(endPoint);\r\n                arrConnectResult.push(points);\r\n           };\r\n\r\n\r\n           for (var i = 0; i < arrConnectResult.length; i++) {\r\n               arrCons[i].refresh(arrConnectResult[i]);\r\n           };\r\n\r\n        },\r\n        boundOffsetXY: function(point, isPositive) {\r\n            var resultPoint = point.clone();\r\n            //直角坐标 x, 和 y, 计算出极坐标\r\n            var angle = Math.atan2(resultPoint.y , resultPoint.x);\r\n            var r = Math.sqrt( Math.pow(resultPoint.x, 2) + Math.pow(resultPoint.y, 2));\r\n            if(isPositive) {\r\n                r = r + this.bundleOffset;\r\n            } else {\r\n                r = r - this.bundleOffset;\r\n            }\r\n\r\n\r\n            //从极坐标计算出直角坐标\r\n            resultPoint.x = r * Math.cos(angle);\r\n            resultPoint.y = r * Math.sin(angle);\r\n            return resultPoint;\r\n        },\r\n\r\n        /**\r\n         * 设置线段的模型数据  (类型 文字)\r\n         * @param {[type]} connector [description]\r\n         * @param {[type]} option    [description]\r\n         */\r\n        setModel: function(connector, option) {\r\n            var originLineType =  connector.model.get(\"style.lineType\");\r\n            connector.model.mergeOption(option);\r\n            zrUtil.merge(connector.model.get(\"options\"), option, true);\r\n            if (originLineType !== option.style.lineType) {\r\n                this.refreshConnector(connector, true);\r\n            };\r\n        },\r\n\r\n\r\n        /**\r\n         * 刷新连接线\r\n         * @param  {[type]} node [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        refreshLineByNode: function(node) {\r\n            // 判断这个节点是否有多条线段\r\n            var keys = this.connectorMap.keys();\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                if (key.indexOf(node.id) != -1) {\r\n                    var arrCons = this.connectorMap.get(key);\r\n                    this.countLinePos(arrCons)\r\n                    if (arrCons.length == 1 ) {\r\n                        //两个节点只有一个连线的情况\r\n                        this.refreshConnector(arrCons[0],true);\r\n                    }\r\n                    else if (arrCons.length > 1) {\r\n                        //两个节点有多个连线的情况\r\n                        this.refreshCons(arrCons);\r\n                    };\r\n                };\r\n            };\r\n        },\r\n        countLinePos:function(arrCons){\r\n            var that = this;\r\n            $.each(arrCons,function(i,n){\r\n                if(n.autoChangePosition == true){\r\n                    var startNode = n.startNode;\r\n                    var endNode = n.endNode;\r\n                    var sRect = Util.getRect(startNode).boundingRect;\r\n                    var eRect = Util.getRect(endNode).boundingRect;\r\n                    var sPos = n.sPos;\r\n                    var ePos = n.ePos;\r\n                    var sPosNow = that.posIsChange(sPos,sRect,eRect,\"startNode\");\r\n                    var ePosNow = that.posIsChange(ePos,sRect,eRect,\"endNode\");\r\n                    if(sPos != sPosNow || ePos != ePosNow){\r\n                        n.sPos = sPosNow;\r\n                        n.ePos = ePosNow;\r\n                        n.options.pos = [sPosNow,ePosNow];\r\n                        n.model.set(\"options.pos\",[sPosNow,ePosNow]);\r\n                    }\r\n                }\r\n            });\r\n        },\r\n        posIsChange:function(pos,sRect,eRect,nodeType){\r\n            var newPos\r\n            if(pos.indexOf(\"top\") != -1 || pos.indexOf(\"bottom\") != -1 ){\r\n                if(sRect.y + sRect.height < eRect.y){\r\n                    if(nodeType == \"startNode\"){\r\n                        newPos=pos.replace(/(top|bottom)/g,\"bottom\");\r\n                    }else{\r\n                        newPos=pos.replace(/(top|bottom)/g,\"top\");\r\n                    }\r\n                }else if(eRect.y + eRect.height < sRect.y){\r\n                    if(nodeType == \"endNode\"){\r\n                        newPos=pos.replace(/(top|bottom)/g,\"bottom\");\r\n                    }else{\r\n                        newPos=pos.replace(/(top|bottom)/g,\"top\");\r\n                    }\r\n                }else{\r\n                    newPos = pos;\r\n                }\r\n            }else if(pos.indexOf(\"left\") != -1 || pos.indexOf(\"right\") != -1){\r\n                if(sRect.x + sRect.width < eRect.x){\r\n                    if(nodeType == \"startNode\"){\r\n                        newPos=pos.replace(/(right|left)/g,\"right\");\r\n                    }else{\r\n                        newPos=pos.replace(/(right|left)/g,\"left\");\r\n                    }\r\n                }else if(eRect.x + eRect.width < sRect.x){\r\n                    if(nodeType == \"endNode\"){\r\n                        newPos=pos.replace(/(right|left)/g,\"right\");\r\n                    }else{\r\n                        newPos=pos.replace(/(right|left)/g,\"left\");\r\n                    }\r\n                }else{\r\n                    newPos = pos;\r\n                }\r\n            }else{\r\n                newPos = pos;\r\n            }\r\n            return newPos;\r\n        }\r\n\t}\r\n\r\n\tvar FlowConnectionManager = zrUtil.extend(ConnectionManager, connectionManagerExtend)\r\n\tmodule.exports = FlowConnectionManager;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/manager/FlowConnectionManager.js\n ** module id = 83\n ** module chunks = 0\n **/","/**\r\n * 连线管理类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Node = require(\"../Node\");\r\n    var Util = require('../util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Point = require(\"../Point.js\");\r\n    var Connector = require(\"../shapes/Connector.js\");\r\n    var Log = require(\"../Log.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var ConnectionManager = {\r\n\r\n        CLOUD_RADIUS: 12,\r\n        CLOUD_LINEWIDTH: 3,\r\n        CLOUD_STROKE_STYLE: \"rgba(255, 153, 0, 0.8)\", //orange\r\n        stencilType : \"SequenceFlow\",\r\n        connectors: [],\r\n        selConnector: null,\r\n        tempConnector: null,\r\n\r\n\r\n\r\n        /**\r\n         * 设置线的不可编辑\r\n         * @param  {[type]} forbidEdit [description]\r\n         * @return {[type]}            [description]\r\n         */\r\n        connectorForbidEdit:function(forbidEdit){\r\n            var that = this;\r\n            for(var i = 0;i < this.connectors.length;i++){\r\n                this.connectors[i].options.isEdit = !forbidEdit;\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * 清空连接线\r\n         * @return {[type]} [description]\r\n         */\r\n        clearSelectCon: function() {\r\n            if (ConnectionManager.selConnector != null) {\r\n                this.refreshConnector(this.selConnector);\r\n            }\r\n        },\r\n        /**\r\n         * 删除连接线\r\n         * @return {[type]} [description]\r\n         */\r\n        deleteSelectCon:function(node,_zr){\r\n            var deleteLine= [];\r\n            for(var i = 0; i < this.connectors.length; i++){\r\n                if(this.connectors[i].startNode == node || this.connectors[i].endNode == node){\r\n                    //1.将线 所联的startNode的outgoing数据删除\r\n                    var startNodeOutgoing = this.connectors[i].startNode.model.get(\"outgoing\");\r\n                    index = zrUtil.indexOf(startNodeOutgoing, this.connectors[i].resourceId);\r\n                    if(index != -1) {\r\n                        startNodeOutgoing.splice(index,1);\r\n                    }\r\n                    //2.从_zr上删除\r\n                    _zr.remove(this.connectors[i]);\r\n                    this.connectors.splice(i, 1);\r\n                    i--;\r\n                    this.selConnector = null;\r\n\r\n                }\r\n            }\r\n        },\r\n        /**\r\n         * 删除选定的线\r\n         * @return {[type]} [description]\r\n         */\r\n        deleteLine:function(_zr){\r\n            //1.将线 所联的startNode的outgoing数据删除\r\n            var startNodeOutgoing = this.selConnector.startNode.model.get(\"outgoing\");\r\n            index = zrUtil.indexOf(startNodeOutgoing, this.selConnector.resourceId);\r\n            if(index != -1) {\r\n                startNodeOutgoing.splice(index,1);\r\n            }\r\n\r\n            if (this.connectorMap) {\r\n                var key = this.getTwoNodeId(this.selConnector.startNode, this.selConnector.endNode);\r\n                this.connectorMap.removeItem(key, this.selConnector);\r\n            }\r\n\r\n            //2.从_zr上删除\r\n            _zr.remove(this.selConnector);\r\n\r\n\r\n            //3.从线数据中删除\r\n            var index = zrUtil.indexOf(this.connectors, this.selConnector);\r\n            if(index != -1) {\r\n                this.connectors.splice(index,1);\r\n            }\r\n            this.selConnector = null;\r\n        },\r\n        /**\r\n         * 重新画线\r\n         * @param  {[type]} connector          [description]\r\n         * @param  {[type]} force\r\n         * @return {[type]}                    [description]\r\n         */\r\n        refreshConnector: function (connector, force) {\r\n            // 只有需要强制刷新  或者 连线为空（<2)时 才进行重新计算重绘\r\n            if( force || (!connector.turningPoints) || (connector.turningPoints.length < 2))\r\n            {\r\n                if (connector.model && connector.model.get(\"style.lineType\")) { connector.options.style.lineType = connector.model.get(\"style.lineType\");}\r\n                var arrStartEndPoint = this.getStartEndPoint(connector);\r\n                var escapeDistance = null;\r\n                if(connector.options.position&&connector.options.position.escapeDistance){\r\n                    escapeDistance = connector.options.position.escapeDistance;\r\n                }\r\n                var solutions = this.connector2Points(connector.options.style.lineType, arrStartEndPoint[0], arrStartEndPoint[1],\r\n                    arrStartEndPoint[2], arrStartEndPoint[3],escapeDistance);  // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n\r\n                connector.refresh(solutions[0][2]);\r\n            }\r\n\r\n            connector.clearHandles();  //清空handle\r\n        },\r\n\r\n\r\n        getStartEndPoint: function(connector) {\r\n            var startNode = connector.startNode;\r\n            var endNode = connector.endNode;\r\n\r\n            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n            var sBounds = [Number(sRect.x), Number(sRect.y), Number(sRect.x) + Number(sRect.width), Number(sRect.y) + Number(sRect.height)];\r\n\r\n            var eRect = endNode.getRect? endNode.getRect().boundingRect : Util.getRect(endNode).boundingRect;\r\n            var eBounds = [Number(eRect.x), Number(eRect.y), Number(eRect.x) + Number(eRect.width), Number(eRect.y) + Number(eRect.height)];\r\n\r\n\r\n            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n            var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n            if (!connector.sPos || !connector.ePos) {\r\n                if (sRect.x < eRect.x) {\r\n                    connector.sPos = \"right\";\r\n                    connector.ePos = \"left\";\r\n                } else {\r\n                    connector.sPos = \"left\";\r\n                    connector.ePos = \"right\";\r\n                }\r\n            }\r\n            var startPoint =  this.calcPointExpression(connector.sPos, sConnectorPoint);\r\n            var endPoint =  this.calcPointExpression(connector.ePos, eConnectorPoint);\r\n            return [startPoint, endPoint,sBounds, eBounds];\r\n        },\r\n\r\n        calcPointExpression: function(pos, point) {\r\n            var variable = {top:point.top.x,\r\n                left: point.left.y,\r\n                right:point.right.y,\r\n                bottom:point.bottom.x,\r\n                center:point.center.x\r\n            };\r\n\r\n            var expression =  \"<% print(\" + pos + \") %>\";\r\n            var val = parseInt(Util.template(expression)(variable));\r\n            if (pos.indexOf(\"top\")!= -1) {\r\n                return new Point(val, point.top.y);\r\n            } else if (pos.indexOf(\"left\")!= -1) {\r\n                return new Point(point.left.x, val);\r\n            } else if (pos.indexOf(\"right\")!= -1) {\r\n                return new Point(point.right.x, val);\r\n            } else if (pos.indexOf(\"bottom\")!= -1) {\r\n                return new Point(val, point.bottom.y);\r\n            } else if (pos.indexOf(\"center\")!= -1) {\r\n                return new Point(val, point.bottom.y);\r\n            }else {\r\n                throw new Error(\"pos参数错误\");\r\n            }\r\n        },\r\n\r\n        /**\r\n         * 创建或修改临时线\r\n         * @param  {[type]} startNode             [description]\r\n         * @param  {[type]} rEndPoint             [description]\r\n         * @param  {[type]} lineType [description]\r\n         * @return {[type]}                       [description]\r\n         */\r\n        manageTempConnector: function(startNode, rEndPoint, lineType) {\r\n\r\n            var sRect = startNode.getRect? startNode.getRect().boundingRect : Util.getRect(startNode).boundingRect;\r\n\r\n            var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n            var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\r\n            if (!ConnectionManager.tempConnector) {\r\n                ConnectionManager.tempConnector = new Connector({isEdit: false, style: {lineType:lineType}});\r\n            }\r\n\r\n            var connector =  ConnectionManager.tempConnector;\r\n            //判断如果没有指定位置的话, 判断开始节点在结束结果左边则采用 right-left 否则采用left-right\r\n            if (sRect.x < rEndPoint.x) {\r\n                connector.sPos = \"right\";\r\n                connector.ePos = \"left\";\r\n            } else {\r\n                connector.sPos = \"left\";\r\n                connector.ePos = \"right\";\r\n            }\r\n\r\n            connector.options.style.lineType = lineType;\r\n            var solutions = this.connector2Points(lineType, sConnectorPoint[connector.sPos], rEndPoint,\r\n                sBounds, null);  // TYPE_STRAIGHT TYPE_JAGGED\r\n\r\n            connector.refresh(solutions[0][2]);\r\n            return connector;\r\n        },\r\n\r\n        /**\r\n         * 删除临时线\r\n         * @param  {[type]} zr             [description]\r\n         */\r\n        removeTempConnector: function(zr) {\r\n            if (ConnectionManager.tempConnector) {\r\n                zr.remove(ConnectionManager.tempConnector);\r\n                ConnectionManager.tempConnector = null;\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n         * 算出 两个节点 指定两个点如何联线\r\n         * @param  {[type]} type       [description]\r\n         * @param  {[type]} startPoint [description]\r\n         * @param  {[type]} endPoint   [description]\r\n         * @param  {[type]} sBounds    [description]\r\n         * @param  {[type]} eBounds    [description]\r\n         * @return {[type]}            [description]\r\n         */\r\n        connector2Points: function(type,  startPoint, endPoint, sBounds, eBounds ,escapeDistance){\r\n            var  figureEscapeDistance = [30, 30];\r\n            if (escapeDistance) {\r\n                if (!zrUtil.isArray(escapeDistance)) {\r\n                    figureEscapeDistance = [escapeDistance, escapeDistance];\r\n                } else {\r\n                    figureEscapeDistance = escapeDistance;\r\n                }\r\n            }\r\n\r\n            Log.group(\"connectionManager: connector2Points\");\r\n\r\n\r\n            Log.info(\"ConnectionManager: connector2Points (\" + type + \", \" + startPoint + \", \" + endPoint + \", \" + sBounds + \", \" + eBounds + ')');\r\n            var solutions = [];\r\n\r\n\r\n\r\n            switch(type){\r\n                case Connector.TYPE_STRAIGHT:  //直线\r\n                    var points = [startPoint.clone(), endPoint.clone()];\r\n                    solutions.push( ['straight', 'straight', points] );\r\n                    break;\r\n\r\n                case Connector.TYPE_CURVE:  //曲线\r\n\r\n                case Connector.TYPE_JAGGED:    //折线\r\n                    var startExitPoint = null;\r\n                    var endExitPoint = null;\r\n\r\n                    //find start exit point  寻找开始出口\r\n                    if(sBounds != null){\r\n                        var potentialExits = [];\r\n\r\n                        potentialExits.push(new Point(startPoint.x, sBounds[1] - figureEscapeDistance[0])); //north 北\r\n                        potentialExits.push(new Point(sBounds[2] + figureEscapeDistance[0], startPoint.y)); //east  东\r\n                        potentialExits.push(new Point(startPoint.x, sBounds[3] + figureEscapeDistance[0])); //south  南\r\n                        potentialExits.push(new Point(sBounds[0] - figureEscapeDistance[0], startPoint.y)); //west  西\r\n\r\n                        //pick closest exit point  寻找与 startPoint 最靠近的出口点\r\n                        startExitPoint = potentialExits[0];\r\n                        for(var i=1; i < potentialExits.length; i++){\r\n                            if(Util.distance(startPoint, potentialExits[i]) < Util.distance(startPoint, startExitPoint)){\r\n                                startExitPoint = potentialExits[i];\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                    //find end exit point  寻找结束出口\r\n                    if(eBounds != null){\r\n                        var potentialExits = [];\r\n\r\n                        potentialExits.push(new Point(endPoint.x, eBounds[1] - figureEscapeDistance[1])); //north\r\n                        potentialExits.push(new Point(eBounds[2] + figureEscapeDistance[1], endPoint.y)); //east\r\n                        potentialExits.push(new Point(endPoint.x, eBounds[3] + figureEscapeDistance[1])); //south\r\n                        potentialExits.push(new Point(eBounds[0] - figureEscapeDistance[1], endPoint.y)); //west\r\n\r\n                        //pick closest exit point  寻找与 endPoint 最靠近的出口点\r\n                        endExitPoint = potentialExits[0];\r\n                        for(var i=1; i < potentialExits.length; i++){\r\n                            if(Util.distance(endPoint, potentialExits[i]) < Util.distance(endPoint, endExitPoint)){\r\n                                endExitPoint = potentialExits[i];\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n                    var s = [startPoint];\r\n                    var gapIndex = 0; //the index of the gap (where do we need to insert new points) DO NOT CHANGE IT\r\n                    if(startExitPoint){\r\n                        s.push(startExitPoint);\r\n                        gapIndex = 1;\r\n                    }\r\n                    if(endExitPoint){\r\n                        s.push(endExitPoint);\r\n                    }\r\n                    s.push(endPoint);\r\n\r\n\r\n\r\n                    //SO - no additional points     S0 解决方案 不添加任何点  基本不会被采用\r\n                    var s0 = Point.cloneArray(s);\r\n                    solutions.push(['s0', 's0', s0]);\r\n\r\n\r\n\r\n                    //S1   S1 解决方案  只有一个折点\r\n                    var s1 = Point.cloneArray(s);\r\n\r\n                    //first variant   第一个变体 s1 s1_1方案  折线点在 startExitPoint的X 与 endExitPoint的 Y位置\r\n                    var s1_1 = Point.cloneArray(s1);\r\n                    s1_1.splice(gapIndex + 1, 0, new Point(s1_1[gapIndex].x , s1_1[gapIndex+1].y) );\r\n                    solutions.push(['s1', 's1_1', s1_1]);\r\n\r\n                    //second variant  第二变体 s1 s1-2方案  折线点在 endExitPoint的X 与  startExitPoint的Y位置\r\n                    var s1_2 = Point.cloneArray(s1);\r\n                    s1_2.splice(gapIndex + 1, 0, new Point(s1_2[gapIndex+1].x , s1_2[gapIndex].y) );\r\n                    solutions.push(['s1', 's1_2', s1_2]);\r\n\r\n\r\n                    //S2  S2 解决方案  添加两个折点\r\n\r\n                    //Variant I   s2_1方案\r\n                    var s2_1 = Point.cloneArray(s);\r\n                    var s2_1_1 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex].y);\r\n                    var s2_1_2 = new Point( (s2_1[gapIndex].x + s2_1[gapIndex+1].x) / 2,  s2_1[gapIndex+1].y);\r\n                    s2_1.splice(gapIndex + 1, 0, s2_1_1, s2_1_2);\r\n                    solutions.push(['s2', 's2_1', s2_1]);\r\n\r\n\r\n                    //Variant II  s2_1方案  1折线点 x: startExitPoint的X 位置 y: startExitPoint的y+endExitPoint的y/2\r\n                    //1折线点 x:endExitPoint的x  y:startExitPoint的y+endExitPoint的y/2\r\n                    var s2_2 = Point.cloneArray(s);\r\n                    var s2_2_1 = new Point( s2_2[gapIndex].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2 );\r\n                    var s2_2_2 = new Point( s2_2[gapIndex+1].x, (s2_2[gapIndex].y + s2_2[gapIndex+1].y)/2);\r\n                    s2_2.splice(gapIndex + 1, 0, s2_2_1, s2_2_2);\r\n                    solutions.push(['s2', 's2_2', s2_2]);\r\n\r\n\r\n                    //Variant III\r\n                    var s2_3 = Point.cloneArray(s);\r\n                    //find the amount (stored in delta) of pixels we need to move right so no intersection with a figure will be present\r\n                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                    var eastExits = [s2_3[gapIndex].x + 20, s2_3[gapIndex+1].x + 20]; //add points X coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                    if(sBounds){\r\n                        eastExits.push(sBounds[2] + 20);\r\n                    }\r\n\r\n                    if(eBounds){\r\n                        eastExits.push(eBounds[2] + 20);\r\n                    }\r\n\r\n                    var eastExit = Util.max(eastExits);\r\n                    var s2_3_1 = new Point( eastExit, s2_3[gapIndex].y );\r\n                    var s2_3_2 = new Point( eastExit, s2_3[gapIndex+1].y );\r\n                    s2_3.splice(gapIndex + 1, 0, s2_3_1, s2_3_2);\r\n                    solutions.push(['s2', 's2_3', s2_3]);\r\n\r\n\r\n                    //Variant IV  s2_4方案\r\n                    var s2_4 = Point.cloneArray(s);\r\n                    //find the amount (stored in delta) of pixels we need to move up so no intersection with a figure will be present\r\n                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                    var northExits = [s2_4[gapIndex].y - 20, s2_4[gapIndex+1].y - 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                    if(sBounds){\r\n                        northExits.push(sBounds[1] - 20);\r\n                    }\r\n\r\n                    if(eBounds){\r\n                        northExits.push(eBounds[1] - 20);\r\n                    }\r\n\r\n                    var northExit = Util.min(northExits);\r\n                    var s2_4_1 = new Point( s2_4[gapIndex].x, northExit);\r\n                    var s2_4_2 = new Point( s2_4[gapIndex+1].x, northExit);\r\n                    s2_4.splice(gapIndex + 1, 0, s2_4_1, s2_4_2);\r\n                    solutions.push(['s2', 's2_4', s2_4]);\r\n\r\n\r\n                    //Variant V\r\n                    var s2_5 = Point.cloneArray(s);\r\n                    //find the amount (stored in delta) of pixels we need to move left so no intersection with a figure will be present\r\n                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                    var westExits = [s2_5[gapIndex].x - 20, s2_5[gapIndex+1].x - 20]; //add points x coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                    if(sBounds){\r\n                        westExits.push(sBounds[0] - 20);\r\n                    }\r\n\r\n                    if(eBounds){\r\n                        westExits.push(eBounds[0] - 20);\r\n                    }\r\n\r\n                    var westExit = Util.min(westExits);\r\n                    var s2_5_1 = new Point( westExit, s2_5[gapIndex].y);\r\n                    var s2_5_2 = new Point( westExit, s2_5[gapIndex+1].y);\r\n                    s2_5.splice(gapIndex + 1, 0, s2_5_1, s2_5_2);\r\n                    solutions.push(['s2', 's2_5', s2_5]);\r\n\r\n\r\n                    //Variant VI\r\n                    var s2_6 = Point.cloneArray(s);\r\n                    //find the amount (stored in delta) of pixels we need to move down so no intersection with a figure will be present\r\n                    //!See:  /documents/specs/connected_figures_deltas.jpg file\r\n\r\n                    var southExits = [s2_6[gapIndex].y + 20, s2_6[gapIndex+1].y + 20]; //add points y coordinates to be able to generate Variant III even in the absence of figures :p\r\n\r\n                    if(sBounds){\r\n                        southExits.push(sBounds[3] + 20);\r\n                    }\r\n\r\n                    if(eBounds){\r\n                        southExits.push(eBounds[3] + 20);\r\n                    }\r\n\r\n                    var southExit = Util.max(southExits);\r\n                    var s2_6_1 = new Point( s2_6[gapIndex].x, southExit);\r\n                    var s2_6_2 = new Point( s2_6[gapIndex+1].x, southExit);\r\n                    s2_6.splice(gapIndex + 1, 0, s2_6_1, s2_6_2);\r\n                    solutions.push(['s2', 's2_6', s2_6]);\r\n\r\n\r\n\r\n                    //FILTER solutions\r\n\r\n                    /*Algorithm\r\n                     * 0. solutions are ordered from minimmun nr of points to maximum >:)\r\n                     * 1. remove all solutions that are not orthogonal (mainly s0 solution)\r\n                     * 2. remove all solutions that go backward (we will not need them ever)\r\n                     * 3. remove all solutions with intersections\r\n                     * 4. pick first class of solutions with same nr of points (ex: 2)\r\n                     * 5. pick the first solution with 90 degree angles (less turnarounds)\r\n                     * (not interesteted) sort by length :p\r\n                     */\r\n\r\n                    //1. filter non ortogonal solutions 删除不是正交直线的方案\r\n                    if(true){\r\n                        Log.info(\"Filter orthogonal solutions. Initial number of solutions = \" + solutions.length);\r\n                        var orthogonalSolution = [];\r\n                        for(var l=0; l<solutions.length; l++){\r\n                            var solution = solutions[l][2];\r\n                            if(Util.orthogonalPath(solution)){\r\n                                orthogonalSolution.push(solutions[l]);\r\n                            }\r\n                        }\r\n                        solutions = orthogonalSolution;\r\n                        Log.info(\"\\n\\tOrthogonalSolutions = \" + solutions.length);\r\n                    }\r\n\r\n                    //2. filter backward solutions  过滤 倒退的方案\r\n                    if(true){\r\n                        //do not allow start and end points to coincide - ignore them\r\n                        if(startPoint.equals(endPoint)){\r\n                            Log.info(\"Start and end point coincide...skip backward solution. I think we will just fall on s0 :)\");\r\n                        }\r\n                        else{\r\n                            Log.info(\"Filter backward solutions. Initial number of solutions = \" + solutions.length);\r\n                            var forwardSolutions = [];\r\n                            var temp = '';\r\n                            for(var l=0; l<solutions.length; l++){\r\n                                var solution = solutions[l][2];\r\n                                if(Util.forwardPath(solution)){\r\n                                    forwardSolutions.push(solutions[l]);\r\n                                }\r\n                                else{\r\n                                    temp = temp +  \"\\n\\t\" + solution;\r\n                                }\r\n                            }\r\n                            solutions = forwardSolutions;\r\n                            Log.info(\"\\n\\t ForwardSolutions = \" + solutions.length);\r\n                            if(solutions.length == 0){\r\n                                Log.info(\"Discarded solutions: \" + temp);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n\r\n                    //3. Filter non intersecting solutions  去除没有交集()的方案\r\n                    if(true){\r\n                        Log.info(\"Filter non intersecting solutions. Initial number of solutions = \" + solutions.length);\r\n                        var nonIntersectionSolutions = []\r\n                        for(var l=0; l<solutions.length; l++){\r\n                            var solution = solutions[l][2];\r\n                            //Log.info(\"Solution id= \" + solutions[l][1] + ' nr points = ' + solution.length + \", points = \" + solution);\r\n                            var intersect = false;\r\n\r\n                            var innerLines = solution.slice(); //just a shallow copy\r\n\r\n                            /*If any bounds just trim the solution. So we avoid the strange case when a connection\r\n                             *startes from a point on a figure and ends inside of the same figure, but not on a connection point*/\r\n                            if(eBounds || sBounds){\r\n                                //i0nnerLines = innerLines.slice(0, innerLines.length - 1);\r\n                                innerLines = innerLines.slice(1, innerLines.length - 1);\r\n                                //Log.info(\"\\t eBounds present,innerLines nr. points = \" + innerLines.length + \", points = \" + innerLines);\r\n                            }\r\n\r\n\r\n\r\n                            //now test for intersection\r\n                            if(sBounds){\r\n                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, sBounds);\r\n                            }\r\n                            if(eBounds){\r\n                                intersect = intersect || Util.polylineIntersectsRectangle(innerLines, eBounds);\r\n                            }\r\n\r\n                            if(!intersect){\r\n                                nonIntersectionSolutions.push(solutions[l]);\r\n                            }\r\n                        }\r\n\r\n                        //If all solutions intersect than this is destiny  :) and just ignore the intersection filter\r\n                        if(nonIntersectionSolutions.length != 0){\r\n                            //reasign to solutions\r\n                            solutions = nonIntersectionSolutions;\r\n                        }\r\n\r\n                        Log.info(\"\\n\\t nonIntersectionSolutions = \" + solutions.length);\r\n                    }\r\n\r\n\r\n                    //4. get first class of solutions with same nr of points 选择与第一个方案点数一样多的方案（因为第一个方案点数最少）\r\n                    if(true){\r\n                        Log.info(\"Get first class of solutions with same nr of points\");\r\n                        if(solutions.length == 0){\r\n                            Log.info(\"This is not possible\");\r\n                        }\r\n\r\n                        var firstSolution = solutions[0][2]; //pick first solution\r\n                        var nrOfPoints = firstSolution.length;\r\n                        var sameNrPointsSolution = [];\r\n\r\n                        for(var l=0; l<solutions.length; l++){\r\n                            var solution = solutions[l][2];\r\n                            if(solution.length == nrOfPoints){\r\n                                sameNrPointsSolution.push(solutions[l]);\r\n                            }\r\n                        }\r\n\r\n                        solutions = sameNrPointsSolution;\r\n                    }\r\n\r\n\r\n\r\n\r\n                    /*5.  计算路径分数 ，取最分数高的\r\n                     Pick the first solution with 90 degree angles (less turnarounds)\r\n                     *in case we have more than one solution in our class\r\n                     */\r\n                    if(true){\r\n                        Log.info(\"pick the first solution with 90 degree angles (less turnarounds)\");\r\n                        var solIndex = 0;\r\n                        for(var l=0; l<solutions.length; l++){\r\n                            var solution = solutions[l][2];\r\n                            if(Util.scorePath( solutions[solIndex][2] ) < Util.scorePath( solutions[l][2] ) ){\r\n                                solIndex = l;\r\n                            }\r\n                        }\r\n                        solutions = [solutions[solIndex]];\r\n                    }\r\n\r\n\r\n                    break;\r\n            }\r\n\r\n            //SMOOTHING curve\r\n            if(type === Connector.TYPE_CURVE){\r\n                this.smoothCurve(solutions);\r\n            }\r\n            //END SMOOTHING curve\r\n\r\n            Log.groupEnd();\r\n\r\n            return solutions;\r\n        },\r\n\r\n        smoothCurve: function(solutions){\r\n            var option = 3;\r\n\r\n            switch(option){\r\n                case 0:\r\n                    //do nothing\r\n                    break;\r\n\r\n                case 1: //add intermediate points\r\n                    //Add the middle point for start and end segment so that we \"force\" the\r\n                    //curve to both come \"perpendicular\" on bounds and also make the curve\r\n                    //\"flee\" more from bounds (on exit)\r\n                    for(var s=0; s<solutions.length; s++){\r\n                        var solTurningPoints = solutions[s][2];\r\n\r\n                        //first segment\r\n                        var a1 = solTurningPoints[0];\r\n                        var a2 = solTurningPoints[1];\r\n                        var startMiddlePoint = Util.getMiddle(a1, a2);\r\n                        solTurningPoints.splice(1,0, startMiddlePoint);\r\n\r\n                        //last segment\r\n                        var a3 = solTurningPoints[solTurningPoints.length - 2];\r\n                        var a4 = solTurningPoints[solTurningPoints.length - 1];\r\n                        var endMiddlePoint = Util.getMiddle(a3, a4);\r\n                        solTurningPoints.splice(solTurningPoints.length - 1, 0, endMiddlePoint);\r\n                    }\r\n                    break;\r\n\r\n                case 2: //remove points\r\n                    for(var s=0; s<solutions.length; s++){\r\n                        var solType= solutions[s][0];\r\n                        if(solType == 's1' || solType == 's2'){\r\n                            var solTurningPoints = solutions[s][2];\r\n                            solTurningPoints.splice(1,1);\r\n                            solTurningPoints.splice(solTurningPoints.length - 2, 1);\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                case 3:\r\n                    /*remove colinear point for s1 as it seems that more colinear points do not look good\r\n                     * on organic solutions >:D*/\r\n                    for(var s=0; s<solutions.length; s++){\r\n                        var solType= solutions[s][0];\r\n                        if(solType == 's1'){\r\n                            var solTurningPoints = solutions[s][2];\r\n                            var reducedSolution = Util.collinearReduction(solTurningPoints);\r\n                            solutions[s][2] = reducedSolution;\r\n                        }\r\n                    }\r\n                    break;\r\n            }//end switch\r\n\r\n        }\r\n    };\r\n    module.exports = ConnectionManager;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/manager/ConnectionManager.js\n ** module id = 84\n ** module chunks = 0\n **/","/**\r\n * 日志类\r\n * @author wang.xiaohu\r\n */\r\n\r\n\r\n    var Log  = {\r\n        LOG_LEVEL_NONE  : 0,\r\n\r\n        LOG_LEVEL_DEBUG : 1,\r\n\r\n        LOG_LEVEL_INFO : 2,\r\n\r\n        LOG_LEVEL_ERROR : 3,\r\n\r\n        level : this.LOG_LEVEL_ERROR,\r\n        \r\n        /**\r\n        * The less important of all messages\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        debug: function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_DEBUG){\r\n                    \r\n                    //in FF is debug\r\n                    if(typeof console.debug == 'function'){\r\n                        console.debug(message);\r\n                    }\r\n                    else{//TODO: in IE is log\r\n    //                    console.info(message);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n\r\n        /**\r\n        * The commonly used log message\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        info : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_INFO){\r\n                    console.info(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n        * The worse kind of message. Usually a crash\r\n        * @param {String} message - the message to be logged\r\n        **/\r\n        error : function (message){\r\n            if(typeof console !== 'undefined'){\r\n                if(this.level <= this.LOG_LEVEL_ERROR){\r\n                    console.error(message);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         *Start grouping the log messages\r\n         *@param {String} title - the title of the group\r\n         *@see <a href=\"http://getfirebug.com/logging\">http://getfirebug.com/logging</a>\r\n         **/\r\n        group : function(title){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){           \r\n                    /**If we do not test for group() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.group === 'function'){\r\n                        console.group(title);\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        /**Ends current message grouping*/\r\n        groupEnd : function(){\r\n            if(this.level <= this.LOG_LEVEL_INFO){ //ignore group if level not debug or info\r\n                if(typeof console !== 'undefined'){\r\n                    /**If we do not test for groupEnd() function you will get an error in Opera\r\n                     *as Opera has it's own console...which does not have a group() function*/\r\n                    if(typeof console.groupEnd === 'function'){\r\n                        console.groupEnd();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    //Log.level = Log.LOG_LEVEL_DEBUG; \r\n    Log.level = Log.LOG_LEVEL_ERROR; \r\n    //Log.level = Log.LOG_LEVEL_ERROR;\r\n    //Log.level = Log.LOG_LEVEL_NONE;\r\n    module.exports = Log;\r\n    \r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Log.js\n ** module id = 85\n ** module chunks = 0\n **/","/**\r\n * 常量定义\r\n */\r\n\r\n\tmodule.exports = \t{\r\n\t\tELEMENT_TYPE: \"elementType\",\r\n\t\tMODE: \"mode\",\r\n\t\tBACKGROUND: \"backgroud\",\r\n\t\tOPTIONS: \"options\",\r\n\t\tUSERDATA: \"userData\",\r\n\t\tID: \"id\",\r\n\t\tSTART_ID: \"startNodeId\",\r\n\t\tEND_ID: \"endNodeId\",\r\n\t\tALARM: \"Alarm\",\r\n\t\tRELATIONID:\"relationId\",\r\n\t\tRELATION_IMAGE:\"relationImage\",\r\n\t\tGROUP: \"Group\",\r\n\t\tCONNECTION: \"connection\",\r\n\t\tCHILDS: \"childs\",\r\n\t\tTREE_ROOT: \"treeRoot\",\r\n\t\tDOCKERS:\"options.dockers\",\r\n\t\tSTYLE_LINETYPE:\"style.lineType\",\r\n\t\tLINEOPERATIONICON:\"LineOperationIcon\",\r\n\t};\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/util/FlowConstants.js\n ** module id = 86\n ** module chunks = 0\n **/","/**\r\n * 节点等的模型\r\n * 里面存的数据用来处理序列化和反序列化\r\n * @class fish.topo.model\r\n */\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var clazzUtil = require('./clazz');\r\n\r\n    function Model(option, parentModel,  extraOpt) {\r\n        this.parentModel = parentModel;\r\n        this.option = option;\r\n\r\n        // Simple optimization\r\n        if (this.init) {\r\n            if (arguments.length <= 3) {\r\n                this.init(option, parentModel,  extraOpt);\r\n            }\r\n            else {\r\n                this.init.apply(this, arguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    Model.prototype = {\r\n\r\n        constructor: Model,\r\n\r\n        /**\r\n         * Model 的初始化函数\r\n         * @private\r\n         * @param {Object} option\r\n         */\r\n        init: function (option) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        mergeOption: function (option) {\r\n            zrUtil.merge(this.option, option, true);\r\n        },\r\n\r\n        /**\r\n         * 获取model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.get(\"options.text\");\r\n         */\r\n        get: function (path, ignoreParent) {\r\n            if (!path) {\r\n                return this.option;\r\n            }\r\n\r\n            if (typeof path === 'string') {\r\n                path = path.split('.');\r\n            }\r\n\r\n            var obj = this.option;\r\n            var parentModel = this.parentModel;\r\n            for (var i = 0; i < path.length; i++) {\r\n                // obj could be number/string/... (like 0)\r\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n                if (obj == null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (obj == null && parentModel && !ignoreParent) {\r\n                obj = parentModel.get(path);\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        /**\r\n         * 设置model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @param {String} value 所需要设置的值\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.set(\"options.text\",\"例子\");\r\n         */\r\n        set: function (path, value) {\r\n            var obj = this.option;\r\n\r\n            if (path.indexOf(\".\") == -1) {\r\n                obj[path] = value;\r\n            } else {\r\n                var fieldArray  = path.split('.');\r\n                var n = fieldArray.length;\r\n                var currentRef = obj;\r\n                var fieldName;\r\n\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    fieldName = fieldArray[i];\r\n                    if(currentRef[fieldName] == null) {\r\n                        currentRef[fieldName] = {};\r\n                    }\r\n                    currentRef = currentRef[fieldName];\r\n                }\r\n                fieldName = fieldArray[n-1];\r\n                currentRef[fieldName] = value;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getShallow: function (key, ignoreParent) {\r\n            var option = this.option;\r\n            var val = option && option[key];\r\n            var parentModel = this.parentModel;\r\n            if (val == null && parentModel && !ignoreParent) {\r\n                val = parentModel.getShallow(key);\r\n            }\r\n            return val;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getModel: function (path, parentModel) {\r\n            var obj = this.get(path, true);\r\n            var thisParentModel = this.parentModel;\r\n            var model = new Model(\r\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n            );\r\n            return model;\r\n        },\r\n\r\n        /**\r\n         *清空model的option\r\n         * @private\r\n         */\r\n        isEmpty: function () {\r\n            return this.option == null;\r\n        },\r\n\r\n        restoreData: function () {},\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        clone: function () {\r\n            var Ctor = this.constructor;\r\n            return new Ctor(zrUtil.clone(this.option));\r\n        }\r\n    };\r\n\r\n    // Enable Model.extend.\r\n    clazzUtil.enableClassExtend(Model);\r\n\r\n    module.exports = Model;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/model.js\n ** module id = 87\n ** module chunks = 0\n **/","\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var clazz = {};\r\n\r\n    var TYPE_DELIMITER = '.';\r\n    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n    /**\r\n     * @public\r\n     */\r\n    var parseClassType = clazz.parseClassType = function (componentType) {\r\n        var ret = {main: '', sub: ''};\r\n        if (componentType) {\r\n            componentType = componentType.split(TYPE_DELIMITER);\r\n            ret.main = componentType[0] || '';\r\n            ret.sub = componentType[1] || '';\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n     */\r\n    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n        RootClass.extend = function (proto) {\r\n            var ExtendedClass = function () {\r\n                preConstruct && preConstruct.apply(this, arguments);\r\n                RootClass.apply(this, arguments);\r\n            };\r\n\r\n            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\r\n            ExtendedClass.extend = this.extend;\r\n            ExtendedClass.superCall = superCall;\r\n            ExtendedClass.superApply = superApply;\r\n            zrUtil.inherits(ExtendedClass, this);\r\n            ExtendedClass.superClass = this;\r\n\r\n            return ExtendedClass;\r\n        };\r\n    };\r\n\r\n    // superCall should have class info, which can not be fetch from 'this'.\r\n    // Consider this case:\r\n    // class A has method f,\r\n    // class B inherits class A, overrides method f, f call superApply('f'),\r\n    // class C inherits class B, do not overrides method f,\r\n    // then when method of class C is called, dead loop occured.\r\n    function superCall(context, methodName) {\r\n        var args = zrUtil.slice(arguments, 2);\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    function superApply(context, methodName, args) {\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    /**\r\n     * @param {Object} entity\r\n     * @param {Object} options\r\n     * @param {boolean} [options.registerWhenExtend]\r\n     * @public\r\n     */\r\n    clazz.enableClassManagement = function (entity, options) {\r\n        options = options || {};\r\n\r\n        /**\r\n         * Component model classes\r\n         * key: componentType,\r\n         * value:\r\n         *     componentClass, when componentType is 'xxx'\r\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n         * @type {Object}\r\n         */\r\n        var storage = {};\r\n\r\n        entity.registerClass = function (Clazz, componentType) {\r\n            if (componentType) {\r\n                componentType = parseClassType(componentType);\r\n\r\n                if (!componentType.sub) {\r\n                    if (storage[componentType.main]) {\r\n                        //已经注册过了，直接返回\r\n                        return;\r\n                    }\r\n                    storage[componentType.main] = Clazz;\r\n                }\r\n                else if (componentType.sub !== IS_CONTAINER) {\r\n                    var container = makeContainer(componentType);\r\n                    container[componentType.sub] = Clazz;\r\n                }\r\n            }\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n            var Clazz = storage[componentTypeMain];\r\n\r\n            if (Clazz && Clazz[IS_CONTAINER]) {\r\n                Clazz = subType ? Clazz[subType] : null;\r\n            }\r\n\r\n            if (throwWhenNotFound && !Clazz) {\r\n                throw new Error(\r\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n                );\r\n            }\r\n\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClassesByMainType = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n\r\n            var result = [];\r\n            var obj = storage[componentType.main];\r\n\r\n            if (obj && obj[IS_CONTAINER]) {\r\n                zrUtil.each(obj, function (o, type) {\r\n                    type !== IS_CONTAINER && result.push(o);\r\n                });\r\n            }\r\n            else {\r\n                result.push(obj);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        entity.hasClass = function (componentType) {\r\n            // Just consider componentType.main.\r\n            componentType = parseClassType(componentType);\r\n            return !!storage[componentType.main];\r\n        };\r\n\r\n        /**\r\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n         */\r\n        entity.getAllClassMainTypes = function () {\r\n            var types = [];\r\n            zrUtil.each(storage, function (obj, type) {\r\n                types.push(type);\r\n            });\r\n            return types;\r\n        };\r\n\r\n        /**\r\n         * If a main type is container and has sub types\r\n         * @param  {string}  componentType\r\n         * @return {boolean}\r\n         */\r\n        entity.hasSubTypes = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n            var obj = storage[componentType.main];\r\n            return obj && obj[IS_CONTAINER];\r\n        };\r\n\r\n        entity.parseClassType = parseClassType;\r\n\r\n        function makeContainer(componentType) {\r\n            var container = storage[componentType.main];\r\n            if (!container || !container[IS_CONTAINER]) {\r\n                container = storage[componentType.main] = {};\r\n                container[IS_CONTAINER] = true;\r\n            }\r\n            return container;\r\n        }\r\n\r\n        if (options.registerWhenExtend) {\r\n            var originalExtend = entity.extend;\r\n            if (originalExtend) {\r\n                entity.extend = function (proto) {\r\n                    var ExtendedClass = originalExtend.call(this, proto);\r\n                    return entity.registerClass(ExtendedClass, proto.type);\r\n                };\r\n            }\r\n        }\r\n\r\n        return entity;\r\n    };\r\n\r\n    module.exports = clazz;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/clazz.js\n ** module id = 88\n ** module chunks = 0\n **/","\r\n\r\n    var forceHelper = require('./forceHelper');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect.js');\r\n    var Util = require('../../../fish-topo-core/lib/util');\r\n    var ConnectionManager = require(\"../../../fish-topo-core/lib/manager/ConnectionManager.js\");\r\n\r\n    /**\r\n     * 力导向布局\r\n     * @param  {[type]} allNodes   [所有节点]\r\n     * @param  {[type]} allCons    [所有线]\r\n     * @param  {[type]} repulsion  [节点之间的斥力因子。该值越大节点之间的斥力越大，两个节点间的距离也会越远。]\r\n     * @param  {[type]} edgeLength [边的两个节点之间的距离，这个距离也会受 repulsion。]\r\n     * @param  {[type]} gravity    [节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。]\r\n     * @return {[type]}            [description]\r\n     */\r\n    module.exports = function(forceLayoutOption) {\r\n        var repulsion = forceLayoutOption.repulsion || 100;\r\n        var gravity = forceLayoutOption.gravity || 0.1;\r\n        var edgeLength = forceLayoutOption.edgeLength || 30;\r\n        var preservedPoints = forceLayoutOption.preservedPoints || {};\r\n        var allNodes = this.forceLayoutOption.allNodes;\r\n        var allCons = this.forceLayoutOption.allCons;\r\n        var rect = this.forceLayoutOption.rect;\r\n        var nodes = _.map(allNodes, function(node, idx) {\r\n            var rep = repulsion; node.w = rep; node.rep = rep; node.p = null;\r\n            return {\r\n                w: rep,\r\n                rep: rep,\r\n                p: null\r\n            };\r\n        });\r\n\r\n        var edges = _.map(allCons, function(con, idx) {\r\n            con.n1 = con.startNode;\r\n            con.n2 = con.endNode;\r\n            con.d = edgeLength;\r\n            con.curveness = 0;\r\n            return {\r\n                n1: con.startNode,\r\n                n2: con.endNode,\r\n                d: edgeLength,\r\n                curveness: 0\r\n            };\r\n        });\r\n\r\n        var forceInstance = forceHelper(allNodes, allCons, {\r\n            rect: rect,\r\n            gravity: gravity\r\n        });\r\n        var oldStep = forceInstance.step;\r\n        forceInstance.step = function(cb) {\r\n            for (var i = 0, l = allNodes.length; i < l; i++) {\r\n                if (nodes[i].fixed) {\r\n                    // Write back to layout instance\r\n                    vec2.copy(nodes[i].p, nodes[i].position);\r\n                }\r\n            }\r\n            oldStep(function(allNodes, allCons, stopped) {\r\n                for (var i = 0, l = allNodes.length; i < l; i++) {\r\n                    if (!allNodes[i].fixed) {\r\n                        allNodes[i].attr(\"position\", allNodes[i].p);\r\n                    }\r\n                    preservedPoints[i] = allNodes[i].p;\r\n                }\r\n                for (var i = 0, l = allCons.length; i < l; i++) {\r\n                    // var e = allCons[i];\r\n                    // var p1 = e.n1.p;\r\n                    // var p2 = e.n2.p;\r\n                    // var points = [p1, p2];\r\n                    // if (e.curveness > 0) {\r\n                    //     points.push([\r\n                    //         (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,\r\n                    //         (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness\r\n                    //     ]);\r\n                    // }\r\n                    // var newPoints = Util.traslatePoints(points, true);\r\n                    // e.refresh(newPoints);\r\n                    ConnectionManager.refreshConnector(allCons[i], true);\r\n                }\r\n                // Update layout\r\n\r\n                cb && cb(stopped);\r\n            });\r\n        };\r\n        forceLayoutOption.forceLayout = forceInstance;\r\n        forceLayoutOption.preservedPoints = preservedPoints;\r\n        // Step to get the layout\r\n        forceInstance.step();\r\n    }\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/layout/forceLayout.js\n ** module id = 89\n ** module chunks = 0\n **/","\r\n\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var scaleAndAdd = vec2.scaleAndAdd;\r\n\r\n    // function adjacentNode(n, e) {\r\n    //     return e.n1 === n ? e.n2 : e.n1;\r\n    // }\r\n\r\n    module.exports = function (nodes, edges, opts) {\r\n        var rect = opts.rect;\r\n        var width = rect.width;\r\n        var height = rect.height;\r\n        var center = [rect.x + width / 2, rect.y + height / 2];\r\n        // var scale = opts.scale || 1;\r\n        var gravity = opts.gravity == null ? 0.1 : opts.gravity;\r\n\r\n        // for (var i = 0; i < edges.length; i++) {\r\n        //     var e = edges[i];\r\n        //     var n1 = e.n1;\r\n        //     var n2 = e.n2;\r\n        //     n1.edges = n1.edges || [];\r\n        //     n2.edges = n2.edges || [];\r\n        //     n1.edges.push(e);\r\n        //     n2.edges.push(e);\r\n        // }\r\n        // Init position\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            var n = nodes[i];\r\n            if (!n.p) {\r\n                // Use the position from first adjecent node with defined position\r\n                // Or use a random position\r\n                // From d3\r\n                // if (n.edges) {\r\n                //     var j = -1;\r\n                //     while (++j < n.edges.length) {\r\n                //         var e = n.edges[j];\r\n                //         var other = adjacentNode(n, e);\r\n                //         if (other.p) {\r\n                //             n.p = vec2.clone(other.p);\r\n                //             break;\r\n                //         }\r\n                //     }\r\n                // }\r\n                // if (!n.p) {\r\n                    n.p = vec2.create(\r\n                        width * (Math.random() - 0.5) + center[0],\r\n                        height * (Math.random() - 0.5) + center[1]\r\n                    );\r\n                // }\r\n            }\r\n            n.pp = vec2.clone(n.p);\r\n            n.edges = null;\r\n        }\r\n\r\n        // Formula in 'Graph Drawing by Force-directed Placement'\r\n        // var k = scale * Math.sqrt(width * height / nodes.length);\r\n        // var k2 = k * k;\r\n\r\n        var friction = 0.6;\r\n\r\n        return {\r\n            warmUp: function () {\r\n                friction = 0.5;\r\n            },\r\n\r\n            setFixed: function (idx) {\r\n                nodes[idx].fixed = true;\r\n            },\r\n\r\n            setUnfixed: function (idx) {\r\n                nodes[idx].fixed = false;\r\n            },\r\n\r\n            step: function (cb) {\r\n                var v12 = [];\r\n                var nLen = nodes.length;\r\n                for (var i = 0; i < edges.length; i++) {\r\n                    var e = edges[i];\r\n                    var n1 = e.n1;\r\n                    var n2 = e.n2;\r\n\r\n                    vec2.sub(v12, n2.p, n1.p);\r\n                    var d = vec2.len(v12) - e.d;\r\n                    var w = n2.w / (n1.w + n2.w);\r\n                    vec2.normalize(v12, v12);\r\n\r\n                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);\r\n                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);\r\n                }\r\n                // Gravity\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v12, center, n.p);\r\n                        // var d = vec2.len(v12);\r\n                        // vec2.scale(v12, v12, 1 / d);\r\n                        // var gravityFactor = gravity;\r\n                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);\r\n                    }\r\n                }\r\n\r\n                // Repulsive\r\n                // PENDING\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n1 = nodes[i];\r\n                    for (var j = i + 1; j < nLen; j++) {\r\n                        var n2 = nodes[j];\r\n                        vec2.sub(v12, n2.p, n1.p);\r\n                        var d = vec2.len(v12);\r\n                        if (d === 0) {\r\n                            // Random repulse\r\n                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);\r\n                            d = 1;\r\n                        }\r\n                        var repFact = (n1.rep + n2.rep) / d / d;\r\n                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);\r\n                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);\r\n                    }\r\n                }\r\n                var v = [];\r\n                for (var i = 0; i < nLen; i++) {\r\n                    var n = nodes[i];\r\n                    if (!n.fixed) {\r\n                        vec2.sub(v, n.p, n.pp);\r\n                        vec2.scaleAndAdd(n.p, n.p, v, friction);\r\n                        vec2.copy(n.pp, n.p);\r\n                    }\r\n                }\r\n\r\n                friction = friction * 0.992;\r\n\r\n                cb && cb(nodes, edges, friction < 0.01);\r\n            }\r\n        };\r\n    }\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/layout/forceHelper.js\n ** module id = 90\n ** module chunks = 0\n **/","\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var ConnectionManager = require(\"../manager/FlowConnectionManager.js\");\r\n    module.exports = function (option) {\r\n        function checkNode(dom){\r\n            dom.treeType = option.type;\r\n            dom.model.set(\"options.treeType\",option.type);\r\n            //1、根据连线  找出起始节点 所有的子结节\r\n            var childrenNode = [];\r\n            for(var i = 0;i < ConnectionManager.connectors.length; i++){\r\n                if(ConnectionManager.connectors[i].startNode == dom){\r\n                    childrenNode.push(ConnectionManager.connectors[i].endNode);\r\n                }\r\n            };\r\n            if(childrenNode.length > 0){\r\n\r\n\r\n                // 2. 遍历子结点\r\n                for(var m = 0;m < childrenNode.length;m++){\r\n                    childrenNode[m].treeType = option.type;\r\n                    var x,y;\r\n                    if(option.type == \"horizontal\"){\r\n                        var average =dom.layout.height;\r\n                        // 2.1 父结点 如果圆形 作不同的处理\r\n                        if(dom instanceof graphic.Circle){\r\n                            //2.2 子节点 如果是圆形  vv\r\n                            if(childrenNode[m] instanceof graphic.Circle){\r\n                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m;\r\n                                x = dom.position[0]+dom.layout.width;\r\n                            }else if(childrenNode[m] instanceof graphic.Image){\r\n                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;\r\n                                x = dom.position[0]+dom.layout.width-childrenNode[m].style.width/2\r\n                            }else{\r\n                                y = dom.position[1]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;\r\n                                x = dom.position[0]+dom.layout.width-childrenNode[m].shape.width/2\r\n                            }\r\n\r\n                        }else{\r\n                            if(childrenNode[m] instanceof graphic.Circle){\r\n                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m;\r\n                                x = dom.position[0]+dom.shape.width/2+dom.layout.width;\r\n                            }else if(childrenNode[m] instanceof graphic.Image){\r\n                                y = dom.position[1]+dom.style.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.height/2;\r\n                                x = dom.position[0]+dom.style.width/2+dom.layout.width-childrenNode[m].style.width/2\r\n                            }else{\r\n                                y = dom.position[1]+dom.shape.height/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.height/2;\r\n                                x = dom.position[0]+dom.shape.width/2+dom.layout.width-childrenNode[m].shape.width/2\r\n                            }\r\n                        }\r\n                    }else{\r\n                        var average =dom.layout.width;\r\n                        // 2.1 父结点 如果圆形 作不同的处理\r\n                        if(dom instanceof graphic.Circle){\r\n                            //2.2 子节点 如果是圆形  vv\r\n                            if(childrenNode[m] instanceof graphic.Circle){\r\n                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m;\r\n                                y = dom.position[1]+dom.layout.height;\r\n                            }else if(childrenNode[m] instanceof graphic.Image){\r\n                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;\r\n                                y = dom.position[1]+dom.layout.height-childrenNode[m].style.height/2\r\n                            }else{\r\n                                x = dom.position[0]-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;\r\n                                y = dom.position[1]+dom.layout.height-childrenNode[m].shape.height/2\r\n                            }\r\n\r\n                        }else{\r\n                            if(childrenNode[m] instanceof graphic.Circle){\r\n                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m;\r\n                                y = dom.position[1]+dom.shape.height/2+dom.layout.height;\r\n                            }else if(childrenNode[m] instanceof graphic.Image){\r\n                                x = dom.position[0]+dom.style.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].style.width/2;\r\n                                y = dom.position[1]+dom.style.height/2+dom.layout.height-childrenNode[m].style.height/2\r\n                            }else{\r\n                                x = dom.position[0]+dom.shape.width/2-average*(childrenNode.length-1)/2+average*m-childrenNode[m].shape.width/2;\r\n                                y = dom.position[1]+dom.shape.height/2+dom.layout.height-childrenNode[m].shape.height/2\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    childrenNode[m].attr(\"position\", [x,y]);\r\n                }\r\n                // 3. 节点位置变化，刷新线\r\n                ConnectionManager.refreshLineByNode(dom);\r\n            }\r\n            // 4.递归 子节点\r\n            for(var j = 0;j < childrenNode.length;j++){\r\n                checkNode(childrenNode[j]);\r\n            }\r\n        }\r\n        checkNode(option.node);\r\n    }\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/layout/treeLayout.js\n ** module id = 91\n ** module chunks = 0\n **/","/**\r\n * Flow工具类\r\n */\r\n\r\n    var Model = require(\"../../../fish-topo-core/lib/model.js\");\r\n    var Constants = require(\"./FlowConstants.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var GroupNode = require(\"../node/GroupNode.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n    /**\r\n     * 根据结点数组 导出JSON格式的数据\r\n     *\r\n     * @param {Array} model 总的模型\r\n     * @return {JSON} JSON格式的数据\r\n     */\r\n    function toJson(model, group) {\r\n        var jsonArr = [];\r\n        group.eachChild(function(node) {\r\n            if (node.model) {\r\n                //如果是组的话\r\n                if (node instanceof GroupNode) {\r\n                    var childArr = [];\r\n                    node.eachChild(function(childNode) {\r\n                        if (childNode.model) {\r\n                            childArr.push(childNode.model.option);\r\n                        };\r\n                    });\r\n                    node.model.set(Constants.CHILDS, childArr);\r\n                };\r\n                if (node instanceof Connector) {\r\n                    node.refreshModel();\r\n                };\r\n                jsonArr.push(node.model.option);\r\n\r\n            }\r\n\r\n\r\n        })\r\n        model.set(Constants.CHILDS, jsonArr);\r\n        return model.option;\r\n    }\r\n\r\n    /**\r\n     * 根据 JSON 生成节点\r\n     * @param  {[type]} fishTopoflow [description]\r\n     * @param  {[type]} json         [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function fromJson(fishTopoflow, group, childShapes, isChild, layoutRootNode) {\r\n        // 1.清空画布\r\n\r\n        var connectors = [];\r\n        // 2.先创建节点  遍历形状 获取模型\r\n\r\n\r\n        for (var i = 0; i < childShapes.length; i++) {\r\n            var shape = childShapes[i];\r\n            if (shape.elementType === Constants.CONNECTION) {\r\n                connectors.push(shape);\r\n            }\r\n            else if (shape.elementType === Constants.ALARM) {\r\n                var relationNode = findNodeById(fishTopoflow.group, shape.relationId);\r\n                fishTopoflow.creatAlarm(relationNode, shape.options);\r\n            }\r\n            else if (shape.elementType === Constants.GROUP) {\r\n                shape.options.id = shape.id;\r\n                var group = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);\r\n                fromJson(fishTopoflow, group, shape.childs, true, layoutRootNode);\r\n\r\n                fishTopoflow.addNode(group);\r\n\r\n\r\n            }\r\n            else {\r\n                // 将模型中的id 传递给创建的节点\r\n                shape.options.id = shape.id;\r\n                var node = fishTopoflow.creatNode(shape.elementType, shape.options, shape.userData);\r\n                if (isChild) {\r\n                    group.add(node);\r\n                } else {\r\n                    fishTopoflow.addNode(node);\r\n                }\r\n\r\n                if (shape.options.layout) {\r\n                    if (shape.options.layout.layout === Constants.TREE_ROOT) {\r\n                        var node = findNodeById(group, shape.id)\r\n                        layoutRootNode.push(node);\r\n                          //  fishTopo.layoutNode(\"tree\",{\"node\":node});\r\n                    };\r\n                };\r\n\r\n            };\r\n\r\n\r\n\r\n        };\r\n\r\n        // 3. 再创建线\r\n        for(var i = 0, len = connectors.length; i < len; i++) {\r\n            var line = connectors[i];\r\n            var startNode = findNodeById(group, line.startNodeId);\r\n            var endNode = findNodeById(group, line.endNodeId);\r\n            if (startNode && endNode) {\r\n                var link = fishTopoflow.creatLink(startNode,endNode,line.options,line.userData);\r\n                if (isChild) {\r\n                    group.add(link);\r\n                } else {\r\n                    fishTopoflow.addNode(link);\r\n                }\r\n                // 为了 线上点击之后显示那些附加的小图标\r\n                link.on(\"click\",function(){\r\n                    for(var i = 0;i < line.icons.length;i++){\r\n                        if (line.icons[i][0] == 'delete') {\r\n                            fishTopoflow.addLineDeleteIcon(link);\r\n                        }else if(line.icons[i][0] == 'change'){\r\n                            fishTopoflow.addLineChangeIcon(link);\r\n                        }else{\r\n                            fishTopoflow.addIcon(line.icons[i][0],{\r\n                                icon:line.icons[i][1].icon,\r\n                                width: line.icons[i][1].width,\r\n                                height: line.icons[i][1].height,\r\n                                lineNode:link\r\n                            })\r\n                        }\r\n\r\n                    }\r\n                })\r\n\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 根据id在group中查找\r\n     * @param  {[type]} group  [description]\r\n     * @param  {[type]} nodeId [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function findNodeById (group, nodeId) {\r\n        var retNode = null;\r\n        group.eachChild(function(node) {\r\n            if (node.model && node.model.get(Constants.ID) === nodeId) {\r\n                retNode = node;\r\n            };\r\n        })\r\n        return retNode;\r\n    }\r\n\r\n\r\n    /**\r\n     * Get canvas which has all thing rendered\r\n     * @param {Object} opts\r\n     * @param {string} [opts.backgroundColor]\r\n     */\r\n    function getRenderedCanvas(zr, opts) {\r\n        opts = opts || {};\r\n        opts.pixelRatio = opts.pixelRatio || 1;\r\n        opts.backgroundColor = opts.backgroundColor\r\n            || \"#FFFFFF\";\r\n        var list = zr.storage.getDisplayList();\r\n        // Stop animations\r\n        zrUtil.each(list, function (el) {\r\n            el.stopAnimation(true);\r\n        });\r\n        return zr.painter.getRenderedCanvas(opts);\r\n    }\r\n\r\n    function toDataURL (zr, opts) {\r\n        opts = opts || {};\r\n        var url = getRenderedCanvas(zr, opts).toDataURL(\r\n            'image/' + (opts && opts.type || 'png')\r\n        );\r\n        return url;\r\n    }\r\n\r\n\r\n    function initNodeEvent (node, api) {\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\r\n\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            node.on(eveName, function (e) {\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = eveName;\r\n                params.target = node;\r\n                api.trigger(eveName, params);\r\n            });\r\n        });\r\n    }\r\n\r\n    module.exports = {\r\n        toJson: toJson,\r\n        fromJson: fromJson,\r\n        toDataURL:toDataURL\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/util/FlowUtil.js\n ** module id = 92\n ** module chunks = 0\n **/","/**\r\n * 连线操作类\r\n * @author miao.cunzhi\r\n */\r\n\r\n\tvar Node = require(\"../Node\");\r\n\tvar Util = require('../util');\r\n\tvar graphic = require(\"../graphic.js\");\r\n    var Point = require(\"../Point.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var ConnectionManager = require('./ConnectionManager.js');\r\n    var LineOperationManager = {\r\n        LineOperations:[],\r\n        isEdit:true,\r\n        creatOperation:function(key,obj,api){\r\n            var lineOperation = new graphic.Image({\r\n                style: {\r\n                    image:obj.icon,\r\n                    width: obj.width||15,\r\n                    height: obj.height||15\r\n                }\r\n            });\r\n            lineOperation.key = key;\r\n            lineOperation.operation = true;\r\n            lineOperation.hide();\r\n            obj.lineNode.icons.push(lineOperation);\r\n            LineOperationManager.LineOperations.push(lineOperation);\r\n\r\n            //小图标 点击事件  如果有回调则调用回调，否则派发事件\r\n            lineOperation.on(\"click\",function(e){\r\n                if(obj.callback){\r\n                    obj.callback(obj.lineNode);\r\n                } else {\r\n                    var params = {};\r\n                    params.event = e;\r\n                    params.type = \"click\";\r\n                    params.elementType = \"LineOperationIcon\";\r\n                    api.trigger(params.type, params);\r\n                }\r\n\r\n            });\r\n            return lineOperation;\r\n        },\r\n\r\n        /**\r\n         * 计算小图标的位置，并显示\r\n         * @param  {[type]} connector [description]\r\n         * @return {[type]}           [description]\r\n         */\r\n        bindOperation:function(connector){\r\n            if(LineOperationManager.isEdit == false){return;}\r\n            var pointPosition = connector.middle();\r\n            var length = [];\r\n            for(var j = 0; j < connector.icons.length; j++){\r\n                length.push(connector.icons[j].style.width);\r\n            }\r\n            var totalLength = 0;\r\n            for(var m = 0; m < connector.icons.length; m++){\r\n                    totalLength += length[m]+10;\r\n            }\r\n            for(var i = 0; i < connector.icons.length; i++){\r\n                var connectorPosition = 0;\r\n                for(var k = 0; k < i; k++){\r\n                    connectorPosition += length[k]+10;\r\n                }\r\n                connector.icons[i].attr(\"position\",[pointPosition[0]+connectorPosition-totalLength/2,pointPosition[1]+5]);\r\n                connector.icons[i].show();\r\n            }\r\n        },\r\n\r\n        hideAllLineOperation: function() {\r\n            for (var li = 0; li < LineOperationManager.LineOperations.length; li++) {\r\n                var icon =  LineOperationManager.LineOperations[li];\r\n                icon.hide();\r\n            }\r\n        },\r\n\r\n        addIcon: function(key, obj, zr, api) {\r\n            //判断是小图标否存在 ，存在则直接返回\r\n            if(obj.lineNode.icons){\r\n                for (var i = 0; i < obj.lineNode.icons.length; i++) {\r\n                    if (obj.lineNode.icons[i].key == key) {\r\n                        LineOperationManager.bindOperation(obj.lineNode);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var lineOperation = LineOperationManager.creatOperation(key, obj, api);\r\n            zr.add(lineOperation);\r\n            LineOperationManager.bindOperation(obj.lineNode);\r\n            return lineOperation;\r\n        },\r\n\r\n        deleteIconObj: function(parentZr,lineNode) {\r\n            return {\r\n                icon:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAOBAMAAADpk+DfAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAtUExURQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMGgKD4AAAAPdFJOUwDH/g+agESj4Y6zUiRnh7lnwbkAAABLSURBVAjXY2BgYDZgAIEnnkCa7a5cYGwCwwklIOhhMBEEgmIGnlAgOMDAprhQUGgDA5vWdJciXJRGR0dTAgPzQ0FBSaBpzMbGBgwAIoUW3sQ2EdkAAAAASUVORK5CYII=\",\r\n                width: 12,\r\n                height: 14,\r\n                lineNode:lineNode,\r\n                callback:function(e) {\r\n                    for(var i = 0; i<lineNode.icons.length;i++){\r\n                        parentZr.remove(lineNode.icons[i])\r\n                    }\r\n                    ConnectionManager.deleteLine(parentZr);\r\n                    LineOperationManager.hideAllLineOperation();\r\n                    e.cancelBubble = true;\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n\tmodule.exports = LineOperationManager;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/manager/LineOperationManager.js\n ** module id = 93\n ** module chunks = 0\n **/","/**\r\n * Flow静态方法类\r\n * @class fish.topo.FishTopoFlow.Flow\r\n */\r\n\r\n\r\n    var Constants = require(\"./util/FlowConstants.js\");\r\n    var Flow = {\r\n        FLOW_TYPE: \"elementType\",\r\n        LINK: \"connection\",\r\n        RECT: \"Rect\",\r\n        Group: 'Group',\r\n        IMAGE: 'Image',\r\n        TEXT: 'Text',\r\n        CIRCLE: 'Circle',\r\n        SECTOR: 'Sector',\r\n        RING: 'Ring',\r\n        POLYGON: 'Polygon',\r\n        POLYLINE: 'Polyline',\r\n        LINE: 'Line',\r\n        BEZIERCURVE: 'Beziercurve',\r\n        ARC: 'Arc',\r\n        SCENE:'scene',\r\n\r\n        /**\r\n         * @method setUserData\r\n         * 设置用户数据\r\n         * @param {Object} node 需要设置数据的节点\r\n         * @param {Object} obj 数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //设置自定义数据\r\n         *      this.fishTopo.Flow.setUserData(rect, { customObj: \"rect\" });\r\n         */\r\n        setUserData: function(node, obj) {\r\n            node.model.set(Constants.USERDATA, obj);\r\n        },\r\n        /**\r\n         * 获取设置的用户数据\r\n         * @param {Object} node 需要获取数据的节点\r\n         * @return {String}      数据\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取自定义数据\r\n         *      this.fishTopo.Flow.getUserData(rect);\r\n         */\r\n        getUserData: function(node) {\r\n            return node.model.get(Constants.USERDATA);\r\n        },\r\n        /**\r\n         * 判断是否是连线\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是连线\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isLink(nodeModel)) { return true;}\r\n         */\r\n        isLink: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.LINK;\r\n        },\r\n        /**\r\n         * 判断是否是节点\r\n         * @param {Object} model 对象的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isNode(nodeModel)) { return true;}\r\n         */\r\n\r\n        isNode: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            var isNode;\r\n            if(elementType !=  Flow.LINK && elementType !=  Flow.SCENE){\r\n                isNode = true;\r\n            }else{\r\n                isNode = false;\r\n            }\r\n            return isNode;\r\n        },\r\n\r\n        /**\r\n         * 判断节点是否是矩形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是矩形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isRect(nodeModel)) { return true;}\r\n         */\r\n        isRect: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return  elementType == Flow.RECT;\r\n        },\r\n        /**\r\n         * 判断节点是否是图片节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是图片节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isImage(nodeModel)) { return true;}\r\n         */\r\n        isImage: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.IMAGE;\r\n        },\r\n        /**\r\n         * 判断节点是否是文字节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是文字节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isText(nodeModel)) { return true;}\r\n         */\r\n        isText: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.TEXT;\r\n        },\r\n        /**\r\n         * 判断节点是否是圆形节点\r\n         * @param {Object} model 节点的model\r\n         * @return {Boolean}      是 否\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //判断是否是圆形节点\r\n         *      var nodeModel = e.target.model;\r\n         *      if (this.fishTopo.Flow.isCircle(nodeModel)) { return true;}\r\n         */\r\n        isCircle: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType == Flow.CIRCLE;\r\n        },\r\n        /**\r\n         * 获取节点的类型\r\n         * @param {Object} model 节点的model\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *      //获取节点类型\r\n         *      var nodeModel = e.target.model;\r\n         *      return this.fishTopo.Flow.getType(nodeModel);\r\n         */\r\n        getType: function(model) {\r\n            var elementType = model.get(Flow.FLOW_TYPE);\r\n            return elementType;\r\n        }\r\n    };\r\n\r\n    module.exports = Flow;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-flow/lib/Flow.js\n ** module id = 94\n ** module chunks = 0\n **/","\r\n    //单例\r\n    var instance = null;\r\n    var emptyFn = function() {};\r\n    //初始默认配置\r\n    var config_default = {\r\n        //线程池\"线程\"数量\r\n        thread: 5,\r\n        //图片加载失败重试次数\r\n        //重试2次，加上原有的一次，总共是3次\r\n        \"tries\": 2\r\n    };\r\n    //工具\r\n    var _helpers = {\r\n        //设置dom属性\r\n        setAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name, value) {\r\n                    dom.dataset[name] = value;\r\n                    return value;\r\n                };\r\n            } else {\r\n                return function(dom, name, value) {\r\n                    dom.setAttribute(\"data-\" + name, value);\r\n                    return value;\r\n                };\r\n            }\r\n        }()),\r\n        //获取dom属性\r\n        getAttr: (function() {\r\n            var img = new Image();\r\n            //判断浏览器是否支持HTML5 dataset\r\n            if (img.dataset) {\r\n                return function(dom, name) {\r\n                    if(!dom.dataset[name]){\r\n                        return dom.getAttribute(\"data-\" + name);\r\n                    }else{\r\n                        return dom.dataset[name];\r\n                    }\r\n                };\r\n            } else {\r\n                return function(dom, name) {\r\n                    return dom.getAttribute(\"data-\" + name);\r\n                };\r\n            }\r\n        }())\r\n    };\r\n    /**\r\n     * 构造方法\r\n     * @param max 最大连接数。数值。\r\n     */\r\n    function ImagePool(max) {\r\n        //最大并发数量\r\n        this.max = max || config_default.thread;\r\n        this.linkHead = null;\r\n        this.linkNode = null;\r\n        //加载池\r\n        //[{img: dom,free: true, node: node}]\r\n        //node\r\n        //{src: \"\", options: {success: \"fn\",error: \"fn\", once: true}, tries: 0}\r\n        this.pool = [];\r\n    }\r\n    /**\r\n     * 初始化\r\n     */\r\n    ImagePool.prototype.initPool = function() {\r\n        var i, img, obj, _s;\r\n        _s = this;\r\n        for (i = 0; i < this.max; i++) {\r\n            obj = {};\r\n            img = new Image();\r\n            _helpers.setAttr(img, \"id\", i);\r\n            img.onload = function() {\r\n                var id, src;\r\n                //回调\r\n                _s.notice(_s.getNode(this), \"success\", this);\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            img.onerror = function() {\r\n                var node = _s.getNode(this);\r\n                //判断尝试次数\r\n                if (node.tries < config_default.tries) {\r\n                    node.tries = node.tries+1;\r\n                    //再次追加到任务链表末尾\r\n                    _s.appendNode(_s.createNode(node.src, node.options, node.notice, node.group, node.tries));\r\n                } else {\r\n                    //error回调\r\n                    //node.options.error.call(null, this.src);\r\n                    _s.notice(node, \"error\", this);\r\n                }\r\n                //处理任务\r\n                _s.executeLink(this);\r\n            };\r\n            obj.img = img;\r\n            obj.free = true;\r\n            this.pool.push(obj);\r\n        }\r\n    };\r\n    /**\r\n     * 回调封装\r\n     * @param node 节点。对象。\r\n     * @param status 状态。字符串。可选值：success(成功)|error(失败)\r\n     * @param img 图片。\r\n     */\r\n    ImagePool.prototype.notice = function(node, status, img) {\r\n        node.notice(status, img);\r\n    };\r\n    /**\r\n     * 处理链表任务\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.executeLink = function(dom) {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //加载下一个图片\r\n            this.setSrc(dom, this.linkHead);\r\n            //去除链表头\r\n            this.shiftNode();\r\n        } else {\r\n            //设置自身状态为空闲\r\n            this.status(dom, true);\r\n        }\r\n    };\r\n    /**\r\n     * 获取空闲\"线程\"\r\n     */\r\n    ImagePool.prototype.getFree = function() {\r\n        var length, i;\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                return this.pool[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * 封装src属性设置\r\n     * 因为改变src属性相当于加载图片，所以把操作封装起来\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setSrc = function(dom, node) {\r\n        //设置池中的\"线程\"为非空闲状态\r\n        this.status(dom, false);\r\n        //关联节点\r\n        this.setNode(dom, node);\r\n        //加载图片\r\n        dom.src = node.src;\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"状态\r\n     * @param dom 图像dom对象。对象。\r\n     * @param status 状态。布尔。可选值：true(空闲)|false(非空闲)\r\n     */\r\n    ImagePool.prototype.status = function(dom, status) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].free = status;\r\n        }\r\n        \r\n        //空闲状态，清除关联的节点\r\n        if (status) {\r\n            this.pool[id].node = null;\r\n        }\r\n    };\r\n    /**\r\n     * 更新池中的\"线程\"的关联节点\r\n     * @param dom 图像dom对象。对象。\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.setNode = function(dom, node) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            this.pool[id].node = node;\r\n            return this.pool[id].node === node;\r\n        }\r\n        \r\n    };\r\n    /**\r\n     * 获取池中的\"线程\"的关联节点\r\n     * @param dom 图像dom对象。对象。\r\n     */\r\n    ImagePool.prototype.getNode = function(dom) {\r\n        var id = _helpers.getAttr(dom, \"id\");\r\n        if(id){\r\n            return this.pool[id].node;\r\n        }\r\n        \r\n    };\r\n    /**\r\n     * 对外接口，加载图片\r\n     * @param src 可以是src字符串，也可以是src字符串数组。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     */\r\n    ImagePool.prototype.load = function(src, options) {\r\n        var srcs = [],\r\n            free = null,\r\n            length = 0,\r\n            i = 0,\r\n            //只初始化一次回调策略\r\n            notice = (function() {\r\n                if (options.once) {\r\n                    return function(status, img) {\r\n                        var g = this.group,\r\n                            o = this.options;\r\n                        //记录\r\n                        g[status].push(img);\r\n                        //判断改组是否全部处理完成\r\n                        if (g.success.length + g.error.length === g.count) {\r\n                            //异步\r\n                            //实际上是作为另一个任务单独执行，防止回调函数执行时间过长影响图片加载速度\r\n                            setTimeout(function() {\r\n                                o.success.call(null, g.success, g.error, g.count);\r\n                            }, 1);\r\n                        }\r\n                    };\r\n                } else {\r\n                    return function(status, img) {\r\n                        var o = this.options;\r\n                        //直接回调\r\n                        setTimeout(function() {\r\n                            o[status].call(null, img);\r\n                        }, 1);\r\n                    };\r\n                }\r\n            }()),\r\n            group = {\r\n                count: 0,\r\n                success: [],\r\n                error: []\r\n            },\r\n            node = null;\r\n        options = options || {};\r\n        options.success = options.success || emptyFn;\r\n        options.error = options.error || emptyFn;\r\n        srcs = srcs.concat(src);\r\n        //设置组元素个数\r\n        group.count = srcs.length;\r\n        //遍历需要加载的图片\r\n        for (i = 0, length = srcs.length; i < length; i++) {\r\n            //创建节点\r\n            node = this.createNode(srcs[i], options, notice, group);\r\n            //判断线程池是否有空闲\r\n            free = this.getFree();\r\n            if (free) {\r\n                //有空闲，则立即加载图片\r\n                this.setSrc(free.img, node);\r\n            } else {\r\n                //没有空闲，将任务添加到链表\r\n                this.appendNode(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * 获取内部状态信息\r\n     * @returns {{}}\r\n     */\r\n    ImagePool.prototype.info = function() {\r\n        var info = {},\r\n            length = 0,\r\n            i = 0,\r\n            node = null;\r\n        //线程\r\n        info.thread = {};\r\n        //线程总数量\r\n        info.thread.count = this.pool.length;\r\n        //空闲线程数量\r\n        info.thread.free = 0;\r\n        //任务\r\n        info.task = {};\r\n        //待处理任务数量\r\n        info.task.count = 0;\r\n        //获取空闲\"线程\"数量\r\n        for (i = 0, length = this.pool.length; i < length; i++) {\r\n            if (this.pool[i].free) {\r\n                info.thread.free = info.thread.free + 1;\r\n            }\r\n        }\r\n        //获取任务数量(任务链长度)\r\n        node = this.linkHead;\r\n        if (node) {\r\n            info.task.count = info.task.count + 1;\r\n            while (node.next) {\r\n                info.task.count = info.task.count + 1;\r\n                node = node.next;\r\n            }\r\n        }\r\n        return info;\r\n    };\r\n    /**\r\n     * 创建节点\r\n     * @param src 图片路径。字符串。\r\n     * @param options 用户自定义参数。包含：success回调、error回调、once标识。\r\n     * @param notice 回调策略。 函数。\r\n     * @param group 组信息。对象。{count: 0, success: [], error: []}\r\n     * @param tr 出错重试次数。数值。默认为0。\r\n     * @returns {{}}\r\n     */\r\n    ImagePool.prototype.createNode = function(src, options, notice, group, tr) {\r\n        var node = {};\r\n        node.src = src;\r\n        node.options = options;\r\n        node.notice = notice;\r\n        node.group = group;\r\n        node.tries = tr || 0;\r\n        return node;\r\n    };\r\n    /**\r\n     * 向任务链表末尾追加节点\r\n     * @param node 节点。对象。\r\n     */\r\n    ImagePool.prototype.appendNode = function(node) {\r\n        //判断链表是否为空\r\n        if (!this.linkHead) {\r\n            this.linkHead = node;\r\n            this.linkNode = node;\r\n        } else {\r\n            this.linkNode.next = node;\r\n            this.linkNode = node;\r\n        }\r\n    };\r\n    /**\r\n     * 删除链表头\r\n     */\r\n    ImagePool.prototype.shiftNode = function() {\r\n        //判断链表是否存在节点\r\n        if (this.linkHead) {\r\n            //修改链表头\r\n            this.linkHead = this.linkHead.next || null;\r\n        }\r\n    };\r\n    /**\r\n     * 导出对外接口\r\n     * @param max 最大连接数。数值。\r\n     * @returns {{load: Function, info: Function}}\r\n     */\r\n    var initImagePool = function(max) {\r\n        if (!instance) {\r\n            instance = new ImagePool(max);\r\n            instance.initPool();\r\n        }\r\n        return {\r\n            /**\r\n             * 加载图片\r\n             */\r\n            load: function() {\r\n                instance.load.apply(instance, arguments);\r\n            },\r\n            /**\r\n             * 内部信息\r\n             * @returns {*|any|void}\r\n             */\r\n            info: function() {\r\n                return instance.info.call(instance);\r\n            }\r\n        };\r\n    };\r\n\r\n    module.exports = { initImagePool: initImagePool }\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/ImagePool.js\n ** module id = 95\n ** module chunks = 0\n **/","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/vml.js\n ** module id = 96\n ** module chunks = 0\n **/","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z 的取值范围为 [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-10) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-10) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    // 不 round 会非常慢\n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path;\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            // 这里是在前面 appendChild 保证顺序的前提下\n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/graphic.js\n ** module id = 97\n ** module chunks = 0\n **/","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/core.js\n ** module id = 98\n ** module chunks = 0\n **/","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToMap = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToMap.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * 刷新\n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function () {\n            var width = this._getWidth();\n            var height = this._getHeight();\n\n            if (this._width != width && this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            this.root.removeChild(this.vmlViewport);\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/Painter.js\n ** module id = 99\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}