{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-network.js","webpack:/webpack/bootstrap d162046e59caad2d42f4","webpack:///index.network.js","webpack:///lib/fish-topo-network/lib/FishTopoNetwork.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/graphic/Pattern.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///lib/fish-topo-network/lib/ExtensionAPI.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/core/timsort.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/animation/requestAnimationFrame.js","webpack:///~/zrender/lib/dom/HandlerProxy.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///lib/fish-topo-core/lib/util.js","webpack:///lib/fish-topo-core/lib/Point.js","webpack:///lib/fish-topo-core/lib/LineStruct.js","webpack:///lib/fish-topo-network/lib/model/NetworkModel.js","webpack:///lib/fish-topo-core/lib/Model.js","webpack:///lib/fish-topo-core/lib/clazz.js","webpack:///lib/fish-topo-network/lib/node/NetworkNode.js","webpack:///lib/fish-topo-core/lib/Node.js","webpack:///lib/fish-topo-network/lib/node/rack/RackNode.js","webpack:///lib/fish-topo-network/lib/NetworkUtil.js","webpack:///lib/fish-topo-network/lib/node/TipWindowNode.js","webpack:///lib/fish-topo-network/lib/node/rack/ServerNode.js","webpack:///lib/fish-topo-network/lib/node/rack/SwitchNode.js","webpack:///lib/fish-topo-network/lib/node/rack/EmptyFloorNode.js","webpack:///lib/fish-topo-network/lib/node/topo/PointNode.js","webpack:///lib/fish-topo-network/lib/node/topo/CardNode.js","webpack:///lib/fish-topo-network/lib/node/topo/TopoDrawNode.js","webpack:///lib/fish-topo-network/lib/node/NetWorkLineNode.js","webpack:///lib/fish-topo-core/lib/shapes/Connector.js","webpack:///lib/fish-topo-core/lib/shapes/Symbol.js","webpack:///lib/fish-topo-core/lib/shapes/Handle.js","webpack:///lib/fish-topo-core/lib/shapes/EffectLine.js","webpack:///lib/fish-topo-core/lib/shapes/ConnectionPoint.js","webpack:///lib/fish-topo-network/lib/model/NetWorkLineModel.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerTopoNode.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerR630Node.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerR730Node.js","webpack:///lib/fish-topo-network/lib/model/topo/CardModel.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerX3550Node.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerX3650Node.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerRD350Node.js","webpack:///lib/fish-topo-network/lib/node/topo/ServerRD650Node.js","webpack:///lib/fish-topo-network/lib/node/topo/SwitchTopoNode.js","webpack:///lib/fish-topo-network/lib/node/topo/SwitchHalfIBNode.js","webpack:///lib/fish-topo-network/lib/node/topo/SwitchFullIBNode.js","webpack:///lib/fish-topo-network/lib/node/topo/SwitchGMNode.js","webpack:///lib/fish-topo-network/lib/node/topo/SwitchKMNode.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterDrawNode.js","webpack:///lib/fish-topo-network/lib/model/cluster/DatabaseModel.js","webpack:///lib/fish-topo-network/lib/model/cluster/AsmModel.js","webpack:///lib/fish-topo-network/lib/model/cluster/ISEModel.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterDatabaseNode.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterAsmNode.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterAsmCellNode.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterIseNode.js","webpack:///lib/fish-topo-network/lib/node/cluster/ClusterIseCellNode.js","webpack:///~/zrender/lib/vml/vml.js","webpack:///~/zrender/lib/vml/graphic.js","webpack:///~/zrender/lib/vml/core.js","webpack:///~/zrender/lib/vml/Painter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoNetwork","dom","opts","group","_dom","allNodes","_api","ExtensionAPI","tipNode","_zr","init","Eventful","NetworkNode","hasClass","NetworkUtil","registerNetworkNode","p_this","p_opts","topoDiv","innerHTML","document","getElementById","zRenderer","zrender","renderer","devicePixelRatio","zrUtil","util","NetworkModel","fishTopoProto","prototype","getDom","getZr","getWidth","getHeight","resize","p_width","p_height","undefined","painter","addNodeByModel","model","that","Shape","getClass","get","node","add","on","e","trigger","getNodeClass","className","showTipWindow","allWidth","width","hideTipWindow","remove","isSelected","clear","exportJson","networkModel","set","getUUID","drawFromJson","json","topoType","type","clientWidth","data","length","clientHeight","height","fromJson","mixin","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoNetWork","version","dependencies","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","isDom","isDisposed","doSingleEnterHover","el","__isHover","__hoverStlDirty","stroke","style","fill","hoverStyle","__hoverStl","lift","colorTool","Gradient","normalStyle","name","hasOwnProperty","__normalStl","setStyle","z2","doSingleLeaveHover","normalStl","doEnterHover","traverse","child","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","props","animatableModel","cb","postfix","duration","getShallow","animationEasing","animateTo","attr","pathTool","round","Math","Path","matrix","vector","Draggable","graphic","Util","Group","Image","Text","textContain","Circle","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","LinearGradient","RadialGradient","BoundingRect","extendShape","extend","extendPath","pathData","extendFromString","makePath","rect","layout","path","createFromString","boundingRect","getBoundingRect","aspect","cx","x","cy","y","resizePath","inherits","mergePath","applyTransform","pathRect","calculateTransform","subPixelOptimizeLine","param","subPixelOptimize","shape","lineWidth","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","max","position","positiveOrNegative","doubledPosition","setHoverStyle","setNormalStyle","options","setText","textStyle","labelModel","color","labelPosition","labelColor","indexOf","textStyleModel","getModel","textDistance","textFont","getFont","textPosition","textFill","getTextColor","updateProps","curry","initProps","getTransform","target","ancestor","mat","identity","mul","getLocalTransform","parent","vertex","transform","invert","transformDirection","direction","hBase","abs","vBase","clone","source","result","Array","i","len","isBuildInObject","merge","overwrite","isObject","targetProp","sourceProp","isArray","mergeAll","targetAndSources","overlay","createCanvas","createElement","getContext","_ctx","array","value","clazz","baseClazz","F","clazzPrototype","prop","constructor","superClass","isArrayLike","each","obj","context","forEach","nativeForEach","map","nativeMap","push","reduce","memo","nativeReduce","filter","nativeFilter","find","bind","func","args","nativeSlice","arguments","apply","concat","objToString","isFunction","isString","BUILTIN_OBJECT","nodeType","retrieve","values","slice","Function","assert","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","[object CanvasPattern]","[object Image]","Object","toString","arrayProto","noop","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","PI","xp","mathCos","mathSin","yp","lambda","mathSqrt","f","cxp","cyp","theta","vAngle","u","v","dTheta","vRatio","addData","createPathProxyFromString","n","cs","replace","cc","RegExp","prevCmd","arr","split","cpx","cpy","PathProxy","CMD","str","charAt","off","shift","parseFloat","isNaN","ctlPtx","ctlPty","L","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","buildPath","setData","transformPath","ctx","rebuildPath","create","dirty","sqrt","sin","cos","vMag","acos","pathEls","pathList","pathEl","__dirty","pathBundle","appendPath","Displayable","pathContain","Pattern","getCanvasPattern","__dirtyPath","strokeContainThreshold","brush","prevEl","hasStroke","hasFill","hasFillGradient","hasStrokeGradient","hasFillPattern","hasStrokePattern","setTransform","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","restoreTransform","text","drawRectText","shapeCfg","inBundle","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","copy","w","lineScale","strokeNoScale","getLineScale","contain","localPos","transformCoordToLocal","containStroke","dirtyPath","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","setShape","Sub","extendFrom","defaultShape","thisShape","Element","Style","__clipPaths","RectText","invisible","z","zlevel","draggable","dragging","silent","culling","cursor","rectHover","progressive","beforeBrush","afterBrush","rectContain","coord","animateStyle","useStyle","createLinearGradient","global","canvasGradient","createRadialGradient","min","r","STYLE_COMMON_PROPS","opacity","shadowBlur","shadowOffsetX","shadowOffsetY","textStroke","textBaseline","textAlign","textVerticalAlign","textShadowBlur","textShadowOffsetX","textShadowOffsetY","textTransform","textRotation","blend","prevStyle","firstDraw","styleName","globalAlpha","globalCompositeOperation","otherStyle","newStyle","method","colorStops","addColorStop","offset","styleProto","guid","Transformable","Animatable","ignore","clipPath","drift","dx","dy","decomposeTransform","beforeUpdate","afterUpdate","update","updateTransform","hide","show","setClipPath","zr","addSelfToZr","removeClipPath","removeSelfFromZr","animators","animation","addAnimator","removeAnimator","idStart","arrySlice","_$handlers","one","event","handler","_h","h","isSilent","newList","l","argLen","splice","triggerWithContext","isNotAroundZero","val","EPSILON","mIdentity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","invTransform","rotate","dpr","tmpTransform","sx","sy","atan2","v2","transformCoordToGlobal","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","a","rad","aa","ac","atx","ab","ad","aty","st","ct","vx","vy","det","b","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","dist","distSquare","Animator","log","animatingShape","pathSplitted","animator","during","done","stopAnimation","forwardToLast","stop","time","delay","easing","callback","count","_animateToShallow","start","objShallow","propertyCount","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","j","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackLen","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","sort","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","lastValue","_target","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","self","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","_life","_initialized","gap","onrestart","easingFuncs","step","globalTime","_startTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","eventType","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","clampCssAngle","clampCssFloat","parseCssInt","parseInt","parseCssFloat","cssHueToRgb","colorStr","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","deltaR","deltaG","deltaB","level","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","config","debugMode","console","window","parsePercent","maxValue","lastIndexOf","tmpRect","textRect","save","align","font","baseline","verticalAlign","lineHeight","res","adjustTextPositionOnRect","shadowColor","textShadowColor","textLines","fillText","strokeText","restore","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","truncateText","containerWidth","ellipsis","maxIterations","minChar","cnCharWidth","ascCharWidth","placeholder","contentWidth","ellipsisWidth","textLine","subLength","estimateLength","charCode","charCodeAt","vec2","v2ApplyTransform","mathMin","mathAbs","mathMax","union","other","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","curve","bbox","min2","max2","hasTypedArray","_len","_xi","_yi","_x0","_y0","_ux","_uy","_lineDash","_dashOffset","_dashIdx","_dashSum","moveTo","lineTo","exceedUnit","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","quadraticCurveTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","idx","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","ux","uy","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","roots","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","tmp","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","prev","next","d1","d2","interval","Infinity","_v0","_t","_v1","v2DistSquare","EPSILON_NUMERIC","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","end","extremity","PI2","fromPoints","points","left","right","top","bottom","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","unit","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","_x","line","_l","_a","_b","_s","image","repeat","_canvasPattern","createPattern","nPoint","mathAtan2","_dragStart","_drag","_dragEnd","draggingTarget","_draggingTarget","offsetX","_y","offsetY","dispatchToElement","dropTarget","findHover","lastDropTarget","_dropTarget","_children","__storage","isGroup","children","childAt","childOfName","childCount","_doAdd","addBefore","nextSibling","storage","addToMap","addChildrenToStorage","delFromMap","delChildrenFromStorage","removeAll","eachChild","includeChildren","tmpMat","childRect","ZImage","LRU","globalImageCache","src","_image","cachedImgObj","onload","pending","put","sWidth","sHeight","drawImage","LinkedList","head","tail","linkedListProto","insert","entry","Entry","insertEntry","maxSize","_list","_map","_maxSize","LRUProto","list","leastUsedEntry","r0","clockwise","unitX","unitY","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","pos","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","roundRectHelper","r1","r2","r3","r4","total","pointAt","someVectorAt","isTangent","cpx2","cpy2","cpx1","cpy1","curveTool","tangentAt","globalCoord","instance","apiList","delInstance","env","Handler","Storage","Animation","HandlerProxy","useVML","canvasSupported","painterCtors","canvas","ZRender","getInstance","registerPainter","Ctor","rendererType","vml","handerProxy","getViewportRoot","stage","_needsRefresh","refreshImmediately","_needsRefreshHover","refreshHoverImmediately","oldDelFromMap","oldAddToMap","elId","getId","addRoot","delRoot","configLayer","zLevel","addHover","refreshHover","removeHover","clearHover","clearAnimation","pathToImage","setCursorStyle","cursorStyle","eventName","eventHandler","detect","ua","os","browser","firefox","match","ie","edge","touchEventsSupported","pointerEventsSupported","navigator","userAgent","makeEventPacket","eveType","cancelBubble","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","wheelDelta","zrDelta","EmptyProxy","isHover","displayable","handlerNames","proxy","_hovered","_lastTouchMoment","_lastX","_lastY","mousemove","hovered","lastHovered","setCursor","mouseout","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","getDisplayList","_downel","_upel","shapeCompareFunc","timsort","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","displayList","_updateAndAddDisplayable","clipPaths","elements","_renderList","displayableSortFunc","minRunLength","DEFAULT_MIN_MERGE","makeAscendingRun","lo","hi","compare","runHi","reverseRun","binaryInsertionSort","mid","pivot","gallopLeft","hint","lastOffset","maxOffset","gallopRight","TimSort","pushRun","_runStart","_runLength","runStart","stackSize","runLength","mergeRuns","mergeAt","forceMergeRuns","start1","length1","start2","length2","mergeLow","mergeHigh","cursor1","cursor2","dest","count1","count2","exit","_minGallop","minGallop","DEFAULT_MIN_GALLOPING","customCursor","customDest","tmpStorageLength","DEFAULT_TMP_STORAGE_LENGTH","stackLength","remaining","ts","minRun","force","Dispatcher","requestAnimationFrame","_clips","_running","_time","_pausedTime","_pauseStart","_paused","clips","_update","getTime","deferredEvents","deferredClips","_startLoop","pause","resume","getBoundingClientRect","clientToLocal","box","clientX","clientY","normalizeEvent","isTouch","touch","targetTouches","changedTouches","detail","addEventListener","isDomLevel2","attachEvent","removeEventListener","detachEvent","preventDefault","stopPropagation","returnValue","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","setTimeout","eventNameFix","processGesture","gestureMgr","_gestureMgr","gestureInfo","recognize","setTouchTimer","_touching","clearTimeout","_touchTimer","useTouchEvent","initDomHandler","makeMouseHandler","fn","touchHandlerNames","_handlers","domHandlers","mouseHandlerNames","HandlerDomProxy","mountHandlers","GestureMgr","eventTool","TOUCH_CLICK_DELAY","element","toElement","relatedTarget","parentNode","touchstart","mousedown","touchmove","touchend","mouseup","click","handlerDomProxyProto","pointPair","center","eventUtil","_track","_doTrack","_recognize","touches","trackItem","recognizers","pinch","track","pinchEnd","pinchPre","isFinite","pinchCenter","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","createRoot","domRoot","domRootStyle","overflow","Layer","MAX_PROGRESSIVE_LAYER_NUMBER","Painter","singleCanvas","nodeName","toUpperCase","_singleCanvas","rootStyle","zlevelList","_zlevelList","layers","_layers","_layerConfig","_width","_height","mainLayer","initContext","_getWidth","_getHeight","_domRoot","appendChild","_createPathToImage","_progressiveLayers","_hoverlayer","_hoverElements","isSingleCanvas","paintAll","_paintList","_startProgessive","__hoverMir","elMirror","__from","hoverElements","from","hoverLayer","getLayer","scope","originalEl","_doPaintEl","token","_progressiveToken","_doPaintList","_furtherProgressive","_progress","_clearProgressive","_updateLayerStatus","eachBuildinLayer","flushProgressiveLayer","currentLayer","currentZLevel","currentProgressiveLayer","layerProgress","progressiveLayerIdx","elZLevel","elFrame","__frame","renderScope","__progress","__maxProgress","__nextIdxNotProg","forcePaint","prevClipLayer","prevElClipPaths","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","progressiveLayers","elCountsLastFrame","progressiveElCountsLastFrame","elCount","lastProgressiveKey","progressiveLayerCount","frameCount","elProgress","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","clearColor","backgroundColor","stl","defaultView","getComputedStyle","paddingLeft","paddingRight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","me","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveMotionBLur","clearColorGradientOrPattern","__canvasGradient","fillRect","chars","uuid","rnd","random","getMaxLineLength","getPolylineLength","lenght","NaN","orthogonalPath","lineIntersectsLine","l1","l2","startPoint","endPoint","contains","a1","b1","a2","b2","polylineIntersectsRectangle","bounds","closedPolyline","lines","Point","tempLine","tempLine1","scorePath","score","signum","forwardPath","traslatePoints","isRevert","newPoints","point1","rotationMatrix","mReturn","translationMatrix","scaleMatrix","getEndPoint","getConnectorPoints","getSoltPoints","getRect","tangentRotation","collinearity","precission","determinant","enhancedRound","number","decimals","getLength","getAngle","centerPoint","outsidePoint","atan","boundRect","randomColor","index","arrHex","strHex","isUndefined","collinearReduction","cloneArray","template","settings","oldSettings","templateSettings","matcher","escape","noMatch","evaluate","escaper","escapeChar","variable","render","argument","isEmpty","StackedMap","createNew","stack","arrKey","keys","removeItem","item","removeTop","escapes","'","\\","\r","\n"," "," ","load","o","newPoint","loadArray","oldX","oldY","equals","anotherPoint","near","getPoints","oType","newLine","contructor","anotherLine","startX","startY","endX","endY","closestX","closestY","getPoint","Xp","Yp","Model","defaultOption","resourceId","properties","notes","extProperties","upperLeft","lowerRight","stencil","showTip","option","parentModel","extraOpt","getDefaultOption","optList","Class","opt","__defaultOption","clazzUtil","mergeOption","ignoreParent","fieldName","fieldArray","currentRef","thisParentModel","restoreData","enableClassExtend","superCall","methodName","superApply","TYPE_DELIMITER","IS_CONTAINER","parseClassType","componentType","main","RootClass","preConstruct","proto","ExtendedClass","enableClassManagement","entity","makeContainer","container","registerClass","Clazz","componentTypeMain","subType","throwWhenNotFound","getClassesByMainType","getAllClassMainTypes","types","hasSubTypes","registerWhenExtend","originalExtend","api","Node","outline","enable","initVisible","nextworkInfo","portNodeList","cardNodeList","initEvent","drawText","content","toJSON","textName","bpmnInfo","refreshText","RackNode","rackkInfo","_UData","_showTip","_rackName","_rackId","_description","_title","parmDate","operation","rack","description","afterButtonNode","MOUSE_EVENT_NAMES","eveName","_parmDate","rectOut","rectIn","_startY","_floorNum","_isnullFloor","_server","modelObj","status","floorNum","serverType","vendor","column","serverModel","rectTray","emptyFloorModel","p_model","eWidth","rackId","rackName","nodes","jsonArr","fishTopoNetwork","UData","desc","rackModel","nodeList","topoModel","clusterModel","TipWindowNode","ServerNode","SwitchNode","EmptyFloorNode","ServerTopoNode","TopoDrawNode","ServerR630Node","ServerR730Node","PointNode","CardNode","ServerX3550Node","ServerX3650Node","ServerRD350Node","ServerRD650Node","SwitchFullIBNode","SwitchHalfIBNode","SwitchKMNode","SwitchGMNode","ClusterDrawNode","ClusterDatabaseNode","ClusterAsmNode","ClusterAsmCellNode","ClusterIseNode","ClusterIseCellNode","NextWorkUtil","_xWidth","_tipContext","hostname","ipaddress","tipContext","tip","serverInfo","imageUrl","cellStateNode","rectServer","_px","_py","rectSwitch","lineInfo","portNode","pointList","_portData","_type","_direction","imgUrl","_resourcesName","_resourceNodeType","_No","portModel","_linInfo","sourceReource","sourceCardNo","sourcePort","nodetype","sourceStatus","targetReource","resourceName","targetPort","port","pModel","addPortByModel","topoInfo","portList","NetWorkLineNode","NetWorkLineModel","serverWidth","switchWidth","clentWidth","_startX","_textW","_textH","textKM","lineKM","lineType","textGB","lineGB","textIB","lineIB","lineOut","lineUp","lineDown","startComputeX","startStorageX","startSwitchX","nodeY","_typeNode","switchType","manager_ipaddr","portNum","portTotal","hostId","host_id","noteType","ports","ps","startNode","endNode","pe","drawLine","p_nodeList","p_serverW","p_switchW","computeWidth","storageWidth","_name","p_startNode","p_endNode","fleftx","flefty","fwidth","fheight","torightx","torighty","towidth","toheight","moddleY","_lindColor","_lineInfo","portType","portState","sourceReourceName","_moddleX","moddleX","fromBounds","toBounds","parmData","netWorkLineModel","netWorkLineNode","ip","con","refreshLine","Connector","symbol","size","_style","_hoverStyle","_isEdit","isEdit","sRect","sBounds","eRect","eBounds","sConnectorPoint","eConnectorPoint","solutions","connector2Points","middleY","s0","defaultOptions","TYPE_STRAIGHT","arrowHoverStyle","handles","connectionPoints","conPointsGroup","autoChangePosition","groupCurve","icons","symbolUtil","Handle","EffectLine","ConnectionPoint","TYPE_JAGGED","TYPE_CURVE","RADIUS","START_NODE","END_NODE","LEFT","RIGHT","TOP","BOTTOM","SEPERATOR","turningPoints","modifyCurve","lineText","textPoint","getTextPostion","symbolTo","effect","polyLine","createSymbol","curveLine","createHoverStyle","createAllconnectionPoint","shapeSetHandle","textPos","textPostion","textWidth","xOffset","middle","getTextRotation","connectionPointCreate","TYPE_CONNECTOR","conPoint","clearHandles","handleShape","isCollineaityFirst","isCollineaitySecond","symbolType","symbolSize","symbolPath","middleX","ellapsedDistance","segment","missingDistance","error","walked","rest","currentSegmentLength","segmentPercent","sPos","ePos","refreshModel","iconNode","icon","sol","getCurvePoint","willDelCurves","cntCurve","cure","P","divide","nr","callee","multiply","q1","q_01","q_02","q_03","q0","q2","q_31","q_32","q_33","q3","Triangle","Diamond","Pin","tanX","tanY","cpLen","cpLen2","Arrow","symbolCtors","roundRect","square","circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","Symbol","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","setColor","connector","visible","actionConnector","anotherHandle","newX","newY","deltaY","deltaX","_lastFrame","_lastFramePercent","initSymbol","curveUtil","EffectLineProto","period","__t","groupCurveAnimate","updateSymbolPositionPolyline","setAnimationPointsPolyline","setAnimationPointsBezierCurve","updateSymbolPositionBezierCurve","__p1","__p2","__cp1","__cp2","_points","accLenArr","_offsets","_length","__lastFramePercent","offsets","NORMAL_COLOR","OVER_COLOR","CONNECTED_COLOR","TYPE_FIGURE","anotherConnectionPoint","isVector","serverNodeB","portsList","_kmx","card1","CardModel","No","resourcesName","resourceNodeType","portData","serverNodeA","SwitchTopoNode","_portNum","switchNode","substring","info","databaseList","dgList","DatabaseModel","AsmModel","ISEModel","dataModelData","asmModelData","storageModelData","dbData","asmData","dgData","childNodeList","iseData","databaseModel","mangerNode","database","asmModel","iseModel","_toModdleY","defaultOptionDatabase","databaseNode","_backModdleY","defaultOptionDg","dgModel","dgNode","p_node","p_eventList","instanse","dg","_interval","_instanseWidth","_instanse","_instanseX","_instanseNode","_instansestatusNode","_instanseTitle","_status","_dgW","_dgH","fullDgHeight","getNodeHeight","fullDgWidth","_lSpace","_lX","dgLineNode","fullDgNode","_dgCellX","_dgCellY","cellModelData","title","cellModel","asmNode","fullAsmHeight","_asmCellX","_asmCellY","_fullAsmX","_fullAsmY","_asmStatusNode","_asmTitle","p_count","p_num","cellNode","cellTitle","iseList","nodeWidth","isedata","disk","iseCellModel","getDgNodeWidth","p_space","isecellNode","isecellStatus","isecellTitle","vmlCore","comma","imageTransformPrefix","Z2","ZLEVEL_BASE","Z_BASE","initRootElStyle","cssText","coordsize","coordorigin","encodeHtmlAttribute","String","rgb2Str","g","append","getZIndex","setColorAndOpacity","getColorAndAlpha","updateFillNode","zrEl","gradientType","focus","expansion","rectWidth","rectHeight","dimension","stops","cs1","cs2","colorAndAlphaList","colorAndAlpha","color1","color2","opacity1","opacity2","focusposition","updateStrokeNode","dashstyle","updateFillAndStroke","vmlEl","isFill","getElementsByTagName","createNode","pathDataToString","cmdStr","brushVML","vmlRoot","_vmlEl","needTransform","strokeEl","weight","zIndex","removeRectText","onRemove","onAdd","appendRectText","isImage","img","tagName","ow","oh","_imageSrc","_imageWidth","_imageHeight","imageRuntimeStyle","runtimeStyle","oldRuntimeWidth","oldRuntimeHeight","dw","dh","sw","sh","hasCrop","doc","vmlElStyle","hasRotation","maxX","maxY","transformFilter","padding","imageEl","_imageEl","cropEl","_cropEl","imageELStyle","tmpImage","cropElStyle","filterStr","textMeasureEl","DEFAULT_STYLE_NORMAL","fontStyleCache","fontStyleCacheCount","MAX_FONT_CACHE_SIZE","fontEl","getFontStyle","fontString","fontStyle","fontFamily","variant","fontVariant","fontWeight","fontSize","family","body","ex","createTextNode","offsetWidth","fromTextEl","textPathEl","skewEl","textVmlEl","_textVmlEl","textpathok","to","coords","textVmlElStyle","toFixed","string","urn","win","vmlInited","namespaces","zrvml","initVML","styleSheets","createStyleSheet","addRule","VMLPainter","vmlViewport","_vmlRoot","_vmlViewport","_firstPaint","createMethodNotSupport","zrLog","__alreadyNotVisible","vmlViewportStyle","currentStyle","notSupportedMethods"],"mappings":"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","file":"fish-topo-network.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoNetwork\"] = factory();\n\telse\n\t\troot[\"fishTopoNetwork\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoNetwork\"] = factory();\n\telse\n\t\troot[\"fishTopoNetwork\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t\r\n\t//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\n\t__webpack_require__(117);\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var ExtensionAPI = __webpack_require__(58);\r\n\t    var Eventful = __webpack_require__(11);\r\n\t    var zrender = __webpack_require__(59);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var RackNode = __webpack_require__(79);\r\n\t    var NetworkUtil = __webpack_require__(80);\r\n\t\r\n\t    function FishTopoNetwork (dom, opts) {\r\n\t        /**\r\n\t         * @type {string}\r\n\t         */\r\n\t        this.id;\r\n\t        /**\r\n\t         * Group id\r\n\t         * @type {string}\r\n\t         */\r\n\t        this.group;\r\n\t\r\n\t        /**\r\n\t         * @type {HTMLDomElement}\r\n\t         * @private\r\n\t         */\r\n\t        this._dom = dom;\r\n\t\r\n\t        this.allNodes = [];\r\n\t\r\n\t        this._api = new ExtensionAPI(this);\r\n\t\r\n\t        this.tipNode = null;\r\n\t\r\n\t        /**\r\n\t         * @type {module:zrender/ZRender}\r\n\t         * @private\r\n\t         */\r\n\t        this._zr = init(this, opts); \r\n\t\r\n\t        Eventful.call(this);\r\n\t        if ( !NetworkNode.hasClass(\"RackNode\")) {\r\n\t            NetworkUtil.registerNetworkNode(); \r\n\t        }     \r\n\t    }\r\n\t\r\n\t    function init(p_this, p_opts) {\r\n\t\r\n\t        var topoDiv = '<div class=\"topoDiv\" id = \"topoDiv\" style=\"width:100%; height:100%; overflow:auto;\"></div>';\r\n\t        p_this._dom.innerHTML = topoDiv;\r\n\t        \r\n\t        var dom = document.getElementById(\"topoDiv\");\r\n\t\r\n\t        var zRenderer = zrender.init(dom, {\r\n\t            renderer: p_opts.renderer || 'canvas',\r\n\t            devicePixelRatio: p_opts.devicePixelRatio\r\n\t        });\r\n\t        return zRenderer;    \r\n\t    };\r\n\t\r\n\t    var fishTopoProto = FishTopoNetwork.prototype;\r\n\t\r\n\t    /**\r\n\t     * @return {HTMLDomElement}\r\n\t     */\r\n\t    fishTopoProto.getDom = function () {\r\n\t        return this._dom;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @return {module:zrender~ZRender}\r\n\t     */\r\n\t    fishTopoProto.getZr = function () {\r\n\t        return this._zr;\r\n\t    };\r\n\t    /**\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getWidth = function () {\r\n\t        return this._zr.getWidth();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @return {number}\r\n\t     */\r\n\t    fishTopoProto.getHeight = function () {\r\n\t        return this._zr.getHeight();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     */\r\n\t    fishTopoProto.resize = function ( p_width, p_height) {\r\n\t        p_width = p_width !== undefined ? p_width : this.getWidth;\r\n\t        p_height = p_height !== undefined ? p_height : this.getHeight() - 50;\r\n\t        this._zr.painter.resize(p_width, p_height);\r\n\t    }; \r\n\t\r\n\t    /**\r\n\t     * 根据模型增加节点\r\n\t     * @param {[type]} model [description]\r\n\t     */\r\n\t    fishTopoProto.addNodeByModel = function(model) {\r\n\t        var that = this;\r\n\t        var Shape = NetworkNode.getClass(model.get(\"stencil.type\"));\r\n\t        if (Shape) {\r\n\t            node = new Shape(model, this._api);\r\n\t            this._zr.add(node); \r\n\t            node.on('click',function(e){\r\n\t                that._api.trigger(e, {});  \r\n\t            });         \r\n\t        }         \r\n\t             \r\n\t    };  \r\n\t\r\n\t    fishTopoProto.getNodeClass = function (className) {\r\n\t        return NetworkNode.getClass(className);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 鼠标悬停提示框展示\r\n\t     * @param {[type]} model [description]\r\n\t     */\r\n\t    fishTopoProto.showTipWindow = function(model) {\r\n\t        var Shape = NetworkNode.getClass(\"TipWindowNode\");\r\n\t        if (Shape) {\r\n\t            var height = this._zr.getHeight();           \r\n\t            if( this.allWidth != undefined ) {\r\n\t                this._zr.painter.resize( this.allWidth + model.width, 730);\r\n\t            }\r\n\t            \r\n\t            var node = new Shape(model, this._api);\r\n\t            this._zr.add(node); \r\n\t            this.tipNode = node;\r\n\t            // node.on('mousedown',function(e){\r\n\t            //     //that.newDrag(this,e.event.clientX,e.event.clientY);   \r\n\t            // });         \r\n\t        }         \r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 鼠标悬停提示框展示\r\n\t     * @param {[type]} model [description]\r\n\t     */\r\n\t    fishTopoProto.hideTipWindow = function(model) { \r\n\t        if (this.tipNode && this.tipNode !== null ) {\r\n\t            this._zr.remove(this.tipNode);      \r\n\t        }         \r\n\t    };\r\n\t\r\n\t    fishTopoProto.init = function () {\r\n\t        var isSelected = this.isSelected;\r\n\t                \r\n\t    };\r\n\t\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t    };   \r\n\t\r\n\t    fishTopoProto.exportJson = function() {\r\n\t        var networkModel = new NetworkModel({});\r\n\t        networkModel.set(\"resourceId\", util.getUUID());\r\n\t        return NetworkUtil.exportJson(networkModel, this.allNodes);\r\n\t    };\r\n\t\r\n\t    fishTopoProto.drawFromJson = function(json) {\r\n\t        var topoType = json.type;\r\n\t        if ( topoType === \"rack\" ) {\r\n\t            var clientWidth = this._zr.getWidth();\r\n\t            if ( (50 + (json.data.length * 250)) > clientWidth ) {\r\n\t                this._zr.painter.resize( 50 + (json.data.length * 250), 730);\r\n\t                if ( clientWidth < this._zr.getWidth() ) {\r\n\t                    this.allWidth = this._zr.getWidth();\r\n\t                }\r\n\t            } \r\n\t        } else if ( topoType === \"topo\" ) {\r\n\t            var clientWidth = this._zr.getWidth();\r\n\t            var clientHeight = 700;\r\n\t            this.width = clientWidth;\r\n\t            this.height = clientHeight;\r\n\t        }\r\n\t        else if ( topoType === \"cluster\" ) {\r\n\t            var clientWidth = this._zr.getWidth();\r\n\t            var clientHeight = 630;\r\n\t            this.width = clientWidth;\r\n\t            this.height = clientHeight;\r\n\t        }\r\n\t        return NetworkUtil.fromJson(this, json);\r\n\t    };  \r\n\t\r\n\t    zrUtil.mixin(FishTopoNetwork, Eventful);\r\n\t\r\n\t    // ---------对外暴露fishTopoNetWork------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoNetwork_instance_';\r\n\t    var fishTopoNetWork = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '1.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoNetWork.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        zrUtil.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoNetWork = new FishTopoNetwork(dom, opts);\r\n\t        fishTopoNetWork.init();\r\n\t\r\n\t        fishTopoNetWork.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoNetWork.id] = fishTopoNetWork;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoNetWork.id);\r\n\t\r\n\t        return fishTopoNetWork;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoNetWork.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoNetWork.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoNetWork.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoNetWork) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoNetWork;\r\n\t\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var pathTool = __webpack_require__(5);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(6);\r\n\t    var colorTool = __webpack_require__(19);\r\n\t    var matrix = __webpack_require__(13);\r\n\t    var vector = __webpack_require__(14);\r\n\t    var Gradient = __webpack_require__(37);\r\n\t    var Draggable = __webpack_require__(38);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(39);\r\n\t\r\n\t    graphic.Image = __webpack_require__(40);\r\n\t\r\n\t    graphic.Text = __webpack_require__(42);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(23);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(43);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(44);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(45);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(46);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(50);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(51);\r\n\t\r\n\t    graphic.Line = __webpack_require__(53);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(54);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(55);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(56);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(57);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(24);\r\n\t\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        Draggable.call(path);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t\r\n\t        zrUtil.inherits(path, Draggable);\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath;\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    graphic.setNormalStyle = function(el, options) {\r\n\t        if (el.__normalStl) {\r\n\t            for (var name in options) {\r\n\t                if (el.__normalStl.hasOwnProperty(name)) {\r\n\t                    el.__normalStl[name] = options[name];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\t\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/core/util\n\t */\n\t\n\t\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1,\n\t        '[object CanvasPattern]': 1,\n\t        // In node-canvas Image can be Canvas.Image\n\t        '[object Image]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} 拷贝后的新对象\n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            }\n\t            else if (\n\t                !isBuildInObject(source)\n\t                // 是否为 dom 对象\n\t                && !isDom(source)\n\t            ) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        return source;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     * @memberOf module:zrender/core/util\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Function} func\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)];\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1\n\t               && typeof(value.nodeName) == 'string';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @memberOf module:zrender/core/util\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/util\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(6);\n\t    var PathProxy = __webpack_require__(25);\n\t    var transformPath = __webpack_require__(36);\n\t    var matrix = __webpack_require__(13);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t            this.dirty(true);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            for (var i = 0; i < len; i++) {\n\t                var pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var zrUtil = __webpack_require__(4);\n\t    var PathProxy = __webpack_require__(25);\n\t    var pathContain = __webpack_require__(28);\n\t\n\t    var Pattern = __webpack_require__(35);\n\t    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = style.hasStroke();\n\t            var hasFill = style.hasFill();\n\t            var fill = style.fill;\n\t            var stroke = style.stroke;\n\t            var hasFillGradient = hasFill && !!(fill.colorStops);\n\t            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n\t            var hasFillPattern = hasFill && !!(fill.image);\n\t            var hasStrokePattern = hasStroke && !!(stroke.image);\n\t\n\t            style.bind(ctx, this, prevEl);\n\t            this.setTransform(ctx);\n\t\n\t            if (this.__dirty) {\n\t                var rect = this.getBoundingRect();\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFillGradient) {\n\t                    this._fillGradient = style.getGradient(ctx, fill, rect);\n\t                }\n\t                if (hasStrokeGradient) {\n\t                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n\t                }\n\t            }\n\t            // Use the gradient or pattern\n\t            if (hasFillGradient) {\n\t                // PENDING If may have affect the state\n\t                ctx.fillStyle = this._fillGradient;\n\t            }\n\t            else if (hasFillPattern) {\n\t                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n\t            }\n\t            if (hasStrokeGradient) {\n\t                ctx.strokeStyle = this._strokeGradient;\n\t            }\n\t            else if (hasStrokePattern) {\n\t                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n\t            }\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Update path sx, sy\n\t            var scale = this.getGlobalScale();\n\t            path.setScale(scale[0], scale[1]);\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape, false);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                // PENDING\n\t                // Remove lineDash\n\t                ctx.setLineDash([]);\n\t            }\n\t\n\t\n\t            this.restoreTransform(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text || style.text === 0) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t        },\n\t\n\t        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n\t        // Like in circle\n\t        buildPath: function (ctx, shapeCfg, inBundle) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            var needsUpdateRect = !rect;\n\t            if (needsUpdateRect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape, false);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            this._rect = rect;\n\t\n\t            if (style.hasStroke()) {\n\t                // Needs update rect with stroke lineWidth when\n\t                // 1. Element changes scale or lineWidth\n\t                // 2. Shape is changed\n\t                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\t                if (this.__dirty || needsUpdateRect) {\n\t                    rectWithStroke.copy(rect);\n\t                    // FIXME Must after updateTransform\n\t                    var w = style.lineWidth;\n\t                    // PENDING, Min line width is needed when line is horizontal or vertical\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                    // Only add extra hover lineWidth when there are no fill\n\t                    if (!style.hasFill()) {\n\t                        w = Math.max(w, this.strokeContainThreshold || 4);\n\t                    }\n\t                    // Consider line width\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        rectWithStroke.width += w / lineScale;\n\t                        rectWithStroke.height += w / lineScale;\n\t                        rectWithStroke.x -= w / lineScale / 2;\n\t                        rectWithStroke.y -= w / lineScale / 2;\n\t                    }\n\t                }\n\t\n\t                // Return rect with stroke\n\t                return rectWithStroke;\n\t            }\n\t\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (style.hasStroke()) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!style.hasFill()) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (style.hasFill()) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (dirtyPath == null) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t                this.__dirtyPath = true;\n\t                this._rect = null;\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Style = __webpack_require__(8);\n\t\n\t    var Element = __webpack_require__(9);\n\t    var RectText = __webpack_require__(22);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        /**\n\t         * Render the element progressively when the value >= 0,\n\t         * usefull for large data.\n\t         * @type {number}\n\t         */\n\t        progressive: -1,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx, prevEl) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty(false);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Use given style object\n\t         * @param  {Object} obj\n\t         */\n\t        useStyle: function (obj) {\n\t            this.style = new Style(obj);\n\t            this.dirty(false);\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t    var STYLE_COMMON_PROPS = [\n\t        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n\t        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n\t    ];\n\t\n\t    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n\t    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    function createLinearGradient(ctx, obj, rect) {\n\t        // var size =\n\t        var x = obj.x;\n\t        var x2 = obj.x2;\n\t        var y = obj.y;\n\t        var y2 = obj.y2;\n\t\n\t        if (!obj.global) {\n\t            x = x * rect.width + rect.x;\n\t            x2 = x2 * rect.width + rect.x;\n\t            y = y * rect.height + rect.y;\n\t            y2 = y2 * rect.height + rect.y;\n\t        }\n\t\n\t        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t    function createRadialGradient(ctx, obj, rect) {\n\t        var width = rect.width;\n\t        var height = rect.height;\n\t        var min = Math.min(width, height);\n\t\n\t        var x = obj.x;\n\t        var y = obj.y;\n\t        var r = obj.r;\n\t        if (!obj.global) {\n\t            x = x * width + rect.x;\n\t            y = y * height + rect.y;\n\t            r = r * min;\n\t        }\n\t\n\t        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t        return canvasGradient;\n\t    }\n\t\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * Only useful in Path and Image element\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * If transform text\n\t         * Only useful in Path and Image element\n\t         * @type {boolean}\n\t         */\n\t        textTransform: false,\n\t\n\t        /**\n\t         * Text rotate around position of Path or Image\n\t         * Only useful in Path and Image element and textTransform is false.\n\t         */\n\t        textRotation: 0,\n\t\n\t        /**\n\t         * @type {string}\n\t         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n\t         */\n\t        blend: null,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el, prevEl) {\n\t            var style = this;\n\t            var prevStyle = prevEl && prevEl.style;\n\t            var firstDraw = !prevStyle;\n\t\n\t            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t                var prop = STYLE_COMMON_PROPS[i];\n\t                var styleName = prop[0];\n\t\n\t                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n\t                    // FIXME Invalid property value will cause style leak from previous element.\n\t                    ctx[styleName] = style[styleName] || prop[1];\n\t                }\n\t            }\n\t\n\t            if ((firstDraw || style.fill !== prevStyle.fill)) {\n\t                ctx.fillStyle = style.fill;\n\t            }\n\t            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n\t                ctx.strokeStyle = style.stroke;\n\t            }\n\t            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n\t                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n\t            }\n\t\n\t            if ((firstDraw || style.blend !== prevStyle.blend)) {\n\t                ctx.globalCompositeOperation = style.blend || 'source-over';\n\t            }\n\t            if (this.hasStroke()) {\n\t                var lineWidth = style.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t        },\n\t\n\t        hasFill: function () {\n\t            var fill = this.fill;\n\t            return fill != null && fill !== 'none';\n\t        },\n\t\n\t        hasStroke: function () {\n\t            var stroke = this.stroke;\n\t            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        },\n\t\n\t        getGradient: function (ctx, obj, rect) {\n\t            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n\t            var canvasGradient = method(ctx, obj, rect);\n\t            var colorStops = obj.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t            return canvasGradient;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n\t        var prop = STYLE_COMMON_PROPS[i];\n\t        if (!(prop[0] in styleProto)) {\n\t            styleProto[prop[0]] = prop[1];\n\t        }\n\t    }\n\t\n\t    // Provide for others\n\t    Style.getGradient = styleProto.getGradient;\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(10);\n\t    var Eventful = __webpack_require__(11);\n\t    var Transformable = __webpack_require__(12);\n\t    var Animatable = __webpack_require__(15);\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.dirty(false);\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty(false);\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty(false);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var idStart = 0x0907;\n\t\n\t    module.exports = function () {\n\t        return idStart++;\n\t    };\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            for (var i = 0; i < _h[event].length; i++) {\n\t                if (_h[event][i].h === handler) {\n\t                    return this;\n\t                }\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(13);\n\t    var vector = __webpack_require__(14);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        if (m) {\n\t            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n\t        }\n\t        else {\n\t            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t        }\n\t    };\n\t\n\t    transformableProto.restoreTransform = function (ctx) {\n\t        var m = this.transform;\n\t        var dpr = ctx.dpr || 1;\n\t        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n\t    }\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * Get global scale\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.getGlobalScale = function () {\n\t        var m = this.transform;\n\t        if (!m) {\n\t            return [1, 1];\n\t        }\n\t        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\t        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        return [sx, sy];\n\t    };\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            if (x == null) {\n\t                x = 0;\n\t            }\n\t            if (y == null) {\n\t                y = 0;\n\t            }\n\t            out[0] = x;\n\t            out[1] = y;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(16);\n\t    var util = __webpack_require__(4);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(20);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n\t         * @param {boolean} [loop] 动画是否循环\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(17);\n\t    var color = __webpack_require__(19);\n\t    var util = __webpack_require__(4);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // arr0 is source array, arr1 is target array.\n\t    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len !== arr1Len) {\n\t            // FIXME Not work for TypedArray\n\t            var isPreviousLarger = arr0Len > arr1Len;\n\t            if (isPreviousLarger) {\n\t                // Cut the previous\n\t                arr0.length = arr1Len;\n\t            }\n\t            else {\n\t                // Fill the previous\n\t                for (var i = arr0Len; i < arr1Len; i++) {\n\t                    arr0.push(\n\t                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                    );\n\t                }\n\t            }\n\t        }\n\t        // Handling NaN value\n\t        var len2 = arr0[0] && arr0[0].length;\n\t        for (var i = 0; i < arr0.length; i++) {\n\t            if (arrDim === 1) {\n\t                if (isNaN(arr0[i])) {\n\t                    arr0[i] = arr1[i];\n\t                }\n\t            }\n\t            else {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (isNaN(arr0[i][j])) {\n\t                        arr0[i][j] = arr1[i][j];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        var lastValue = kfValues[trackLen - 1];\n\t        // Polyfill array and NaN value\n\t        for (var i = 0; i < trackLen - 1; i++) {\n\t            if (isValueArray) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            else {\n\t                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n\t                    kfValues[i] = lastValue;\n\t                }\n\t            }\n\t        }\n\t        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            // In the easing function like elasticOut, percent may less than 0\n\t            if (percent < 0) {\n\t                frame = 0;\n\t            }\n\t            else if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                // PENDING start from lastFrame ?\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                // PENDING really need to do this ?\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} easing\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(18);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (globalTime) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = globalTime + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (globalTime - this._startTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart (globalTime);\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function (globalTime) {\n\t            var remainder = (globalTime - this._startTime) % this._life;\n\t            this._startTime = globalTime - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\t        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n\t            colorStr += ',' + arrColor[3];\n\t        }\n\t        return type + '(' + colorStr + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(21);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(23);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t\n\t            // FIXME\n\t            ctx.save();\n\t\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            if (!style.textTransform) {\n\t                if (transform) {\n\t                    tmpRect.copy(rect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = tmpRect;\n\t                }\n\t            }\n\t            else {\n\t                this.setTransform(ctx);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t\n\t                if (verticalAlign) {\n\t                    switch (verticalAlign) {\n\t                        case 'middle':\n\t                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= textRect.height - textRect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += textRect.lineHeight / 2;\n\t                    }\n\t                    // Force bseline to be middle\n\t                    baseline = 'middle';\n\t                }\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t            ctx.textAlign = align || 'left';\n\t            // Use canvas default alphabetic baseline\n\t            ctx.textBaseline = baseline || 'alphabetic';\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t            // TODO Invalid font\n\t            ctx.font = font || '12px sans-serif';\n\t\n\t            // Text shadow\n\t            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowColor = style.textShadowColor || 'transparent';\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t\n\t            if (style.textRotation) {\n\t                transform && ctx.translate(transform[4], transform[5]);\n\t                ctx.rotate(style.textRotation);\n\t                transform && ctx.translate(-transform[4], -transform[5]);\n\t            }\n\t\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            ctx.restore();\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(4);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var retrieve = util.retrieve;\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} containerWidth\n\t     * @param  {string} textFont\n\t     * @param  {number} [ellipsis='...']\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minChar=0] If truncate result are less\n\t     *                  then minChar, ellipsis will not show, which is\n\t     *                  better for user hint in some cases.\n\t     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n\t     * @return {string}\n\t     */\n\t    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = options || {};\n\t\n\t        ellipsis = retrieve(ellipsis, '...');\n\t        var maxIterations = retrieve(options.maxIterations, 2);\n\t        var minChar = retrieve(options.minChar, 0);\n\t        // FIXME\n\t        // Other languages?\n\t        var cnCharWidth = getTextWidth('国', textFont);\n\t        // FIXME\n\t        // Consider proportional font?\n\t        var ascCharWidth = getTextWidth('a', textFont);\n\t        var placeholder = retrieve(options.placeholder, '');\n\t\n\t        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n\t        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\t        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\t        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n\t            contentWidth -= ascCharWidth;\n\t        }\n\t\n\t        var ellipsisWidth = getTextWidth(ellipsis);\n\t        if (ellipsisWidth > contentWidth) {\n\t            ellipsis = '';\n\t            ellipsisWidth = 0;\n\t        }\n\t\n\t        contentWidth = containerWidth - ellipsisWidth;\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            var textLine = textLines[i];\n\t            var lineWidth = getTextWidth(textLine, textFont);\n\t\n\t            if (lineWidth <= containerWidth) {\n\t                continue;\n\t            }\n\t\n\t            for (var j = 0;; j++) {\n\t                if (lineWidth <= contentWidth || j >= maxIterations) {\n\t                    textLine += ellipsis;\n\t                    break;\n\t                }\n\t\n\t                var subLength = j === 0\n\t                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n\t                    : lineWidth > 0\n\t                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n\t                    : 0;\n\t\n\t                textLine = textLine.substr(0, subLength);\n\t                lineWidth = getTextWidth(textLine, textFont);\n\t            }\n\t\n\t            if (textLine === '') {\n\t                textLine = placeholder;\n\t            }\n\t\n\t            textLines[i] = textLine;\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < contentWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        truncateText: truncateText,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont || '12px sans-serif';\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var matrix = __webpack_require__(13);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t    var vec2 = __webpack_require__(14);\n\t    var bbox = __webpack_require__(27);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var dpr = __webpack_require__(21).devicePixelRatio;\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAbs = Math.abs;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t\n\t        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n\t        this._ux = 0;\n\t        this._uy = 0;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        setScale: function (sx, sy) {\n\t            this._ux = mathAbs(1 / dpr / sx) || 0;\n\t            this._uy = mathAbs(1 / dpr / sy) || 0;\n\t        },\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            ctx && (this.dpr = ctx.dpr);\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            var exceedUnit = mathAbs(x - this._xi) > this._ux\n\t                || mathAbs(y - this._yi) > this._uy\n\t                // Force draw the first segment\n\t                || this._len < 5;\n\t\n\t            this.addData(CMD.L, x, y);\n\t\n\t            if (this._ctx && exceedUnit) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            if (exceedUnit) {\n\t                this._xi = x;\n\t                this._yi = y;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n\t            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            var x0, y0;\n\t            var xi, yi;\n\t            var x, y;\n\t            var ux = this._ux;\n\t            var uy = this._uy;\n\t            var len = this._len;\n\t            for (var i = 0; i < len;) {\n\t                var cmd = d[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = d[i];\n\t                    yi = d[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        x0 = xi = d[i++];\n\t                        y0 = yi = d[i++];\n\t                        ctx.moveTo(xi, yi);\n\t                        break;\n\t                    case CMD.L:\n\t                        x = d[i++];\n\t                        y = d[i++];\n\t                        // Not draw too small seg between\n\t                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n\t                            ctx.lineTo(x, y);\n\t                            xi = x;\n\t                            yi = y;\n\t                        }\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        xi = d[i - 2];\n\t                        yi = d[i - 1];\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        var endAngle = theta + dTheta;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n\t                        }\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(theta) * rx + cx;\n\t                            y0 = mathSin(theta) * ry + cy;\n\t                        }\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = d[i];\n\t                        y0 = yi = d[i + 1];\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                        xi = x0;\n\t                        yi = y0;\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-8;\n\t    var EPSILON_NUMERIC = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON_NUMERIC) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var curve = __webpack_require__(26);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    var xDim = [];\n\t    var yDim = [];\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t        min[0] = Infinity;\n\t        min[1] = Infinity;\n\t        max[0] = -Infinity;\n\t        max[1] = -Infinity;\n\t\n\t        for (i = 0; i < n; i++) {\n\t            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t            min[0] = mathMin(x, min[0]);\n\t            max[0] = mathMax(x, max[0]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t            min[1] = mathMin(y, min[1]);\n\t            max[1] = mathMax(y, max[1]);\n\t        }\n\t\n\t        min[0] = mathMin(x0, min[0]);\n\t        max[0] = mathMax(x0, max[0]);\n\t        min[0] = mathMin(x3, min[0]);\n\t        max[0] = mathMax(x3, max[0]);\n\t\n\t        min[1] = mathMin(y0, min[1]);\n\t        max[1] = mathMax(y0, max[1]);\n\t        min[1] = mathMin(y3, min[1]);\n\t        max[1] = mathMax(y3, max[1]);\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var line = __webpack_require__(29);\n\t    var cubic = __webpack_require__(30);\n\t    var quadratic = __webpack_require__(31);\n\t    var arc = __webpack_require__(32);\n\t    var normalizeRadian = __webpack_require__(33).normalizeRadian;\n\t    var curve = __webpack_require__(26);\n\t\n\t    var windingLine = __webpack_require__(34);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t\n\t                // Avoid winding error when intersection point is the connect point of two line of polygon\n\t                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? unit : -unit;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? unit : -unit;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >= 0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    // Remove one endpoint.\n\t                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\t\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ < x) {   // Quick reject\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? unit : -unit;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? unit : -unit;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                // Remove one endpoint.\n\t                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\t\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ < x) {   // Quick reject\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? unit : -unit;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                // if (w !== 0) {\n\t                //     return true;\n\t                // }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        // FIXME subpaths may overlap\n\t                        // if (w !== 0) {\n\t                        //     return true;\n\t                        // }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(26);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(33).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        // Ignore horizontal line\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t\n\t        // Avoid winding error when intersection point is the connect point of two line of polygon\n\t        if (t === 1 || t === 0) {\n\t            dir = y1 < y0 ? 0.5 : -0.5;\n\t        }\n\t\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var Pattern = function (image, repeat) {\n\t        this.image = image;\n\t        this.repeat = repeat;\n\t\n\t        // Can be cloned\n\t        this.type = 'pattern';\n\t    };\n\t\n\t    Pattern.prototype.getCanvasPattern = function (ctx) {\n\t\n\t        return this._canvasPattern\n\t            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n\t    };\n\t\n\t    module.exports = Pattern;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var vec2 = __webpack_require__(14);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t    var Element = __webpack_require__(9);\n\t    var BoundingRect = __webpack_require__(24);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        isGroup: true,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * 所有子孙元素是否响应鼠标事件\n\t         * @name module:/zrender/container/Group#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var LRU = __webpack_require__(41);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function ZImage(opts) {\n\t        Displayable.call(this, opts);\n\t    }\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t\n\t            // Must bind each time\n\t            style.bind(ctx, this, prevEl);\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t *\n\t * Text not support gradient\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(7);\n\t    var zrUtil = __webpack_require__(4);\n\t    var textContain = __webpack_require__(23);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx, prevEl) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            // Always bind style\n\t            style.bind(ctx, this, prevEl);\n\t\n\t            if (text) {\n\t\n\t                this.setTransform(ctx);\n\t\n\t                var textBaseline;\n\t                var textAlign = style.textAlign;\n\t                var font = style.textFont || style.font;\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    textBaseline = 'middle';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2 - rect.lineHeight / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height - rect.lineHeight / 2;\n\t                            break;\n\t                        default:\n\t                            y += rect.lineHeight / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    textBaseline = style.textBaseline;\n\t                }\n\t\n\t                // TODO Invalid font\n\t                ctx.font = font || '12px sans-serif';\n\t                ctx.textAlign = textAlign || 'left';\n\t                // Use canvas default left textAlign. Giving invalid value will cause state not change\n\t                if (ctx.textAlign !== textAlign) {\n\t                    ctx.textAlign = 'left';\n\t                }\n\t                ctx.textBaseline = textBaseline || 'alphabetic';\n\t                // Use canvas default alphabetic baseline\n\t                if (ctx.textBaseline !== textBaseline) {\n\t                    ctx.textBaseline = 'alphabetic';\n\t                }\n\t\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n\t                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                this.restoreTransform(ctx);\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var textVerticalAlign = style.textVerticalAlign;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign,\n\t                    textVerticalAlign ? 'top' : style.textBaseline\n\t                );\n\t                switch (textVerticalAlign) {\n\t                    case 'middle':\n\t                        rect.y -= rect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        rect.y -= rect.height;\n\t                        break;\n\t                }\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t\n\t        buildPath : function (ctx, shape, inBundle) {\n\t            // Better stroking in ShapeBundle\n\t            // Always do it may have performence issue ( fill may be 2x more cost)\n\t            if (inBundle) {\n\t                ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            }\n\t            // Better stroking in ShapeBundle\n\t            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(47);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(48);\n\t    var smoothBezier = __webpack_require__(49);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(14);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(14);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(47);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(52);\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(26);\n\t    var vec2 = __webpack_require__(14);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n\t    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\t\n\t    var out = [];\n\t\n\t    function someVectorAt(shape, t, isTangent) {\n\t        var cpx2 = shape.cpx2;\n\t        var cpy2 = shape.cpy2;\n\t        if (cpx2 === null || cpy2 === null) {\n\t            return [\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n\t                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n\t            ];\n\t        }\n\t        else {\n\t            return [\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n\t                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n\t            ];\n\t        }\n\t    }\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (t) {\n\t            return someVectorAt(this.shape, t, false);\n\t        },\n\t\n\t        /**\n\t         * Get tangent at percent\n\t         * @param  {number} t\n\t         * @return {Array.<number>}\n\t         */\n\t        tangentAt: function (t) {\n\t            var p = someVectorAt(this.shape, t, true);\n\t            return vec2.normalize(p, p);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(6).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        // Can be cloned\n\t        this.type = 'linear';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(4);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     * @param {boolean} [globalCoord=false]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        // Can be cloned\n\t        this.type = 'radial';\n\t\n\t        // If use global coord\n\t        this.global = globalCoord || false;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var apiList = [\r\n\t        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n\t        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getNodeClass', 'showTipWindow', 'hideTipWindow', 'resize', 'clear'\r\n\t    ];\r\n\t\r\n\t    function ExtensionAPI(instance) {\r\n\t        zrUtil.each(apiList, function (name) {\r\n\t            this[name] = zrUtil.bind(instance[name], instance);\r\n\t        }, this);\r\n\t    }\r\n\t\r\n\t    module.exports = ExtensionAPI;\r\n\t\r\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(10);\n\t    var env = __webpack_require__(60);\n\t\n\t    var Handler = __webpack_require__(61);\n\t    var Storage = __webpack_require__(62);\n\t    var Animation = __webpack_require__(64);\n\t    var HandlerProxy = __webpack_require__(67);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(69)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.1.3';\n\t\n\t    /**\n\t     * Initializing a zrender instance\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * Get zrender instance by id\n\t     * @param {string} id zrender instance id\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n\t        this.handler = new Handler(storage, painter, handerProxy);\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                    if (self._needsRefreshHover) {\n\t                        self.refreshHoverImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Change configuration of layer\n\t         * @param {string} zLevel\n\t         * @param {Object} config\n\t         * @param {string} [config.clearColor=0] Clear color\n\t         * @param {string} [config.motionBlur=false] If enable motion blur\n\t         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Repaint the canvas immediately\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * Mark and repaint the canvas in the next frame of browser\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * Add element to hover layer\n\t         * @param  {module:zrender/Element} el\n\t         * @param {Object} style\n\t         */\n\t        addHover: function (el, style) {\n\t            if (this.painter.addHover) {\n\t                this.painter.addHover(el, style);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add element from hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        removeHover: function (el) {\n\t            if (this.painter.removeHover) {\n\t                this.painter.removeHover(el);\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clear all hover elements in hover layer\n\t         * @param  {module:zrender/Element} el\n\t         */\n\t        clearHover: function () {\n\t            if (this.painter.clearHover) {\n\t                this.painter.clearHover();\n\t                this.refreshHover();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Refresh hover in next frame\n\t         */\n\t        refreshHover: function () {\n\t            this._needsRefreshHover = true;\n\t        },\n\t\n\t        /**\n\t         * Refresh hover immediately\n\t         */\n\t        refreshHoverImmediately: function () {\n\t            this._needsRefreshHover = false;\n\t            this.painter.refreshHover && this.painter.refreshHover();\n\t        },\n\t\n\t        /**\n\t         * Resize the canvas.\n\t         * Should be invoked when container size is changed\n\t         */\n\t        resize: function() {\n\t            this.painter.resize();\n\t            this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * Stop and clear all animation immediately\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * Get container width\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * Get container height\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * Export the canvas as Base64 URL\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff']\n\t         * @return {string} Base64 URL\n\t         */\n\t        // toDataURL: function(type, backgroundColor) {\n\t        //     return this.painter.getRenderedCanvas({\n\t        //         backgroundColor: backgroundColor\n\t        //     }).toDataURL(type);\n\t        // },\n\t\n\t        /**\n\t         * Converting a path to image.\n\t         * It has much better performance of drawing image rather than drawing a vector path.\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * Set default cursor\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            this.handler.setCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * Bind event\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {Function} eventHandler Handler function\n\t         * @param {Object} [context] Context object\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * Unbind event\n\t         * @param {string} eventName Event name\n\t         * @param {Function} [eventHandler] Handler function\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * Trigger event manually\n\t         *\n\t         * @param {string} eventName Event name\n\t         * @param {event=} event Event object\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * Clear all objects and the canvas.\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * Dispose self.\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        // var touchpad = webos && ua.match(/TouchPad/);\n\t        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        // var playbook = ua.match(/PlayBook/);\n\t        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        // if (android) os.android = true, os.version = android[2];\n\t        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        // if (webos) os.webos = true, os.version = webos[2];\n\t        // if (touchpad) os.touchpad = true;\n\t        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        // if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        // if (playbook) browser.playbook = true;\n\t        // if (kindle) os.kindle = true, os.version = kindle[1];\n\t        // if (silk) browser.silk = true, browser.version = silk[1];\n\t        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) browser.firefox = true, browser.version = firefox[1];\n\t        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        // if (webview) browser.webview = true;\n\t        if (ie) {\n\t            browser.ie = true; browser.version = ie[1];\n\t        }\n\t        if (ie) {\n\t            browser.ie = true;\n\t            browser.version = ie[1];\n\t        }\n\t        if (edge) {\n\t            browser.edge = true;\n\t            browser.version = edge[1];\n\t        }\n\t\n\t        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n\t        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var Draggable = __webpack_require__(38);\n\t\n\t    var Eventful = __webpack_require__(11);\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t\n\t    function EmptyProxy () {}\n\t    EmptyProxy.prototype.dispose = function () {};\n\t\n\t    var handlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove'\n\t    ];\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function(storage, painter, proxy) {\n\t        Eventful.call(this);\n\t\n\t        this.storage = storage;\n\t\n\t        this.painter = painter;\n\t\n\t        proxy = proxy || new EmptyProxy();\n\t        /**\n\t         * Proxy of event. can be Dom, WebGLSurface, etc.\n\t         */\n\t        this.proxy = proxy;\n\t\n\t        // Attach handler\n\t        proxy.handler = this;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t\n\t        Draggable.call(this);\n\t\n\t        util.each(handlerNames, function (name) {\n\t            proxy.on && proxy.on(name, this[name], this);\n\t        }, this);\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        mousemove: function (event) {\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t            var proxy = this.proxy;\n\t\n\t            this._hovered = hovered;\n\t\n\t            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\t\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this.dispatchToElement(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this.dispatchToElement(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this.dispatchToElement(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        mouseout: function (event) {\n\t            this.dispatchToElement(this._hovered, 'mouseout', event);\n\t\n\t            this.trigger('globalout', {\n\t                event: event\n\t            });\n\t        },\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t\n\t            this.proxy.dispose();\n\t\n\t            this.storage =\n\t            this.proxy =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} [cursorStyle='default'] 例如 crosshair\n\t         */\n\t        setCursorStyle: function (cursorStyle) {\n\t            var proxy = this.proxy;\n\t            proxy.setCursor && proxy.setCursor(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetEl 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        dispatchToElement: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n\t        Handler.prototype[name] = function (event) {\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t\n\t            if (name === 'mousedown') {\n\t                this._downel = hovered;\n\t                // In case click triggered before mouseup\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'mosueup') {\n\t                this._upel = hovered;\n\t            }\n\t            else if (name === 'click') {\n\t                if (this._downel !== this._upel) {\n\t                    return;\n\t                }\n\t            }\n\t\n\t            this.dispatchToElement(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var el = displayable;\n\t            while (el) {\n\t                // If ancestor is silent or clipped by ancestor\n\t                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n\t                    return false;\n\t                }\n\t                el = el.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var env = __webpack_require__(60);\n\t\n\t    var Group = __webpack_require__(39);\n\t\n\t    // Use timsort because in most case elements are partially sorted\n\t    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n\t    var timsort = __webpack_require__(63);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                // if (a.z2 === b.z2) {\n\t                //     // FIXME Slow has renderidx compare\n\t                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n\t                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n\t                //     return a.__renderidx - b.__renderidx;\n\t                // }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         *\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._roots.length; i++) {\n\t                this._roots[i].traverse(cb, context);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            // for (var i = 0, len = displayList.length; i < len; i++) {\n\t            //     displayList[i].__renderidx = i;\n\t            // }\n\t\n\t            // displayList.sort(shapeCompareFunc);\n\t            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            if (el.__dirty) {\n\t\n\t                el.update();\n\t\n\t            }\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.isGroup) {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    if (el.__dirty) {\n\t                        child.__dirty = true;\n\t                    }\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty(false);\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        },\n\t\n\t        displayableSortFunc: shapeCompareFunc\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\t// https://github.com/mziccard/node-timsort\n\t\n\t    var DEFAULT_MIN_MERGE = 32;\n\t\n\t    var DEFAULT_MIN_GALLOPING = 7;\n\t\n\t    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\t\n\t    function minRunLength(n) {\n\t        var r = 0;\n\t\n\t        while (n >= DEFAULT_MIN_MERGE) {\n\t            r |= n & 1;\n\t            n >>= 1;\n\t        }\n\t\n\t        return n + r;\n\t    }\n\t\n\t    function makeAscendingRun(array, lo, hi, compare) {\n\t        var runHi = lo + 1;\n\t\n\t        if (runHi === hi) {\n\t            return 1;\n\t        }\n\t\n\t        if (compare(array[runHi++], array[lo]) < 0) {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n\t                runHi++;\n\t            }\n\t\n\t            reverseRun(array, lo, runHi);\n\t        }\n\t        else {\n\t            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n\t                runHi++;\n\t            }\n\t        }\n\t\n\t        return runHi - lo;\n\t    }\n\t\n\t    function reverseRun(array, lo, hi) {\n\t        hi--;\n\t\n\t        while (lo < hi) {\n\t            var t = array[lo];\n\t            array[lo++] = array[hi];\n\t            array[hi--] = t;\n\t        }\n\t    }\n\t\n\t    function binaryInsertionSort(array, lo, hi, start, compare) {\n\t        if (start === lo) {\n\t            start++;\n\t        }\n\t\n\t        for (; start < hi; start++) {\n\t            var pivot = array[start];\n\t\n\t            var left = lo;\n\t            var right = start;\n\t            var mid;\n\t\n\t            while (left < right) {\n\t                mid = left + right >>> 1;\n\t\n\t                if (compare(pivot, array[mid]) < 0) {\n\t                    right = mid;\n\t                }\n\t                else {\n\t                    left = mid + 1;\n\t                }\n\t            }\n\t\n\t            var n = start - left;\n\t\n\t            switch (n) {\n\t                case 3:\n\t                    array[left + 3] = array[left + 2];\n\t\n\t                case 2:\n\t                    array[left + 2] = array[left + 1];\n\t\n\t                case 1:\n\t                    array[left + 1] = array[left];\n\t                    break;\n\t                default:\n\t                    while (n > 0) {\n\t                        array[left + n] = array[left + n - 1];\n\t                        n--;\n\t                    }\n\t            }\n\t\n\t            array[left] = pivot;\n\t        }\n\t    }\n\t\n\t    function gallopLeft(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) > 0) {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t        else {\n\t            maxOffset = hint + 1;\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t\n\t        lastOffset++;\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) > 0) {\n\t                lastOffset = m + 1;\n\t            }\n\t            else {\n\t                offset = m;\n\t            }\n\t        }\n\t        return offset;\n\t    }\n\t\n\t    function gallopRight(value, array, start, length, hint, compare) {\n\t        var lastOffset = 0;\n\t        var maxOffset = 0;\n\t        var offset = 1;\n\t\n\t        if (compare(value, array[start + hint]) < 0) {\n\t            maxOffset = hint + 1;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            var tmp = lastOffset;\n\t            lastOffset = hint - offset;\n\t            offset = hint - tmp;\n\t        }\n\t        else {\n\t            maxOffset = length - hint;\n\t\n\t            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n\t                lastOffset = offset;\n\t                offset = (offset << 1) + 1;\n\t\n\t                if (offset <= 0) {\n\t                    offset = maxOffset;\n\t                }\n\t            }\n\t\n\t            if (offset > maxOffset) {\n\t                offset = maxOffset;\n\t            }\n\t\n\t            lastOffset += hint;\n\t            offset += hint;\n\t        }\n\t\n\t        lastOffset++;\n\t\n\t        while (lastOffset < offset) {\n\t            var m = lastOffset + (offset - lastOffset >>> 1);\n\t\n\t            if (compare(value, array[start + m]) < 0) {\n\t                offset = m;\n\t            }\n\t            else {\n\t                lastOffset = m + 1;\n\t            }\n\t        }\n\t\n\t        return offset;\n\t    }\n\t\n\t    function TimSort(array, compare) {\n\t        var minGallop = DEFAULT_MIN_GALLOPING;\n\t        var length = 0;\n\t        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n\t        var stackLength = 0;\n\t        var runStart;\n\t        var runLength;\n\t        var stackSize = 0;\n\t\n\t        length = array.length;\n\t\n\t        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n\t            tmpStorageLength = length >>> 1;\n\t        }\n\t\n\t        var tmp = [];\n\t\n\t        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\t\n\t        runStart = [];\n\t        runLength = [];\n\t\n\t        function pushRun(_runStart, _runLength) {\n\t            runStart[stackSize] = _runStart;\n\t            runLength[stackSize] = _runLength;\n\t            stackSize += 1;\n\t        }\n\t\n\t        function mergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n\t                    if (runLength[n - 1] < runLength[n + 1]) {\n\t                        n--;\n\t                    }\n\t                }\n\t                else if (runLength[n] > runLength[n + 1]) {\n\t                    break;\n\t                }\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function forceMergeRuns() {\n\t            while (stackSize > 1) {\n\t                var n = stackSize - 2;\n\t\n\t                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n\t                    n--;\n\t                }\n\t\n\t                mergeAt(n);\n\t            }\n\t        }\n\t\n\t        function mergeAt(i) {\n\t            var start1 = runStart[i];\n\t            var length1 = runLength[i];\n\t            var start2 = runStart[i + 1];\n\t            var length2 = runLength[i + 1];\n\t\n\t            runLength[i] = length1 + length2;\n\t\n\t            if (i === stackSize - 3) {\n\t                runStart[i + 1] = runStart[i + 2];\n\t                runLength[i + 1] = runLength[i + 2];\n\t            }\n\t\n\t            stackSize--;\n\t\n\t            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n\t            start1 += k;\n\t            length1 -= k;\n\t\n\t            if (length1 === 0) {\n\t                return;\n\t            }\n\t\n\t            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\t\n\t            if (length2 === 0) {\n\t                return;\n\t            }\n\t\n\t            if (length1 <= length2) {\n\t                mergeLow(start1, length1, start2, length2);\n\t            }\n\t            else {\n\t                mergeHigh(start1, length1, start2, length2);\n\t            }\n\t        }\n\t\n\t        function mergeLow(start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length1; i++) {\n\t                tmp[i] = array[start1 + i];\n\t            }\n\t\n\t            var cursor1 = 0;\n\t            var cursor2 = start2;\n\t            var dest = start1;\n\t\n\t            array[dest++] = array[cursor2++];\n\t\n\t            if (--length2 === 0) {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t                return;\n\t            }\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t            var count1, count2, exit;\n\t\n\t            while (1) {\n\t                count1 = 0;\n\t                count2 = 0;\n\t                exit = false;\n\t\n\t                do {\n\t                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n\t                        array[dest++] = array[cursor2++];\n\t                        count2++;\n\t                        count1 = 0;\n\t\n\t                        if (--length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest++] = tmp[cursor1++];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        for (i = 0; i < count1; i++) {\n\t                            array[dest + i] = tmp[cursor1 + i];\n\t                        }\n\t\n\t                        dest += count1;\n\t                        cursor1 += count1;\n\t                        length1 -= count1;\n\t                        if (length1 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest++] = array[cursor2++];\n\t\n\t                    if (--length2 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[dest + i] = array[cursor2 + i];\n\t                        }\n\t\n\t                        dest += count2;\n\t                        cursor2 += count2;\n\t                        length2 -= count2;\n\t\n\t                        if (length2 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    array[dest++] = tmp[cursor1++];\n\t\n\t                    if (--length1 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            minGallop < 1 && (minGallop = 1);\n\t\n\t            if (length1 === 1) {\n\t                for (i = 0; i < length2; i++) {\n\t                    array[dest + i] = array[cursor2 + i];\n\t                }\n\t                array[dest + length2] = tmp[cursor1];\n\t            }\n\t            else if (length1 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeLow preconditions were not respected');\n\t            }\n\t            else {\n\t                for (i = 0; i < length1; i++) {\n\t                    array[dest + i] = tmp[cursor1 + i];\n\t                }\n\t            }\n\t        }\n\t\n\t        function mergeHigh (start1, length1, start2, length2) {\n\t            var i = 0;\n\t\n\t            for (i = 0; i < length2; i++) {\n\t                tmp[i] = array[start2 + i];\n\t            }\n\t\n\t            var cursor1 = start1 + length1 - 1;\n\t            var cursor2 = length2 - 1;\n\t            var dest = start2 + length2 - 1;\n\t            var customCursor = 0;\n\t            var customDest = 0;\n\t\n\t            array[dest--] = array[cursor1--];\n\t\n\t            if (--length1 === 0) {\n\t                customCursor = dest - (length2 - 1);\n\t\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t\n\t                return;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t                return;\n\t            }\n\t\n\t            var _minGallop = minGallop;\n\t\n\t            while (true) {\n\t                var count1 = 0;\n\t                var count2 = 0;\n\t                var exit = false;\n\t\n\t                do {\n\t                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n\t                        array[dest--] = array[cursor1--];\n\t                        count1++;\n\t                        count2 = 0;\n\t                        if (--length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    else {\n\t                        array[dest--] = tmp[cursor2--];\n\t                        count2++;\n\t                        count1 = 0;\n\t                        if (--length2 === 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                } while ((count1 | count2) < _minGallop);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                do {\n\t                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\t\n\t                    if (count1 !== 0) {\n\t                        dest -= count1;\n\t                        cursor1 -= count1;\n\t                        length1 -= count1;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor1 + 1;\n\t\n\t                        for (i = count1 - 1; i >= 0; i--) {\n\t                            array[customDest + i] = array[customCursor + i];\n\t                        }\n\t\n\t                        if (length1 === 0) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = tmp[cursor2--];\n\t\n\t                    if (--length2 === 1) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\t\n\t                    if (count2 !== 0) {\n\t                        dest -= count2;\n\t                        cursor2 -= count2;\n\t                        length2 -= count2;\n\t                        customDest = dest + 1;\n\t                        customCursor = cursor2 + 1;\n\t\n\t                        for (i = 0; i < count2; i++) {\n\t                            array[customDest + i] = tmp[customCursor + i];\n\t                        }\n\t\n\t                        if (length2 <= 1) {\n\t                            exit = true;\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    array[dest--] = array[cursor1--];\n\t\n\t                    if (--length1 === 0) {\n\t                        exit = true;\n\t                        break;\n\t                    }\n\t\n\t                    _minGallop--;\n\t                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\t\n\t                if (exit) {\n\t                    break;\n\t                }\n\t\n\t                if (_minGallop < 0) {\n\t                    _minGallop = 0;\n\t                }\n\t\n\t                _minGallop += 2;\n\t            }\n\t\n\t            minGallop = _minGallop;\n\t\n\t            if (minGallop < 1) {\n\t                minGallop = 1;\n\t            }\n\t\n\t            if (length2 === 1) {\n\t                dest -= length1;\n\t                cursor1 -= length1;\n\t                customDest = dest + 1;\n\t                customCursor = cursor1 + 1;\n\t\n\t                for (i = length1 - 1; i >= 0; i--) {\n\t                    array[customDest + i] = array[customCursor + i];\n\t                }\n\t\n\t                array[dest] = tmp[cursor2];\n\t            }\n\t            else if (length2 === 0) {\n\t                throw new Error();\n\t                // throw new Error('mergeHigh preconditions were not respected');\n\t            }\n\t            else {\n\t                customCursor = dest - (length2 - 1);\n\t                for (i = 0; i < length2; i++) {\n\t                    array[customCursor + i] = tmp[i];\n\t                }\n\t            }\n\t        }\n\t\n\t        this.mergeRuns = mergeRuns;\n\t        this.forceMergeRuns = forceMergeRuns;\n\t        this.pushRun = pushRun;\n\t    }\n\t\n\t    function sort(array, compare, lo, hi) {\n\t        if (!lo) {\n\t            lo = 0;\n\t        }\n\t        if (!hi) {\n\t            hi = array.length;\n\t        }\n\t\n\t        var remaining = hi - lo;\n\t\n\t        if (remaining < 2) {\n\t            return;\n\t        }\n\t\n\t        var runLength = 0;\n\t\n\t        if (remaining < DEFAULT_MIN_MERGE) {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n\t            return;\n\t        }\n\t\n\t        var ts = new TimSort(array, compare);\n\t\n\t        var minRun = minRunLength(remaining);\n\t\n\t        do {\n\t            runLength = makeAscendingRun(array, lo, hi, compare);\n\t            if (runLength < minRun) {\n\t                var force = remaining;\n\t                if (force > minRun) {\n\t                    force = minRun;\n\t                }\n\t\n\t                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n\t                runLength = force;\n\t            }\n\t\n\t            ts.pushRun(lo, runLength);\n\t            ts.mergeRuns();\n\t\n\t            remaining -= runLength;\n\t            lo += runLength;\n\t        } while (remaining !== 0);\n\t\n\t        ts.forceMergeRuns();\n\t    }\n\t\n\t    module.exports = sort;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var Dispatcher = __webpack_require__(65).Dispatcher;\n\t\n\t    var requestAnimationFrame = __webpack_require__(66);\n\t\n\t    var Animator = __webpack_require__(16);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time;\n\t\n\t        this._pausedTime;\n\t\n\t        this._pauseStart;\n\t\n\t        this._paused = false;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime() - this._pausedTime;\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t\n\t        _startLoop: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    !self._paused && self._update();\n\t                }\n\t            }\n\t\n\t            requestAnimationFrame(step);\n\t        },\n\t\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t\n\t            this._time = new Date().getTime();\n\t            this._pausedTime = 0;\n\t\n\t            this._startLoop();\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t\n\t        /**\n\t         * Pause\n\t         */\n\t        pause: function () {\n\t            if (!this._paused) {\n\t                this._pauseStart = new Date().getTime();\n\t                this._paused = true;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Resume\n\t         */\n\t        resume: function () {\n\t            if (this._paused) {\n\t                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n\t                this._paused = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        // TODO Gap\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(11);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n\t    }\n\t\n\t    function clientToLocal(el, e, out) {\n\t        // clientX/clientY is according to view port.\n\t        var box = getBoundingClientRect(el);\n\t        out = out || {};\n\t        out.zrX = e.clientX - box.left;\n\t        out.zrY = e.clientY - box.top;\n\t        return out;\n\t    }\n\t\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n\t     */\n\t    function normalizeEvent(el, e) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            clientToLocal(el, e, e);\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                ? e.targetTouches[0]\n\t                : e.changedTouches[0];\n\t            touch && clientToLocal(el, touch, e);\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        clientToLocal: clientToLocal,\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var eventTool = __webpack_require__(65);\n\t    var zrUtil = __webpack_require__(4);\n\t    var Eventful = __webpack_require__(11);\n\t    var env = __webpack_require__(60);\n\t    var GestureMgr = __webpack_require__(68);\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout',\n\t        'mouseup', 'mousedown', 'mousemove'\n\t    ];\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    function processGesture(proxy, event, stage) {\n\t        var gestureMgr = proxy._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            proxy.handler.findHover(event.zrX, event.zrY, null),\n\t            proxy.dom\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this.trigger('mousemove', event);\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.dom) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.dom) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this.trigger('mouseout', event);\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // Default mouse behaviour should not be disabled here.\n\t            // For example, page may needs to be slided.\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // 平板补充一次findHover\n\t            // this._mobileFindFixed(event);\n\t            // Trigger mousemove and mousedown\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t\n\t            event = normalizeEvent(this.dom, event);\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.dom, event);\n\t            this.trigger(name, event);\n\t        };\n\t    });\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        for (var i = 0; i < touchHandlerNames.length; i++) {\n\t            var name = touchHandlerNames[i];\n\t            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t\n\t    function HandlerDomProxy(dom) {\n\t        Eventful.call(this);\n\t\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        this._handlers = {};\n\t\n\t        initDomHandler(this);\n\t\n\t        if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            zrUtil.each(handlerNames, function (name) {\n\t                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    }\n\t\n\t    var handlerDomProxyProto = HandlerDomProxy.prototype;\n\t    handlerDomProxyProto.dispose = function () {\n\t        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n\t        }\n\t    };\n\t\n\t    handlerDomProxyProto.setCursor = function (cursorStyle) {\n\t        this.dom.style.cursor = cursorStyle || 'default';\n\t    };\n\t\n\t    zrUtil.mixin(HandlerDomProxy, Eventful);\n\t\n\t    module.exports = HandlerDomProxy;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var eventUtil = __webpack_require__(65);\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target, root) {\n\t            this._doTrack(event, target, root);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target, root) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                var pos = eventUtil.clientToLocal(root, touch);\n\t                trackItem.points.push([pos.zrX, pos.zrY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(21);\n\t    var util = __webpack_require__(4);\n\t    var log = __webpack_require__(20);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var timsort = __webpack_require__(63);\n\t\n\t    var Layer = __webpack_require__(70);\n\t\n\t    var requestAnimationFrame = __webpack_require__(66);\n\t\n\t    // PENDIGN\n\t    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n\t    //\n\t    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n\t    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n\t            return false;\n\t        }\n\t\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var path = clipPath.path;\n\t\n\t            clipPath.setTransform(ctx);\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            clipPath.restoreTransform(ctx);\n\t        }\n\t    }\n\t\n\t    function createRoot(width, height) {\n\t        var domRoot = document.createElement('div');\n\t        var domRootStyle = domRoot.style;\n\t\n\t        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t        domRootStyle.position = 'relative';\n\t        domRootStyle.overflow = 'hidden';\n\t        domRootStyle.width = width + 'px';\n\t        domRootStyle.height = height + 'px';\n\t        return domRoot;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        // In node environment using node-canvas\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] =\n\t            rootStyle['user-select'] =\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        var zlevelList = this._zlevelList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:zrender/Layer>}\n\t         * @private\n\t         */\n\t        var layers = this._layers = {};\n\t\n\t        /**\n\t         * @type {Object.<string, Object>}\n\t         * @type {private}\n\t         */\n\t        this._layerConfig = {};\n\t\n\t        if (!singleCanvas) {\n\t            this._width = this._getWidth();\n\t            this._height = this._getHeight();\n\t\n\t            var domRoot = this._domRoot = createRoot(\n\t                this._width, this._height\n\t            );\n\t            root.appendChild(domRoot);\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            layers[0] = mainLayer;\n\t            zlevelList.push(0);\n\t        }\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t\n\t        // Layers for progressive rendering\n\t        this._progressiveLayers = [];\n\t\n\t        /**\n\t         * @type {module:zrender/Layer}\n\t         * @private\n\t         */\n\t        this._hoverlayer;\n\t\n\t        this._hoverElements = [];\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t\n\t            var list = this.storage.getDisplayList(true);\n\t\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            this.refreshHover();\n\t\n\t            if (this._progressiveLayers.length) {\n\t                this._startProgessive();\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        addHover: function (el, hoverStyle) {\n\t            if (el.__hoverMir) {\n\t                return;\n\t            }\n\t            var elMirror = new el.constructor({\n\t                style: el.style,\n\t                shape: el.shape\n\t            });\n\t            elMirror.__from = el;\n\t            el.__hoverMir = elMirror;\n\t            elMirror.setStyle(hoverStyle);\n\t            this._hoverElements.push(elMirror);\n\t        },\n\t\n\t        removeHover: function (el) {\n\t            var elMirror = el.__hoverMir;\n\t            var hoverElements = this._hoverElements;\n\t            var idx = util.indexOf(hoverElements, elMirror);\n\t            if (idx >= 0) {\n\t                hoverElements.splice(idx, 1);\n\t            }\n\t            el.__hoverMir = null;\n\t        },\n\t\n\t        clearHover: function (el) {\n\t            var hoverElements = this._hoverElements;\n\t            for (var i = 0; i < hoverElements.length; i++) {\n\t                var from = hoverElements[i].__from;\n\t                if (from) {\n\t                    from.__hoverMir = null;\n\t                }\n\t            }\n\t            hoverElements.length = 0;\n\t        },\n\t\n\t        refreshHover: function () {\n\t            var hoverElements = this._hoverElements;\n\t            var len = hoverElements.length;\n\t            var hoverLayer = this._hoverlayer;\n\t            hoverLayer && hoverLayer.clear();\n\t\n\t            if (!len) {\n\t                return;\n\t            }\n\t            timsort(hoverElements, this.storage.displayableSortFunc);\n\t\n\t            // Use a extream large zlevel\n\t            // FIXME?\n\t            if (!hoverLayer) {\n\t                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n\t            }\n\t\n\t            var scope = {};\n\t            hoverLayer.ctx.save();\n\t            for (var i = 0; i < len;) {\n\t                var el = hoverElements[i];\n\t                var originalEl = el.__from;\n\t                // Original el is removed\n\t                // PENDING\n\t                if (!(originalEl && originalEl.__zr)) {\n\t                    hoverElements.splice(i, 1);\n\t                    originalEl.__hoverMir = null;\n\t                    len--;\n\t                    continue;\n\t                }\n\t                i++;\n\t\n\t                // Use transform\n\t                // FIXME style and shape ?\n\t                if (!originalEl.invisible) {\n\t                    el.transform = originalEl.transform;\n\t                    el.invTransform = originalEl.invTransform;\n\t                    el.__clipPaths = originalEl.__clipPaths;\n\t                    // el.\n\t                    this._doPaintEl(el, hoverLayer, true, scope);\n\t                }\n\t            }\n\t            hoverLayer.ctx.restore();\n\t        },\n\t\n\t        _startProgessive: function () {\n\t            var self = this;\n\t\n\t            if (!self._furtherProgressive) {\n\t                return;\n\t            }\n\t\n\t            // Use a token to stop progress steps triggered by\n\t            // previous zr.refresh calling.\n\t            var token = self._progressiveToken = +new Date();\n\t\n\t            self._progress++;\n\t            requestAnimationFrame(step);\n\t\n\t            function step() {\n\t                // In case refreshed or disposed\n\t                if (token === self._progressiveToken && self.storage) {\n\t\n\t                    self._doPaintList(self.storage.getDisplayList());\n\t\n\t                    if (self._furtherProgressive) {\n\t                        self._progress++;\n\t                        requestAnimationFrame(step);\n\t                    }\n\t                    else {\n\t                        self._progressiveToken = -1;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _clearProgressive: function () {\n\t            this._progressiveToken = -1;\n\t            this._progress = 0;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                layer.__dirty && layer.clear();\n\t            });\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            this._clearProgressive();\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            this._doPaintList(list, paintAll);\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        _doPaintList: function (list, paintAll) {\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            // var invTransform = [];\n\t            var scope;\n\t\n\t            var progressiveLayerIdx = 0;\n\t            var currentProgressiveLayer;\n\t\n\t            var width = this._width;\n\t            var height = this._height;\n\t            var layerProgress;\n\t            var frame = this._progress;\n\t            function flushProgressiveLayer(layer) {\n\t                var dpr = ctx.dpr || 1;\n\t                ctx.save();\n\t                ctx.globalAlpha = 1;\n\t                ctx.shadowBlur = 0;\n\t                // Avoid layer don't clear in next progressive frame\n\t                currentLayer.__dirty = true;\n\t                ctx.setTransform(1, 0, 0, 1, 0, 0);\n\t                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t\n\t                var elFrame = el.__frame;\n\t\n\t                // Flush at current context\n\t                // PENDING\n\t                if (elFrame < 0 && currentProgressiveLayer) {\n\t                    flushProgressiveLayer(currentProgressiveLayer);\n\t                    currentProgressiveLayer = null;\n\t                }\n\t\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    if (ctx) {\n\t                        ctx.restore();\n\t                    }\n\t\n\t                    // Reset scope\n\t                    scope = {};\n\t\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t                    ctx.save();\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (!(currentLayer.__dirty || paintAll)) {\n\t                    continue;\n\t                }\n\t\n\t                if (elFrame >= 0) {\n\t                    // Progressive layer changed\n\t                    if (!currentProgressiveLayer) {\n\t                        currentProgressiveLayer = this._progressiveLayers[\n\t                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n\t                        ];\n\t\n\t                        currentProgressiveLayer.ctx.save();\n\t                        currentProgressiveLayer.renderScope = {};\n\t\n\t                        if (currentProgressiveLayer\n\t                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n\t                        ) {\n\t                            // flushProgressiveLayer(currentProgressiveLayer);\n\t                            // Quick jump all progressive elements\n\t                            // All progressive element are not dirty, jump over and flush directly\n\t                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n\t                            // currentProgressiveLayer = null;\n\t                            continue;\n\t                        }\n\t\n\t                        layerProgress = currentProgressiveLayer.__progress;\n\t\n\t                        if (!currentProgressiveLayer.__dirty) {\n\t                            // Keep rendering\n\t                            frame = layerProgress;\n\t                        }\n\t\n\t                        currentProgressiveLayer.__progress = frame + 1;\n\t                    }\n\t\n\t                    if (elFrame === frame) {\n\t                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n\t                    }\n\t                }\n\t                else {\n\t                    this._doPaintEl(el, currentLayer, paintAll, scope);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                flushProgressiveLayer(currentProgressiveLayer);\n\t            }\n\t\n\t            // Restore the lastLayer ctx\n\t            ctx && ctx.restore();\n\t            // If still has clipping state\n\t            // if (scope.prevElClipPaths) {\n\t            //     ctx.restore();\n\t            // }\n\t\n\t            this._furtherProgressive = false;\n\t            util.each(this._progressiveLayers, function (layer) {\n\t                if (layer.__maxProgress >= layer.__progress) {\n\t                    this._furtherProgressive = true;\n\t                }\n\t            }, this);\n\t        },\n\t\n\t        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n\t            var ctx = currentLayer.ctx;\n\t            var m = el.transform;\n\t            if (\n\t                (currentLayer.__dirty || forcePaint)\n\t                // Ignore invisible element\n\t                && !el.invisible\n\t                // Ignore transparent element\n\t                && el.style.opacity !== 0\n\t                // Ignore scale 0 element, in some environment like node-canvas\n\t                // Draw a scale 0 element can cause all following draw wrong\n\t                // And setTransform with scale 0 will cause set back transform failed.\n\t                && !(m && !m[0] && !m[3])\n\t                // Ignore culled element\n\t                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n\t            ) {\n\t\n\t                var clipPaths = el.__clipPaths;\n\t\n\t                // Optimize when clipping on group with several elements\n\t                if (scope.prevClipLayer !== currentLayer\n\t                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n\t                ) {\n\t                    // If has previous clipping state, restore from it\n\t                    if (scope.prevElClipPaths) {\n\t                        scope.prevClipLayer.ctx.restore();\n\t                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\t\n\t                        // Reset prevEl since context has been restored\n\t                        scope.prevEl = null;\n\t                    }\n\t                    // New clipping state\n\t                    if (clipPaths) {\n\t                        ctx.save();\n\t                        doClip(clipPaths, ctx);\n\t                        scope.prevClipLayer = currentLayer;\n\t                        scope.prevElClipPaths = clipPaths;\n\t                    }\n\t                }\n\t                el.beforeBrush && el.beforeBrush(ctx);\n\t\n\t                el.brush(ctx, scope.prevEl || null);\n\t                scope.prevEl = el;\n\t\n\t                el.afterBrush && el.afterBrush(ctx);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t            var progressiveLayers = this._progressiveLayers;\n\t\n\t            var elCountsLastFrame = {};\n\t            var progressiveElCountsLastFrame = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCountsLastFrame[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                progressiveElCountsLastFrame[idx] = layer.elCount;\n\t                layer.elCount = 0;\n\t                layer.__dirty = false;\n\t            });\n\t\n\t            var progressiveLayerCount = 0;\n\t            var currentProgressiveLayer;\n\t            var lastProgressiveKey;\n\t            var frameCount = 0;\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                var elProgress = el.progressive;\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    layer.__dirty = layer.__dirty || el.__dirty;\n\t                }\n\t\n\t                /////// Update progressive\n\t                if (elProgress >= 0) {\n\t                    // Fix wrong progressive sequence problem.\n\t                    if (lastProgressiveKey !== elProgress) {\n\t                        lastProgressiveKey = elProgress;\n\t                        frameCount++;\n\t                    }\n\t                    var elFrame = el.__frame = frameCount - 1;\n\t                    if (!currentProgressiveLayer) {\n\t                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n\t                        currentProgressiveLayer = progressiveLayers[idx];\n\t                        if (!currentProgressiveLayer) {\n\t                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n\t                                'progressive', this, this.dpr\n\t                            );\n\t                            currentProgressiveLayer.initContext();\n\t                        }\n\t                        currentProgressiveLayer.__maxProgress = 0;\n\t                    }\n\t                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n\t                    currentProgressiveLayer.elCount++;\n\t\n\t                    currentProgressiveLayer.__maxProgress = Math.max(\n\t                        currentProgressiveLayer.__maxProgress, elFrame\n\t                    );\n\t\n\t                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n\t                        // Should keep rendering this  layer because progressive rendering is not finished yet\n\t                        layer.__dirty = true;\n\t                    }\n\t                }\n\t                else {\n\t                    el.__frame = -1;\n\t\n\t                    if (currentProgressiveLayer) {\n\t                        currentProgressiveLayer.__nextIdxNotProg = i;\n\t                        progressiveLayerCount++;\n\t                        currentProgressiveLayer = null;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (currentProgressiveLayer) {\n\t                progressiveLayerCount++;\n\t                currentProgressiveLayer.__nextIdxNotProg = i;\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCountsLastFrame[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t\n\t            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n\t            util.each(progressiveLayers, function (layer, idx) {\n\t                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n\t                    el.__dirty = true;\n\t                }\n\t                if (layer.__dirty) {\n\t                    layer.__progress = 0;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            var scope = {};\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                this._doPaintEl(el, imageLayer, true, scope);\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n\t                    - (parseInt10(stl.paddingLeft) || 0)\n\t                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n\t                    - (parseInt10(stl.paddingTop) || 0)\n\t                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(40);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(4);\n\t    var config = __webpack_require__(21);\n\t    var Style = __webpack_require__(8);\n\t    var Pattern = __webpack_require__(35);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            this.ctx.dpr = this.dpr;\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var clearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width, height);\n\t            if (clearColor) {\n\t                var clearColorGradientOrPattern;\n\t                // Gradient\n\t                if (clearColor.colorStops) {\n\t                    // Cache canvas gradient\n\t                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n\t                        x: 0,\n\t                        y: 0,\n\t                        width: width,\n\t                        height: height\n\t                    });\n\t\n\t                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n\t                }\n\t                // Pattern\n\t                else if (clearColor.image) {\n\t                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n\t                }\n\t                ctx.save();\n\t                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n\t                ctx.fillRect(0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width, height);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 工具方法类\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Point = __webpack_require__(72);\r\n\t    var Line = __webpack_require__(73);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    /**\r\n\t     * 构造类继承关系\r\n\t     *\r\n\t     * @param {Function} clazz 源类\r\n\t     * @param {Function} baseClazz 基类\r\n\t     */\r\n\t    function inherits(clazz, baseClazz) {\r\n\t        var clazzPrototype = clazz.prototype;\r\n\t\r\n\t        function F() {}\r\n\t        F.prototype = baseClazz.prototype;\r\n\t        clazz.prototype = new F();\r\n\t\r\n\t        for (var prop in clazzPrototype) {\r\n\t            clazz.prototype[prop] = clazzPrototype[prop];\r\n\t        }\r\n\t        clazz.prototype.constructor = clazz;\r\n\t        clazz.superClass = baseClazz;\r\n\t    }\r\n\t\r\n\t    function getUUID() {\r\n\t        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n\t            uuid = new Array(36),\r\n\t            rnd = 0,\r\n\t            r;\r\n\t        for (var i = 0; i < 36; i++) {\r\n\t            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n\t                uuid[i] = '-';\r\n\t            } else if (i == 14) {\r\n\t                uuid[i] = '4';\r\n\t            } else {\r\n\t                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n\t                r = rnd & 0xf;\r\n\t                rnd = rnd >> 4;\r\n\t                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n\t            }\r\n\t        }\r\n\t        return \"sid-\" + uuid.join('');\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算两点之间的距离\r\n\t     *@param {Point} p1 - first {Point}\r\n\t     *@param {Point} p2 - second {Point}\r\n\t     *@return {Number} - the distance between those 2 points. It is always positive.\r\n\t     **/\r\n\t    function distance(p1, p2) {\r\n\t        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回一条折线 最长的两个点\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function getMaxLineLength(points) {\r\n\t        var m = distance(points[0], points[1]);\r\n\t        var result = [points[0], points[1]];\r\n\t        for (var i = 1; i < points.length - 1; i++) {\r\n\t\r\n\t            if (m < distance(points[i], points[i + 1])) {\r\n\t                m = distance(points[i], points[i + 1])\r\n\t                result = [points[i], points[i + 1]];\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return result;\r\n\t    }\r\n\t\r\n\t    /**Returns the length of a Polyline that would be created with a set of points\r\n\t     *@param {Array} v - an {Array} of {Points}\r\n\t     *@return {Number} - a positive number equal with total length*/\r\n\t    function getPolylineLength(v) {\r\n\t        var l = 0;\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            l += distance(v[i], v[i + 1]);\r\n\t        }\r\n\t\r\n\t        return l;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the max of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n\t     **/\r\n\t    function max(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m < v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**Returns the min of a vector\r\n\t     *@param {Array} v - vector of {Number}s\r\n\t     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n\t     *@author alex@scriptoid.com\r\n\t     **/\r\n\t    function min(v) {\r\n\t        if (v.lenght == 0) {\r\n\t            return NaN;\r\n\t        } else {\r\n\t            var m = v[0];\r\n\t            for (var i = 0; i < v.length; i++) {\r\n\t                if (m > v[i]) {\r\n\t                    m = v[i];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            return m;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是否正交直线路径\r\n\t     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function orthogonalPath(v) {\r\n\t        if (v.length <= 1) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 1; i++) {\r\n\t            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n\t     *and not the infinite lines from geometry\r\n\t     *@param {Line} l1 - fist line/segment\r\n\t     *@param {Line} l2 - last line/segment\r\n\t     *@return {Boolean} true - if the lines intersect or false if not\r\n\t     **/\r\n\t    function lineIntersectsLine(l1, l2) {\r\n\t        // check for two vertical lines\r\n\t        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n\t            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n\t                // then check segment bounds for overlapping\r\n\t                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n\t                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                // lines are paralel\r\n\t                false;\r\n\t        }\r\n\t        // if one line is vertical, and another line is not vertical\r\n\t        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n\t            // let assume l2 is vertical, otherwise exchange them\r\n\t            if (l1.startPoint.x == l1.endPoint.x) {\r\n\t                var l = l1;\r\n\t                l1 = l2;\r\n\t                l2 = l;\r\n\t            }\r\n\t            // finding intersection of 'infinite' lines\r\n\t            // equation of the first line is y = ax + b, second: x = c\r\n\t            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n\t            var x0 = l2.startPoint.x;\r\n\t            var y0 = a * x0 + b;\r\n\t            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t        }\r\n\t\r\n\t        // check normal case - both lines are not vertical\r\n\t        else {\r\n\t            //line equation is : y = a*x + b, b = y - a * x\r\n\t            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n\t            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\t\r\n\t            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n\t            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\t\r\n\t            if (a1 == a2) { //paralel lines\r\n\t                return b1 == b2 ?\r\n\t                    // for coincide lines, check for segment bounds overlapping\r\n\t                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n\t                    // not coincide paralel lines have no chance to intersect\r\n\t                    false;\r\n\t            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\t\r\n\t                /*\r\n\t                 * if one of the lines are vertical, then x0 is equal to their x,\r\n\t                 * otherwise:\r\n\t                 * y1 = a1 * x + b1\r\n\t                 * y2 = a2 * x + b2\r\n\t                 * => x0 = (b2 - b1) / (a1 - a2)\r\n\t                 * => y0 = a1 * x0 + b1\r\n\t                 **/\r\n\t                x0 = (b2 - b1) / (a1 - a2);\r\n\t                y0 = a1 * x0 + b1;\r\n\t                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n\t     *@param {Array} points - and {Array} of {Point}s\r\n\t     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n\t     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n\t     *\r\n\t     *@return true - if line intersects the rectangle, false - if not\r\n\t     **/\r\n\t    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\t\r\n\t\r\n\t        //get the 4 lines/segments represented by the bounds\r\n\t        var lines = [];\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n\t        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\t\r\n\t        for (var k = 0; k < points.length - 1; k++) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine = new Line(points[k], points[k + 1]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var i = 0; i < lines.length; i++) {\r\n\t                if (lineIntersectsLine(tempLine, lines[i])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        //check the closed figure - that is last point connected to the first\r\n\t        if (closedPolyline) {\r\n\t            //create a line out of each 2 consecutive points\r\n\t            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\t\r\n\t            //see if that line intersect any of the line on bounds border\r\n\t            for (var j = 0; j < lines.length; j++) {\r\n\t                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算路径的分数\r\n\t     * Score a ortogonal path made out of Points\r\n\t     *Iterates over a set of points (minimum 3)\r\n\t     *For each 3 points (i, i+1, i+2) :\r\n\t     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n\t     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n\t     *  - if the 3rd goes back we imediatelly return -1\r\n\t     *@param {Array} v - an array of {Point}s\r\n\t     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n\t     *  The bigger the number the smooth the path is\r\n\t     **/\r\n\t    function scorePath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return -1;\r\n\t        }\r\n\t\r\n\t        var score = 0;\r\n\t        for (var i = 1; i < v.length - 1; i++) {\r\n\t            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n\t                    score++;\r\n\t                } else { //going back - no good\r\n\t                    return -1;\r\n\t                }\r\n\t            } else { //not on same vertical nor horizontal\r\n\t                score--;\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return score;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 返回数字符号（+ -)\r\n\t     * Returns the sign of a number\r\n\t     *@param {Number} x - the number\r\n\t     *@returns {Number}\r\n\t     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n\t     **/\r\n\t    function signum(x) {\r\n\t        if (x > 0)\r\n\t            return 1;\r\n\t        else if (x < 0)\r\n\t            return -1;\r\n\t        else\r\n\t            return 0;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断 点数组 是不是有效路径（没有回路）\r\n\t     *Tests if a vector of points is a valid path (not going back)\r\n\t     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n\t     *@param {Array} v - an {Array} of {Point}s\r\n\t     *@return {Boolean} - true if path is valid, false otherwise\r\n\t     **/\r\n\t    function forwardPath(v) {\r\n\t        if (v.length <= 2) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        for (var i = 0; i < v.length - 2; i++) {\r\n\t            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n\t                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n\t                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n\t                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n\t                        return false;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t     * @param  {[type]} points [description]\r\n\t     * @param  {[type]} isRevert [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    function traslatePoints(points, isRevert) {\r\n\t        var newPoints = [];\r\n\t        if (isRevert) {\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var point = points[i];\r\n\t                newPoints.push(new Point(point[0], point[1]));\r\n\t            }\r\n\t            return newPoints;\r\n\t        } else {\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point1 = points[j];\r\n\t                newPoints.push([point1.x, point1.y]);\r\n\t            }\r\n\t            return newPoints;\r\n\t        }\r\n\t\r\n\t\r\n\t    }\r\n\t\r\n\t    function rotationMatrix(angle) {\r\n\t        var mReturn = [\r\n\t            [Math.cos(angle), -Math.sin(angle), 0],\r\n\t            [Math.sin(angle), Math.cos(angle), 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t        return mReturn;\r\n\t    }\r\n\t\r\n\t    function translationMatrix(dx, dy) {\r\n\t        return [\r\n\t            [1, 0, dx],\r\n\t            [0, 1, dy],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    function scaleMatrix(sx, sy) {\r\n\t        if (sy == null) {\r\n\t            sy = sx;\r\n\t        }\r\n\t        return [\r\n\t            [sx, 0, 0],\r\n\t            [0, sy, 0],\r\n\t            [0, 0, 1]\r\n\t        ];\r\n\t    }\r\n\t\r\n\t    /** It will return the end point of a line on a given angle (clockwise).\r\n\t     * @param {Point} startPoint - the start of the line\r\n\t     * @param {Number} length - the length of the line\r\n\t     * @param {Number} angle - the angle of the line in radians\r\n\t     * @return {Point} - the endPoint of the line\r\n\t     */\r\n\t    function getEndPoint(startPoint, length, angle) {\r\n\t        var endPoint = startPoint.clone();\r\n\t        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n\t        endPoint.y -= length;\r\n\t        endPoint.transform(rotationMatrix(angle));\r\n\t        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n\t        return endPoint;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getConnectorPoints(node) {\r\n\t        return {\r\n\t            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n\t            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n\t            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n\t            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n\t            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\t\r\n\t        };\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取获取两个图形的外面四个连接点\r\n\t     * @param  {[type]} node [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    function getSoltPoints(node) {\r\n\t        return [\r\n\t            //top\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n\t            //right\r\n\t            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n\t            //bottom\r\n\t            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n\t            //left\r\n\t            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n\t            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\t\r\n\t        ]\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 计算 p1 p2两点所连接的直线的角度\r\n\t     * @param  {[type]} p1 [description]\r\n\t     * @param  {[type]} p2 [description]\r\n\t     * @return {[type]}    [description]\r\n\t     */\r\n\t    function tangentRotation(p1, p2) {\r\n\t        return -Math.PI / 2 - Math.atan2(\r\n\t            p2.y - p1.y, p2.x - p1.x\r\n\t        );\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 判断3点是否在一条直线上\r\n\t     * Tests if 3 points are coliniar with matrix determinants.\r\n\t     * If the determinat of matrix\r\n\t     * /         \\\r\n\t     * | x1 y1 1 |\r\n\t     * | x2 y2 1 |\r\n\t     * | x3 y3 1 |\r\n\t     * \\         /\r\n\t     * is zero it means that the points are colinear\r\n\t     *@param {Point} p1 - first point\r\n\t     *@param {Point} p2 - second point\r\n\t     *@param {Point} p3 - third point\r\n\t     * @param {Number} precission\r\n\t     *@return {Boolean} - true if coliniar and false if not\r\n\t     *@author Alex\r\n\t     *@see http://en.wikipedia.org/wiki/Determinant\r\n\t     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n\t     **/\r\n\t    function collinearity(p1, p2, p3, precission) {\r\n\t        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\t\r\n\t        if (precission) {\r\n\t            return Math.abs(determinant) <= precission;\r\n\t        } else {\r\n\t            return determinant === 0;\r\n\t        }\r\n\t    }\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 四舍五入 保存decimals的小数\r\n\t     **/\r\n\t    function enhancedRound(number, decimals) {\r\n\t        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取两点之间的长度\r\n\t     **/\r\n\t    function getLength(startPoint, endPoint) {\r\n\t        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 获取角度\r\n\t     * @param  {[type]} centerPoint  [description]\r\n\t     * @param  {[type]} outsidePoint [description]\r\n\t     * @param  {[type]} round        [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function getAngle(centerPoint, outsidePoint, round) {\r\n\t        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n\t        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n\t        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n\t        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n\t        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n\t        angle = -angle;\r\n\t\r\n\t        //endAngle+=90;\r\n\t        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n\t            angle += Math.PI;\r\n\t        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n\t            angle += Math.PI * 2;\r\n\t        }\r\n\t        while (angle >= Math.PI * 2) {\r\n\t            angle -= Math.PI * 2;\r\n\t        }\r\n\t        if (isNaN(angle)) { //Nan\r\n\t            angle = 0; //we are at center point;\r\n\t        }\r\n\t        if (round) {\r\n\t            angle = Math.round(angle / round) * round\r\n\t        }\r\n\t        return angle;\r\n\t    }\r\n\t\r\n\t    function getRect(node) {\r\n\t        var boundingRect = node.getBoundingRect();\r\n\t        //创建最小包围盒虚线\r\n\t        var points = [];\r\n\t        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n\t        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n\t        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\t\r\n\t        var boundRect, cx, cy;\r\n\t        if (node instanceof graphic.Circle) {\r\n\t            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n\t            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),\r\n\t                Number(node.position[1]) - Number(boundingRect.height / 2),\r\n\t                Number(boundingRect.width), Number(boundingRect.height));\r\n\t            cx = Number(node.position[0]);\r\n\t            cy = Number(node.position[1]);\r\n\t        } else {\r\n\t            boundRect = new BoundingRect(Number(node.position[0]),\r\n\t                Number(node.position[1]),\r\n\t                Number(boundingRect.width), Number(boundingRect.height));\r\n\t            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;\r\n\t            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;\r\n\t        }\r\n\t        return {\r\n\t            x: Number(cx),\r\n\t            y: Number(cy),\r\n\t            width: Number(boundingRect.width),\r\n\t            height: Number(boundingRect.height),\r\n\t            points: points,\r\n\t            boundingRect: boundRect\r\n\t        };\r\n\t    }\r\n\t\r\n\t    var StackedMap = {\r\n\t        createNew: function() {\r\n\t            var stack = [];\r\n\t\r\n\t            return {\r\n\t                add: function(key, value) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    arrKey.push(value)\r\n\t\r\n\t                },\r\n\t                get: function(key) {\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            return stack[i].value;\r\n\t                        }\r\n\t                    }\r\n\t                    //如果没有找到的话，则创建一个新的数组\r\n\t                    var value = [];\r\n\t                    stack.push({ key: key, value: value });\r\n\t                    return value;\r\n\t                },\r\n\t                keys: function() {\r\n\t                    var keys = [];\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        keys.push(stack[i].key);\r\n\t                    }\r\n\t                    return keys;\r\n\t                },\r\n\t                top: function() {\r\n\t                    return stack[stack.length - 1];\r\n\t                },\r\n\t                remove: function(key) {\r\n\t                    var idx = -1;\r\n\t                    for (var i = 0; i < stack.length; i++) {\r\n\t                        if (key == stack[i].key) {\r\n\t                            idx = i;\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    return stack.splice(idx, 1)[0];\r\n\t                },\r\n\t                removeItem: function(key, item) {\r\n\t                    var arrKey = this.get(key);\r\n\t                    var index = zrUtil.indexOf(arrKey, item);\r\n\t                    arrKey.splice(index, 1);\r\n\t\r\n\t                },\r\n\t                removeTop: function() {\r\n\t                    return stack.splice(stack.length - 1, 1)[0];\r\n\t                },\r\n\t                length: function() {\r\n\t                    return stack.length;\r\n\t                },\r\n\t                clear: function() {\r\n\t                    stack.splice(0, stack.length);\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    };\r\n\t\r\n\t    function randomColor() {\r\n\t        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n\t            strHex = \"#\",\r\n\t            index;\r\n\t        for (var i = 0; i < 6; i++) {\r\n\t            index = Math.round(Math.random() * 15);\r\n\t            strHex += arrHex[index];\r\n\t        }\r\n\t        return strHex;\r\n\t    }\r\n\t\r\n\t    function isUndefined(obj) {\r\n\t        return obj === void 0;\r\n\t    }\r\n\t\r\n\t    function collinearReduction (v) {\r\n\t        var r = [];\r\n\t\r\n\t        if(v.length < 3){\r\n\t            return Point.cloneArray(v);\r\n\t        }\r\n\t\r\n\t        r.push( v[0].clone() );\r\n\t        for(var i=1; i < v.length-1; i++){\r\n\t            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n\t            {\r\n\t                continue;\r\n\t            }\r\n\t            else{\r\n\t                r.push( v[i].clone() );\r\n\t            }\r\n\t        }\r\n\t        r.push( v[v.length-1].clone() );\r\n\t\r\n\t        return r;\r\n\t    }\r\n\t\r\n\t    // By default, Underscore uses ERB-style template delimiters, change the\r\n\t    // following template settings to use alternative delimiters.\r\n\t    var templateSettings = {\r\n\t        evaluate: /<%([\\s\\S]+?)%>/g,\r\n\t        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n\t        escape: /<%-([\\s\\S]+?)%>/g\r\n\t    };\r\n\t\r\n\t    // When customizing `templateSettings`, if you don't want to define an\r\n\t    // interpolation, evaluation or escaping regex, we need one that is\r\n\t    // guaranteed not to match.\r\n\t    var noMatch = /(.)^/;\r\n\t\r\n\t    // Certain characters need to be escaped so that they can be put into a\r\n\t    // string literal.\r\n\t    var escapes = {\r\n\t        \"'\": \"'\",\r\n\t        '\\\\': '\\\\',\r\n\t        '\\r': 'r',\r\n\t        '\\n': 'n',\r\n\t        '\\u2028': 'u2028',\r\n\t        '\\u2029': 'u2029'\r\n\t    };\r\n\t\r\n\t    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\t\r\n\t    var escapeChar = function(match) {\r\n\t        return '\\\\' + escapes[match];\r\n\t    };\r\n\t\r\n\t    // JavaScript micro-templating, similar to John Resig's implementation.\r\n\t    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n\t    // and correctly escapes quotes within interpolated code.\r\n\t    // NB: `oldSettings` only exists for backwards compatibility.\r\n\t    function template(text, settings, oldSettings) {\r\n\t        if (!settings && oldSettings) settings = oldSettings;\r\n\t        settings = settings || {};\r\n\t        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\t\r\n\t        // Combine delimiters into one regular expression via alternation.\r\n\t        var matcher = RegExp([\r\n\t            (settings.escape || noMatch).source,\r\n\t            (settings.interpolate || noMatch).source,\r\n\t            (settings.evaluate || noMatch).source\r\n\t        ].join('|') + '|$', 'g');\r\n\t\r\n\t        // Compile the template source, escaping string literals appropriately.\r\n\t        var index = 0;\r\n\t        var source = \"__p+='\";\r\n\t        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n\t            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n\t            index = offset + match.length;\r\n\t\r\n\t            if (escape) {\r\n\t                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n\t            } else if (interpolate) {\r\n\t                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n\t            } else if (evaluate) {\r\n\t                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n\t            }\r\n\t\r\n\t            // Adobe VMs need the match returned to produce the correct offest.\r\n\t            return match;\r\n\t        });\r\n\t        source += \"';\\n\";\r\n\t\r\n\t        // If a variable is not specified, place data values in local scope.\r\n\t        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\t\r\n\t        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n\t            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n\t            source + 'return __p;\\n';\r\n\t\r\n\t        try {\r\n\t            var render = new Function(settings.variable || 'obj', source);\r\n\t        } catch (e) {\r\n\t            e.source = source;\r\n\t            throw e;\r\n\t        }\r\n\t\r\n\t        var template = function(data) {\r\n\t            return render.call(this, data);\r\n\t        };\r\n\t\r\n\t        // Provide the compiled source as a convenience for precompilation.\r\n\t        var argument = settings.variable || 'obj';\r\n\t        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\t\r\n\t        return template;\r\n\t    }\r\n\t\r\n\t    function isEmpty(obj) {\r\n\t        if (obj == null) return true;\r\n\t        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n\t    }\r\n\t\r\n\t    module.exports = {\r\n\t        inherits: inherits,\r\n\t        getUUID: getUUID,\r\n\t        distance: distance,\r\n\t        getPolylineLength: getPolylineLength,\r\n\t        max: max,\r\n\t        min: min,\r\n\t        isEmpty: isEmpty,\r\n\t        orthogonalPath: orthogonalPath,\r\n\t        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n\t        scorePath: scorePath,\r\n\t        forwardPath: forwardPath,\r\n\t        traslatePoints: traslatePoints,\r\n\t        getEndPoint: getEndPoint,\r\n\t        getConnectorPoints: getConnectorPoints,\r\n\t        tangentRotation: tangentRotation,\r\n\t        collinearity: collinearity,\r\n\t        translationMatrix: translationMatrix,\r\n\t        scaleMatrix: scaleMatrix,\r\n\t        round: enhancedRound,\r\n\t        getLength: getLength,\r\n\t        getAngle: getAngle,\r\n\t        getRect: getRect,\r\n\t        StackedMap: StackedMap,\r\n\t        getMaxLineLength: getMaxLineLength,\r\n\t        randomColor: randomColor,\r\n\t        template: template,\r\n\t        isUndefined: isUndefined,\r\n\t        getSoltPoints:getSoltPoints,\r\n\t        collinearReduction: collinearReduction\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of Point\r\n\t      *\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Point}\r\n\t      * @param {Number} x The x coordinate of point.\r\n\t      * @param {Number} y The y coordinate of point.\r\n\t      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n\t      * then Point from math perspective.\r\n\t      **/\r\n\t    function Point(x, y){\r\n\t        /**The x coordinate of point*/\r\n\t        this.x = x;\r\n\t        \r\n\t        /**The y coordinate of point*/\r\n\t        this.y = y;\r\n\t        \r\n\t\r\n\t    }\r\n\t\r\n\t    /**Creates a {Point} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Point} a newly constructed Point\r\n\t     **/\r\n\t    Point.load = function(o){\r\n\t        var newPoint = new Point(Number(o.x), Number(o.y));\r\n\t        return newPoint;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Creates an array of points from an array of {JSONObject}s\r\n\t     *@param {Array} v - the array of JSONObjects\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.loadArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(Point.load(v[i]));\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**Clones an array of points\r\n\t     *@param {Array} v - the array of {Point}s\r\n\t     *@return an {Array} of {Point}s\r\n\t     **/\r\n\t    Point.cloneArray = function(v){\r\n\t        var newPoints = [];\r\n\t        for(var i=0; i< v.length; i++){\r\n\t            newPoints.push(v[i].clone());\r\n\t        }\r\n\t        return newPoints;\r\n\t    };\r\n\t\r\n\t    Point.prototype = {\r\n\t        constructor : Point,\r\n\t        \r\n\t        transform:function(matrix){\r\n\t            var oldX = this.x;\r\n\t            var oldY = this.y;\r\n\t            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n\t            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n\t        },\r\n\t        \r\n\t        /**Tests if this point is similar to other point\r\n\t         *@param {Point} anotherPoint - the other point\r\n\t         **/\r\n\t        equals:function(anotherPoint){\r\n\t            if(! (anotherPoint instanceof Point) ){\r\n\t                return false;\r\n\t            }\r\n\t            return (this.x == anotherPoint.x)\r\n\t            && (this.y == anotherPoint.y)\r\n\t        },\r\n\t\r\n\t        /**Clone current Point\r\n\t         **/\r\n\t        clone: function(){\r\n\t            var newPoint = new Point(this.x, this.y);\r\n\t            return newPoint;\r\n\t        },\r\n\t\r\n\t        /**Tests to see if a point (x, y) is within a range of current Point\r\n\t         *@param {Numeric} x - the x coordinate of tested point\r\n\t         *@param {Numeric} y - the x coordinate of tested point\r\n\t         *@param {Numeric} radius - the radius of the vicinity\r\n\t         **/\r\n\t        near:function(x, y, radius){\r\n\t            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\t\r\n\t            return (distance <= radius);\r\n\t        },\r\n\t\r\n\t        contains: function(x,y){\r\n\t            return this.x == x && this.y == y;\r\n\t        },\r\n\t\r\n\t        toString:function(){\r\n\t            return '[' + this.x + ',' + this.y + ']';\r\n\t        },\r\n\t\r\n\t        getPoints:function(){\r\n\t            return [this];\r\n\t        }\r\n\t    };\r\n\t    module.exports = Point;\r\n\t    \n\n/***/ },\n/* 73 */\n/***/ function(module, exports) {\n\n\t\r\n\t\r\n\t    /**\r\n\t      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n\t      * geometrical Line\r\n\t      *\r\n\t      * @constructor\r\n\t      * @this {Line}\r\n\t      * @param {Point} startPoint - starting point of the line\r\n\t      * @param {Point} endPoint - the ending point of the line\r\n\t      **/\r\n\t    function Line(startPoint, endPoint){\r\n\t        /**Starting {@link Point} of the line*/\r\n\t        this.startPoint = startPoint;\r\n\t\r\n\t        /**Ending {@link Point} of the line*/\r\n\t        this.endPoint = endPoint;\r\n\t\r\n\t        /**Serialization type*/\r\n\t        this.oType = 'Line'; //object type used for JSON deserialization\r\n\t    }\r\n\t\r\n\t    /**Creates a {Line} out of JSON parsed object\r\n\t     *@param {JSONObject} o - the JSON parsed object\r\n\t     *@return {Line} a newly constructed Line\r\n\t     **/\r\n\t    Line.load = function(o){\r\n\t        var newLine = new Line(\r\n\t            Point.load(o.startPoint),\r\n\t            Point.load(o.endPoint)\r\n\t        );\r\n\t\r\n\t        return newLine;\r\n\t    };\r\n\t\r\n\t    Line.prototype = {\r\n\t        contructor: Line,\r\n\t\r\n\t\r\n\t\r\n\t        clone:function(){\r\n\t            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n\t            return ret;\r\n\t        },\r\n\t\r\n\t        equals:function(anotherLine){\r\n\t            if(!anotherLine instanceof Line){\r\n\t                return false;\r\n\t            }\r\n\t            return this.startPoint.equals(anotherLine.startPoint)\r\n\t            && this.endPoint.equals(anotherLine.endPoint)\r\n\t        },\r\n\t\r\n\t        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n\t         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n\t         * @param {Number} x - the X coordinates\r\n\t         * @param {Number} y - the Y coordinates\r\n\t         **/\r\n\t        contains: function(x, y){\r\n\t            // if the point is inside rectangle bounds of the segment\r\n\t            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n\t                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n\t                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n\t                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\t\r\n\t                // check for vertical line\r\n\t                if (this.startPoint.x == this.endPoint.x) {\r\n\t                    return x == this.startPoint.x;\r\n\t                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n\t                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n\t                    var b = this.startPoint.y - a * this.startPoint.x;\r\n\t                    return y == a * x + b;\r\n\t                }\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /*\r\n\t         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n\t         *@param {Number} x - the x coordinates\r\n\t         *@param {Number} y - the y coordinates\r\n\t         *@param {Number} radius - the radius to search for\r\n\t         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t         **/\r\n\t        near:function(x,y,radius){\r\n\t\r\n\t            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n\t                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n\t                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n\t            }\r\n\t\r\n\t            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n\t                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n\t                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n\t                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n\t            }\r\n\t\r\n\t\r\n\t            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n\t            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n\t            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n\t            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\t\r\n\t            /*We will compute the distance from point to the line\r\n\t             * by using the algorithm from\r\n\t             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n\t             * */\r\n\t\r\n\t            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n\t            var a = this.endPoint.y - this.startPoint.y;\r\n\t            var b = this.startPoint.x - this.endPoint.x;\r\n\t            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\t\r\n\t            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n\t            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\t\r\n\t            //Thirdly we get coordinates of closest line's point to target point\r\n\t            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n\t            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\t\r\n\t            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n\t                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\t\r\n\t            return  r;\r\n\t\r\n\t        },\r\n\t\r\n\t        /**we need to create a new array each time, or we will affect the actual shape*/\r\n\t        getPoints:function(){\r\n\t            var points = [];\r\n\t            points.push(this.startPoint);\r\n\t            points.push(this.endPoint);\r\n\t            return points;\r\n\t        },\r\n\t\r\n\t        /**Return the {Point} corresponding the t certain t value\r\n\t         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n\t        getPoint: function(t){\r\n\t            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n\t            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\t\r\n\t            return new Point(Xp, Yp);\r\n\t        },\r\n\t\r\n\t        // /**\r\n\t        //  * Returns the middle of the line\r\n\t        //  * @return {Point} the middle point\r\n\t        //  * */\r\n\t        // getMiddle : function(){\r\n\t        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t\r\n\t        // getLength : function(){\r\n\t        //     return Util.getLength(this.startPoint, this.endPoint);\r\n\t        // },\r\n\t\r\n\t        // /**\r\n\t        //  *Get bounds for this line\r\n\t        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n\t        //  **/\r\n\t        // getBounds:function(){\r\n\t        //     return Util.getBounds(this.getPoints());\r\n\t        // },\r\n\t\r\n\t        /**String representation*/\r\n\t        toString:function(){\r\n\t            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n\t        }\r\n\t    };\r\n\t    module.exports = Line;\r\n\t\r\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Network model\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var NetworkModel = Model.extend({\r\n\t        /**\r\n\t         * @type {Object}\r\n\t         * @protected\r\n\t         */\r\n\t        defaultOption: {\r\n\t        \tresourceId: \"\",  //资源ID\r\n\t            properties: {\r\n\t                type: -1,  //类型\r\n\t                name: \"\", //名称\r\n\t                notes: \"\",  //备注\r\n\t                //no: \"\"\r\n\t                extProperties: {\r\n\t                },  //扩展属性\r\n\t                bounds: {\r\n\t                    upperLeft: {x: 0, y: 0},  //左上角坐标\r\n\t                    lowerRight: {x: 0, y: 0} //右下角坐标\r\n\t                }\r\n\t            },\r\n\t            stencil: {type: \"NextworkNode\"},\r\n\t            showTip: false\r\n\t        },\r\n\t\r\n\t        init: function (option, parentModel, extraOpt) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        }\r\n\t\r\n\t    });\r\n\t    module.exports = NetworkModel;\r\n\t\r\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 节点等的模型\r\n\t * 里面存的数据用来处理序列化和反序列化\r\n\t * @class fish.topo.model\r\n\t */\r\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var clazzUtil = __webpack_require__(76);\r\n\t\r\n\t    function Model(option, parentModel,  extraOpt) {\r\n\t        this.parentModel = parentModel;\r\n\t        this.option = option;\r\n\t\r\n\t        // Simple optimization\r\n\t        if (this.init) {\r\n\t            if (arguments.length <= 3) {\r\n\t                this.init(option, parentModel,  extraOpt);\r\n\t            }\r\n\t            else {\r\n\t                this.init.apply(this, arguments);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    Model.prototype = {\r\n\t\r\n\t        constructor: Model,\r\n\t\r\n\t        /**\r\n\t         * Model 的初始化函数\r\n\t         * @private\r\n\t         * @param {Object} option\r\n\t         */\r\n\t        init: function (option) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        mergeOption: function (option) {\r\n\t            zrUtil.merge(this.option, option, true);\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 获取model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.get(\"options.text\");\r\n\t         */\r\n\t        get: function (path, ignoreParent) {\r\n\t            if (!path) {\r\n\t                return this.option;\r\n\t            }\r\n\t\r\n\t            if (typeof path === 'string') {\r\n\t                path = path.split('.');\r\n\t            }\r\n\t\r\n\t            var obj = this.option;\r\n\t            var parentModel = this.parentModel;\r\n\t            for (var i = 0; i < path.length; i++) {\r\n\t                // obj could be number/string/... (like 0)\r\n\t                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n\t                if (obj == null) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (obj == null && parentModel && !ignoreParent) {\r\n\t                obj = parentModel.get(path);\r\n\t            }\r\n\t            return obj;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 设置model的某个属性的值\r\n\t         * @param {string} path model中的属性\r\n\t         * @param {String} value 所需要设置的值\r\n\t         * @return {String}\r\n\t         *\r\n\t         * **使用范例**：\r\n\t         *\r\n\t         *      @example\r\n\t         *          node.model.set(\"options.text\",\"例子\");\r\n\t         */\r\n\t        set: function (path, value) {\r\n\t            var obj = this.option;\r\n\t\r\n\t            if (path.indexOf(\".\") == -1) {\r\n\t                obj[path] = value;\r\n\t            } else {\r\n\t                var fieldArray  = path.split('.');\r\n\t                var n = fieldArray.length;\r\n\t                var currentRef = obj;\r\n\t                var fieldName;\r\n\t\r\n\t                for (var i = 0; i < n - 1; i++) {\r\n\t                    fieldName = fieldArray[i];\r\n\t                    if(currentRef[fieldName] == null) {\r\n\t                        currentRef[fieldName] = {};\r\n\t                    }\r\n\t                    currentRef = currentRef[fieldName];\r\n\t                }\r\n\t                fieldName = fieldArray[n-1];\r\n\t                currentRef[fieldName] = value;\r\n\t            }\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getShallow: function (key, ignoreParent) {\r\n\t            var option = this.option;\r\n\t            var val = option && option[key];\r\n\t            var parentModel = this.parentModel;\r\n\t            if (val == null && parentModel && !ignoreParent) {\r\n\t                val = parentModel.getShallow(key);\r\n\t            }\r\n\t            return val;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        getModel: function (path, parentModel) {\r\n\t            var obj = this.get(path, true);\r\n\t            var thisParentModel = this.parentModel;\r\n\t            var model = new Model(\r\n\t                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n\t            );\r\n\t            return model;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         *清空model的option\r\n\t         * @private\r\n\t         */\r\n\t        isEmpty: function () {\r\n\t            return this.option == null;\r\n\t        },\r\n\t\r\n\t        restoreData: function () {},\r\n\t\r\n\t        /**\r\n\t         * @private\r\n\t         */\r\n\t        clone: function () {\r\n\t            var Ctor = this.constructor;\r\n\t            return new Ctor(zrUtil.clone(this.option));\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // Enable Model.extend.\r\n\t    clazzUtil.enableClassExtend(Model);\r\n\t\r\n\t    module.exports = Model;\r\n\t\r\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var clazz = {};\r\n\t\r\n\t    var TYPE_DELIMITER = '.';\r\n\t    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n\t    /**\r\n\t     * @public\r\n\t     */\r\n\t    var parseClassType = clazz.parseClassType = function (componentType) {\r\n\t        var ret = {main: '', sub: ''};\r\n\t        if (componentType) {\r\n\t            componentType = componentType.split(TYPE_DELIMITER);\r\n\t            ret.main = componentType[0] || '';\r\n\t            ret.sub = componentType[1] || '';\r\n\t        }\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n\t     */\r\n\t    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n\t        RootClass.extend = function (proto) {\r\n\t            var ExtendedClass = function () {\r\n\t                preConstruct && preConstruct.apply(this, arguments);\r\n\t                RootClass.apply(this, arguments);\r\n\t            };\r\n\t\r\n\t            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\t\r\n\t            ExtendedClass.extend = this.extend;\r\n\t            ExtendedClass.superCall = superCall;\r\n\t            ExtendedClass.superApply = superApply;\r\n\t            zrUtil.inherits(ExtendedClass, this);\r\n\t            ExtendedClass.superClass = this;\r\n\t\r\n\t            return ExtendedClass;\r\n\t        };\r\n\t    };\r\n\t\r\n\t    // superCall should have class info, which can not be fetch from 'this'.\r\n\t    // Consider this case:\r\n\t    // class A has method f,\r\n\t    // class B inherits class A, overrides method f, f call superApply('f'),\r\n\t    // class C inherits class B, do not overrides method f,\r\n\t    // then when method of class C is called, dead loop occured.\r\n\t    function superCall(context, methodName) {\r\n\t        var args = zrUtil.slice(arguments, 2);\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    function superApply(context, methodName, args) {\r\n\t        return this.superClass.prototype[methodName].apply(context, args);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @param {Object} entity\r\n\t     * @param {Object} options\r\n\t     * @param {boolean} [options.registerWhenExtend]\r\n\t     * @public\r\n\t     */\r\n\t    clazz.enableClassManagement = function (entity, options) {\r\n\t        options = options || {};\r\n\t\r\n\t        /**\r\n\t         * Component model classes\r\n\t         * key: componentType,\r\n\t         * value:\r\n\t         *     componentClass, when componentType is 'xxx'\r\n\t         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n\t         * @type {Object}\r\n\t         */\r\n\t        var storage = {};\r\n\t\r\n\t        entity.registerClass = function (Clazz, componentType) {\r\n\t            if (componentType) {\r\n\t                componentType = parseClassType(componentType);\r\n\t\r\n\t                if (!componentType.sub) {\r\n\t                    if (storage[componentType.main]) {\r\n\t                        //已经注册过了，直接返回\r\n\t                        return;\r\n\t                    }\r\n\t                    storage[componentType.main] = Clazz;\r\n\t                }\r\n\t                else if (componentType.sub !== IS_CONTAINER) {\r\n\t                    var container = makeContainer(componentType);\r\n\t                    container[componentType.sub] = Clazz;\r\n\t                }\r\n\t            }\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n\t            var Clazz = storage[componentTypeMain];\r\n\t\r\n\t            if (Clazz && Clazz[IS_CONTAINER]) {\r\n\t                Clazz = subType ? Clazz[subType] : null;\r\n\t            }\r\n\t\r\n\t            if (throwWhenNotFound && !Clazz) {\r\n\t                throw new Error(\r\n\t                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n\t                );\r\n\t            }\r\n\t\r\n\t            return Clazz;\r\n\t        };\r\n\t\r\n\t        entity.getClassesByMainType = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t\r\n\t            var result = [];\r\n\t            var obj = storage[componentType.main];\r\n\t\r\n\t            if (obj && obj[IS_CONTAINER]) {\r\n\t                zrUtil.each(obj, function (o, type) {\r\n\t                    type !== IS_CONTAINER && result.push(o);\r\n\t                });\r\n\t            }\r\n\t            else {\r\n\t                result.push(obj);\r\n\t            }\r\n\t\r\n\t            return result;\r\n\t        };\r\n\t\r\n\t        entity.hasClass = function (componentType) {\r\n\t            // Just consider componentType.main.\r\n\t            componentType = parseClassType(componentType);\r\n\t            return !!storage[componentType.main];\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n\t         */\r\n\t        entity.getAllClassMainTypes = function () {\r\n\t            var types = [];\r\n\t            zrUtil.each(storage, function (obj, type) {\r\n\t                types.push(type);\r\n\t            });\r\n\t            return types;\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * If a main type is container and has sub types\r\n\t         * @param  {string}  componentType\r\n\t         * @return {boolean}\r\n\t         */\r\n\t        entity.hasSubTypes = function (componentType) {\r\n\t            componentType = parseClassType(componentType);\r\n\t            var obj = storage[componentType.main];\r\n\t            return obj && obj[IS_CONTAINER];\r\n\t        };\r\n\t\r\n\t        entity.parseClassType = parseClassType;\r\n\t\r\n\t        function makeContainer(componentType) {\r\n\t            var container = storage[componentType.main];\r\n\t            if (!container || !container[IS_CONTAINER]) {\r\n\t                container = storage[componentType.main] = {};\r\n\t                container[IS_CONTAINER] = true;\r\n\t            }\r\n\t            return container;\r\n\t        }\r\n\t\r\n\t        if (options.registerWhenExtend) {\r\n\t            var originalExtend = entity.extend;\r\n\t            if (originalExtend) {\r\n\t                entity.extend = function (proto) {\r\n\t                    var ExtendedClass = originalExtend.call(this, proto);\r\n\t                    return entity.registerClass(ExtendedClass, proto.type);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t\r\n\t        return entity;\r\n\t    };\r\n\t\r\n\t    module.exports = clazz;\r\n\t\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\tvar Node = __webpack_require__(78);\r\n\t\tvar zrUtil = __webpack_require__(4);\r\n\t\tvar graphic = __webpack_require__(3);\r\n\t\tvar clazzUtil = __webpack_require__(76);\r\n\t\t\r\n\t\t//创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t\tfunction NetworkNode(model, api) {\r\n\t\t\tNode.call(this);\r\n\t\t\tthis.model = model;\t\t\r\n\t\t\tthis.options =\r\n\t\t\t{\r\n\t\t\t\toutline: {\r\n\t\t\t\t\tenable: true, // 是否有外框\r\n\t\t\t\t\tradius: true, // 是否圆角\r\n\t\t\t\t\tinitVisible: false\r\n\t\t\t\t},\r\n\t\t\t\ttext: {\r\n\t\t\t\t\tcolor: '#000000', // 文本颜色\r\n\t\t\t\t\tlineHeight: 24 // 文本行高\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tthis.nextworkInfo = {type: -1, name:\"NextworkNode\" };    //节点信息\r\n\t\t\tthis.portNodeList = [];\r\n\t\t\tthis.cardNodeList = [];\r\n\t\t\tthis.initEvent(api);\r\n\t\t};\r\n\t\r\n\t    NetworkNode.prototype.initEvent = function(api) {\r\n\t        var that = this;\r\n\t        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t        //     that.on(eveName, function (e) {\r\n\t\t       //      var params = {};\r\n\t\t       //      params.event = e;\r\n\t\t       //      params.type = eveName;\r\n\t\t       //      params.model = that.model\r\n\t\t       //      api.trigger(eveName, params); \r\n\t        //     }, this);\r\n\t        // }, this);\r\n\t    };\t\r\n\t\r\n\t\tNetworkNode.prototype.render = function() {\r\n\t\r\n\t\t};\r\n\t\r\n\t\t/**\r\n\t\t * drawText\r\n\t\t * @description 画一个文本\r\n\t\t * @param {string} content\r\n\t\t * @param {number} x\r\n\t\t * @param {number} y\r\n\t\t * @param {string} color\r\n\t\t */\r\n\t\tNetworkNode.prototype.drawText = function (content, x, y, color) {\r\n\t\t\tvar text = new graphic.Text({\r\n\t\t\t\tstyle: {\r\n\t\t\t\t\ttext: content,\r\n\t\t\t\t\tx: x,\r\n\t\t\t\t\ty: y + 6,\r\n\t\t\t\t\tcolor: color ? color : this.options.text.color,\r\n\t\t\t\t\ttextFont: '12px Microsoft YaHei'\r\n\t\t\t\t},\r\n\t\t\t\tzlevel: 20\r\n\t\t\t});\r\n\t\t\treturn {\r\n\t\t\t\ttext: text,\r\n\t\t\t\trect: text.getBoundingRect()\r\n\t\t\t};\r\n\t\t};\t\r\n\t\r\n\t\r\n\t\tNetworkNode.prototype.toJSON = function() {\r\n\t\t\tthis.model.set(\"resourceId\", this.resourceId);\r\n\t\t\tthis.model.set(\"properties.type\", this.nextworkInfo.type);\r\n\t\t\tthis.model.set(\"stencil.type\", this.nextworkInfo.name);\r\n\t\t\tthis.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t\t\tthis.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t\t\tthis.model.set(\"bounds.lowerRight.x\", this.position[0] + this.getBoundingRect().width);\r\n\t\t\tthis.model.set(\"bounds.lowerRight.y\", this.position[1] + this.getBoundingRect().height);\r\n\t\t\treturn this.model.option;\r\n\t\t};\r\n\t\tzrUtil.inherits(NetworkNode, Node);\r\n\t\r\n\t\tclazzUtil.enableClassManagement(NetworkNode, {\r\n\t        registerWhenExtend: true\r\n\t    });\r\n\t\tmodule.exports = NetworkNode;\r\n\t\r\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var util = __webpack_require__(71)\r\n\t    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t    function Node() {\r\n\t        this.resourceId = util.getUUID(); // 生成节点ID\r\n\t        graphic.Group.call(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.render = function() {};\r\n\t\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @param  {[type]} json [description]\r\n\t     * @return {[type]}      [description]\r\n\t     */\r\n\t    Node.prototype.getRect = function(json) {};\r\n\t\r\n\t    /**\r\n\t     * drawText\r\n\t     * @description 画一个文本\r\n\t     * @param {string} name\r\n\t     * @param {string} color\r\n\t     */\r\n\t    Node.prototype.drawText = function(name,color) {\r\n\t        var textName = this.bpmnInfo.name;\r\n\t        if(name != null){\r\n\t            textName = name;\r\n\t        }\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: textName,\r\n\t                color: color ? color : this.options.text.color,\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        //文字绘制的位置  \r\n\t        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t    /**\r\n\t     * refreshText\r\n\t     * @description 刷新文本\r\n\t     */\r\n\t    Node.prototype.refreshText = function() {\r\n\t        var text = this.childOfName(\"Title\");\r\n\t        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n\t        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n\t        text.attr(\"style\", { x: x, y: y });\r\n\t    };\r\n\t    /**\r\n\t     * 由父类实现\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Node.prototype.toJSON = function() {};\r\n\t\r\n\t    graphic.Util.inherits(Node, graphic.Group);\r\n\t    module.exports = Node;\r\n\t\r\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function RackNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"RackNode\" };    \r\n\t        this.model = model;\r\n\t        this.render(model, api);\r\n\t    };\r\n\t\r\n\t    RackNode.prototype.render = function(model,api) {\r\n\t        this.model = model;\r\n\t        var _UData = model.get(\"UData\");\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _rackName = model.get(\"rack\");\r\n\t        var _rackId = model.get(\"id\");\r\n\t        var _description = model.get(\"description\");\r\n\t        //title\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: 80,\r\n\t                y: -30,\r\n\t                text: _rackName + '  42U',\r\n\t                width: 80,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '18px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true,\r\n\t            parmDate: { operation: \"detailRack\", rack: _rackName, id:_rackId, description: _description}\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var afterButtonNode = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 40,\r\n\t                y: -27,\r\n\t                image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/delete.png',\r\n\t                width: 18,\r\n\t                height: 18\r\n\t            },\r\n\t            z: 1000,\r\n\t            draggable: false,\r\n\t            parmDate: { operation: \"deleteRack\", rack: _rackName, id:_rackId }\r\n\t        }); \r\n\t        this.add(afterButtonNode);\r\n\t\r\n\t        //绑定悬浮事件\r\n\t        var MOUSE_EVENT_NAMES = ['click'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t\r\n\t            _title.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                if (eveName === \"click\") {\r\n\t                    var _parmDate = e.target.parmDate;\r\n\t                    params.event = _parmDate;\r\n\t                }  \r\n\t                api.trigger(eveName, params); \r\n\t            }, this);\r\n\t\r\n\t            afterButtonNode.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                if (eveName === \"click\") {\r\n\t                    var _parmDate = e.target.parmDate;\r\n\t                    params.event = _parmDate;\r\n\t                }  \r\n\t                api.trigger(eveName, params); \r\n\t            }, this);\r\n\t\r\n\t\r\n\t        }, this);\r\n\t  \r\n\t        var rectOut = new graphic.Rect({\r\n\t            shape: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                width: model.get(\"width\"),\r\n\t                height: model.get(\"height\")\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '1'//,\r\n\t            }          \r\n\t        });        \r\n\t        this.add(rectOut);\r\n\t        var rectIn = new graphic.Rect({\r\n\t            shape: {\r\n\t                x: 5,\r\n\t                y: 5,\r\n\t                width: model.get(\"width\") - 10,\r\n\t                height: model.get(\"height\") - 10\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '1'//,\r\n\t            }          \r\n\t        });        \r\n\t        this.add(rectIn);\r\n\t\r\n\t        var j = 1;\r\n\t        var _startY =  635;\r\n\t        while( j < 43 ) { \r\n\t            var _floorNum = 1;\r\n\t            // var _y =  5 + ((42 - j ) * 15);\r\n\t            var _y =  _startY - (j * 15);\r\n\t            var _isnullFloor = false;\r\n\t            for ( var f = 0; f < _UData.length; f++ ) {\r\n\t                if ( j === parseInt(_UData[f].floor) ) {\r\n\t                    _floorNum = parseInt(_UData[f].height);\r\n\t                    _y = _y - (_floorNum - 1) * 15;\r\n\t                    var _server = \"Server\";\r\n\t                    if (_UData[f].type.toUpperCase() === \"SWITCH\") {\r\n\t                        _server = \"Switch\";\r\n\t                    }\r\n\t                    var modelObj = {\r\n\t                        resourceId: util.getUUID(),  \r\n\t                        properties: {\r\n\t                            type: \"Server\",         \r\n\t                            extProperties: {\r\n\t                            }  \r\n\t                        },\r\n\t                        bounds: {\r\n\t                            upperLeft: {x: 5, y: _y}  \r\n\t                        },\r\n\t                        stencil: {type: _server + \"Node\"}\r\n\t                    };\r\n\t                    modelObj.height =  15 * _floorNum - 1;\r\n\t                    modelObj.width = model.get(\"width\") - 10;\r\n\t                    modelObj.parmDate = _UData[f];\r\n\t                    modelObj.floor = _UData[f].floor;\r\n\t                    modelObj.status = _UData[f].status;\r\n\t                    modelObj.floorNum = _floorNum;\r\n\t                    // if () {\r\n\t\r\n\t                    // }\r\n\t                    modelObj.serverType =  (_UData[f].vendor === undefined || _UData[f].vendor === \"Unknown\") ? \"Server\": _UData[f].vendor;\r\n\t                    if( _UData[f].column !== undefined) {\r\n\t                        modelObj.column = _UData[f].column;\r\n\t                    }\r\n\t                    //判断是否band悬浮事件\r\n\t                    modelObj.showTip = _showTip;\r\n\t                    var serverModel = new NetworkModel(modelObj);\r\n\t                    this.addNodeByModel(serverModel, api);\r\n\t\r\n\t                    var rectTray = new graphic.Rect({\r\n\t                        shape: {\r\n\t                            x: 5,\r\n\t                            y: _y + (15 * _floorNum) - 1 ,\r\n\t                            width: model.get(\"width\") - 10,\r\n\t                            height: 1\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: '#FFFFFF',\r\n\t                            stroke: '#B3B3B3',\r\n\t                            lineWidth: '0.5'//,\r\n\t                        }          \r\n\t                    });        \r\n\t                    this.add(rectTray);\r\n\t                    _isnullFloor = true;\r\n\t                }\r\n\t            }\r\n\t            if( !_isnullFloor ) {\r\n\t                //   var rectTray = new graphic.Rect({\r\n\t                //     shape: {\r\n\t                //         x: 5,\r\n\t                //         y: 5 + ((42 - j ) * 15) ,\r\n\t                //         width: model.get(\"width\") - 10,\r\n\t                //         height: 15\r\n\t                //     },\r\n\t                //     style: {\r\n\t                //         fill: '#FFFFFF',\r\n\t                //         stroke: '#B3B3B3',\r\n\t                //         lineDash: [3],  \r\n\t                //         lineWidth: '1'//,\r\n\t                //     }          \r\n\t                // });        \r\n\t                // this.add(rectTray);\r\n\t\r\n\t                var modelObj = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    properties: {\r\n\t                        type: \"EmptyFloor\",         \r\n\t                        extProperties: {\r\n\t                        }  \r\n\t                    },\r\n\t                    bounds: {\r\n\t                        upperLeft: {x: 5, y: _y}  \r\n\t                    },\r\n\t                    width: model.get(\"width\"),\r\n\t                    height: 15,\r\n\t                    stencil: {type: \"EmptyFloorNode\"}\r\n\t                };\r\n\t                modelObj.showTip = _showTip;\r\n\t                modelObj.parmDate = {nodeType: 'EmptyFloorNode', floor: j};\r\n\t                var emptyFloorModel = new NetworkModel(modelObj);\r\n\t                this.addNodeByModel(emptyFloorModel, api);\r\n\t\r\n\t            }\r\n\t            j = j + _floorNum;\r\n\t        }\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    RackNode.prototype.addNodeByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this.api);\r\n\t            this.add(node);\r\n\t            var MOUSE_EVENT_NAMES = ['click'];\r\n\t            if ( p_model.get(\"showTip\") ) {\r\n\t                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n\t            }\r\n\t\r\n\t            if ( p_model.get(\"properties.type\") === \"EmptyFloorNode\" ) {\r\n\t                 MOUSE_EVENT_NAMES = ['click'];\r\n\t            }\r\n\t\r\n\t            //绑定悬浮事件\r\n\t            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t                node.on(eveName, function (e) {\r\n\t                    var params = {};\r\n\t                    if ( eveName === \"mouseover\") {\r\n\t                        // var _h = e.target.style.height !== undefined ?  (e.target.style.height / 2) : (15 / 2);\r\n\t                        var _ew = e.target.style.width !== undefined ?  (e.target.style.width + 5) : 205;\r\n\t                        params = {};\r\n\t                        params.event = e;\r\n\t                        // params.x = node.parent.position[0] + e.target.position[0];\r\n\t                        // params.y = node.parent.position[1] + e.target.position[1] + _h;\r\n\t                        params.x = e.offsetX;\r\n\t                        params.y = e.offsetY;\r\n\t                        params.width = 150;\r\n\t                        params.height = 170;\r\n\t                        params.eWidth =  5 ;\r\n\t                        // params.eWidth = _ew ;\r\n\t                        params.parmDate = e.target.parmDate;\r\n\t                        if ( api.getHeight() - params.y > params.height ) {\r\n\t                            params.layout = \"down\";\r\n\t                        } else {\r\n\t                            params.layout = \"up\";\r\n\t                        }\r\n\t                        // api.showTipWindow(params);\r\n\t                    } else if (eveName === \"mouseout\") {\r\n\t                        api.hideTipWindow(e.event.target);\r\n\t                    }  else if (eveName === \"click\") {\r\n\t                        var _parmDate = e.target.parmDate;\r\n\t                        if ( e.target.parent.rackkInfo !== undefined ) {\r\n\t                            _parmDate.rackId = e.target.parent.model.option.id;\r\n\t                            _parmDate.rackName = e.target.parent.model.option.rack;\r\n\t                        }  \r\n\t                        params.event =_parmDate;\r\n\t                    }  else if (eveName === \"dbclick\") {\r\n\t                        params.event = e.target.parmDate;\r\n\t                    } \r\n\t                    api.trigger(eveName, params); \r\n\t                }, this);\r\n\t            }, this);\r\n\t\r\n\t        }\r\n\t    };\r\n\t\r\n\t    // RackNode.prototype.toJSON = function() {\r\n\t    //     // body...\r\n\t    //     return this.model.option;\r\n\t    // };\r\n\t    zrUtil.inherits(RackNode, NetworkNode);\r\n\t    module.exports = RackNode;\r\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t */\r\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var RackNode = __webpack_require__(79);\r\n\t    var TipWindowNode = __webpack_require__(81);\r\n\t    var ServerNode = __webpack_require__(82);\r\n\t    var SwitchNode = __webpack_require__(83);\r\n\t    var EmptyFloorNode = __webpack_require__(84);\r\n\t    \r\n\t\r\n\t    var PointNode = __webpack_require__(85);\r\n\t    var CardNode =  __webpack_require__(86);\r\n\t    var TopoDrawNode = __webpack_require__(87);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    var ServerR630Node = __webpack_require__(96);\r\n\t    var ServerR730Node = __webpack_require__(97);\r\n\t    var ServerX3550Node = __webpack_require__(99);\r\n\t    var ServerX3650Node = __webpack_require__(100);\r\n\t    var ServerRD350Node = __webpack_require__(101);\r\n\t    var ServerRD650Node = __webpack_require__(102);\r\n\t    var SwitchTopoNode = __webpack_require__(103);\r\n\t    var SwitchHalfIBNode = __webpack_require__(104);\r\n\t    var SwitchFullIBNode = __webpack_require__(105);\r\n\t    var SwitchGMNode = __webpack_require__(106);\r\n\t    var SwitchKMNode = __webpack_require__(107);\r\n\t\r\n\t    var ClusterDrawNode = __webpack_require__(108);\r\n\t    var ClusterDatabaseNode = __webpack_require__(112);\r\n\t    var ClusterAsmNode = __webpack_require__(113);\r\n\t    var ClusterAsmCellNode = __webpack_require__(114);\r\n\t    var ClusterIseNode = __webpack_require__(115);\r\n\t    var ClusterIseCellNode =  __webpack_require__(116);\r\n\t \r\n\t    /**\r\n\t     * 根据结点数组 导出JSON格式的数据\r\n\t     *\r\n\t     * @param {Array} nodes 结点数组\r\n\t     * @return {JSON} JSON格式的数据\r\n\t     */\r\n\t    function exportJson(networkModel, nodes) {\r\n\t        var jsonArr = [];\r\n\t        for(var i = 0; i < nodes.length;i++){\r\n\t            var node = nodes[i];\r\n\t            if( node && node.toJSON) {\r\n\t                jsonArr.push(node.toJSON());\r\n\t            }\r\n\t        }\r\n\t        networkModel.set(\"childShapes\", jsonArr)  \r\n\t\r\n\t        return networkModel.option;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 根据 JSON 生成节点\r\n\t     * @param  {[type]} fishTopoBpmn [description]\r\n\t     * @param  {[type]} json         [description]\r\n\t     * @return {[type]}              [description]\r\n\t     */\r\n\t    function fromJson(fishTopoNetwork, json) {\r\n\t        // 1.清空画布\r\n\t        fishTopoNetwork.clear();\r\n\t        if ( json.type === \"rack\" ) {\r\n\t            var _x = 50;\r\n\t            for(var i = 0; i < json.data.length; i++) {\r\n\t                var modelObj = {\r\n\t                    resourceId: util.getUUID(),\r\n\t                    properties: {\r\n\t                        type: json.data[i].rack\r\n\t                    },\r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: 50} \r\n\t                    },\r\n\t                    stencil: {type: \"RackNode\"}\r\n\t                };\r\n\t                modelObj.height =  json.data[i].height != undefined ? json.data[i].height: 640;\r\n\t                modelObj.width = json.data[i].width != undefined ? json.data[i].width: 200;\r\n\t                modelObj.UData = json.data[i].UData;\r\n\t                modelObj.rack = json.data[i].name;\r\n\t                modelObj.id =  json.data[i].rack;\r\n\t                modelObj.description =  json.data[i].desc;\r\n\t                modelObj.showTip = json.showTip;\r\n\t                var rackModel = new NetworkModel(modelObj);\r\n\t                fishTopoNetwork.addNodeByModel(rackModel);\r\n\t                _x += 250;\r\n\t           }\r\n\t        } else if( json.type === \"topo\" ) {\r\n\t            var modelObj = {\r\n\t                resourceId: util.getUUID(),\r\n\t                bounds: {\r\n\t                    upperLeft: {x: 0, y: 0} \r\n\t                },\r\n\t                stencil: {type: \"TopoDrawNode\"}\r\n\t            };\r\n\t            modelObj.height =  fishTopoNetwork.height;\r\n\t            modelObj.width = fishTopoNetwork.width;\r\n\t            modelObj.nodeList = json.data;\r\n\t            modelObj.showTip = json.showTip;\r\n\t            var topoModel = new NetworkModel(modelObj);\r\n\t            fishTopoNetwork.addNodeByModel(topoModel);\r\n\t        } else if( json.type === \"cluster\" ) {\r\n\t            var modelObj = {\r\n\t                resourceId: util.getUUID(),\r\n\t                bounds: {\r\n\t                    upperLeft: {x: 0, y: 0} \r\n\t                },\r\n\t                stencil: {type: \"ClusterDrawNode\"}\r\n\t            };\r\n\t            modelObj.height =  fishTopoNetwork.height;\r\n\t            modelObj.width = fishTopoNetwork.width;\r\n\t            modelObj.nodeList = json.data;\r\n\t            modelObj.showTip = json.showTip;\r\n\t            var clusterModel = new NetworkModel(modelObj);\r\n\t            fishTopoNetwork.addNodeByModel(clusterModel);\r\n\t        }\r\n\t        \r\n\t    }\r\n\t\r\n\t    function registerNetworkNode () {\r\n\t        NetworkNode.registerClass(RackNode, \"RackNode\");\r\n\t        NetworkNode.registerClass(TipWindowNode, \"TipWindowNode\");\r\n\t        NetworkNode.registerClass(ServerNode, \"ServerNode\");\r\n\t        NetworkNode.registerClass(SwitchNode, \"SwitchNode\");\r\n\t        NetworkNode.registerClass(EmptyFloorNode, \"EmptyFloorNode\");\r\n\t\r\n\t        NetworkNode.registerClass(ServerTopoNode, \"ServerTopoNode\");\r\n\t        NetworkNode.registerClass(TopoDrawNode, \"TopoDrawNode\");\r\n\t        NetworkNode.registerClass(ServerR630Node, \"ServerR630Node\");\r\n\t        NetworkNode.registerClass(ServerR730Node, \"ServerR730Node\");\r\n\t        NetworkNode.registerClass(PointNode, \"PointNode\"); \r\n\t        NetworkNode.registerClass(CardNode, \"CardNode\"); \r\n\t        NetworkNode.registerClass(ServerX3550Node, \"ServerX3550Node\"); \r\n\t        NetworkNode.registerClass(ServerX3650Node, \"ServerX3650Node\"); \r\n\t        NetworkNode.registerClass(ServerRD350Node, \"ServerRD350Node\");\r\n\t        NetworkNode.registerClass(ServerRD650Node, \"ServerRD650Node\");\r\n\t        NetworkNode.registerClass(SwitchFullIBNode, \"SwitchFullIBNode\");\r\n\t        NetworkNode.registerClass(SwitchHalfIBNode, \"SwitchHalfIBNode\");\r\n\t        NetworkNode.registerClass(SwitchKMNode, \"SwitchKMNode\");\r\n\t        NetworkNode.registerClass(SwitchGMNode, \"SwitchGMNode\"); \r\n\t        \r\n\t        NetworkNode.registerClass(ClusterDrawNode, \"ClusterDrawNode\"); \r\n\t        NetworkNode.registerClass(ClusterDatabaseNode, \"ClusterDatabaseNode\"); \r\n\t        NetworkNode.registerClass(ClusterAsmNode, \"ClusterAsmNode\");  \r\n\t        NetworkNode.registerClass(ClusterAsmCellNode, \"ClusterAsmCellNode\"); \r\n\t        NetworkNode.registerClass(ClusterIseNode, \"ClusterIseNode\"); \r\n\t        NetworkNode.registerClass(ClusterIseCellNode, \"ClusterIseCellNode\"); \r\n\t                     \r\n\t    }   \r\n\t\r\n\t    var NextWorkUtil = {\r\n\t        exportJson: exportJson,\r\n\t        fromJson: fromJson,\r\n\t        registerNetworkNode: registerNetworkNode\r\n\t    };\r\n\t    module.exports = NextWorkUtil;\r\n\t\r\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\tvar Node = __webpack_require__(78);\r\n\t\tvar zrUtil = __webpack_require__(4);\r\n\t\tvar graphic = __webpack_require__(3);\r\n\t\tvar clazzUtil = __webpack_require__(76);\r\n\t\t\r\n\t\t//创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\t\tfunction TipWindowNode(model, api) {\r\n\t\t\tNode.call(this);\r\n\t\t\tthis.model = model;\t\t\r\n\t\t\tthis.nextworkInfo = {type: -1, name:\"TipWindowNodeDiagram\" };    //节点信息\r\n\t\t\tthis.initEvent(api);\r\n\t        this.render(model, api);\r\n\t\t};\r\n\t\r\n\t    TipWindowNode.prototype.initEvent = function(api) {\r\n\t        // var that = this;\r\n\t        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t        //     that.on(eveName, function (e) {\r\n\t\t       //      var params = {};\r\n\t\t       //      params.event = e;\r\n\t\t       //      params.type = eveName;\r\n\t\t       //      params.model = that.model\r\n\t\t       //      api.trigger(eveName, params); \r\n\t        //     }, this);\r\n\t        // }, this);\r\n\t    };\t\r\n\t\r\n\t\tTipWindowNode.prototype.render = function(model, api) {\r\n\t\t\tvar _x = model.x;\r\n\t        var _y = model.y;\r\n\t        var _xWidth = model.eWidth;\r\n\t        var _width = model.width;\r\n\t        var _height = model.height;\r\n\t\t\tvar points = [\r\n\t\t\t\t\t[_x + _xWidth + 20, _y],\r\n\t\t\t\t\t[_x + _xWidth, _y],\r\n\t\t\t\t\t[_x + _xWidth + 20, _y + 15],\t\r\n\t\t\t\t\t[_x + _xWidth + 20, _y + _height],\r\n\t\t\t\t\t[_x + _xWidth + _width, _y + _height],\r\n\t\t\t\t\t[_x + _xWidth + _width, _y]\r\n\t\t\t\t];\r\n\t\t\tif ( model.layout != undefined && model.layout === \"up\" ) {\r\n\t\t\t\tpoints = [\r\n\t\t\t\t\t[_x + _xWidth + 20, _y],\r\n\t\t\t\t\t[_x + _xWidth, _y],\r\n\t\t\t\t\t[_x + _xWidth + 20, _y - 15],\t\r\n\t\t\t\t\t[_x + _xWidth + 20, _y - _height],\r\n\t\t\t\t\t[_x + _xWidth + _width, _y - _height],\r\n\t\t\t\t\t[_x + _xWidth + _width, _y]\r\n\t\t\t\t];\r\n\t\t\t} \r\n\t\r\n\t\t\tif ( model.layout != undefined && model.layout === \"left\" ) {\r\n\t\t\t\tpoints = [\r\n\t\t\t\t\t[_x - 2 * _width - 10, _y],\r\n\t\t\t\t\t[_x - 2 * _width + 10, _y],\r\n\t\t\t\t\t[_x - 2 * _width - 10, _y + 15],\t\r\n\t\t\t\t\t[_x - 2 * _width - 10, _y + _height],\r\n\t\t\t\t\t[_x - 2 * _width - _width, _y + _height],\r\n\t\t\t\t\t[_x - 2 * _width - _width, _y]\r\n\t\t\t\t];\r\n\t\t\t}\t\r\n\t\t\tvar _tipContext = \"请查询数据\";\r\n\t\t\tif ( model.parmDate !== undefined ) {\r\n\t\t\t\tif( model.parmDate.type === \"switch\" ) {\r\n\t\t\t\t\t_tipContext = 'hostname: '+ model.parmDate.hostname +' \\n status: ' + model.parmDate.status + ' \\n floor: ' + model.parmDate.floor +  '\\n height: ' + model.parmDate.height + \"\\n vendor:\" +  model.parmDate.vendor;\r\n\t\t\t\t\r\n\t\t\t\t} else if( model.parmDate.nodeType === \"EmptyFloorNode\" ) {\r\n\t\t\t\t\t_tipContext = 'floor: ' + model.parmDate.floor;\r\n\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t_tipContext = 'hostname: '+ model.parmDate.hostname +' \\n status: ' + model.parmDate.status + ' \\n  Ip: ' + model.parmDate.ipaddress +  '\\n floor: ' + model.parmDate.floor +  '\\n height: ' + model.parmDate.height + \"\\n vendor:\" +  model.parmDate.vendor;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif ( model.parmDate.tipContext !== undefined ) {\r\n\t\t\t\t\t_tipContext = model.parmDate.tipContext;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar tip = new graphic.Polygon({\r\n\t            shape: {\r\n\t                points: points\r\n\t            },\r\n\t            style: {\r\n\t\t\t\t\tstroke: 'rgba(174, 174,174, 1.0)',\r\n\t\t\t\t\tfill: 'rgba(255, 255, 255, 1.0)',\r\n\t\t\t\t\tlineWidth: 1,\r\n\t\t\t\t\ttext: _tipContext,\r\n\t\t\t\t\ttextAlign: 'center'//,\r\n\t\t\t\t\t//textPosition: 'left',\r\n\t\t\t\t\t//smooth: 'bezier'\t\r\n\t\t\t\t},   \r\n\t\t\t\tz: 1000     \r\n\t        });        \r\n\t        this.add(tip);\r\n\t\t};\r\n\t\r\n\t\tzrUtil.inherits(TipWindowNode, Node);\r\n\t\r\n\t\r\n\t\tmodule.exports = TipWindowNode;\r\n\t\r\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t     var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    function ServerNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.serverInfo = {type: -1, name: \"ServerNode\" };    //\r\n\t        this.model = model;\r\n\t        return this.render(model,api);\r\n\t    };\r\n\t\r\n\t    \r\n\t        \r\n\t    ServerNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var status = model.get(\"status\");\r\n\t        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"serverType\") ;\r\n\t        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n\t        //      imageUrl += status;\r\n\t        // }\r\n\t        imageUrl += '.png';\r\n\t\r\n\t        //״̬ \r\n\t        var cellStateNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 10,\r\n\t                cy: (15 * model.get(\"floorNum\") - 3) / 2,\r\n\t                r: 4\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826',\r\n\t                opacity: 1,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            },\r\n\t            z: 1000 \r\n\t        });\r\n\t        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n\t            cellStateNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(cellStateNode);\r\n\t\r\n\t        var rectServer = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: model.get(\"width\"),\r\n\t                height:  15 * model.get(\"floorNum\") - 3\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: model.get(\"parmDate\")    \r\n\t        }); \r\n\t        //rectServer.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n\t        this.add(rectServer);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t        // return rectServer;\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerNode, NetworkNode);\r\n\t    module.exports = ServerNode;\r\n\t\r\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    function SwitchNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.serverInfo = {type: -1, name: \"SwitchNode\" };    //\r\n\t        this.model = model;\r\n\t        return this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchNode.prototype.render = function(model,api) {\r\n\t        this.model = model;\r\n\t        var _px = model.get(\"bounds.upperLeft.x\");\r\n\t        var _py = model.get(\"bounds.upperLeft.y\");\r\n\t        var _height = model.get(\"height\");\r\n\t        var _width = model.get(\"width\");\r\n\t        if(model.get(\"column\") === undefined || model.get(\"column\") === \"all\" ) {\r\n\t            \r\n\t        } else {\r\n\t            _width = model.get(\"width\") / 2 - 5;\r\n\t            if ( model.get(\"column\") === \"right\" ) {\r\n\t                 _px = 5 + _width + 5;\r\n\t            }      \r\n\t        }\r\n\t        var rectSwitch = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/IBSwitchFull.png',\r\n\t                width: _width,\r\n\t                height:  _height\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate : model.get(\"parmDate\")    \r\n\t            // _parmDate : \"111\"       \r\n\t        }); \r\n\t        rectSwitch.position = [ _px, _py]; \r\n\t        return rectSwitch;\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(SwitchNode, NetworkNode);\r\n\t    module.exports = SwitchNode;\r\n\t\r\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    function EmptyFloorNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.serverInfo = {type: -1, name: \"EmptyFloorNode\" };    //\r\n\t        this.model = model;\r\n\t        return this.render(model,api);\r\n\t    };\r\n\t\r\n\t    EmptyFloorNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var rectTray = new graphic.Rect({\r\n\t                shape: {\r\n\t                    x: 0,\r\n\t                    y: 0,\r\n\t                    width: model.get(\"width\") - 10,\r\n\t                    height: 15\r\n\t                },\r\n\t                style: {\r\n\t                    fill: '#FFFFFF',\r\n\t                    stroke: '#B3B3B3',\r\n\t                    lineDash: [3],  \r\n\t                    lineWidth: '1'//,\r\n\t                }  ,\r\n\t                draggable: false,\r\n\t                parmDate: model.get(\"parmDate\")            \r\n\t            });        \r\n\t        this.add(rectTray);\r\n\t        rectTray.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")]; \r\n\t        return rectTray;\r\n\t\r\n\t        // var rectServer = new graphic.Image({\r\n\t        //     position: [0, 0],\r\n\t        //     scale: [1, 1],\r\n\t        //     style: {\r\n\t        //         x: 0,\r\n\t        //         y: 0,\r\n\t        //         image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/lenovoRd650a.png',\r\n\t        //         width: model.get(\"width\") - 10,\r\n\t        //         height:  15\r\n\t        //     },\r\n\t        //     draggable: false\r\n\t        // }); \r\n\t        // rectServer.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n\t        // return rectServer;\r\n\t\r\n\t    };\r\n\t    zrUtil.inherits(EmptyFloorNode, NetworkNode);\r\n\t    module.exports = EmptyFloorNode;\r\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function PointNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"PointNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    PointNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        // this.add(_title);\r\n\t\r\n\t        var portNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                width: model.get(\"width\"),\r\n\t                height: model.get(\"height\")\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#E2E3D9',\r\n\t                stroke: '#B3B3B3',\r\n\t                opacity: 0.1,\r\n\t                lineWidth: '1'//,\r\n\t            }          \r\n\t        });              \r\n\t        this.add(portNode);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t   \r\n\t\r\n\t    zrUtil.inherits(PointNode, NetworkNode);\r\n\t    module.exports = PointNode;\r\n\t\r\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function CardNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"CardNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.pointList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    CardNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _portData = model.get(\"portData\");\r\n\t        var _type = model.get(\"type\");\r\n\t        var _direction = model.get(\"direction\");\r\n\t        var imgUrl = \"\";\r\n\t        if( _type === \"1\" || _type === \"3\" ) {\r\n\t            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/IB1.jpg';\r\n\t        }else if ( _type === \"5\" ) {\r\n\t            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km2.jpg';\r\n\t        } else if( _type === \"6\" ) {\r\n\t            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km4.jpg';\r\n\t        }\r\n\t\r\n\t\r\n\t         var rectServer = new graphic.Image({\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imgUrl,\r\n\t                width: model.get(\"width\"),\r\n\t                height: model.get(\"height\")\r\n\t            },\r\n\t            draggable: false,\r\n\t            invisible: false,\r\n\t            parmDate: _portData\r\n\t        }); \r\n\t        this.add(rectServer);\r\n\t        rectServer.hide();\r\n\t\r\n\t        var _resourcesName = model.get(\"resourcesName\");\r\n\t        var _resourceNodeType = model.get(\"resourceNodeType\");\r\n\t        var _No = model.get(\"No\");\r\n\t        if ( _direction === \"leftRight\" ) {\r\n\t            var _x = 4;\r\n\t            var _y = 2;\r\n\t            var _width = 8;\r\n\t            var _height = 5; \r\n\t            if ( _type === \"1\" ||  _type === \"2\" ||  _type === \"3\" ||  _type === \"4\" ) {\r\n\t                _width = 20;\r\n\t            }\r\n\t            for( var i = 0; i < _portData.length; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = _height;\r\n\t                portModel.width = _width;\r\n\t\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = _resourcesName;\r\n\t                _linInfo.sourceCardNo = _No;\r\n\t                _linInfo.sourcePort = i;\r\n\t                _linInfo.nodetype = _resourceNodeType; \r\n\t                _linInfo.sourceStatus =  _portData[i].status;        \r\n\t                _linInfo.targetReource = _portData[i].target.resourceName ;\r\n\t                _linInfo.targetPort = _portData[i].target.port;\r\n\t\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                 _x = _x + _width + 2;\r\n\t            }    \r\n\t        } \r\n\t        \r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t   CardNode.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, api);\r\n\t            this.pointList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(CardNode, NetworkNode);\r\n\t    module.exports = CardNode;\r\n\t\r\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var NetWorkLineNode = __webpack_require__(88);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var NetWorkLineModel = __webpack_require__(94);\r\n\t\r\n\t    function TopoDrawNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.topoInfo = {type: -1, name: \"TopoDrawNode\" };    \r\n\t        this.model = model;\r\n\t        this.portList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    TopoDrawNode.prototype.render = function(model, api) {\r\n\t        var nodeList = model.get(\"nodeList\");\r\n\t        var serverWidth = 160; //服务器宽度\r\n\t        var switchWidth = 300; //交换机宽度\r\n\t        //根据Node数量计算实际画布宽度\r\n\t        var clentWidth = this.getWidth(nodeList, serverWidth, switchWidth);\r\n\t        clentWidth = clentWidth > model.get(\"width\") ? clentWidth : model.get(\"width\");\r\n\t        api.resize(clentWidth, model.get(\"height\"));\r\n\t\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _startX = 100,\r\n\t            _textW = 30,\r\n\t            _startY = 10,\r\n\t            _textH = 20;\r\n\t        var textKM = new graphic.Text({\r\n\t            style: {\r\n\t                x: _startX,\r\n\t                y: _startY,\r\n\t                text: '千兆',\r\n\t                width: _textW,\r\n\t                height: _textH,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '10px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(textKM);\r\n\t\r\n\t        var lineKM = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : _startX + _textW,\r\n\t                y1 : _startY + 10,\r\n\t                x2 : _startX + _textW + 100,\r\n\t                y2 : _startY + 10,\r\n\t                lineWidth : 5,  \r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#0704EC',\r\n\t                lineType : 'solid',// default solid\r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineKM);\r\n\t\r\n\t        _startY = _startY + _textH;\r\n\t        var textGB = new graphic.Text({\r\n\t            style: {\r\n\t                x: _startX,\r\n\t                y: _startY,\r\n\t                text: '万兆',\r\n\t                width: _textW,\r\n\t                height: _textH,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '10px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(textGB);\r\n\t\r\n\t        var lineGB = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : _startX + _textW,\r\n\t                y1 : _startY + 10 ,\r\n\t                x2 : _startX + _textW + 100,\r\n\t                y2 : _startY + 10,\r\n\t                lineWidth : 5,  \r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#070413',\r\n\t                lineType : 'solid',// default solid\r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineGB);\r\n\t\r\n\t        _startY =  _startY + _textH;\r\n\t        var textIB = new graphic.Text({\r\n\t            style: {\r\n\t                x: _startX,\r\n\t                y: _startY,\r\n\t                text: 'IB',\r\n\t                width: _textW,\r\n\t                height: _textH,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '10px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(textIB);\r\n\t\r\n\t        var lineIB = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : _startX + _textW,\r\n\t                y1 : _startY + 10,\r\n\t                x2 : _startX + _textW + 100,\r\n\t                y2 : _startY + 10,\r\n\t                lineWidth : 5,  \r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#62A4DD',\r\n\t                lineType : 'solid',// default solid\r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineIB);\r\n\t\r\n\t        //主线布局\r\n\t        var lineOut = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : 50,\r\n\t                y1 : 70,\r\n\t                x2 : 50,\r\n\t                y2 : 700,\r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#000',\r\n\t                lineType : 'solid',// default solid\r\n\t                lineWidth : 3,  \r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineOut);\r\n\t\r\n\t        var lineUp = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : 50,\r\n\t                y1 : 250,\r\n\t                x2 : clentWidth - 50,\r\n\t                y2 : 250,\r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#000',\r\n\t                lineType : 'solid',// default solid\r\n\t                lineWidth : 3,  \r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineUp);\r\n\t\r\n\t        var lineDown = new graphic.Line({\r\n\t            shape: {\r\n\t                x1 : 50,\r\n\t                y1 : 450,\r\n\t                x2 : clentWidth - 50,\r\n\t                y2 : 450, \r\n\t                text : 'line'\r\n\t            },\r\n\t            style: {\r\n\t                stroke: '#000',\r\n\t                lineType : 'solid',// default solid\r\n\t                lineWidth : 3,  \r\n\t                fill: null\r\n\t            }        \r\n\t        });        \r\n\t        this.add(lineDown);\r\n\t\r\n\t         //循环添加topo图上的节点\r\n\t        var startComputeX = 70;\r\n\t        var startStorageX = 110; \r\n\t        var startSwitchX = 90; \r\n\t        for ( var i = 0; i < nodeList.length; i++ ) {\r\n\t            var nodeY = 145;\r\n\t            var modelObj = {};\r\n\t            var _typeNode = \"TopoDrawNode\";\r\n\t            if ( nodeList[i].nodetype === \"compute\" ) {\r\n\t                if (nodeList[i].type  === \"ServerR730\" || nodeList[i].type  === \"ServerX3650\") {\r\n\t                    nodeY = 125;\r\n\t                }\r\n\t                _typeNode = nodeList[i].type + \"Node\";\r\n\t                modelObj = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startComputeX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: _typeNode}\r\n\t                };\r\n\t                modelObj.name = nodeList[i].resourceName;\r\n\t                modelObj.width = serverWidth;\r\n\t                startComputeX += serverWidth + 20;\r\n\t            } else if (nodeList[i].nodetype === \"storage\" ) {           \r\n\t                nodeY = 550;\r\n\t                _typeNode = nodeList[i].type + \"Node\";\r\n\t                modelObj = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startStorageX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: _typeNode}\r\n\t                };\r\n\t                modelObj.name = nodeList[i].resourceName;\r\n\t                modelObj.width = serverWidth;\r\n\t                startStorageX += serverWidth + 20;\r\n\t            } else if (nodeList[i].nodetype === \"switch\" ) {\r\n\t                var type = nodeList[i].type !== undefined && nodeList[i].type !== null ? nodeList[i].type : \"\";\r\n\t                var switchType = \"SwitchHalfIB\";\r\n\t                if ( type.toUpperCase() === \"FULL\" ) {\r\n\t                    switchType = \"SwitchFullIB\";\r\n\t                }\r\n\t                _typeNode = switchType + \"Node\";\r\n\t                nodeY = 335;\r\n\t                modelObj = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startSwitchX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: _typeNode}\r\n\t                }; \r\n\t                if ( nodeList[i].type  === \"Half\" ) {\r\n\t                    modelObj.width = switchWidth / 2;\r\n\t                    startSwitchX += switchWidth / 2 + 50;\r\n\t                } else {\r\n\t                    modelObj.width = switchWidth;\r\n\t                    startSwitchX += switchWidth + 50;\r\n\t                } \r\n\t                modelObj.name = \"Name: \"  + nodeList[i].resourceName + \", No：\" + nodeList[i].manager_ipaddr;\r\n\t                modelObj.portNum = nodeList[i].portTotal;\r\n\t            } else if (nodeList[i].nodetype === \"ESwitch\" ) {\r\n\t                nodeY = 335;\r\n\t                modelObj = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startSwitchX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: \"SwitchKMNode\"}\r\n\t                }; \r\n\t                modelObj.name = nodeList[i].resourceName;\r\n\t                modelObj.width = switchWidth;\r\n\t                startSwitchX += switchWidth + 50;       \r\n\t            }\r\n\t            if ( modelObj.stencil !== undefined && modelObj.stencil.type !== undefined ) {\r\n\t                if ( modelObj.stencil.type !== undefined &&  modelObj.stencil.type !== \"ServerR730Node\" &&\r\n\t                     modelObj.stencil.type !== \"ServerR630Node\" &&\r\n\t                     modelObj.stencil.type !== \"SwitchFullIBNode\" &&\r\n\t                     modelObj.stencil.type !== \"SwitchHalfIBNode\" &&\r\n\t                     modelObj.stencil.type !== \"SwitchKMNode\"\r\n\t                 ) {\r\n\t                    modelObj.stencil.type = \"ServerTopoNode\";\r\n\t                }\r\n\t            }\r\n\t            \r\n\t            modelObj.status =  nodeList[i].status;\r\n\t            modelObj.nodetype = nodeList[i].nodetype;\r\n\t            modelObj.type = nodeList[i].type;\r\n\t            var _parmDate = {};\r\n\t            _parmDate.hostId = nodeList[i].host_id;\r\n\t            _parmDate.name = nodeList[i].resourceName;\r\n\t            _parmDate.noteType = nodeList[i].nodetype;\r\n\t            _parmDate.status = nodeList[i].status;\r\n\t            _parmDate.type = nodeList[i].type;\r\n\t            _parmDate.key = nodeList[i].manager_ipaddr ? nodeList[i].manager_ipaddr : \"\";\r\n\t\r\n\t\r\n\t            modelObj.parmDate = _parmDate;\r\n\t            modelObj.height =  15;\r\n\t            if ( nodeList[i].ports != undefined ) {\r\n\t                modelObj.ports = nodeList[i].ports;\r\n\t            }\r\n\t            //判断是否band悬浮事件\r\n\t            modelObj.showTip = _showTip;\r\n\t            var serverModel = new NetworkModel(modelObj);\r\n\t            this.addNodeByModel(serverModel, api);\r\n\t        }\r\n\t\r\n\t        //连线\r\n\t        for ( var ps = 0; ps < this.portList.length; ps++ ) {\r\n\t            var startNode = this.portList[ps];\r\n\t            var endNode = null;\r\n\t            for ( var pe = 0; pe < this.portList.length; pe++ ) {\r\n\t                if (startNode.lineInfo.targetReource === this.portList[pe].lineInfo.sourceReource \r\n\t                    && startNode.lineInfo.targetPort === this.portList[pe].lineInfo.sourcePort ) {\r\n\t                    endNode = this.portList[pe];\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            //连线\r\n\t            if( endNode !== null && startNode != null ) {\r\n\t                this.drawLine(startNode, endNode, api);\r\n\t            }\r\n\t\r\n\t\r\n\t        }\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    TopoDrawNode.prototype.getWidth = function( p_nodeList, p_serverW, p_switchW ) {\r\n\t        // var computeCount = 0;\r\n\t        // var storageCount = 0; \r\n\t        // var switchCount = 0; \r\n\t        // for ( var i = 0; i < p_nodeList.length; i++ ) {\r\n\t        //     if ( p_nodeList[i].nodetype === \"1\" ) {\r\n\t        //        computeCount++;\r\n\t        //     } else if (p_nodeList[i].nodetype === \"2\" ) {           \r\n\t        //         storageCount++;\r\n\t        //     } else if (p_nodeList[i].nodetype === \"3\" ) {\r\n\t        //         switchCount++;\r\n\t        //     }\r\n\t        // }\r\n\t        // var serverCount = computeCount > storageCount ? computeCount : storageCount; \r\n\t        // var w1 = 60 + serverCount * (p_serverW + 50) + 150;\r\n\t        // var s1 = 40 + switchCount * (p_switchW + 50) + 150;\r\n\t        var computeWidth = 210;\r\n\t        var storageWidth = 210; \r\n\t        var switchWidth = 190; \r\n\t        for ( var i = 0; i < p_nodeList.length; i++ ) {\r\n\t            if ( p_nodeList[i].nodetype === \"compute\" ) {\r\n\t               computeWidth += p_serverW + 50;\r\n\t            } else if (p_nodeList[i].nodetype === \"storage\" ) {           \r\n\t                storageWidth += p_serverW + 50;\r\n\t            } else if (p_nodeList[i].nodetype === \"switch\" ) {\r\n\t                if( p_nodeList[i].portTotal > 12 ) {\r\n\t                    switchWidth += p_switchW + 50; \r\n\t                } else {\r\n\t                    switchWidth += (p_switchW / 2) + 50; \r\n\t                }\r\n\t            } else if (p_nodeList[i].nodetype === \"ESwitch\" ) {\r\n\t                switchWidth += p_switchW + 50; \r\n\t            }\r\n\t        }\r\n\t        var serverWidth = computeWidth > storageWidth ? computeWidth : storageWidth;\r\n\t        return serverWidth > switchWidth ? serverWidth : switchWidth;\r\n\t    };\r\n\t\r\n\t    TopoDrawNode.prototype.addNodeByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, api);\r\n\t            this.add(node);\r\n\t            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {\r\n\t                for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n\t                    this.portList.push(node.portNodeList[i]);\r\n\t                }\r\n\t                //this.portList.concat(node.portNodeList);\r\n\t            }\r\n\t\r\n\t             //绑定事件\r\n\t            var MOUSE_EVENT_NAMES = ['click'];\r\n\t            if ( p_model.get(\"showTip\") ) {\r\n\t                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n\t            }\r\n\t            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t                node.on(eveName, function (e) {\r\n\t                    var params = {};\r\n\t                    if ( eveName === \"mouseover\") {\r\n\t                        params.event = e;\r\n\t                        params.x = e.offsetX;\r\n\t                        params.y = e.offsetY;\r\n\t                        params.width = 150;\r\n\t                        params.height = 170;\r\n\t                        params.eWidth =  5 ;\r\n\t                        params.parmDate = e.target.parent.parmDate;\r\n\t                        params.type = \"lineTip\";\r\n\t                        if (params.parmDate !== undefined ) {\r\n\t                            var _name = params.parmDate.name;\r\n\t                            var text = \"name: \" + _name + \"\\n\" +\r\n\t                                       \"noteType: \"+ params.parmDate.noteType + \"\\n\";\r\n\t                            if ( params.parmDate.status !== null && params.parmDate.status !== undefined ) {\r\n\t                                text += \"status: \"+ params.parmDate.status + \"\\n\";\r\n\t                            }\r\n\t                             if ( params.parmDate.type !== null && params.parmDate.type !== undefined ) {\r\n\t                                text += \"type: \"+ params.parmDate.type + \"\\n\";\r\n\t                            }\r\n\t                            params.parmDate.tipContext = text; \r\n\t                        } \r\n\t                        \r\n\t                        if ( api.getHeight() - params.y > params.height ) {\r\n\t                            params.layout = \"down\";\r\n\t                        } else {\r\n\t                            params.layout = \"up\";\r\n\t                        }\r\n\t\r\n\t                        //api.showTipWindow(params);\r\n\t                    } else if (eveName === \"mouseout\") {\r\n\t                        api.hideTipWindow(e.event.target);\r\n\t                    } else if (eveName === \"click\") {\r\n\t                        var _parmDate = e.target.parmDate;\r\n\t                        params.event =_parmDate;\r\n\t                    } \r\n\t                    api.trigger(eveName, params); \r\n\t                }, this);\r\n\t             }, this);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    TopoDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {\r\n\t        var fleftx = p_startNode.position[0] + p_startNode.parent.position[0] + p_startNode.parent.parent.position[0];\r\n\t        var flefty = p_startNode.position[1] + p_startNode.parent.position[1] + p_startNode.parent.parent.position[1];\r\n\t        var fwidth = p_startNode.model.get(\"width\");\r\n\t        var fheight = p_startNode.model.get(\"height\");\r\n\t\r\n\t        var torightx = p_endNode.position[0] + p_endNode.parent.position[0];\r\n\t        var torighty = p_endNode.position[1] + p_endNode.parent.position[1];\r\n\t        var towidth = p_endNode.model.get(\"width\");\r\n\t        var toheight = p_endNode.model.get(\"height\");\r\n\t        var moddleY = 250;\r\n\t        var nodetype = p_startNode.model.get(\"lineInfo\").nodetype;\r\n\t        if( nodetype === \"storage\" ) {\r\n\t            moddleY = 450;\r\n\t        }\r\n\t        var _lindColor = \"#62A4DD\";\r\n\t        var _lineInfo = p_startNode.model.get(\"lineInfo\");\r\n\t        if ( _lineInfo.portType === \"1\") {\r\n\t            _lindColor = \"#62A4DD\";\r\n\t        } else if ( _lineInfo.portType === \"2\")  {\r\n\t             _lindColor = \"#070413\";\r\n\t        } else if ( _lineInfo.portType === \"3\")  {\r\n\t            _lindColor = \"#0704EC\";\r\n\t        } \r\n\t        if ( _lineInfo.portState.toUpperCase() !== \"UP\" ) {\r\n\t            _lindColor = \"#FFCC00\";\r\n\t        }\r\n\t        if ( p_endNode.model.get(\"lineInfo\").sourceReourceName !== undefined && p_endNode.model.get(\"lineInfo\").sourceReourceName !== null ) {\r\n\t            _lineInfo.sourceReourceName = p_endNode.model.get(\"lineInfo\").sourceReourceName;\r\n\t        }\r\n\t        var _moddleX = p_startNode.lineInfo.moddleX;\r\n\t        var defaultOption = {\r\n\t            fromBounds : {x: fleftx, y: flefty, width: fwidth, height: fheight},\r\n\t            toBounds: {x: torightx, y: torighty, width: towidth, height: toheight},\r\n\t            moddleY: moddleY,\r\n\t            style : {\r\n\t                lineWidth : 1,\r\n\t                stroke: _lindColor//,\r\n\t                //fill: '#9699DD'\r\n\t            },\r\n\t            hoverStyle : {\r\n\t                lineWidth : 1,\r\n\t                stroke: '#47D930'//,\r\n\t                //fill:'#2FDE92'\r\n\t            }\r\n\t        };\r\n\t        if ( _moddleX !== undefined ) {\r\n\t            defaultOption.moddleX =  _moddleX;\r\n\t        }\r\n\t\r\n\t        defaultOption.parmData = _lineInfo;\r\n\t        var netWorkLineModel = new NetWorkLineModel(defaultOption);\r\n\t        var netWorkLineNode = new NetWorkLineNode(netWorkLineModel);\r\n\t        this.add(netWorkLineNode);\r\n\t\r\n\t\r\n\t        //绑定事件\r\n\t        var MOUSE_EVENT_NAMES = ['mouseover', 'mouseout'];\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            netWorkLineNode.on(eveName, function (e) {\r\n\t                var params = {};\r\n\t                if ( eveName === \"mouseover\") {\r\n\t                    params.event = e;\r\n\t                    params.x = e.offsetX;\r\n\t                    params.y = e.offsetY;\r\n\t                    params.width = 200;\r\n\t                    params.height = 170;\r\n\t                    params.eWidth =  5 ;\r\n\t                    params.parmDate = e.target.parent.parent.parmData;\r\n\t                    params.type = \"lineTip\";\r\n\t                    var text = \"Status: \"+  params.parmDate.portState + \"\\n\";\r\n\t                        text += \"Source Reource: \"+  params.parmDate.sourceReource + \"\\n\";\r\n\t                        text += \"Source Port: \"+  params.parmDate.sourcePort + \"\\n\";\r\n\t                    if ( params.parmDate.ip !== undefined && params.parmDate.ip !== null ) {\r\n\t                        text += \"IP: \"+  params.parmDate.ip+ \"\\n\";\r\n\t                    }  \r\n\t                    if ( params.parmDate.portType !== undefined && params.parmDate.portType !== null ) {\r\n\t                        if ( params.parmDate.portType === \"1\" ) {\r\n\t                            text += \"Port Type: IB口\\n\";\r\n\t                        } else if ( params.parmDate.portType === \"2\" ) {\r\n\t                            text += \"Port Type: 万兆口\\n\";\r\n\t                        } else if ( params.parmDate.portType === \"3\" ) {\r\n\t                            text += \"Port Type: 千兆口\\n\";\r\n\t                        }\r\n\t                    }  \r\n\t                \r\n\t                    if ( params.parmDate.targetReource !== undefined && params.parmDate.targetReource !== null ) {\r\n\t                        if ( params.parmDate.sourceReourceName !== undefined && params.parmDate.sourceReourceName !== null ) {\r\n\t                            text += \"Target Reource: \" +  params.parmDate.sourceReourceName + \"\\n\";\r\n\t                        } else {\r\n\t                            text += \"Target Reource: \" +  params.parmDate.targetReource + \"\\n\";\r\n\t                        }   \r\n\t                    }  \r\n\t\r\n\t                    if ( params.parmDate.targetPort !== undefined && params.parmDate.targetPort !== null ) {\r\n\t                        text += \"Target Port: \" +  params.parmDate.targetPort + \"\\n\";\r\n\t                    }  \r\n\t\r\n\t                    \r\n\t\r\n\t                    params.parmDate.tipContext = text;\r\n\t\r\n\t                    if ( api.getHeight() - params.y > params.height ) {\r\n\t                        params.layout = \"down\";\r\n\t                    } else {\r\n\t                        params.layout = \"up\";\r\n\t                    }\r\n\t\r\n\t\r\n\t                    api.showTipWindow(params);\r\n\t                } else if (eveName === \"mouseout\") {\r\n\t                    api.hideTipWindow(e.event.target);\r\n\t                }\r\n\t                //api.trigger(eveName, params); \r\n\t            }, this);\r\n\t         }, this);\r\n\t    }\r\n\t    zrUtil.inherits(TopoDrawNode, NetworkNode);\r\n\t    module.exports = TopoDrawNode;\r\n\t\r\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\tvar Node = __webpack_require__(78);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t\tvar Util = __webpack_require__(71);\r\n\t\tvar graphic = __webpack_require__(3);\r\n\t    var Point = __webpack_require__(72);\r\n\t    var Connector = __webpack_require__(89);\r\n\t\r\n\t\tfunction NetWorkLineNode(model,api) {\r\n\t\t\tNode.call(this);\r\n\t        this.model = model;  // NetWorkLineModal\r\n\t        this.con = null;        \r\n\t\t\tthis.render();\r\n\t\t\tthis.refreshLine();\r\n\t        this.lineType = this.model.get(\"lineType\");\r\n\t        this.parmData = this.model.get(\"parmData\");\r\n\t        \r\n\t\t};\r\n\t\r\n\t\tNetWorkLineNode.prototype.render = function() {\r\n\t            var parmData = {};\r\n\t            if ( this.model.get(\"isVector\") ) {\r\n\t                 parmData.symbol = {type:\"arrow\", size: 10, color:\"#000000\"};\r\n\t            } else {\r\n\t                 parmData.symbol = {type:\"\"};\r\n\t            }\r\n\t            var _style = this.model.get(\"style\");\r\n\t            if ( this.lineType ?  this.lineType : this.model.option.lineType) {\r\n\t                _style.lineType = this.lineType ?  this.lineType : this.model.option.lineType;\r\n\t            }\r\n\t            var _hoverStyle = this.model.get(\"hoverStyle\");\r\n\t            parmData.style = _style;\r\n\t            parmData.hoverStyle = _hoverStyle;\r\n\t            \r\n\t            var _isEdit = this.model.get(\"isEdit\");\r\n\t            parmData.isEdit = _isEdit;\r\n\t            this.con =  new Connector(parmData);  //\"arrow\"\r\n\t            this.add(this.con);\r\n\t\t};\r\n\t\r\n\t    NetWorkLineNode.prototype.refreshLine = function () {\r\n\t        var moddleY = this.model.get(\"moddleY\");\r\n\t        var moddleX = this.model.get(\"moddleX\");\r\n\t\r\n\t        var sRect = this.model.get(\"fromBounds\");\r\n\t        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n\t\r\n\t        var eRect = this.model.get(\"toBounds\");\r\n\t        var eBounds = [eRect.x, eRect.y, eRect.x + eRect.width, eRect.y + eRect.height];\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        var startPoint = null;\r\n\t        var endPoint = null;\r\n\t        if (sRect.y < eRect.y) {\r\n\t            startPoint = sConnectorPoint.bottom;\r\n\t            endPoint = eConnectorPoint.top;\r\n\t        } else {\r\n\t            startPoint = sConnectorPoint.top;\r\n\t            endPoint = eConnectorPoint.bottom;\r\n\t        }\r\n\t\r\n\t        var solutions = this.connector2Points(startPoint, endPoint, moddleX, \r\n\t                        moddleY, sBounds, eBounds);\r\n\t            //adjust connector\r\n\t        //  console.info(\"connector2Points() -> Solution: \" + solutions[0][2]);\r\n\t        // var points = Util.traslatePoints(solutions[0][2]);\r\n\t\r\n\t        //this.line.attr('shape', {points: points});\r\n\t        this.con.refresh(solutions[0][2]);\r\n\t    };\r\n\t\r\n\t    NetWorkLineNode.prototype.connector2Points = function(startPoint, endPoint, moddleX, middleY, sBounds, eBounds ){\r\n\t        var solutions = [];\r\n\t        //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n\t        var s = [startPoint];\r\n\t        if ( moddleX !== undefined && moddleX !== null ) {\r\n\t             s.push(new Point(startPoint.x - moddleX, startPoint.y));\r\n\t             s.push(new Point(startPoint.x - moddleX, middleY));\r\n\t             s.push(new Point(endPoint.x, middleY)); \r\n\t        } else {\r\n\t            s.push(new Point(startPoint.x, middleY));\r\n\t            s.push(new Point(endPoint.x, middleY)); \r\n\t        }\r\n\t        s.push(endPoint);        \r\n\t\r\n\t        //SO - no additional points     S0 解决方案 \r\n\t        var s0 = Point.cloneArray(s);\r\n\t        solutions.push(['s0', 's0', s0]);\r\n\t        return solutions;\r\n\t        \r\n\t    };\r\n\t\r\n\t\tUtil.inherits(NetWorkLineNode, Node);\r\n\t\r\n\t\tmodule.exports = NetWorkLineNode;\r\n\t\r\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连接线\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var Util = __webpack_require__(71);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Node = __webpack_require__(78);\r\n\t    var symbolUtil = __webpack_require__(90);\r\n\t    var Handle = __webpack_require__(91);\r\n\t    var EffectLine = __webpack_require__(92);\r\n\t    var ConnectionPoint = __webpack_require__(93);\r\n\t    var Point = __webpack_require__(72);\r\n\t    /**\r\n\t     * 构造函数\r\n\t     * @param {[type]} options [description]\r\n\t     */\r\n\t    function Connector(options) {\r\n\t        Node.call(this);\r\n\t        if(options.model&&options.model.option&&options.model.option.resourceId){\r\n\t            this.resourceId = options.model.option.resourceId;\r\n\t        }else{\r\n\t            this.resourceId = Util.getUUID();// 生成节点ID\r\n\t        }\r\n\t        var defaultOptions = {\r\n\t            symbol: {type:\"arrow\" , size: 10, color:\"#000000\"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n\t            style: {lineWidth:1, stroke:\"#000000\", lineType:Connector.TYPE_STRAIGHT},    //样式\r\n\t            hoverStyle: {lineWidth:2, stroke:\"lime\"}, //移上去的样式\r\n\t            arrowHoverStyle: {fill:\"lime\"},\r\n\t            shape: {points:null, smooth:false, smoothConstraint:null},//形状\r\n\t            position: [0,0],\r\n\t            isEdit: true,  //是否可编辑\r\n\t            text: {\r\n\t                text: \"\",\r\n\t                color: '#000000', // 文本颜色\r\n\t                textFont: '12px Microsoft YaHei'\r\n\t            },\r\n\t            z: 0\r\n\t        }\r\n\t        var opt = options || {};\r\n\t        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n\t        this.model = options.model;\r\n\t        this.handles = [];\r\n\t        this.connectionPoints = [];\r\n\t        this.conPointsGroup = null;\r\n\t        this.startNode = null;\r\n\t        this.endNode = null;\r\n\t        this.autoChangePosition = false\r\n\t        this.line = null;\r\n\t        this.groupCurve = new graphic.Group();\r\n\t        this.icons = [];  // 用于存储线段上面的操作图标\r\n\t        this.render();\r\n\t    }\r\n\t\r\n\t    Connector.TYPE_STRAIGHT = 'straight';\r\n\t\r\n\t    Connector.TYPE_JAGGED = 'jagged';\r\n\t\r\n\t    Connector.TYPE_CURVE = 'curve';\r\n\t\r\n\t    Connector.RADIUS = 3;\r\n\t\r\n\t    Connector.START_NODE = \"startNode\";\r\n\t\r\n\t    Connector.END_NODE = \"endNode\";\r\n\t\r\n\t    Connector.LEFT = \"left\";\r\n\t\r\n\t    Connector.RIGHT = \"right\";\r\n\t\r\n\t    Connector.TOP = \"top\";\r\n\t\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t\r\n\t    Connector.BOTTOM = \"bottom\";\r\n\t\r\n\t    Connector.SEPERATOR = \"-\";\r\n\t    /**\r\n\t     * 重新画线，如果传空则根据turningPoints 重新画线\r\n\t     * @param  {[type]} points [description]\r\n\t     * @return {[type]}        [description]\r\n\t     */\r\n\t    Connector.prototype.refresh = function(points) {\r\n\t        if(points) {\r\n\t            this.turningPoints = points;\r\n\t        }\r\n\t        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n\t        var points = Util.traslatePoints(this.turningPoints);\r\n\t\r\n\t        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n\t            this.modifyCurve(this.turningPoints);\r\n\t        } else {\r\n\t            this.line.attr('shape', {points: points});\r\n\t        }\r\n\t\r\n\t        var lineText = this.childOfName('lineText');\r\n\t        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t        if (!lineText  && this.options.text.text) {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n\t            this.add(text.text);\r\n\t            lineText = this.childOfName('lineText');\r\n\t        }\r\n\t        if (lineText) {\r\n\t            lineText.setStyle(\"text\", this.options.text.text);\r\n\t\r\n\t            var textPoint = this.getTextPostion(this.options.text);\r\n\t\r\n\t            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n\t            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n\t            // }\r\n\t\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t        }\r\n\t        var symbolTo = this.childOfName('toSymbol');\r\n\t        if(symbolTo) {\r\n\t            if(this.options.effect&&this.options.effect.show){\r\n\t                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);\r\n\t            }else{\r\n\t                symbolTo.attr('position', points[points.length -1]);\r\n\t                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));\r\n\t            }\r\n\t        }\r\n\t   };\r\n\t    /**\r\n\t     * 渲染\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.render = function() {\r\n\t        var that = this;\r\n\t        //1.创建箭头\r\n\t        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n\t        if (symbolTo) {\r\n\t            this.add(symbolTo);\r\n\t        }\r\n\t\r\n\t        //2.创建线\r\n\t        this.curveLine = new graphic.BezierCurve({\r\n\t            position: this.options.position,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.groupCurve.add(this.curveLine);\r\n\t        this.add(this.groupCurve);\r\n\t\r\n\t        this.polyLine = new graphic.Polyline({\r\n\t            position: this.options.position,\r\n\t            shape: this.options.shape,\r\n\t            style: this.options.style,\r\n\t            z: this.options.z\r\n\t        });\r\n\t        this.add(this.polyLine);\r\n\t\r\n\t        if((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n\t            this.line = this.groupCurve;\r\n\t            this.createHoverStyle(this.curveLine);\r\n\t            this.polyLine.hide();\r\n\t        }\r\n\t        else {\r\n\t            this.line = this.polyLine;\r\n\t            this.createHoverStyle(this.polyLine);\r\n\t            this.curveLine.hide();\r\n\t        }\r\n\t\r\n\t        //3.侦听线事件\r\n\t        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n\t        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            this.line.on(eveName, zrUtil.bind(function (e) {\r\n\t                e.cancelBubble = true;\r\n\t                var params = {};\r\n\t                params.event = e;\r\n\t                params.type = \"Connector:\" + eveName;\r\n\t                params.target = that;\r\n\t                this.trigger(params.type, params);\r\n\t                if(this.options.isEdit == false){return;}\r\n\t\r\n\t                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {\r\n\t                    this.createAllconnectionPoint()\r\n\t                }\r\n\t                if(this.handles.length < 1 ) {\r\n\t                    this.shapeSetHandle();\r\n\t                }\r\n\t            }, this));\r\n\t        }, this);\r\n\t\r\n\t        //3.创建调整线的连接点\r\n\t        if(this.options.isEdit) {\r\n\t            this.conPointsGroup = new graphic.Group();\r\n\t            this.add(this.conPointsGroup);\r\n\t        }\r\n\t\r\n\t        //4.创建线上文本\r\n\t        if (this.options.text.text && this.options.text.text != \"\") {\r\n\t            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n\t            this.add(text.text);\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    //设置style\r\n\t    Connector.prototype.setStyle = function(options) {\r\n\t        if(options.color){\r\n\t            if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n\t                this.groupCurve.eachChild(function(curve) {\r\n\t                    curve.attr(\"style\",{stroke:options.color});\r\n\t                    graphic.setNormalStyle(curve, {stroke:options.color});\r\n\t                });\r\n\t            }else{\r\n\t                this.polyLine.attr(\"style\",{stroke:options.color});\r\n\t                graphic.setNormalStyle(this.polyLine, {stroke:options.color});\r\n\t            }\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                symbolTo.attr(\"style\",{fill:options.color});\r\n\t                graphic.setNormalStyle(symbolTo, {fill:options.color});\r\n\t            }\r\n\t            this.options.style.stroke = options.color;\r\n\t            this.model.set(\"options.style.stroke\", options.color);\r\n\t            this.model.set(\"options.symbol.color\", options.color);\r\n\t            this.options.symbol.color = options.color;\r\n\t        }\r\n\t\r\n\t        if(options.text){\r\n\t             var lineText = this.childOfName('lineText');\r\n\t            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n\t            if (!lineText  && options.text.text) {\r\n\t                var text = this.drawText(\"lineText\", options.text.text,0, 0);\r\n\t                this.add(text.text);\r\n\t                lineText = this.childOfName('lineText');\r\n\t            }\r\n\t\r\n\t            if(options.text.text || options.text.text == \"\"){\r\n\t                lineText.setStyle(\"text\", options.text.text);\r\n\t                this.options.text.text = options.text.text;\r\n\t            }\r\n\t            var textPoint = this.getTextPostion(options.text);\r\n\t            lineText.attr(\"position\", textPoint);\r\n\t            if(options.text.textPos){\r\n\t                this.options.text.textPos = options.text.textPos;\r\n\t            }else{\r\n\t                this.options.text.textPos = 'center';\r\n\t            }\r\n\t            if(options.text.color){\r\n\t                lineText.attr(\"style\",{\r\n\t                    fill: options.text.color\r\n\t                });\r\n\t                this.options.text.color = options.text.color;\r\n\t            }\r\n\t            this.model.set(\"options.text\", options.text);\r\n\t        }\r\n\t\r\n\t        if(options.symbol){\r\n\t            if(options.symbol.type){\r\n\t                this.options.symbol.type = options.symbol.type;\r\n\t                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n\t            }\r\n\t            if(options.symbol.size){\r\n\t                this.options.symbol.size = options.symbol.size;\r\n\t                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n\t            }\r\n\t            if(options.symbol.color){\r\n\t                this.options.symbol.color = options.symbol.color;\r\n\t                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n\t            }\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if (symbolTo) {\r\n\t                this.remove(symbolTo);\r\n\t            }\r\n\t            var symbol = this.createSymbol(\"toSymbol\",this.model.get(\"options\"))\r\n\t            if (symbol) {\r\n\t                this.add(symbol);\r\n\t            }\r\n\t            this.refresh();\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的位置\r\n\t     * @param  {Object} text {text:'', color:'', textPos:''}\r\n\t     * @return {Object}      {x,y}\r\n\t     */\r\n\t    Connector.prototype.getTextPostion = function(text) {\r\n\t        var textPostion = [];\r\n\t        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t        if(text&&text.textPos){\r\n\t            if(text.textPos == 'start'){\r\n\t                var xOffset = text.xOffset || 0;\r\n\t                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];\r\n\t            }else if(text.textPos == 'end'){\r\n\t                var points  = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length-2],this.turningPoints[this.turningPoints.length-1]]);\r\n\t                var angle = Util.getAngle(points[0],points[1]);\r\n\t                var length =  Util.distance(points[0],points[1]) - textWidth;\r\n\t                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t                textPostion = [newPoint.x,newPoint.y];\r\n\t            }else{\r\n\t                textPostion = this.middle(text);\r\n\t            }\r\n\t        }else{\r\n\t            var position = this.middle(text);\r\n\t            textPostion = [position[0]-textWidth/2,position[1]];\r\n\t        }\r\n\t\r\n\t        return textPostion;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的旋转角度\r\n\t     * @param  {Object} textPostion {x,y}\r\n\t     * @return {Number}             角度值\r\n\t     */\r\n\t    Connector.prototype.getTextRotation = function(textPostion) {\r\n\t        //计算出极坐标的角度\r\n\t        var points  = Util.getMaxLineLength(this.turningPoints);\r\n\t        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2\r\n\t        return angle;\r\n\t    };\r\n\t\r\n\t    Connector.prototype.createHoverStyle = function(el) {\r\n\t        if (this.options.hoverStyle) {\r\n\t            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\t\r\n\t            var symbolTo = this.childOfName('toSymbol');\r\n\t            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}\r\n\t\r\n\t            el.on('mouseover', zrUtil.bind(function() {\r\n\t                graphic.doEnterHover(el);\r\n\t                if(symbolTo){graphic.doEnterHover(symbolTo);}\r\n\t\r\n\t                this.groupCurve.eachChild(function(line) {\r\n\t                    graphic.doEnterHover(line);\r\n\t                });\r\n\t            },this))\r\n\t              .on('mouseout', zrUtil.bind(function() {\r\n\t                graphic.doLeaveHover(el);\r\n\t                if(symbolTo){graphic.doLeaveHover(symbolTo);}\r\n\t                this.groupCurve.eachChild(function(line) {\r\n\t                    graphic.doLeaveHover(line);\r\n\t                });\r\n\t            },this));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * 创建Node的连接点\r\n\t     * @private\r\n\t     *\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.createAllconnectionPoint = function() {\r\n\t        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\t\r\n\t        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\t\r\n\t        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n\t        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\t\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n\t        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\t\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t\r\n\t        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建连接点\r\n\t     * @private\r\n\t     * @param  {[type]} shape [description]\r\n\t     * @param  {[type]} point [description]\r\n\t     * @param  {[type]} type  [description]\r\n\t     * @return {[type]}       [description]\r\n\t     */\r\n\t    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n\t        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n\t        this.conPointsGroup.add(conPoint.shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.clearHandles = function() {\r\n\t        for (var i = 0; i < this.handles.length; i++) {\r\n\t            this.remove(this.handles[i].handleShape);\r\n\t        }\r\n\t        this.handles = [];\r\n\t        if (this.conPointsGroup) {\r\n\t            this.conPointsGroup.removeAll();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 创建拆线 线断的控制点\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.shapeSetHandle = function() {\r\n\t        for(var i=1; i<this.turningPoints.length-2; i++){\r\n\t            var h;\r\n\t            var x, y;\r\n\t            //是否在一条线上\r\n\t            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);\r\n\t            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);\r\n\t            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))\r\n\t                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {\r\n\t\r\n\t                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical\r\n\t                    x = this.turningPoints[i].x;\r\n\t                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;\r\n\t\r\n\t                    h = new Handle('h',x,y,this);\r\n\t\r\n\t\r\n\t                }\r\n\t                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal\r\n\t                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;\r\n\t                    y = this.turningPoints[i].y;\r\n\t                    h =  new  Handle('v',x,y,this);\r\n\t                }\r\n\t                if (h) {\r\n\t                    this.add(h.handleShape);\r\n\t                    this.handles.push(h);\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 创建箭头\r\n\t     * @param  {[type]} name       [description]\r\n\t     * @param  {[type]} options [description]\r\n\t     * @return {[type]}            [description]\r\n\t     */\r\n\t    Connector.prototype.createSymbol = function(name, options) {\r\n\t        var symbolType = options.symbol.type;\r\n\t        var symbolSize =this.options.symbol.size;\r\n\t        if (symbolType === 'none') {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        if (!zrUtil.isArray(symbolSize)) {\r\n\t            symbolSize = [symbolSize, symbolSize];\r\n\t        }\r\n\t        var symbolPath = symbolUtil.createSymbol(\r\n\t            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n\t            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z\r\n\t        );\r\n\t        symbolPath.name = name;\r\n\t\r\n\t        return symbolPath;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 绘制线段上的文本\r\n\t     * @param  {[type]} content [description]\r\n\t     * @param  {[type]} name [description]\r\n\t     * @param  {[type]} x       [description]\r\n\t     * @param  {[type]} y       [description]\r\n\t     * @param  {[type]} color   [description]\r\n\t     * @return {[type]}         [description]\r\n\t     */\r\n\t    Connector.prototype.drawText = function (name,content, x, y, color) {\r\n\t        var text = new graphic.Text({\r\n\t            style: {\r\n\t                text: content,\r\n\t                x: x,\r\n\t                y: y,\r\n\t                fill: color ? color : this.options.text.color,\r\n\t                textFont: this.options.text.textFont\r\n\t            },\r\n\t            zlevel: 20\r\n\t        });\r\n\t        text.name = name;\r\n\t        return {\r\n\t            text: text,\r\n\t            rect: text.getBoundingRect()\r\n\t        };\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取线段的中间值\r\n\t     * @return {[type]} text\r\n\t     */\r\n\t    Connector.prototype.middle = function(text){\r\n\t\r\n\t        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){\r\n\t            var points  = Util.getMaxLineLength(this.turningPoints);\r\n\t            //如果是求线段上的文字的中间值\r\n\t            // if(text) {\r\n\t            //     //取出字的长度，计算角度，\r\n\t            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n\t            //     var angle = Util.getAngle(points[0],points[1]);\r\n\t            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n\t            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n\t            //     return [newPoint.x, newPoint.y];\r\n\t            // } else {\r\n\t            //     var middleX = (points[0].x + points[1].x)/2;\r\n\t            //     var middleY = (points[0].y + points[1].y) /2;\r\n\t            //     return [middleX, middleY];\r\n\t            // }\r\n\t            var middleX = (points[0].x + points[1].x)/2;\r\n\t            var middleY = (points[0].y + points[1].y) /2;\r\n\t            return [middleX, middleY];\r\n\t        }\r\n\t        else if(this.options.style.lineType == Connector.TYPE_JAGGED){\r\n\t\r\n\t            //find total distance\r\n\t            var distance = this.getLength();\r\n\t\r\n\t            //find between what turning points the half distance is\r\n\t            var index = -1;\r\n\t            var ellapsedDistance = 0;\r\n\t            for(var i=0; i<this.turningPoints.length-1; i++){\r\n\t                index = i;\r\n\t                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n\t                if(ellapsedDistance + segment < distance /2){\r\n\t                    ellapsedDistance += segment;\r\n\t                }\r\n\t                else{\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t\r\n\t            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n\t            if(index != -1){\r\n\t                var missingDistance = distance / 2 - ellapsedDistance;\r\n\t                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)\r\n\t                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n\t                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)\r\n\t                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n\t                } else{\r\n\t                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1]\r\n\t                        + \" nr of points \" + this.turningPoints.length\r\n\t                        );\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t        else if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n\t            var t = 0.5;\r\n\t            var l = this.getLength();\r\n\t\r\n\t            var walked = 0;\r\n\t            for(var j =0; j< this.turningPoints.length-1; j++){\r\n\t                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){\r\n\t                    break;\r\n\t                }\r\n\t\r\n\t                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\t            }\r\n\t\r\n\t            var rest = l * t - walked;\r\n\t            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\t\r\n\t            //find the position/ration of the middle of Polyline on current segment\r\n\t            var segmentPercent = rest / currentSegmentLength;\r\n\t\r\n\t            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n\t            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\t\r\n\t            return [Xp, Yp];\r\n\t\r\n\t        }\r\n\t\r\n\t        return null;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * find total distance\r\n\t     * @return {Number} [description]\r\n\t     */\r\n\t    Connector.prototype.getLength = function() {\r\n\t            //find total distance\r\n\t        var distance = 0;\r\n\t        for(var i=0; i<this.turningPoints.length-1; i++){\r\n\t            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n\t        }\r\n\t        return distance;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 转JSON对象\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.toJSON = function() {\r\n\t\r\n\t        this.model.set(\"resourceId\", this.resourceId);\r\n\t        this.model.set(\"properties.type\", 14);\r\n\t\r\n\t        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n\t        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n\t        this.model.set(\"style.sPos\", this.sPos);\r\n\t        this.model.set(\"style.ePos\", this.ePos);\r\n\t        this.model.set(\"dockers\",this.turningPoints);\r\n\t        return this.model.option;\r\n\t    };\r\n\t\r\n\t     /**\r\n\t     * refreshModel\r\n\t     * @return {[type]} [description]\r\n\t     */\r\n\t    Connector.prototype.refreshModel = function() {\r\n\t        this.model.set(\"options.dockers\",this.turningPoints);\r\n\t        var icons = [];\r\n\t        for(var i = 0;i < this.icons.length;i++){\r\n\t            var iconNode = this.icons[i];\r\n\t            var option = [iconNode.key,{\r\n\t                icon:iconNode.style.image,\r\n\t                width: iconNode.style.width,\r\n\t                height: iconNode.style.height\r\n\t            }];\r\n\t            icons.push(option);\r\n\t        }\r\n\t        this.model.set(\"icons\",icons);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整曲线的形状\r\n\t     * @param  {array} points 点数组\r\n\t     * @return {void}\r\n\t     */\r\n\t    Connector.prototype.modifyCurve = function(points) {\r\n\t        var sol = this.getCurvePoint(points);\r\n\t\r\n\t        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n\t        var willDelCurves = [];\r\n\t        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {\r\n\t            willDelCurves.push(this.groupCurve.childAt(j));\r\n\t        }\r\n\t        zrUtil.each(willDelCurves, function(curve) {\r\n\t            this.groupCurve.remove(curve);\r\n\t        }, this);\r\n\t        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n\t        for (var i = 0; i < sol.length; i++) {\r\n\t            var line = this.groupCurve.childAt(i);\r\n\t            if (line) {\r\n\t                line.attr('shape', sol[i]);\r\n\t            } else {\r\n\t                var cure = new graphic.BezierCurve({\r\n\t                    position: this.options.position,\r\n\t                    style: this.options.style,\r\n\t                    shape: sol[i],\r\n\t                    z: this.options.z\r\n\t                });\r\n\t                this.groupCurve.add(cure);\r\n\t                this.createHoverStyle(cure);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 根据传入的点数组计算曲线的点\r\n\t     * @param  {array} P 点数组\r\n\t     * @return {object}        曲线的点数组\r\n\t     */\r\n\t    Connector.prototype.getCurvePoint = function(P) {\r\n\t        var n = P.length;\r\n\t        var sol = [];\r\n\t        if (n === 3) {\r\n\t            sol.push({x1: P[0].x,\r\n\t                   y1: P[0].y,\r\n\t                   cpx1: P[1].x,\r\n\t                   cpy1: P[1].y,\r\n\t                   x2: P[2].x,\r\n\t                   y2: P[2].y\r\n\t                });\r\n\t            return sol;\r\n\t        }\r\n\t        else if (n === 4) {\r\n\t            sol.push({x1: P[0].x,\r\n\t                   y1: P[0].y,\r\n\t                   cpx1: P[1].x,\r\n\t                   cpy1: P[1].y,\r\n\t                   cpx2: P[2].x,\r\n\t                   cpy2: P[2].y,\r\n\t                   x2: P[3].x,\r\n\t                   y2: P[3].y\r\n\t                });\r\n\t            return sol;\r\n\t        }\r\n\t\r\n\t        /**Computes factorial\r\n\t         * @param {Number} k the number\r\n\t         * */\r\n\t        function fact(k){\r\n\t            if(k===0 || k===1){\r\n\t                return 1;\r\n\t            }\r\n\t            else{\r\n\t                return k * fact(k-1);\r\n\t            }\r\n\t        }\r\n\t\r\n\t        /**Computes Bernstain*/\r\n\t        function B(i,n,u){\r\n\t            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);\r\n\t        }\r\n\t\r\n\t        /**Computes the sum between two point\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function sum(p1, p2){\r\n\t            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n\t        }\r\n\t\r\n\t        /**Computes the difference between first {Point} and second {Point}\r\n\t         *@param p1 - {Point}\r\n\t         *@param p2 - {Point}\r\n\t         *@return {Point} the sum of initial points\r\n\t         **/\r\n\t        function minus(p1, p2){\r\n\t            return new Point(p1.x - p2.x, p1.y - p2.y);\r\n\t        }\r\n\t\r\n\t        /**Computes the division of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function divide(p, nr){\r\n\t            if(nr == 0){\r\n\t                throw \"Division by zero not allowed (yet :) \" + this.callee ;\r\n\t            }\r\n\t            return new Point(p.x/nr, p.y/nr);\r\n\t        }\r\n\t\r\n\t        /**Computes the multiplication of a {Point} by a number\r\n\t         *@param p - {Point}\r\n\t         *@param nr - {Number}\r\n\t         *@return {Point}\r\n\t         **/\r\n\t        function multiply(p, nr){\r\n\t            return new Point (p.x * nr, p.y * nr);\r\n\t        }\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t        /*\r\n\t         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n\t         *but otherwise we will get division by zero\r\n\t         */\r\n\t        var k = [0,0,0];\r\n\t\r\n\t        var j;\r\n\t        for(j=0;j<=n-3;j++){\r\n\t            k.push(j);\r\n\t        }\r\n\t\r\n\t        k.push(n-3, n-3);\r\n\t\r\n\t\r\n\t\r\n\t        for(i=1; i<=n-3; i++){\r\n\t            //q1 - compute start point\r\n\t            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);\r\n\t\r\n\t            //q0 - compute 1st controll point\r\n\t            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);\r\n\t            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);\r\n\t            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );\r\n\t            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\t\r\n\t            //q2 - compute 2nd controll point\r\n\t            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );\r\n\t\r\n\t            //q3 - compute end point\r\n\t            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);\r\n\t            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);\r\n\t            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );\r\n\t            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\t\r\n\t            //store solution\r\n\t            //\r\n\t            sol.push({x1: q0.x,\r\n\t                   y1: q0.y,\r\n\t                   cpx1: q1.x,\r\n\t                   cpy1: q1.y,\r\n\t                   cpx2: q2.x,\r\n\t                   cpy2: q2.y,\r\n\t                   x2: q3.x,\r\n\t                   y2: q3.y\r\n\t                });\r\n\t        }\r\n\t\r\n\t        return sol;\r\n\t    };\r\n\t\r\n\t\r\n\t    Util.inherits(Connector,Node);\r\n\t\r\n\t    module.exports = Connector;\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 90 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\r\n\t\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var BoundingRect = __webpack_require__(24);\r\n\t    /**\r\n\t     * Triangle shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Triangle = graphic.extendShape({\r\n\t        type: 'triangle',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy + height);\r\n\t            path.lineTo(cx - width, cy + height);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t    /**\r\n\t     * Diamond shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Diamond = graphic.extendShape({\r\n\t        type: 'diamond',\r\n\t        shape: {\r\n\t            cx: 0,\r\n\t            cy: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t        buildPath: function (path, shape) {\r\n\t            var cx = shape.cx;\r\n\t            var cy = shape.cy;\r\n\t            var width = shape.width / 2;\r\n\t            var height = shape.height / 2;\r\n\t            path.moveTo(cx, cy - height);\r\n\t            path.lineTo(cx + width, cy);\r\n\t            path.lineTo(cx, cy + height);\r\n\t            path.lineTo(cx - width, cy);\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Pin shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Pin = graphic.extendShape({\r\n\t        type: 'pin',\r\n\t        shape: {\r\n\t            // x, y on the cusp\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (path, shape) {\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var w = shape.width / 5 * 3;\r\n\t            // Height must be larger than width\r\n\t            var h = Math.max(w, shape.height);\r\n\t            var r = w / 2;\r\n\t\r\n\t            // Dist on y with tangent point and circle center\r\n\t            var dy = r * r / (h - r);\r\n\t            var cy = y - h + r + dy;\r\n\t            var angle = Math.asin(dy / r);\r\n\t            // Dist on x with tangent point and circle center\r\n\t            var dx = Math.cos(angle) * r;\r\n\t\r\n\t            var tanX = Math.sin(angle);\r\n\t            var tanY = Math.cos(angle);\r\n\t\r\n\t            path.arc(\r\n\t                x, cy, r,\r\n\t                Math.PI - angle,\r\n\t                Math.PI * 2 + angle\r\n\t            );\r\n\t\r\n\t            var cpLen = r * 0.6;\r\n\t            var cpLen2 = r * 0.7;\r\n\t            path.bezierCurveTo(\r\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x, y - cpLen2,\r\n\t                x, y\r\n\t            );\r\n\t            path.bezierCurveTo(\r\n\t                x, y - cpLen2,\r\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n\t                x - dx, cy + dy\r\n\t            );\r\n\t            path.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Arrow shape\r\n\t     * @inner\r\n\t     */\r\n\t    var Arrow = graphic.extendShape({\r\n\t\r\n\t        type: 'arrow',\r\n\t\r\n\t        shape: {\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var height = shape.height;\r\n\t            var width = shape.width;\r\n\t            var x = shape.x;\r\n\t            var y = shape.y;\r\n\t            var dx = width / 3 * 2;\r\n\t            ctx.moveTo(x, y);\r\n\t            ctx.lineTo(x + dx, y + height);\r\n\t            ctx.lineTo(x, y + height / 4 * 3);\r\n\t            ctx.lineTo(x - dx, y + height);\r\n\t            ctx.lineTo(x, y);\r\n\t            ctx.closePath();\r\n\t        }\r\n\t    });\r\n\t\r\n\t    /**\r\n\t     * Map of path contructors\r\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\r\n\t     */\r\n\t    var symbolCtors = {\r\n\t        line: graphic.Line,\r\n\t\r\n\t        rect: graphic.Rect,\r\n\t\r\n\t        roundRect: graphic.Rect,\r\n\t\r\n\t        square: graphic.Rect,\r\n\t\r\n\t        circle: graphic.Circle,\r\n\t\r\n\t        diamond: Diamond,\r\n\t\r\n\t        pin: Pin,\r\n\t\r\n\t        arrow: Arrow,\r\n\t\r\n\t        triangle: Triangle\r\n\t    };\r\n\t\r\n\t    var symbolShapeMakers = {\r\n\t\r\n\t        line: function (x, y, w, h, shape) {\r\n\t            // FIXME\r\n\t            shape.x1 = x;\r\n\t            shape.y1 = y + h / 2;\r\n\t            shape.x2 = x + w;\r\n\t            shape.y2 = y + h / 2;\r\n\t        },\r\n\t\r\n\t        rect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        roundRect: function (x, y, w, h, shape) {\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t            shape.r = Math.min(w, h) / 4;\r\n\t        },\r\n\t\r\n\t        square: function (x, y, w, h, shape) {\r\n\t            var size = Math.min(w, h);\r\n\t            shape.x = x;\r\n\t            shape.y = y;\r\n\t            shape.width = size;\r\n\t            shape.height = size;\r\n\t        },\r\n\t\r\n\t        circle: function (x, y, w, h, shape) {\r\n\t            // Put circle in the center of square\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.r = Math.min(w, h) / 2;\r\n\t        },\r\n\t\r\n\t        diamond: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        pin: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        arrow: function (x, y, w, h, shape) {\r\n\t            shape.x = x + w / 2;\r\n\t            shape.y = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        },\r\n\t\r\n\t        triangle: function (x, y, w, h, shape) {\r\n\t            shape.cx = x + w / 2;\r\n\t            shape.cy = y + h / 2;\r\n\t            shape.width = w;\r\n\t            shape.height = h;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolBuildProxies = {};\r\n\t    for (var name in symbolCtors) {\r\n\t        symbolBuildProxies[name] = new symbolCtors[name]();\r\n\t    }\r\n\t\r\n\t    var Symbol = graphic.extendShape({\r\n\t\r\n\t        type: 'symbol',\r\n\t\r\n\t        shape: {\r\n\t            symbolType: '',\r\n\t            x: 0,\r\n\t            y: 0,\r\n\t            width: 0,\r\n\t            height: 0\r\n\t        },\r\n\t\r\n\t        beforeBrush: function () {\r\n\t            var style = this.style;\r\n\t            var shape = this.shape;\r\n\t            // FIXME\r\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n\t                style.textPosition = ['50%', '40%'];\r\n\t                style.textAlign = 'center';\r\n\t                style.textVerticalAlign = 'middle';\r\n\t            }\r\n\t        },\r\n\t\r\n\t        buildPath: function (ctx, shape) {\r\n\t            var symbolType = shape.symbolType;\r\n\t            var proxySymbol = symbolBuildProxies[symbolType];\r\n\t            if (shape.symbolType !== 'none') {\r\n\t                if (!proxySymbol) {\r\n\t                    // Default rect\r\n\t                    symbolType = 'rect';\r\n\t                    proxySymbol = symbolBuildProxies[symbolType];\r\n\t                }\r\n\t                symbolShapeMakers[symbolType](\r\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n\t                );\r\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t\r\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n\t    var symbolPathSetColor = function (color) {\r\n\t        if (this.type !== 'image') {\r\n\t            var symbolStyle = this.style;\r\n\t            var symbolShape = this.shape;\r\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\r\n\t                symbolStyle.stroke = color;\r\n\t            }\r\n\t            else if (this.__isEmptyBrush) {\r\n\t                symbolStyle.stroke = color;\r\n\t                symbolStyle.fill = '#fff';\r\n\t            }\r\n\t            else {\r\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n\t                symbolStyle.fill && (symbolStyle.fill = color);\r\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n\t            }\r\n\t            this.dirty();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var symbolUtil = {\r\n\t        /**\r\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n\t         * @param {string} symbolType\r\n\t         * @param {number} x\r\n\t         * @param {number} y\r\n\t         * @param {number} w\r\n\t         * @param {number} h\r\n\t         * @param {number} z\r\n\t         * @param {string} color\r\n\t         */\r\n\t        createSymbol: function (symbolType, x, y, w, h, color, z) {\r\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\r\n\t            if (isEmpty) {\r\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n\t            }\r\n\t            var symbolPath;\r\n\t\r\n\t            if (symbolType.indexOf('image://') === 0) {\r\n\t                symbolPath = new graphic.Image({\r\n\t                    style: {\r\n\t                        image: symbolType.slice(8),\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t            else if (symbolType.indexOf('path://') === 0) {\r\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));\r\n\t            }\r\n\t            else {\r\n\t                symbolPath = new Symbol({\r\n\t                    shape: {\r\n\t                        symbolType: symbolType,\r\n\t                        x: x,\r\n\t                        y: y,\r\n\t                        width: w,\r\n\t                        height: h\r\n\t                    },\r\n\t                    z: z\r\n\t                });\r\n\t            }\r\n\t\r\n\t            symbolPath.__isEmptyBrush = isEmpty;\r\n\t\r\n\t            symbolPath.setColor = symbolPathSetColor;\r\n\t\r\n\t            symbolPath.setColor(color);\r\n\t\r\n\t            return symbolPath;\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = symbolUtil;\r\n\t\r\n\n\n/***/ },\n/* 91 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 画句柄\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Util = __webpack_require__(71);\r\n\t    function Handle(type, x, y, connector){\r\n\t        this.type = type;\r\n\t\r\n\t        this.x = x;\r\n\t\r\n\t        this.y = y;\r\n\t\r\n\t        this.visible = true;\r\n\t\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.handleShape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: x,\r\n\t                cy: y,\r\n\t                r: Handle.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: \"rgb(0,255,0)\",\r\n\t                stroke:\"rgb(0,0,0)\"\r\n\t            },\r\n\t            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n\t            draggable:true\r\n\t        });\r\n\t\r\n\t        var that = this;\r\n\t        this.handleShape.on(\"drag\", function(e) {\r\n\t            that.actionConnector(e.offsetX,e.offsetY);\r\n\t        });\r\n\t       // return this.circle;\r\n\t    }\r\n\t\r\n\t    Handle.RADIUS = 4;\r\n\t\r\n\t    Handle.prototype = {\r\n\t\r\n\t        constructor : Handle,\r\n\t\r\n\t        equals : function(anotherHandle){\r\n\t            if(!anotherHandle instanceof Handle){\r\n\t                return false;\r\n\t            }\r\n\t\r\n\t            return this.type == anotherHandle.type\r\n\t            && this.x == anotherHandle.x\r\n\t            && this.y == anotherHandle.y\r\n\t            && this.visible == anotherHandle.visible;\r\n\t        },\r\n\t\r\n\t        /**\r\n\t         * 移动句柄\r\n\t         * @param  {[type]} newX [description]\r\n\t         * @param  {[type]} newY [description]\r\n\t         * @return {[type]}      [description]\r\n\t         */\r\n\t        actionConnector: function(newX, newY){\r\n\t            switch(this.type){\r\n\t                case 'v':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n\t                            && this.connector.turningPoints[i].y == this.y\r\n\t                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n\t                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n\t                        {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaY = newY - this.y;\r\n\t                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\t\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.y = newY;  //将句柄新的位置赋值给y\r\n\t\r\n\t                    break;\r\n\t\r\n\t                case 'h':\r\n\t                    var index;\r\n\t                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n\t                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n\t                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n\t                            && this.connector.turningPoints[i].x == this.x\r\n\t                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n\t                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n\t                            {\r\n\t                            index = i;\r\n\t                        }\r\n\t                    }\r\n\t                    var deltaX = newX-this.x;\r\n\t                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n\t                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n\t                    this.connector.turningPoints[index].transform(translationMatrix);\r\n\t                    this.connector.refresh();\r\n\t                    this.x = newX; //将句柄新的位置赋值给x\r\n\t\r\n\t                    break;\r\n\t            }\r\n\t           //. this.shape.updateMiddleText();\r\n\t        }\r\n\t    };\r\n\t    module.exports = Handle;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 连线动态效果\r\n\t * @author miao.cunzhi\r\n\t */\r\n\t\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var vec2 = __webpack_require__(14);\r\n\t    var curveUtil = __webpack_require__(26);\r\n\t    var symbolUtil = __webpack_require__(90);\r\n\t\r\n\t    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n\t        this._lastFrame = 0;\r\n\t        this._lastFramePercent = 0;\r\n\t        this.symbol = symbol;\r\n\t        this.groupCurve = groupCurve;\r\n\t        this.initSymbol(options, polyLine);\r\n\t    }\r\n\t    var EffectLineProto = EffectLine.prototype;\r\n\t\r\n\t    EffectLineProto.initSymbol = function(options, polyLine) {\r\n\t        var that = this;\r\n\t        this.symbol.z2 = 100;\r\n\t        this.symbol.culling = true;\r\n\t        var period = options.effect.period * 1000;\r\n\t        this.symbol.__t = 0;\r\n\t        this.symbol.stopAnimation();\r\n\t        if ((options.style.lineType == \"curve\")) {\r\n\t            if (this.groupCurve) {\r\n\t                var i = 0;\r\n\t                period = period / this.groupCurve._children.length;\r\n\t                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n\t            }\r\n\t\r\n\t        } else {\r\n\t            this.symbol.animate('', true)\r\n\t                .when(period, {\r\n\t                    __t: 1\r\n\t                })\r\n\t                .delay(0)\r\n\t                .during(function() {\r\n\t                    that.updateSymbolPositionPolyline();\r\n\t                })\r\n\t                .start();\r\n\t            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n\t        var that = this;\r\n\t        if (curveLine == undefined) {\r\n\t            curveLine = this.groupCurve._children[0];\r\n\t            i = 0;\r\n\t        }\r\n\t        var points;\r\n\t        var pos = curveLine.shape;\r\n\t        points = [\r\n\t            [pos.x1, pos.y1],\r\n\t            [pos.x2, pos.y2],\r\n\t            [pos.cpx1, pos.cpy1],\r\n\t            [pos.cpx2, pos.cpy2]\r\n\t        ];\r\n\t        this.setAnimationPointsBezierCurve(points);\r\n\t        this.symbol.animate('')\r\n\t            .when(period, {\r\n\t                __t: 1\r\n\t            })\r\n\t            .delay(0)\r\n\t            .during(function() {\r\n\t                that.updateSymbolPositionBezierCurve();\r\n\t            })\r\n\t            .done(function() {\r\n\t                that.symbol.__t = 0;\r\n\t                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n\t            })\r\n\t            .start();\r\n\t\r\n\t    };\r\n\t\r\n\t\r\n\t    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n\t        this.symbol.__p1 = points[0];\r\n\t        this.symbol.__p2 = points[1];\r\n\t        this.symbol.__cp1 = points[2] || [\r\n\t            (points[0][0] + points[1][0]) / 2,\r\n\t            (points[0][1] + points[1][1]) / 2\r\n\t        ];\r\n\t        this.symbol.__cp2 = points[3];\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n\t        var p1 = this.symbol.__p1;\r\n\t        var p2 = this.symbol.__p2;\r\n\t        var cp1 = this.symbol.__cp1;\r\n\t        var cp2 = this.symbol.__cp2;\r\n\t        var t = this.symbol.__t;\r\n\t        var pos = this.symbol.position;\r\n\t        var tx, ty;\r\n\t        if (cp2[0] != undefined) {\r\n\t            var cubicAt = curveUtil.cubicAt;\r\n\t            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n\t            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n\t            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n\t        } else {\r\n\t            var quadraticAt = curveUtil.quadraticAt;\r\n\t            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n\t            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n\t            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n\t            // Tangent\r\n\t            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n\t            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n\t        }\r\n\t        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\t\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n\t        this._points = points;\r\n\t        var accLenArr = [0];\r\n\t        var len = 0;\r\n\t        for (var i = 1; i < points.length; i++) {\r\n\t            var p1 = points[i - 1];\r\n\t            var p2 = points[i];\r\n\t            len += vec2.dist(p1, p2);\r\n\t            accLenArr.push(len);\r\n\t        }\r\n\t        if (len === 0) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        for (var j = 0; j < accLenArr.length; j++) {\r\n\t            accLenArr[j] /= len;\r\n\t        }\r\n\t        this._offsets = accLenArr;\r\n\t        this._length = len;\r\n\t        this.symbol._lastFrame = 0;\r\n\t        this.symbol.__lastFramePercent = 0;\r\n\t    };\r\n\t\r\n\t    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n\t        var t = this.symbol.__t;\r\n\t        var points = this._points;\r\n\t        var offsets = this._offsets;\r\n\t        var len = points.length;\r\n\t\r\n\t        if (!offsets) {\r\n\t            // Has length 0\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var lastFrame = this._lastFrame;\r\n\t        var frame;\r\n\t\r\n\t        if (t < this._lastFramePercent) {\r\n\t            // Start from the next frame\r\n\t            // PENDING start from lastFrame ?\r\n\t            var start = Math.min(lastFrame + 1, len - 1);\r\n\t            for (frame = start; frame >= 0; frame--) {\r\n\t                if (offsets[frame] <= t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            // PENDING really need to do this ?\r\n\t            frame = Math.min(frame, len - 2);\r\n\t        } else {\r\n\t            for (var frame = lastFrame; frame < len; frame++) {\r\n\t                if (offsets[frame] > t) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            frame = Math.min(frame - 1, len - 2);\r\n\t        }\r\n\t        vec2.lerp(\r\n\t            this.symbol.position, points[frame], points[frame + 1],\r\n\t            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n\t        );\r\n\t\r\n\t        this._lastFrame = frame;\r\n\t        this._lastFramePercent = t;\r\n\t        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n\t        this.symbol.rotation = angle - Math.PI / 2;\r\n\t        this.symbol.ignore = false;\r\n\t    };\r\n\t    module.exports = EffectLine;\r\n\t\r\n\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 控制点\r\n\t * @author wang.xiaohu\r\n\t */\r\n\t\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var Util = __webpack_require__(71);\r\n\t    function ConnectionPoint(connector, point, type, options){\r\n\t        this.connector = connector;\r\n\t\r\n\t        this.point = point.clone();\r\n\t\r\n\t        this.type = type;\r\n\t\r\n\t        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\t\r\n\t        this.oType = 'ConnectionPoint';\r\n\t\r\n\t        this.shape = new graphic.Circle({\r\n\t            shape: {\r\n\t                cx: this.point.x,\r\n\t                cy: this.point.y,\r\n\t                r: ConnectionPoint.RADIUS\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: this.color,\r\n\t                stroke:'#000000'\r\n\t            },\r\n\t            z : options.z + 2  //节点Z为1 线段为0;\r\n\t        });\r\n\t        this.shape.type =  this.type;\r\n\t\r\n\t        this.shape.connector = connector;\r\n\t        //return this.circle;\r\n\t    }\r\n\t\r\n\t    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\t\r\n\t    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\t\r\n\t    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\t\r\n\t    ConnectionPoint.RADIUS = 4;\r\n\t\r\n\t    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\t\r\n\t    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\t\r\n\t    ConnectionPoint.prototype = {\r\n\t\r\n\t        constructor : ConnectionPoint,\r\n\t\r\n\t        equals : function(anotherConnectionPoint){\r\n\t            return this.point.equals(anotherConnectionPoint.point)\r\n\t            && this.connector == anotherConnectionPoint.connector\r\n\t            && this.type == anotherConnectionPoint.type\r\n\t            && this.color == anotherConnectionPoint.color\r\n\t            && this.radius == anotherConnectionPoint.radius;\r\n\t        }\r\n\t\r\n\t\r\n\t    };\r\n\t    module.exports = ConnectionPoint;\r\n\t\r\n\t\r\n\t\r\n\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Network model\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t\r\n\t    var NetWorkLineModel = Model.extend({\r\n\t        /**\r\n\t         * @type {Object}\r\n\t         * @protected\r\n\t         */\r\n\t        defaultOption: {\r\n\t            fromBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]\r\n\t            toBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]\r\n\t            moddleX: 0,  // 中间线的Y坐标\r\n\t            moddleY: 0,  // 中间线的Y坐标\r\n\t            style: {\r\n\t                lineWidth:1,  // 线宽度\r\n\t                stroke: \"#FFFFFF\",  //线颜色\r\n\t            },\r\n\t            hoverStyle: {\r\n\t                lineWidth:1,  // 线宽度\r\n\t                stroke: \"#FFFFFF\",  //线颜色\r\n\t            },\r\n\t            isVector: false\r\n\t        },\r\n\t\r\n\t        init: function (option, parentModel, extraOpt) {\r\n\t            zrUtil.merge(option, this.getDefaultOption());\r\n\t        },\r\n\t\r\n\t        getDefaultOption: function () {\r\n\t            if (!this.hasOwnProperty('__defaultOption')) {\r\n\t                var optList = [];\r\n\t                var Class = this.constructor;\r\n\t                while (Class) {\r\n\t                    var opt = Class.prototype.defaultOption;\r\n\t                    opt && optList.push(opt);\r\n\t                    Class = Class.superClass;\r\n\t                }\r\n\t\r\n\t                var defaultOption = {};\r\n\t                for (var i = optList.length - 1; i >= 0; i--) {\r\n\t                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n\t                }\r\n\t                this.__defaultOption = defaultOption;\r\n\t            }\r\n\t            return this.__defaultOption;\r\n\t        }\r\n\t\r\n\t    });\r\n\t    module.exports = NetWorkLineModel;\r\n\t\r\n\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function ServerTopoNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerTopoNode\" };    \r\n\t        this.model = model;\r\n\t        this.portNodeList = [];\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerTopoNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _width = model.get(\"width\");\r\n\t        var _height = 20;\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: _height,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var status = model.get(\"status\");\r\n\t        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n\t        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n\t        //      imageUrl += status;\r\n\t        // }\r\n\t        imageUrl += '.png';\r\n\t        var cellStateNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 10,\r\n\t                cy: 10,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826',\r\n\t                opacity: 1,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            } ,\r\n\t            z: 1000\r\n\t        });\r\n\t        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n\t            cellStateNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(cellStateNode);\r\n\t        \r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: _width,\r\n\t                height:  _height\r\n\t            },\r\n\t            //z: 1000,\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t        this.add(serverNodeB);\r\n\t\r\n\t        var portsList = model.get(\"ports\");\r\n\t        if ( portsList !== undefined ) {\r\n\t            var _kmx = 10;\r\n\t            for ( var i = 0; i < portsList.length; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 7;\r\n\t                portModel.width = 7;\r\n\t\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\");\r\n\t                _linInfo.sourcePort = i;\r\n\t                _linInfo.sourceCardNo = 0;\r\n\t                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n\t                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n\t                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n\t                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n\t                     _linInfo.ip = portsList[i].ip;\r\n\t                }\r\n\t                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n\t                    if ( portsList[i].type === \"1\" ) {\r\n\t                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n\t                    } else {\r\n\t                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n\t                    }\r\n\t                }   \r\n\t                portModel.lineInfo = _linInfo;         \r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _kmx = _kmx + 5;      \r\n\t            }\r\n\t        }\r\n\t       \r\n\t        var ports = model.get('ports');\r\n\t        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {\r\n\t\r\n\t        }\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerTopoNode.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.portNodeList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerTopoNode, NetworkNode);\r\n\t    module.exports = ServerTopoNode;\r\n\t\r\n\n\n/***/ },\n/* 96 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerR630Node(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerR630Node\" };    \r\n\t        this.model = model;\r\n\t        this.portNodeList = [];\r\n\t        this.cardNodeList = [];\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerR630Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _width = model.get(\"width\");\r\n\t        var _height = 20;\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: _height,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var status = model.get(\"status\");\r\n\t        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n\t        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n\t        //      imageUrl += status;\r\n\t        // }\r\n\t        imageUrl += '.png';\r\n\t\r\n\t        var cellStateNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 10,\r\n\t                cy: 10,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826',\r\n\t                opacity: 1,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            } ,\r\n\t            z: 1000\r\n\t        });\r\n\t        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n\t            cellStateNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(cellStateNode);\r\n\t  \r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: _width,\r\n\t                height:  _height\r\n\t            },\r\n\t            //z: 1000,\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t        this.add(serverNodeB);\r\n\t\r\n\t        var portsList = model.get(\"ports\");\r\n\t        if ( portsList !== undefined ) {\r\n\t            var _kmx = 10;\r\n\t            for ( var i = 0; i < portsList.length; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 7;\r\n\t                portModel.width = 7;\r\n\t\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\");\r\n\t                _linInfo.sourcePort = i;\r\n\t                _linInfo.sourceCardNo = 0;\r\n\t                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n\t                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n\t                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n\t                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n\t                     _linInfo.ip = portsList[i].ip;\r\n\t                }\r\n\t                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n\t                    if ( portsList[i].type === \"1\" ) {\r\n\t                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n\t                    } else {\r\n\t                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n\t                    }\r\n\t                }   \r\n\t                portModel.lineInfo = _linInfo;         \r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _kmx = _kmx + 5;      \r\n\t            }\r\n\t        }\r\n\t       \r\n\t        var ports = model.get('ports');\r\n\t        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {\r\n\t\r\n\t        }\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerR630Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.portNodeList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerR630Node, NetworkNode);\r\n\t    module.exports = ServerR630Node;\r\n\t\r\n\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var CardModel = __webpack_require__(98);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerR730Node(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerR730Node\" };    \r\n\t        this.model = model;\r\n\t        this.portNodeList = [];\r\n\t        this.cardNodeList = [];\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerR730Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _height = 20;\r\n\t        var me = this;\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var status = model.get(\"status\");\r\n\t        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n\t        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n\t        //      imageUrl += status;\r\n\t        // }\r\n\t        imageUrl += '.png';\r\n\t        \r\n\t        var cellStateNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 10,\r\n\t                cy: 20,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826',\r\n\t                opacity: 1,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            } ,\r\n\t            z: 1000\r\n\t        });\r\n\t        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n\t            cellStateNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(cellStateNode);\r\n\t\r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40,\r\n\t            },\r\n\t            //z: 1000,\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t        this.add(serverNodeB);\r\n\t        \r\n\t        var portsList = model.get(\"ports\");\r\n\t        if ( portsList !== undefined ) {\r\n\t            var _kmx = 10;\r\n\t            for ( var i = 0; i < portsList.length; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 7;\r\n\t                portModel.width = 7;\r\n\t\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\");\r\n\t                _linInfo.sourcePort = i;\r\n\t                _linInfo.sourceCardNo = 0;\r\n\t                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n\t                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n\t                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n\t                 if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n\t                     _linInfo.ip = portsList[i].ip;\r\n\t                }\r\n\t                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n\t                  \r\n\t                     if ( portsList[i].type === \"1\" ) {\r\n\t                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n\t                    } else {\r\n\t                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n\t                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n\t\r\n\t                    }\r\n\t                }  \r\n\t\r\n\t                portModel.lineInfo = _linInfo;         \r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _kmx = _kmx + 5;      \r\n\t            }\r\n\t        }       \r\n\t        \r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerR730Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.portNodeList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    ServerR730Node.prototype.addNodeByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, api);\r\n\t            var pointList = node.pointList;\r\n\t            if ( pointList !== undefined && pointList.length > 0 ) {\r\n\t                for( var i = 0; i < pointList.length; i++ ) {\r\n\t                    if ( pointList[i].lineInfo.sourceCardNo === \"1\" ) {\r\n\t                        pointList[i].lineInfo.moddleX = 35;\r\n\t                    } else if( pointList[i].lineInfo.sourceCardNo === \"2\" ) {\r\n\t                        pointList[i].lineInfo.moddleX = 25;\r\n\t                    } else if( pointList[i].lineInfo.sourceCardNo === \"3\" ) {\r\n\t\r\n\t                    } else if( pointList[i].lineInfo.sourceCardNo === \"4\" ) {\r\n\t                        pointList[i].lineInfo.moddleX = 25;\r\n\t                    }else if( pointList[i].lineInfo.sourceCardNo === \"5\" ) {\r\n\t\r\n\t                    }\r\n\t                  this.portNodeList.push(pointList[i]);   \r\n\t                }\r\n\t            }\r\n\t            this.add(node);\r\n\t            this.cardNodeList.push(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerR730Node, NetworkNode);\r\n\t    module.exports = ServerR730Node;\r\n\t\r\n\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t\r\n\t    var CardModel = NetworkModel.extend({\r\n\t        No: \"\",\r\n\t        resourcesName: \"\",\r\n\t        resourceNodeType : \"1\",\r\n\t        height: 5,\r\n\t        width: 5,\r\n\t        type: \"\",\r\n\t        direction: \"leftRight\",//updown\r\n\t        portData: []\r\n\t    });\r\n\t    module.exports = CardModel;\r\n\t\r\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerX3550Node(model,api) {\r\n\t        ServerTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerX3550Node\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerX3550Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/xIBMX3550b.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t        var serverNodeA = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/xIBMX3550a.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t\r\n\t        serverNodeB.on(\"mouseover\", function(params){\r\n\t            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeA.attr(\"position\", [0,0]);\r\n\t        });\r\n\t        serverNodeA.on(\"mouseout\", function(params){\r\n\t            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeB.attr(\"position\", [0,0]);\r\n\t        });\r\n\t\r\n\t        this.add(serverNodeA);\r\n\t        this.add(serverNodeB);\r\n\t        \r\n\t        //画默认的以太网端口\r\n\t        var _kmx = 95;\r\n\t        for (var i = 0; i < 4; i++ ) {\r\n\t            var portModel = {};\r\n\t            portModel = {\r\n\t                resourceId: util.getUUID(),  \r\n\t                bounds: {\r\n\t                    upperLeft: {x: _kmx, y: 15}  \r\n\t                },\r\n\t                stencil: {type: \"PointNode\"}\r\n\t            };\r\n\t            portModel.height = 8;\r\n\t            portModel.width = 8;\r\n\t            var pModel = new NetworkModel(portModel);\r\n\t            this.addPortByModel(pModel, api);\r\n\t            _kmx = _kmx + 13;\r\n\t        }\r\n\t\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerX3550Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerX3550Node, NetworkNode);\r\n\t    module.exports = ServerX3550Node;\r\n\t\r\n\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerX3650Node(model,api) {\r\n\t        ServerTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerX3650Node\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerX3650Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../..fish-topo-network/src/images/' + model.get(\"type\") + '.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  80\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t        var serverNodeA = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/IBMX3650a.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  80\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t\r\n\t        serverNodeB.on(\"mouseover\", function(params){\r\n\t            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeA.attr(\"position\", [0,0]);\r\n\t          //  serverNodeA.show();\r\n\t        });\r\n\t        serverNodeA.on(\"mouseout\", function(params){\r\n\t            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeB.attr(\"position\", [0,0]);\r\n\t        });\r\n\t\r\n\t        this.add(serverNodeA);\r\n\t        this.add(serverNodeB);\r\n\t        \r\n\t        //画默认的以太网端口\r\n\t        var _kmx = 165;\r\n\t        for (var i = 0; i < 4; i++ ) {\r\n\t            var portModel = {};\r\n\t            portModel = {\r\n\t                resourceId: util.getUUID(),  \r\n\t                bounds: {\r\n\t                    upperLeft: {x: _kmx, y: 55}  \r\n\t                },\r\n\t                stencil: {type: \"PointNode\"}\r\n\t            };\r\n\t            portModel.height = 10;\r\n\t            portModel.width = 10;\r\n\t            var pModel = new NetworkModel(portModel);\r\n\t            this.addPortByModel(pModel, api);\r\n\t            _kmx = _kmx + 13;\r\n\t        }\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerX3650Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerX3650Node, NetworkNode);\r\n\t    module.exports = ServerX3650Node;\r\n\t\r\n\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerRD350Node(model,api) {\r\n\t        ServerTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerRD350Node\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerRD350Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/lenovoRd350b.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40\r\n\t            },\r\n\t            draggable: false\r\n\t        }); \r\n\t\r\n\t        var serverNodeA = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/lenovoRd350a.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40\r\n\t            },\r\n\t            z: 1000,\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t\r\n\t        serverNodeB.on(\"mouseover\", function(params){\r\n\t            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeA.attr(\"position\", [0,0]);\r\n\t        });\r\n\t        serverNodeA.on(\"mouseout\", function(params){\r\n\t            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeB.attr(\"position\", [0,0]);\r\n\t        });\r\n\t\r\n\t        this.add(serverNodeA);\r\n\t        this.add(serverNodeB);\r\n\t        \r\n\t        //画默认的以太网端口\r\n\t        var _kmx = 95;\r\n\t        for (var i = 0; i < 4; i++ ) {\r\n\t            var portModel = {};\r\n\t            portModel = {\r\n\t                resourceId: util.getUUID(),  \r\n\t                bounds: {\r\n\t                    upperLeft: {x: _kmx, y: 15}  \r\n\t                },\r\n\t                stencil: {type: \"PointNode\"}\r\n\t            };\r\n\t            portModel.height = 8;\r\n\t            portModel.width = 8;\r\n\t            var pModel = new NetworkModel(portModel);\r\n\t            this.addPortByModel(pModel, api);\r\n\t            _kmx = _kmx + 13;\r\n\t        }\r\n\t\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerRD350Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerRD350Node, NetworkNode);\r\n\t    module.exports = ServerRD350Node;\r\n\t\r\n\n\n/***/ },\n/* 102 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ServerTopoNode = __webpack_require__(95);\r\n\t    \r\n\t    function ServerRD650Node(model,api) {\r\n\t        ServerTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ServerRD650Node\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ServerRD650Node.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var serverNodeB = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/lenovoRd650b.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  80\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t\r\n\t        var serverNodeA = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/lenovoRd650a.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height:  80\r\n\t            },\r\n\t            z: 1000,\r\n\t            draggable: false\r\n\t        }); \r\n\t\r\n\t\r\n\t        serverNodeB.on(\"mouseover\", function(params){\r\n\t            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeA.attr(\"position\", [0,0]);\r\n\t          //  serverNodeA.show();\r\n\t        });\r\n\t        serverNodeA.on(\"mouseout\", function(params){\r\n\t            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n\t            serverNodeB.attr(\"position\", [0,0]);\r\n\t        });\r\n\t\r\n\t        this.add(serverNodeA);\r\n\t        this.add(serverNodeB);\r\n\t        \r\n\t        //画默认的以太网端口\r\n\t        var portModel = {};\r\n\t        portModel = {\r\n\t            resourceId: util.getUUID(),  \r\n\t            bounds: {\r\n\t                upperLeft: {x: 88, y: 55}  \r\n\t            },\r\n\t            stencil: {type: \"PointNode\"}\r\n\t        };\r\n\t        portModel.height = 10;\r\n\t        portModel.width = 10;\r\n\t        var pModel = new NetworkModel(portModel);\r\n\t        this.addPortByModel(pModel, api);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ServerRD650Node.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ServerRD650Node, NetworkNode);\r\n\t    module.exports = ServerRD650Node;\r\n\t\r\n\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    \r\n\t    function SwitchTopoNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"SwitchTopoNode\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchTopoNode.prototype.render = function(model, api) {\r\n\t        \r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(SwitchTopoNode, NetworkNode);\r\n\t    module.exports = SwitchTopoNode;\r\n\t\r\n\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var SwitchTopoNode = __webpack_require__(103);\r\n\t    \r\n\t    function SwitchHalfIBNode(model,api) {\r\n\t        SwitchTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"SwitchHalfIBNode\" };    \r\n\t        this.model = model;\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.portNodeList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchHalfIBNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _portNum = model.get(\"portNum\");\r\n\t        var imageUrl = \"../../../../fish-topo-network/src/images/IBSwitchHalf\" + _portNum + \".png\";\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 130,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var switchNode = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: model.get(\"width\"),\r\n\t                height:  40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t        this.add(switchNode);\r\n\t\r\n\t        if ( _portNum === \"12\") {\r\n\t            var _y = 12;\r\n\t            var _x = 42;\r\n\t            for (var i = 1; i < 7; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 6;\r\n\t                portModel.width = 11;\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t                _linInfo.sourcePort = i.toString();\r\n\t                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _x = _x + portModel.width + 3;\r\n\t            }\r\n\t            \r\n\t            _y = 22;\r\n\t            _x = 42;\r\n\t            for (var i = 7; i < 13; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 6;\r\n\t                portModel.width = 11;\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t                _linInfo.sourcePort = i.toString();\r\n\t                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _x = _x + portModel.width + 3;     \r\n\t            }\r\n\t        } else if ( _portNum === \"8\" ) {\r\n\t            var _y = 12;\r\n\t            var _x = 70;\r\n\t            for (var i = 1; i < 5; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 6;\r\n\t                portModel.width = 11;\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t                _linInfo.sourcePort = i.toString();\r\n\t                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _x = _x + portModel.width + 3;\r\n\t            }\r\n\t            \r\n\t            _y = 22;\r\n\t            _x = 70;\r\n\t            for (var i = 5; i < 9; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 6;\r\n\t                portModel.width = 11;\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t                _linInfo.sourcePort = i.toString();\r\n\t                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                _x = _x + portModel.width + 3;     \r\n\t            }\r\n\t\r\n\t        }\r\n\t        \r\n\t\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    SwitchHalfIBNode.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.add(node);\r\n\t            this.portNodeList.push(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(SwitchHalfIBNode, NetworkNode);\r\n\t    module.exports = SwitchHalfIBNode;\r\n\t\r\n\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var SwitchTopoNode = __webpack_require__(103);\r\n\t    \r\n\t    function SwitchFullIBNode(model,api) {\r\n\t        SwitchTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"SwitchFullIBNode\" };    \r\n\t        this.model = model;\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.portNodeList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchFullIBNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var _portNum = model.get(\"portNum\");\r\n\t        var imageUrl = \"../../../../fish-topo-network/src/images/IBSwitchFull\" + _portNum + \".png\";\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: 20,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var switchNode = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: imageUrl,\r\n\t                width: model.get(\"width\"),\r\n\t                height: 40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t        this.add(switchNode);\r\n\t\r\n\t        var _y = 14;\r\n\t        var _x = 18;\r\n\t        for (var i = 1; i < 19; i++ ) {\r\n\t            var portModel = {};\r\n\t            portModel = {\r\n\t                resourceId: util.getUUID(),  \r\n\t                bounds: {\r\n\t                    upperLeft: {x: _x, y: _y}  \r\n\t                },\r\n\t                stencil: {type: \"PointNode\"}\r\n\t            };\r\n\t            portModel.height = 6;\r\n\t            portModel.width = 11;\r\n\t            var _linInfo = {};\r\n\t            _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t            _linInfo.sourcePort = i.toString();\r\n\t            _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2 );\r\n\t            portModel.lineInfo = _linInfo;\r\n\t            var pModel = new NetworkModel(portModel);\r\n\t            this.addPortByModel(pModel, api);\r\n\t            if (i % 3 === 0 ) {\r\n\t                _x = _x + portModel.width + 5;\r\n\t            } else {\r\n\t                _x = _x + portModel.width + 2;\r\n\t            }       \r\n\t        }\r\n\t        \r\n\t        if ( _portNum > 18 ) {\r\n\t            _y = 24;\r\n\t            _x = 18;\r\n\t            for (var i = 19; i < 37; i++ ) {\r\n\t                var portModel = {};\r\n\t                portModel = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: _x, y: _y}  \r\n\t                    },\r\n\t                    stencil: {type: \"PointNode\"}\r\n\t                };\r\n\t                portModel.height = 6;\r\n\t                portModel.width = 11;\r\n\t                var _linInfo = {};\r\n\t                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n\t                _linInfo.sourcePort = i.toString();\r\n\t                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2 );\r\n\t                portModel.lineInfo = _linInfo;\r\n\t                var pModel = new NetworkModel(portModel);\r\n\t                this.addPortByModel(pModel, api);\r\n\t                if (i % 3 === 0 ) {\r\n\t                    _x = _x + portModel.width + 5;\r\n\t                } else {\r\n\t                    _x = _x + portModel.width + 2;\r\n\t                }       \r\n\t            }\r\n\t        }\r\n\t        \r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t     SwitchFullIBNode.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.portNodeList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(SwitchFullIBNode, NetworkNode);\r\n\t    module.exports = SwitchFullIBNode;\r\n\t\r\n\n\n/***/ },\n/* 106 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var SwitchTopoNode = __webpack_require__(103);\r\n\t    \r\n\t    function SwitchGMNode(model,api) {\r\n\t        SwitchTopoNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"SwitchGMNode\" };    \r\n\t        this.model = model;\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchGMNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var switchNode = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/GMSwitch.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height: 40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t        this.add(switchNode);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t   \r\n\t\r\n\t    zrUtil.inherits(SwitchGMNode, NetworkNode);\r\n\t    module.exports = SwitchGMNode;\r\n\t\r\n\n\n/***/ },\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var SwitchTopoNode = __webpack_require__(103);\r\n\t    \r\n\t    function SwitchKMNode(model,api) {\r\n\t        SwitchTopoNode.call(this, model, api);\r\n\t        //this.rackkInfo = {type: -1, name: \"SwitchKMNode\" };    \r\n\t        this.model = model;\r\n\t        this.parmDate = this.model.get(\"parmDate\");\r\n\t        this.portNodeList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    SwitchKMNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t\r\n\t        var _title = new graphic.Text({\r\n\t            style: {\r\n\t                x: model.get(\"width\") / 2 - 10,\r\n\t                y: -20,\r\n\t                text: model.get(\"name\"),\r\n\t                width: 200,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '12px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });\r\n\t        this.add(_title);\r\n\t\r\n\t        var switchNode = new graphic.Image({\r\n\t            position: [0, 0],\r\n\t            scale: [1, 1],\r\n\t            style: {\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                image: '../../../../fish-topo-network/src/images/KMSwitch.png',\r\n\t                width: model.get(\"width\"),\r\n\t                height: 40\r\n\t            },\r\n\t            draggable: false,\r\n\t            parmDate: this.model.get(\"parmDate\")\r\n\t        }); \r\n\t        this.add(switchNode);\r\n\t\r\n\t\r\n\t        //�˿�\r\n\t        var portModel = {};\r\n\t        portModel = {\r\n\t            resourceId: util.getUUID(),  \r\n\t            bounds: {\r\n\t                upperLeft: {x:model.get(\"width\") / 2, y: 10}  \r\n\t            },\r\n\t            stencil: {type: \"PointNode\"}\r\n\t        };\r\n\t        portModel.height = 6;\r\n\t        portModel.width = 11;\r\n\t        var _linInfo = {};\r\n\t        _linInfo.sourceReource = model.get(\"name\");\r\n\t        _linInfo.sourcePort = \"-1\";\r\n\t        portModel.lineInfo = _linInfo;\r\n\t        var pModel = new NetworkModel(portModel);\r\n\t        this.addPortByModel(pModel, api);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    SwitchKMNode.prototype.addPortByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this._api);\r\n\t            this.portNodeList.push(node);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    zrUtil.inherits(SwitchKMNode, NetworkNode);\r\n\t    module.exports = SwitchKMNode;\r\n\t\r\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var NetWorkLineNode = __webpack_require__(88);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var DatabaseModel = __webpack_require__(109);\r\n\t\tvar AsmModel = __webpack_require__(110);\r\n\t\tvar ISEModel = __webpack_require__(111);\r\n\t    var NetWorkLineModel = __webpack_require__(94);\r\n\t    var Connector = __webpack_require__(89);\r\n\t\r\n\t\r\n\t    function ClusterDrawNode(model, api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.info = {type: -1, name: \"ClusterDrawNode\" };    \r\n\t        this.model = model;\r\n\t        this.databaseList = [];\r\n\t        this.dgList = [];\r\n\t        this.render(model, api);\r\n\t    };\r\n\t\r\n\t    ClusterDrawNode.prototype.render = function(model, api) {\r\n\t    \tvar nodeList = model.get(\"nodeList\");\r\n\t        var _showTip = model.get(\"showTip\");\r\n\t        var dataModelData = {};\r\n\t    \tvar asmModelData = {};\r\n\t    \tvar storageModelData = {};\r\n\t    \tvar _dgList = [];\r\n\t    \tfor( var i = 0; i < nodeList.length; i++ ) {\r\n\t    \t\tvar nodeY = 10;\r\n\t            var startX = 0;\r\n\t    \t\tif ( nodeList[i].type === \"database\" ) {\r\n\t    \t\t\tvar dbData = nodeList[i].dbData;\r\n\t    \t\t\tif ( dbData != undefined && dbData.length > 0 ) {\r\n\t                    dataModelData = {\r\n\t                        resourceId: util.getUUID(),  \r\n\t                        bounds: {\r\n\t                            upperLeft: {x: startX, y: nodeY}  \r\n\t                        },\r\n\t                        stencil: {type: \"ClusterDatabaseNode\"}\r\n\t                    };\r\n\t                    dataModelData.dbData = dbData;\r\n\t                    dataModelData.showTip = _showTip;\r\n\t    \t\t\t}\t\r\n\t    \t\t} else if( nodeList[i].type === \"asm\") {\r\n\t    \t\t\tvar startX = 0;\r\n\t    \t\t\tnodeY = 250;\r\n\t    \t\t\tasmModelData = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: \"ClusterAsmNode\"}\r\n\t                };\r\n\t                asmModelData.name = nodeList[i].name;\r\n\t                asmModelData.asmData = nodeList[i].asmData;\r\n\t                asmModelData.dgData = nodeList[i].dgData;\r\n\t                asmModelData.status = nodeList[i].status;\r\n\t                asmModelData.showTip = _showTip;\r\n\t    \t\t} else if( nodeList[i].type === \"storage\" ) {\r\n\t    \t\t\tvar startX = 0;\r\n\t    \t\t\tnodeY = 550;\r\n\t    \t\t\tstorageModelData = {\r\n\t                    resourceId: util.getUUID(),  \r\n\t                    bounds: {\r\n\t                        upperLeft: {x: startX, y: nodeY}  \r\n\t                    },\r\n\t                    stencil: {type: \"ClusterIseNode\"}\r\n\t                };\r\n\t                storageModelData.childNodeList = nodeList[i].iseData;\r\n\t                storageModelData.showTip = _showTip;\r\n\t    \t\t}\r\n\t\r\n\t    \t}\r\n\t\r\n\t        var databaseModel = new DatabaseModel(dataModelData);\r\n\t        this.addNodeByModel(databaseModel, api);\r\n\t\r\n\t        \r\n\t        //画矩形\r\n\t        var mangerNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                r: 20,\r\n\t                x: 50,\r\n\t                y: 300,\r\n\t                width: api.getWidth() - 100,\r\n\t                height: 300\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '1',\r\n\t                lineDash: [12]  \r\n\t            }          \r\n\t        });              \r\n\t        this.add(mangerNode);\r\n\t\r\n\t        asmModelData.database = dataModelData.dbData !== undefined ? dataModelData.dbData.length : 0;\r\n\t    \tvar asmModel = new AsmModel(asmModelData);\r\n\t        this.addNodeByModel(asmModel, api);\r\n\t\r\n\t        var iseModel = new ISEModel(storageModelData);\r\n\t        this.addNodeByModel(iseModel, api);\r\n\t\r\n\t\r\n\t\r\n\t        //连线\r\n\t        for (var l = 0; l < this.databaseList.length; l++ ) {\r\n\t            this.drawLine(this.databaseList[l], this.dgList[l], api);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    ClusterDrawNode.prototype.addNodeByModel = function( p_model, api) {\r\n\t        \r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, api);\r\n\t            this.add(node);\r\n\t            var MOUSE_EVENT_NAMES = ['click'];\r\n\t            if ( p_model.get(\"showTip\") ) {\r\n\t                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n\t            }\r\n\t            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t                 node.on(eveName, function (e) {\r\n\t                     var params = {};\r\n\t                    if ( eveName === \"mouseover\") {\r\n\t                        params.event = e;\r\n\t                        params.x = node.parent.position[0] +  (e.target.shape ? e.target.shape.x : 0) + (e.target.shape ? e.target.shape.width : 0);\r\n\t                        params.y = node.parent.position[1] + (e.target.shape ? e.target.shape.y : 0) + (e.target.shape ? e.target.shape.height : 0) / 2;\r\n\t                        params.width = 150;\r\n\t                        params.height = 170;\r\n\t                        params.eWidth =  5 ;\r\n\t                        params.parmDate = e.target.parmDate;\r\n\t                        if ( api.getWidth() - params.x < params.width ) {\r\n\t                            params.layout = \"left\";\r\n\t                        } else {\r\n\t                            params.layout = \"right\";\r\n\t                        }\r\n\t                        //api.showTipWindow(params);\r\n\t                    } else if (eveName === \"mouseout\") {\r\n\t                        //api.hideTipWindow(e.event.target);\r\n\t                    } else if (eveName === \"click\") {\r\n\t                        params.event = e;\r\n\t                        params.parmDate = e.target.parmDate;\r\n\t                    } \r\n\t                    api.trigger(eveName, params);   \r\n\t                }, this);\r\n\t            });\r\n\t\r\n\t            if ( api.getWidth()  < node.clientWidth ) {\r\n\t                api.resize(node.clientWidth, api.getHeight());\r\n\t            }\r\n\t            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {\r\n\t                if ( node.info.name === \"ClusterDatabaseNode\" ) {\r\n\t                    for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n\t                        this.databaseList.push(node.portNodeList[i]);\r\n\t                    }\r\n\t                } else if( node.info.name === \"ClusterAsmNode\" ) {\r\n\t                    for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n\t                        this.dgList.push(node.portNodeList[i]);\r\n\t                    }\r\n\t                } \r\n\t            }\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    ClusterDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {\r\n\t        var fleftx = p_startNode.parent.position[0] + p_startNode.shape.x;\r\n\t        var flefty = p_startNode.parent.position[1] + p_startNode.shape.y;\r\n\t        var fwidth =  p_startNode.shape.width;\r\n\t        var fheight = p_startNode.shape.height;\r\n\t\r\n\t        var torightx = p_endNode.parent.position[0] + p_endNode.shape.x;\r\n\t        var torighty = p_endNode.parent.position[1] + p_endNode.shape.y;\r\n\t        var towidth =  p_endNode.shape.width;\r\n\t        var toheight = p_endNode.shape.height;\r\n\t        var moddleY = 200;    \r\n\t        var moddleX = api.getWidth() / 2; \r\n\t        \r\n\t        var _toModdleY = moddleY;\r\n\t        if ( torightx + 25 > moddleX ) {\r\n\t            _toModdleY = moddleY - 15;\r\n\t        } else {\r\n\t            _toModdleY = moddleY + 15;\r\n\t        }\r\n\t\r\n\t        var defaultOptionDatabase = {\r\n\t            fromBounds : {x: fleftx - 15, y: flefty, width: fwidth, height: fheight},\r\n\t            toBounds: {x: torightx - 15, y: torighty, width: towidth, height: toheight},\r\n\t            moddleY: _toModdleY,\r\n\t            style : {\r\n\t                lineWidth : 3,\r\n\t                stroke: '#050505'//,\r\n\t                //fill: '#9699DD'\r\n\t            },\r\n\t            hoverStyle : {\r\n\t                lineWidth : 3,\r\n\t                stroke: '#0B8329'//,\r\n\t                //fill:'#2FDE92'\r\n\t            },\r\n\t            isEdit: false,\r\n\t            isVector: true,\r\n\t            lineType: Connector.TYPE_CURVE\r\n\t        }\r\n\t        var databaseModel = new NetWorkLineModel(defaultOptionDatabase);\r\n\t        var databaseNode = new NetWorkLineNode(databaseModel);\r\n\t        this.add(databaseNode);\r\n\t\r\n\t        var _backModdleY = moddleY;\r\n\t        if ( torightx + 25 > moddleX ) {\r\n\t            _backModdleY = moddleY + 15;\r\n\t        } else {\r\n\t            _backModdleY = moddleY - 15;\r\n\t        }\r\n\t         var defaultOptionDg = {\r\n\t            fromBounds : {x: torightx + 15, y: torighty, width: towidth, height: toheight},\r\n\t            toBounds: {x: fleftx + 15, y: flefty, width: fwidth, height: fheight},\r\n\t            moddleY: _backModdleY,\r\n\t            style : {\r\n\t                lineWidth : 3,\r\n\t                stroke: '#050505'//,\r\n\t                //fill: '#9699DD'\r\n\t            },\r\n\t            hoverStyle : {\r\n\t                lineWidth : 3,\r\n\t                stroke: '#0B8329'//,\r\n\t                //fill:'#2FDE92'\r\n\t            },\r\n\t            isEdit: false,\r\n\t            isVector: true,\r\n\t            lineType: Connector.TYPE_CURVE\r\n\t        }\r\n\t        var dgModel = new NetWorkLineModel(defaultOptionDg);\r\n\t        var dgNode = new NetWorkLineNode(dgModel);\r\n\t        this.add(dgNode);\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    ClusterDrawNode.prototype.bind = function( p_node, p_eventList, api) {\r\n\t        if ( p_eventList != undefined && p_eventList.length > 0 ) {\r\n\t            //绑定悬浮事件\r\n\t            zrUtil.each(p_eventList, function (eveName) {\r\n\t                p_node.on(eveName, function (e) {\r\n\t                    if ( eveName === \"mouseover\") {\r\n\t                        var params = {};\r\n\t                        params.event = e;\r\n\t                        params.x = p_node.position[0] + e.target.shape.width;\r\n\t                        params.y = p_node.position[1] + e.target.shape.height / 2;\r\n\t                        params.width = 150;\r\n\t                        params.height = 170;\r\n\t                        params.eWidth =  5 ;\r\n\t                        params.parmDate = e.target.parmDate;\r\n\t                        api.showTipWindow(params);\r\n\t                    } else {\r\n\t                        api.hideTipWindow(e.event.target);\r\n\t                    }    \r\n\t                }, this);\r\n\t            }, this);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    zrUtil.inherits(ClusterDrawNode, NetworkNode);\r\n\t    module.exports = ClusterDrawNode;\r\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Server DatabaseModel\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t\r\n\t    var DatabaseModel = NetworkModel.extend({\r\n\t        name: \"\",\r\n\t    \theight: 200,\r\n\t        width: 190,\r\n\t        status : \"online\",\r\n\t        instanse: {},\r\n\t        dg: []\r\n\t    });\r\n\t    module.exports = DatabaseModel;\r\n\t\r\n\n\n/***/ },\n/* 110 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Server AsmModel\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t\r\n\t    var AsmModel = NetworkModel.extend({\r\n\t        name: \"\",\r\n\t    \theight: 200,\r\n\t        width: 190,\r\n\t        status : \"online\",\r\n\t        asmData : [],\r\n\t        dg: []\r\n\t    });\r\n\t    module.exports = AsmModel;\r\n\t\r\n\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * ISE Model\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\t    var Model = __webpack_require__(75);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t\r\n\t    var ISEModel = NetworkModel.extend({\r\n\t        name: \"\",\r\n\t    \theight: 200,\r\n\t        width: 250,\r\n\t        status : \"online\",\r\n\t        childNodeList: []\r\n\t    });\r\n\t    module.exports = ISEModel;\r\n\t\r\n\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var ClusterDrawNode = __webpack_require__(108);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function ClusterDatabaseNode(model, api) {\r\n\t        ClusterDrawNode.call(this, model, api);\r\n\t        this.info = {type: -1, name: \"ClusterDatabaseNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.portNodeList = [];\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ClusterDatabaseNode.prototype.render = function(model, api) {\r\n\t        this.model = model;\r\n\t        var dbData = model.get(\"dbData\");\r\n\t        var _width = 280;\r\n\t        var _height = 80;\r\n\t        var _interval = 50;\r\n\t        var _x = (api.getWidth() - dbData.length * (_width + _interval)) / 2 - 140;\r\n\t        var _y = 0;\r\n\t        for ( var d = 0 ; d < dbData.length; d++ ) {\r\n\t            var parmDate = dbData[d];\r\n\t            parmDate.type = \"database\";\r\n\t            //实例宽度\r\n\t            var _instanseWidth = 150;\r\n\t            _width = (_instanseWidth + 10) * (dbData[d].instanse.length + 1) + 10;\r\n\t\r\n\t             //创建数据库对象\r\n\t            var portNode = new graphic.Rect({\r\n\t                shape: {\r\n\t                    r: 10,\r\n\t                    x: _x,\r\n\t                    y: _y,\r\n\t                    width: _width,\r\n\t                    height: _height\r\n\t                },\r\n\t                style: {\r\n\t                    //fill: '#E2E3D9',\r\n\t                    //stroke: '#B3B3B3',\r\n\t                    fill: '#FFFFFF',\r\n\t                    stroke: '#88888B',\r\n\t                    opacity: 1,\r\n\t                    lineWidth: '2'//,\r\n\t                },\r\n\t                parmDate: parmDate       \r\n\t            });  \r\n\t            portNode.lineInfo = this.lineInfo;            \r\n\t            this.add(portNode);\r\n\t\r\n\t            // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];   \r\n\t            // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\t            //      portNode.on(eveName, function (e) {\r\n\t            //         if ( eveName === \"mouseover\") {\r\n\t            //             var params = {};\r\n\t            //             params.event = e;\r\n\t            //             params.x = portNode.parent.position[0] + e.target.shape.x + e.target.shape.width;\r\n\t            //             params.y = portNode.parent.position[1] + e.target.shape.y + e.target.shape.height / 2;\r\n\t            //             params.width = 150;\r\n\t            //             params.height = 170;\r\n\t            //             params.eWidth =  5 ;\r\n\t            //             params.parmDate = e.target.parmDate;\r\n\t            //             if ( api.getWidth() - params.x < params.width ) {\r\n\t            //                 params.layout = \"left\";\r\n\t            //             } else {\r\n\t            //                 params.layout = \"right\";\r\n\t            //             }\r\n\t            //             //api.showTipWindow(params);\r\n\t            //         } else {\r\n\t            //             //api.hideTipWindow(e.event.target);\r\n\t            //         }    \r\n\t            //     }, this);\r\n\t            // });\r\n\t           \r\n\t\r\n\t            this.portNodeList.push(portNode);\r\n\t\r\n\t            var _instanse = dbData[d].instanse;\r\n\t            //创建数据库实例对象\r\n\t            if( _instanse != undefined && _instanse.length > 0 ) {\r\n\t                 var _title = new graphic.Text({\r\n\t                    style: {\r\n\t                        x: _x + 70,\r\n\t                        y: 15,\r\n\t                        text: \"数据库实例: \",\r\n\t                        width: 70,\r\n\t                        height: 20,\r\n\t                        fill: '#8F8B8A',\r\n\t                        textFont: '14px Microsoft Yahei',\r\n\t                        textBaseline: 'top'\r\n\t                    },\r\n\t                    draggable: true\r\n\t                });\r\n\t                this.add(_title);\r\n\t\r\n\t                var _instanseX = _x + _instanseWidth + 10;\r\n\t                _instanseWidth = 150;\r\n\t                for (var i = 0; i < _instanse.length; i++ ) {\r\n\t\r\n\t                    var _instanseNode = new graphic.Rect({\r\n\t                        shape: {\r\n\t                            x: _instanseX,\r\n\t                            y: 10,\r\n\t                            width: _instanseWidth,\r\n\t                            height: 30\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: '#FFFFFF',\r\n\t                            stroke: '#88888B',\r\n\t                            opacity: 1,\r\n\t                            lineWidth: '2'//,\r\n\t                        }          \r\n\t                    }); \r\n\t                    this.add(_instanseNode);\r\n\t\r\n\t                     //状态 \r\n\t                    var _instansestatusNode = new graphic.Circle({\r\n\t                         shape: {\r\n\t                            cx: _instanseX + 15,\r\n\t                            cy: 25,\r\n\t                            r: 5\r\n\t                        },\r\n\t                        style: {\r\n\t                            fill: '#077826'/*,\r\n\t                            stroke: '#B3B3B3',\r\n\t                            lineWidth: '2'//,*/\r\n\t                        } \r\n\t                    });\r\n\t                    if ( _instanse[i].status === \"offline\") {\r\n\t                        _instansestatusNode.style.fill = \"#999999\";\r\n\t                    }\r\n\t                    this.add(_instansestatusNode);\r\n\t\r\n\t                    //文字\r\n\t                    var _instanseTitle = new graphic.Text({\r\n\t                        style: {\r\n\t                            x: _instanseX + 25,\r\n\t                            y: 15,\r\n\t                            text: _instanse[i].name,\r\n\t                            width: 200,\r\n\t                            height: 20,\r\n\t                            fill: '#8F8B8A',\r\n\t                            textFont: '14px Microsoft Yahei',\r\n\t                            textBaseline: 'top'\r\n\t                        },\r\n\t                        draggable: true\r\n\t                    });       \r\n\t                    this.add(_instanseTitle);\r\n\t                    _instanseX = _instanseWidth + _instanseX + 10;\r\n\t                }\r\n\t            }\r\n\t\r\n\t\r\n\t            // //物理状态 \r\n\t            // var _phyStatus = new graphic.Rect({\r\n\t            //     shape: {\r\n\t            //         x: _instanseX,\r\n\t            //         y: 32,\r\n\t            //         width: 280,\r\n\t            //         height: 50\r\n\t            //     },\r\n\t            //     style: {\r\n\t            //         fill: '#CCCCCC',\r\n\t            //         stroke: '#B3B3B3',\r\n\t            //         lineWidth: '2'//,\r\n\t            //     }          \r\n\t            // }); \r\n\t            // if ( model.get(\"status\") === \"offline\") {\r\n\t            //     _phyStatus.style.fill = \"#CFB624\";\r\n\t            // }\r\n\t            // this.add(_phyStatus);\r\n\t\r\n\t            //状态 \r\n\t            var _status = new graphic.Circle({\r\n\t                 shape: {\r\n\t                    cx: _x + _width / 2 - 30,\r\n\t                    cy: 60,\r\n\t                    r: 5\r\n\t                },\r\n\t                style: {\r\n\t                    fill: '#077826'/*,\r\n\t                    stroke: '#B3B3B3',\r\n\t                    lineWidth: '2'//,*/\r\n\t                } \r\n\t            });\r\n\t            if ( model.get(\"status\") === \"offline\") {\r\n\t                _status.style.fill = \"#999999\";\r\n\t            }\r\n\t            this.add(_status);\r\n\t\r\n\t            var _title = new graphic.Text({\r\n\t                style: {\r\n\t                    x: _x + _width / 2 - 20,\r\n\t                    y: 50,\r\n\t                    text: dbData[d].name,\r\n\t                    width: 200,\r\n\t                    height: 20,\r\n\t                    fill: '#020202',\r\n\t                    textFont: '18px Microsoft Yahei',\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t                draggable: true\r\n\t            });\r\n\t            this.add(_title);\r\n\t            _x = _x + _width + _interval;\r\n\t        }\r\n\t        this.clientWidth = _x + 50;\r\n\t    \r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t   \r\n\t    zrUtil.inherits(ClusterDatabaseNode, NetworkNode);\r\n\t\r\n\t    module.exports = ClusterDatabaseNode;\r\n\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var ClusterDrawNode = __webpack_require__(108);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function ClusterAsmNode(model,api) {\r\n\t        ClusterDrawNode.call(this, model, api);\r\n\t        this.info = {type: -1, name: \"ClusterAsmNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        return this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ClusterAsmNode.prototype.render = function(model, api) {\r\n\t        var dgList = model.get(\"dgData\");\r\n\t        var _dgW = 150;\r\n\t        var _dgH = 30;\r\n\t        var fullDgHeight = this.getNodeHeight( dgList.length + 1, _dgH, 4 );\r\n\t        var fullDgWidth = (_dgW + 5) * 4 + 5;\r\n\t\r\n\t        var _startX = (api.getWidth() - fullDgWidth) / 2;\r\n\t        var _startY = 0;\r\n\t\r\n\t        //影藏连线点\r\n\t        var databaseList = model.get(\"database\");\r\n\t        if ( databaseList > 0 ) {\r\n\t            var _lSpace = ( fullDgWidth - (databaseList * 30) ) / (databaseList + 1) \r\n\t            var _lX = _startX + _lSpace;\r\n\t            var _lY = 0;\r\n\t            for ( var l = 0; l < databaseList; l++ ) {\r\n\t                var dgLineNode = new graphic.Rect({\r\n\t                    shape: {\r\n\t                        r: 10,\r\n\t                        x: _lX,\r\n\t                        y: 0,\r\n\t                        width: 5,\r\n\t                        height: 5\r\n\t                    },\r\n\t                    style: {\r\n\t                        fill: 'red',\r\n\t                        stroke: 'red',\r\n\t                        opacity: 0.001,\r\n\t                        lineWidth: '2'//,\r\n\t                    }          \r\n\t                });\r\n\t                this.add(dgLineNode);\r\n\t                this.portNodeList.push(dgLineNode); \r\n\t                _lX += _lSpace;\r\n\t            }\r\n\t        }\r\n\t              \r\n\t        var fullDgNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                r: 10,\r\n\t                x: _startX,\r\n\t                y: _startY,\r\n\t                width: fullDgWidth,\r\n\t                height: fullDgHeight\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#88888B',\r\n\t                opacity: 1,\r\n\t                lineWidth: '2'//,\r\n\t            }          \r\n\t        }); \r\n\t        this.add(fullDgNode);\r\n\t\r\n\t        //添加DG 单元\r\n\t        var _dgCellX = _startX + 5;\r\n\t        var _dgCellY = _startY + 5;\r\n\t        for ( var i = -1 ; i < dgList.length; i++ ) { \r\n\t            if ( i === -1 ) {\r\n\t                var _title = new graphic.Text({\r\n\t                    style: {\r\n\t                        x: _dgCellX + 70,\r\n\t                        y: _dgCellY + 7,\r\n\t                        text: \"DG List: \",\r\n\t                        width: _dgW,\r\n\t                        height: _dgH,\r\n\t                        fill: '#8F8B8A',\r\n\t                        textFont: '14px Microsoft Yahei',\r\n\t                        textBaseline: 'top'\r\n\t                    },\r\n\t                    draggable: true\r\n\t                });\r\n\t                this.add(_title);\r\n\t\r\n\t            } else {\r\n\t                 var cellModelData = {\r\n\t                    resourceId: util.getUUID(), \r\n\t                    bounds: {\r\n\t                            upperLeft: {x: 0, y: 0}  \r\n\t                        }, \r\n\t                    stencil: {type: \"ClusterAsmCellNode\"}\r\n\t                };\r\n\t         \r\n\t                cellModelData.bounds.upperLeft.x = _dgCellX;\r\n\t                cellModelData.bounds.upperLeft.y = _dgCellY;\r\n\t\r\n\t                cellModelData.height = _dgH;\r\n\t                cellModelData.width = _dgW;\r\n\t                cellModelData.title = dgList[i].name;\r\n\t                cellModelData.status = dgList[i].status;\r\n\t                var cellModel = new NetworkModel(cellModelData);\r\n\t                this.addNodeByModel(cellModel, api); \r\n\t\r\n\t            }\r\n\t           \r\n\t            if ( (i + 2) % 4 !== 0 ) {\r\n\t                _dgCellX = _dgCellX + _dgW + 5;\r\n\t                _dgCellY = _dgCellY;\r\n\t            } else {\r\n\t                _dgCellX = _startX + 5;\r\n\t                _dgCellY = _dgCellY + _dgH + 5;\r\n\t            }\r\n\t\r\n\t        }\r\n\t\r\n\t        var parmDate = {};\r\n\t        parmDate.type = \"asm\";\r\n\t        var asmNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                r: 10,\r\n\t                x: _startX,\r\n\t                y: _startY + fullDgHeight,\r\n\t                width: fullDgWidth,\r\n\t                height: 100\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#88888B',\r\n\t                opacity: 1,\r\n\t                lineWidth: '2'//,\r\n\t            },\r\n\t            parmDate: parmDate             \r\n\t        });              \r\n\t        this.add(asmNode);\r\n\t\r\n\t        //遍历ASM实例对象\r\n\t        var asmData = model.get(\"asmData\");\r\n\t        var fullAsmHeight = this.getNodeHeight(asmData.length, _dgH, 4);\r\n\t         //添加DG 单元\r\n\t        var _asmCellX = _startX + 5;\r\n\t        var _asmCellY = _startY + fullDgHeight + 5;\r\n\t\r\n\t        for ( var j = -1; j < asmData.length; j++ ) { \r\n\t            if ( j === -1) {\r\n\t                var _title = new graphic.Text({\r\n\t                    style: {\r\n\t                        x: _asmCellX + 70,\r\n\t                        y: _asmCellY + 7,\r\n\t                        text: \"ASM实例: \",\r\n\t                        width: _dgW,\r\n\t                        height: _dgH,\r\n\t                        fill: '#8F8B8A',\r\n\t                        textFont: '14px Microsoft Yahei',\r\n\t                        textBaseline: 'top'\r\n\t                    },\r\n\t                    draggable: true\r\n\t                });\r\n\t                this.add(_title);\r\n\t            } else {\r\n\t                var cellModelData = {\r\n\t                    resourceId: util.getUUID(), \r\n\t                    bounds: {\r\n\t                            upperLeft: {x: 0, y: 0}  \r\n\t                        }, \r\n\t                    stencil: {type: \"ClusterAsmCellNode\"}\r\n\t                };\r\n\t         \r\n\t                cellModelData.bounds.upperLeft.x = _asmCellX;\r\n\t                cellModelData.bounds.upperLeft.y = _asmCellY;\r\n\t\r\n\t                cellModelData.height = _dgH;\r\n\t                cellModelData.width = _dgW;\r\n\t                cellModelData.title = asmData[j].name;\r\n\t                cellModelData.status = asmData[j].status;\r\n\t                var cellModel = new NetworkModel(cellModelData);\r\n\t                this.addNodeByModel(cellModel, api); \r\n\t\r\n\t            }\r\n\t            \r\n\t            if ( (j + 2) % 4 !== 0 ) {\r\n\t                _asmCellX = _asmCellX + _dgW + 5;\r\n\t                _asmCellY = _asmCellY;\r\n\t            } else {\r\n\t                _asmCellX = _startX + 5;\r\n\t                _asmCellY = _asmCellY + _dgH + 5;\r\n\t            }\r\n\t\r\n\t        }\r\n\t        \r\n\t        var _fullAsmX = _startX + 200;\r\n\t        var _fullAsmY = _startY + fullDgHeight + fullAsmHeight + 10;\r\n\t        \r\n\t        //状态 \r\n\t        var _asmStatusNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: _fullAsmX,\r\n\t                cy: _fullAsmY + 10,\r\n\t                r: 7\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826'/*,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            } \r\n\t        });\r\n\t        if ( model.get(\"status\") === \"offline\") {\r\n\t            _asmStatusNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(_asmStatusNode);\r\n\t\r\n\t        var _asmTitle = new graphic.Text({\r\n\t            style: {\r\n\t                x: _fullAsmX + 20,\r\n\t                y: _fullAsmY,\r\n\t                text: \"ASM\",\r\n\t                width: 190,\r\n\t                height: 20,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '18px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });       \r\n\t        this.add(_asmTitle);\r\n\t        \r\n\t        \r\n\t        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n\t        return _startY + fullDgHeight + 100;\r\n\t    };\r\n\t\r\n\t    ClusterAsmNode.prototype.addNodeByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this.api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    ClusterAsmNode.prototype.getNodeHeight  = function( p_count, p_height, p_num) {\r\n\t        var returnValue = 0;\r\n\t        if(  p_count % p_num !== 0 ) {\r\n\t            returnValue =  ( (parseInt(p_count) - parseInt(p_count) %  p_num) / p_num  + 1) * (p_height + 5) + 5;\r\n\t        } else {\r\n\t            returnValue =  ( parseInt(p_count) / p_num) * (p_height + 5)  + 5;\r\n\t        }\r\n\t        return returnValue;\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ClusterAsmNode, NetworkNode);\r\n\t    module.exports = ClusterAsmNode;\r\n\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function ClusterAsmCellNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ClusterAsmCellNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ClusterAsmCellNode.prototype.render = function(model, api) {\r\n\t        var _y = model.get(\"bounds.upperLeft.y\");\r\n\t        var _x = model.get(\"bounds.upperLeft.x\");\r\n\t        var _width = model.get(\"width\");\r\n\t        var _height = model.get(\"height\");\r\n\t        var cellNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                r: 10,\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                width: _width,\r\n\t                height: _height\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#88888B',\r\n\t                opacity: 1,\r\n\t                lineWidth: '2'//,\r\n\t            }          \r\n\t        });              \r\n\t        this.add(cellNode);\r\n\t\r\n\t        //状态 \r\n\t        var cellStateNode = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 10,\r\n\t                cy: 15,\r\n\t                r: _height / 2 - 10\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826'/*,\r\n\t                stroke: '#B3B3B3',\r\n\t                lineWidth: '2'//,*/\r\n\t            } \r\n\t        });\r\n\t        if ( model.get(\"status\") === \"offline\") {\r\n\t            cellStateNode.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(cellStateNode);\r\n\t\r\n\t        var cellTitle = new graphic.Text({\r\n\t            style: {\r\n\t                x: 20,\r\n\t                y: 5,\r\n\t                text: model.get(\"title\"),\r\n\t                width: 50,\r\n\t                height: 30,\r\n\t                fill: '#8F8B8A',\r\n\t                textFont: '14px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });       \r\n\t        this.add(cellTitle);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t\r\n\t    zrUtil.inherits(ClusterAsmCellNode, NetworkNode);\r\n\t    module.exports = ClusterAsmCellNode;\r\n\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    var ISEModel = __webpack_require__(111);\r\n\t    function ClusterIseNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ClusterIseNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ClusterIseNode.prototype.render = function(model, api) {\r\n\t        var iseList = model.get(\"childNodeList\");\r\n\t        var startX = 0;\r\n\t        var startY = 0;\r\n\t        var nodeWidth = 0;\r\n\t        for ( var i = 0; i < iseList.length; i++ ) {\r\n\t            var isedata = {\r\n\t                resourceId: util.getUUID(),  \r\n\t                bounds: {\r\n\t                    upperLeft: {x: startX, y: startY}  \r\n\t                },\r\n\t                stencil: {type: \"ClusterIseCellNode\"}\r\n\t            };\r\n\t            isedata.width = 100;\r\n\t            isedata.height = 150;\r\n\t            isedata.status = iseList[i].status;\r\n\t            isedata.title = iseList[i].name;\r\n\t            isedata.childNodeList = iseList[i].disk;\r\n\t            var iseCellModel = new ISEModel(isedata);\r\n\t            this.addNodeByModel(iseCellModel, api);\r\n\t            startX = startX + 100 + 50;\r\n\t            nodeWidth = nodeWidth + 150;\r\n\t        }\r\n\t\r\n\t        var _x = (api.getWidth() - nodeWidth) / 2;\r\n\t        this.position = [_x , model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t    ClusterIseNode.prototype.addNodeByModel = function( p_model, api) {\r\n\t        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n\t        var node = null;\r\n\t        if ( Shape ) {\r\n\t            node = new Shape(p_model, this.api);\r\n\t            this.add(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    ClusterIseNode.prototype.getDgNodeWidth  = function( p_count, p_height, p_space) {\r\n\t        var returnValue = 0;\r\n\t       \r\n\t        return returnValue;\r\n\t    };\r\n\t\r\n\t    zrUtil.inherits(ClusterIseNode, NetworkNode);\r\n\t    module.exports = ClusterIseNode;\r\n\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t    var util = __webpack_require__(71);\r\n\t    var NetworkNode = __webpack_require__(77);\r\n\t    var zrUtil = __webpack_require__(4);\r\n\t    var graphic = __webpack_require__(3);\r\n\t    var NetworkModel = __webpack_require__(74);\r\n\t    \r\n\t    function ClusterIseCellNode(model,api) {\r\n\t        NetworkNode.call(this, model, api);\r\n\t        this.rackkInfo = {type: -1, name: \"ClusterIseCellNode\" };    \r\n\t        this.model = model;\r\n\t        this.lineInfo = model.get('lineInfo');\r\n\t        this.render(model,api);\r\n\t    };\r\n\t\r\n\t    ClusterIseCellNode.prototype.render = function(model, api) {\r\n\t        var isecellNode = new graphic.Rect({\r\n\t            shape: {\r\n\t                r: 10,\r\n\t                x: 0,\r\n\t                y: 0,\r\n\t                width: 120,\r\n\t                height: 100\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#FFFFFF',\r\n\t                stroke: '#88888B',\r\n\t                opacity: 1,\r\n\t                lineWidth: '2'//,\r\n\t            }          \r\n\t        });              \r\n\t        this.add(isecellNode);\r\n\t\r\n\t        //状态 \r\n\t        var isecellStatus = new graphic.Circle({\r\n\t             shape: {\r\n\t                cx: 15,\r\n\t                cy: 45,\r\n\t                r: 5\r\n\t            },\r\n\t            style: {\r\n\t                fill: '#077826'/*,\r\n\t                stroke: '#89898B',\r\n\t                lineWidth: '2'//,*/\r\n\t            } \r\n\t        });\r\n\t        if ( model.get(\"status\") === \"offline\") {\r\n\t            isecellStatus.style.fill = \"#999999\";\r\n\t        }\r\n\t        this.add(isecellStatus);\r\n\t\r\n\t        var isecellTitle = new graphic.Text({\r\n\t            style: {\r\n\t                x: 25,\r\n\t                y: 35,\r\n\t                text: \"ISE: \" + model.get(\"title\"),\r\n\t                width: 50,\r\n\t                height: 30,\r\n\t                fill: '#020202',\r\n\t                textFont: '14px Microsoft Yahei',\r\n\t                textBaseline: 'top'\r\n\t            },\r\n\t            draggable: true\r\n\t        });       \r\n\t        this.add(isecellTitle);\r\n\t\r\n\t        this.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n\t    };\r\n\t\r\n\t\r\n\t    zrUtil.inherits(ClusterIseCellNode, NetworkNode);\r\n\t    module.exports = ClusterIseCellNode;\r\n\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(118);\n\t    __webpack_require__(59).registerPainter('vml', __webpack_require__(120));\n\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// http://www.w3.org/TR/NOTE-VML\n\t// TODO Use proxy like svg instead of overwrite brush methods\n\t\n\t\n\tif (!__webpack_require__(60).canvasSupported) {\n\t    var vec2 = __webpack_require__(14);\n\t    var BoundingRect = __webpack_require__(24);\n\t    var CMD = __webpack_require__(25).CMD;\n\t    var colorTool = __webpack_require__(19);\n\t    var textContain = __webpack_require__(23);\n\t    var RectText = __webpack_require__(22);\n\t    var Displayable = __webpack_require__(7);\n\t    var ZImage = __webpack_require__(40);\n\t    var Text = __webpack_require__(42);\n\t    var Path = __webpack_require__(6);\n\t\n\t    var Gradient = __webpack_require__(37);\n\t\n\t    var vmlCore = __webpack_require__(119);\n\t\n\t    var round = Math.round;\n\t    var sqrt = Math.sqrt;\n\t    var abs = Math.abs;\n\t    var cos = Math.cos;\n\t    var sin = Math.sin;\n\t    var mathMax = Math.max;\n\t\n\t    var applyTransform = vec2.applyTransform;\n\t\n\t    var comma = ',';\n\t    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\t\n\t    var Z = 21600;\n\t    var Z2 = Z / 2;\n\t\n\t    var ZLEVEL_BASE = 100000;\n\t    var Z_BASE = 1000;\n\t\n\t    var initRootElStyle = function (el) {\n\t        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n\t        el.coordsize = Z + ','  + Z;\n\t        el.coordorigin = '0,0';\n\t    };\n\t\n\t    var encodeHtmlAttribute = function (s) {\n\t        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n\t    };\n\t\n\t    var rgb2Str = function (r, g, b) {\n\t        return 'rgb(' + [r, g, b].join(',') + ')';\n\t    };\n\t\n\t    var append = function (parent, child) {\n\t        if (child && parent && child.parentNode !== parent) {\n\t            parent.appendChild(child);\n\t        }\n\t    };\n\t\n\t    var remove = function (parent, child) {\n\t        if (child && parent && child.parentNode === parent) {\n\t            parent.removeChild(child);\n\t        }\n\t    };\n\t\n\t    var getZIndex = function (zlevel, z, z2) {\n\t        // z 的取值范围为 [0, 1000]\n\t        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n\t    };\n\t\n\t    var parsePercent = function (value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    };\n\t\n\t    /***************************************************\n\t     * PATH\n\t     **************************************************/\n\t\n\t    var setColorAndOpacity = function (el, color, opacity) {\n\t        var colorArr = colorTool.parse(color);\n\t        opacity = +opacity;\n\t        if (isNaN(opacity)) {\n\t            opacity = 1;\n\t        }\n\t        if (colorArr) {\n\t            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n\t            el.opacity = opacity * colorArr[3];\n\t        }\n\t    };\n\t\n\t    var getColorAndAlpha = function (color) {\n\t        var colorArr = colorTool.parse(color);\n\t        return [\n\t            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n\t            colorArr[3]\n\t        ];\n\t    };\n\t\n\t    var updateFillNode = function (el, style, zrEl) {\n\t        // TODO pattern\n\t        var fill = style.fill;\n\t        if (fill != null) {\n\t            // Modified from excanvas\n\t            if (fill instanceof Gradient) {\n\t                var gradientType;\n\t                var angle = 0;\n\t                var focus = [0, 0];\n\t                // additional offset\n\t                var shift = 0;\n\t                // scale factor for offset\n\t                var expansion = 1;\n\t                var rect = zrEl.getBoundingRect();\n\t                var rectWidth = rect.width;\n\t                var rectHeight = rect.height;\n\t                if (fill.type === 'linear') {\n\t                    gradientType = 'gradient';\n\t                    var transform = zrEl.transform;\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                        applyTransform(p1, p1, transform);\n\t                    }\n\t                    var dx = p1[0] - p0[0];\n\t                    var dy = p1[1] - p0[1];\n\t                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n\t                    // The angle should be a non-negative number.\n\t                    if (angle < 0) {\n\t                        angle += 360;\n\t                    }\n\t\n\t                    // Very small angles produce an unexpected result because they are\n\t                    // converted to a scientific notation string.\n\t                    if (angle < 1e-6) {\n\t                        angle = 0;\n\t                    }\n\t                }\n\t                else {\n\t                    gradientType = 'gradientradial';\n\t                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n\t                    var transform = zrEl.transform;\n\t                    var scale = zrEl.scale;\n\t                    var width = rectWidth;\n\t                    var height = rectHeight;\n\t                    focus = [\n\t                        // Percent in bounding rect\n\t                        (p0[0] - rect.x) / width,\n\t                        (p0[1] - rect.y) / height\n\t                    ];\n\t                    if (transform) {\n\t                        applyTransform(p0, p0, transform);\n\t                    }\n\t\n\t                    width /= scale[0] * Z;\n\t                    height /= scale[1] * Z;\n\t                    var dimension = mathMax(width, height);\n\t                    shift = 2 * 0 / dimension;\n\t                    expansion = 2 * fill.r / dimension - shift;\n\t                }\n\t\n\t                // We need to sort the color stops in ascending order by offset,\n\t                // otherwise IE won't interpret it correctly.\n\t                var stops = fill.colorStops.slice();\n\t                stops.sort(function(cs1, cs2) {\n\t                    return cs1.offset - cs2.offset;\n\t                });\n\t\n\t                var length = stops.length;\n\t                // Color and alpha list of first and last stop\n\t                var colorAndAlphaList = [];\n\t                var colors = [];\n\t                for (var i = 0; i < length; i++) {\n\t                    var stop = stops[i];\n\t                    var colorAndAlpha = getColorAndAlpha(stop.color);\n\t                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\t                    if (i === 0 || i === length - 1) {\n\t                        colorAndAlphaList.push(colorAndAlpha);\n\t                    }\n\t                }\n\t\n\t                if (length >= 2) {\n\t                    var color1 = colorAndAlphaList[0][0];\n\t                    var color2 = colorAndAlphaList[1][0];\n\t                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n\t                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\t\n\t                    el.type = gradientType;\n\t                    el.method = 'none';\n\t                    el.focus = '100%';\n\t                    el.angle = angle;\n\t                    el.color = color1;\n\t                    el.color2 = color2;\n\t                    el.colors = colors.join(',');\n\t                    // When colors attribute is used, the meanings of opacity and o:opacity2\n\t                    // are reversed.\n\t                    el.opacity = opacity2;\n\t                    // FIXME g_o_:opacity ?\n\t                    el.opacity2 = opacity1;\n\t                }\n\t                if (gradientType === 'radial') {\n\t                    el.focusposition = focus.join(',');\n\t                }\n\t            }\n\t            else {\n\t                // FIXME Change from Gradient fill to color fill\n\t                setColorAndOpacity(el, fill, style.opacity);\n\t            }\n\t        }\n\t    };\n\t\n\t    var updateStrokeNode = function (el, style) {\n\t        // if (style.lineJoin != null) {\n\t        //     el.joinstyle = style.lineJoin;\n\t        // }\n\t        // if (style.miterLimit != null) {\n\t        //     el.miterlimit = style.miterLimit * Z;\n\t        // }\n\t        // if (style.lineCap != null) {\n\t        //     el.endcap = style.lineCap;\n\t        // }\n\t        if (style.lineDash != null) {\n\t            el.dashstyle = style.lineDash.join(' ');\n\t        }\n\t        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n\t            setColorAndOpacity(el, style.stroke, style.opacity);\n\t        }\n\t    };\n\t\n\t    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n\t        var isFill = type == 'fill';\n\t        var el = vmlEl.getElementsByTagName(type)[0];\n\t        // Stroke must have lineWidth\n\t        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n\t            // FIXME Remove before updating, or set `colors` will throw error\n\t            if (style[type] instanceof Gradient) {\n\t                remove(vmlEl, el);\n\t            }\n\t            if (!el) {\n\t                el = vmlCore.createNode(type);\n\t            }\n\t\n\t            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n\t            append(vmlEl, el);\n\t        }\n\t        else {\n\t            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n\t            remove(vmlEl, el);\n\t        }\n\t    };\n\t\n\t    var points = [[], [], []];\n\t    var pathDataToString = function (data, m) {\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        var str = [];\n\t        var nPoint;\n\t        var cmdStr;\n\t        var cmd;\n\t        var i;\n\t        var xi;\n\t        var yi;\n\t        for (i = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            cmdStr = '';\n\t            nPoint = 0;\n\t            switch (cmd) {\n\t                case M:\n\t                    cmdStr = ' m ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case L:\n\t                    cmdStr = ' l ';\n\t                    nPoint = 1;\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    points[0][0] = xi;\n\t                    points[0][1] = yi;\n\t                    break;\n\t                case Q:\n\t                case C:\n\t                    cmdStr = ' c ';\n\t                    nPoint = 3;\n\t                    var x1 = data[i++];\n\t                    var y1 = data[i++];\n\t                    var x2 = data[i++];\n\t                    var y2 = data[i++];\n\t                    var x3;\n\t                    var y3;\n\t                    if (cmd === Q) {\n\t                        // Convert quadratic to cubic using degree elevation\n\t                        x3 = x2;\n\t                        y3 = y2;\n\t                        x2 = (x2 + 2 * x1) / 3;\n\t                        y2 = (y2 + 2 * y1) / 3;\n\t                        x1 = (xi + 2 * x1) / 3;\n\t                        y1 = (yi + 2 * y1) / 3;\n\t                    }\n\t                    else {\n\t                        x3 = data[i++];\n\t                        y3 = data[i++];\n\t                    }\n\t                    points[0][0] = x1;\n\t                    points[0][1] = y1;\n\t                    points[1][0] = x2;\n\t                    points[1][1] = y2;\n\t                    points[2][0] = x3;\n\t                    points[2][1] = y3;\n\t\n\t                    xi = x3;\n\t                    yi = y3;\n\t                    break;\n\t                case A:\n\t                    var x = 0;\n\t                    var y = 0;\n\t                    var sx = 1;\n\t                    var sy = 1;\n\t                    var angle = 0;\n\t                    if (m) {\n\t                        // Extract SRT from matrix\n\t                        x = m[4];\n\t                        y = m[5];\n\t                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n\t                    }\n\t\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var startAngle = data[i++] + angle;\n\t                    var endAngle = data[i++] + startAngle + angle;\n\t                    // FIXME\n\t                    // var psi = data[i++];\n\t                    i++;\n\t                    var clockwise = data[i++];\n\t\n\t                    var x0 = cx + cos(startAngle) * rx;\n\t                    var y0 = cy + sin(startAngle) * ry;\n\t\n\t                    var x1 = cx + cos(endAngle) * rx;\n\t                    var y1 = cy + sin(endAngle) * ry;\n\t\n\t                    var type = clockwise ? ' wa ' : ' at ';\n\t                    if (Math.abs(x0 - x1) < 1e-10) {\n\t                        // IE won't render arches drawn counter clockwise if x0 == x1.\n\t                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n\t                            // Offset x0 by 1/80 of a pixel. Use something\n\t                            // that can be represented in binary\n\t                            if (clockwise) {\n\t                                x0 += 270 / Z;\n\t                            }\n\t                        }\n\t                        else {\n\t                            // Avoid case draw full circle\n\t                            if (Math.abs(y0 - cy) < 1e-10) {\n\t                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n\t                                    y1 -= 270 / Z;\n\t                                }\n\t                                else {\n\t                                    y1 += 270 / Z;\n\t                                }\n\t                            }\n\t                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n\t                                x1 += 270 / Z;\n\t                            }\n\t                            else {\n\t                                x1 -= 270 / Z;\n\t                            }\n\t                        }\n\t                    }\n\t                    str.push(\n\t                        type,\n\t                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n\t                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n\t                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n\t                        round((x0 * sx + x) * Z - Z2), comma,\n\t                        round((y0 * sy + y) * Z - Z2), comma,\n\t                        round((x1 * sx + x) * Z - Z2), comma,\n\t                        round((y1 * sy + y) * Z - Z2)\n\t                    );\n\t\n\t                    xi = x1;\n\t                    yi = y1;\n\t                    break;\n\t                case CMD.R:\n\t                    var p0 = points[0];\n\t                    var p1 = points[1];\n\t                    // x0, y0\n\t                    p0[0] = data[i++];\n\t                    p0[1] = data[i++];\n\t                    // x1, y1\n\t                    p1[0] = p0[0] + data[i++];\n\t                    p1[1] = p0[1] + data[i++];\n\t\n\t                    if (m) {\n\t                        applyTransform(p0, p0, m);\n\t                        applyTransform(p1, p1, m);\n\t                    }\n\t\n\t                    p0[0] = round(p0[0] * Z - Z2);\n\t                    p1[0] = round(p1[0] * Z - Z2);\n\t                    p0[1] = round(p0[1] * Z - Z2);\n\t                    p1[1] = round(p1[1] * Z - Z2);\n\t                    str.push(\n\t                        // x0, y0\n\t                        ' m ', p0[0], comma, p0[1],\n\t                        // x1, y0\n\t                        ' l ', p1[0], comma, p0[1],\n\t                        // x1, y1\n\t                        ' l ', p1[0], comma, p1[1],\n\t                        // x0, y1\n\t                        ' l ', p0[0], comma, p1[1]\n\t                    );\n\t                    break;\n\t                case CMD.Z:\n\t                    // FIXME Update xi, yi\n\t                    str.push(' x ');\n\t            }\n\t\n\t            if (nPoint > 0) {\n\t                str.push(cmdStr);\n\t                for (var k = 0; k < nPoint; k++) {\n\t                    var p = points[k];\n\t\n\t                    m && applyTransform(p, p, m);\n\t                    // 不 round 会非常慢\n\t                    str.push(\n\t                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n\t                        k < nPoint - 1 ? comma : ''\n\t                    );\n\t                }\n\t            }\n\t        }\n\t\n\t        return str.join('');\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    Path.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            vmlEl = vmlCore.createNode('shape');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        updateFillAndStroke(vmlEl, 'fill', style, this);\n\t        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\t\n\t        var m = this.transform;\n\t        var needTransform = m != null;\n\t        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\t        if (strokeEl) {\n\t            var lineWidth = style.lineWidth;\n\t            // Get the line scale.\n\t            // Determinant of this.m_ means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            if (needTransform && !style.strokeNoScale) {\n\t                var det = m[0] * m[3] - m[1] * m[2];\n\t                lineWidth *= sqrt(abs(det));\n\t            }\n\t            strokeEl.weight = lineWidth + 'px';\n\t        }\n\t\n\t        var path = this.path;\n\t        if (this.__dirtyPath) {\n\t            path.beginPath();\n\t            this.buildPath(path, this.shape);\n\t            path.toStatic();\n\t            this.__dirtyPath = false;\n\t        }\n\t\n\t        vmlEl.path = pathDataToString(path.data, this.transform);\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Path.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Path.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t    /***************************************************\n\t     * IMAGE\n\t     **************************************************/\n\t    var isImage = function (img) {\n\t        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n\t        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n\t        // return img instanceof Image;\n\t    };\n\t\n\t    // Rewrite the original path method\n\t    ZImage.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        var image = style.image;\n\t\n\t        // Image original width, height\n\t        var ow;\n\t        var oh;\n\t\n\t        if (isImage(image)) {\n\t            var src = image.src;\n\t            if (src === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t            else {\n\t                var imageRuntimeStyle = image.runtimeStyle;\n\t                var oldRuntimeWidth = imageRuntimeStyle.width;\n\t                var oldRuntimeHeight = imageRuntimeStyle.height;\n\t                imageRuntimeStyle.width = 'auto';\n\t                imageRuntimeStyle.height = 'auto';\n\t\n\t                // get the original size\n\t                ow = image.width;\n\t                oh = image.height;\n\t\n\t                // and remove overides\n\t                imageRuntimeStyle.width = oldRuntimeWidth;\n\t                imageRuntimeStyle.height = oldRuntimeHeight;\n\t\n\t                // Caching image original width, height and src\n\t                this._imageSrc = src;\n\t                this._imageWidth = ow;\n\t                this._imageHeight = oh;\n\t            }\n\t            image = src;\n\t        }\n\t        else {\n\t            if (image === this._imageSrc) {\n\t                ow = this._imageWidth;\n\t                oh = this._imageHeight;\n\t            }\n\t        }\n\t        if (!image) {\n\t            return;\n\t        }\n\t\n\t        var x = style.x || 0;\n\t        var y = style.y || 0;\n\t\n\t        var dw = style.width;\n\t        var dh = style.height;\n\t\n\t        var sw = style.sWidth;\n\t        var sh = style.sHeight;\n\t        var sx = style.sx || 0;\n\t        var sy = style.sy || 0;\n\t\n\t        var hasCrop = sw && sh;\n\t\n\t        var vmlEl = this._vmlEl;\n\t        if (!vmlEl) {\n\t            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n\t            // vmlEl = vmlCore.createNode('group');\n\t            vmlEl = vmlCore.doc.createElement('div');\n\t            initRootElStyle(vmlEl);\n\t\n\t            this._vmlEl = vmlEl;\n\t        }\n\t\n\t        var vmlElStyle = vmlEl.style;\n\t        var hasRotation = false;\n\t        var m;\n\t        var scaleX = 1;\n\t        var scaleY = 1;\n\t        if (this.transform) {\n\t            m = this.transform;\n\t            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n\t            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\t\n\t            hasRotation = m[1] || m[2];\n\t        }\n\t        if (hasRotation) {\n\t            // If filters are necessary (rotation exists), create them\n\t            // filters are bog-slow, so only create them if abbsolutely necessary\n\t            // The following check doesn't account for skews (which don't exist\n\t            // in the canvas spec (yet) anyway.\n\t            // From excanvas\n\t            var p0 = [x, y];\n\t            var p1 = [x + dw, y];\n\t            var p2 = [x, y + dh];\n\t            var p3 = [x + dw, y + dh];\n\t            applyTransform(p0, p0, m);\n\t            applyTransform(p1, p1, m);\n\t            applyTransform(p2, p2, m);\n\t            applyTransform(p3, p3, m);\n\t\n\t            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n\t            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\t\n\t            var transformFilter = [];\n\t            transformFilter.push('M11=', m[0] / scaleX, comma,\n\t                        'M12=', m[2] / scaleY, comma,\n\t                        'M21=', m[1] / scaleX, comma,\n\t                        'M22=', m[3] / scaleY, comma,\n\t                        'Dx=', round(x * scaleX + m[4]), comma,\n\t                        'Dy=', round(y * scaleY + m[5]));\n\t\n\t            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n\t            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\t            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n\t                + transformFilter.join('') + ', SizingMethod=clip)';\n\t\n\t        }\n\t        else {\n\t            if (m) {\n\t                x = x * scaleX + m[4];\n\t                y = y * scaleY + m[5];\n\t            }\n\t            vmlElStyle.filter = '';\n\t            vmlElStyle.left = round(x) + 'px';\n\t            vmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        var imageEl = this._imageEl;\n\t        var cropEl = this._cropEl;\n\t\n\t        if (!imageEl) {\n\t            imageEl = vmlCore.doc.createElement('div');\n\t            this._imageEl = imageEl;\n\t        }\n\t        var imageELStyle = imageEl.style;\n\t        if (hasCrop) {\n\t            // Needs know image original width and height\n\t            if (! (ow && oh)) {\n\t                var tmpImage = new Image();\n\t                var self = this;\n\t                tmpImage.onload = function () {\n\t                    tmpImage.onload = null;\n\t                    ow = tmpImage.width;\n\t                    oh = tmpImage.height;\n\t                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\t                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t\n\t                    // Caching image original width, height and src\n\t                    self._imageWidth = ow;\n\t                    self._imageHeight = oh;\n\t                    self._imageSrc = image;\n\t                };\n\t                tmpImage.src = image;\n\t            }\n\t            else {\n\t                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n\t                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\t            }\n\t\n\t            if (! cropEl) {\n\t                cropEl = vmlCore.doc.createElement('div');\n\t                cropEl.style.overflow = 'hidden';\n\t                this._cropEl = cropEl;\n\t            }\n\t            var cropElStyle = cropEl.style;\n\t            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n\t            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n\t            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n\t                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\t\n\t            if (! cropEl.parentNode) {\n\t                vmlEl.appendChild(cropEl);\n\t            }\n\t            if (imageEl.parentNode != cropEl) {\n\t                cropEl.appendChild(imageEl);\n\t            }\n\t        }\n\t        else {\n\t            imageELStyle.width = round(scaleX * dw) + 'px';\n\t            imageELStyle.height = round(scaleY * dh) + 'px';\n\t\n\t            vmlEl.appendChild(imageEl);\n\t\n\t            if (cropEl && cropEl.parentNode) {\n\t                vmlEl.removeChild(cropEl);\n\t                this._cropEl = null;\n\t            }\n\t        }\n\t\n\t        var filterStr = '';\n\t        var alpha = style.opacity;\n\t        if (alpha < 1) {\n\t            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n\t        }\n\t        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\t\n\t        imageELStyle.filter = filterStr;\n\t\n\t        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Append to root\n\t        append(vmlRoot, vmlEl);\n\t\n\t        // Text\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, this.getBoundingRect());\n\t        }\n\t    };\n\t\n\t    ZImage.prototype.onRemove = function (vmlRoot) {\n\t        remove(vmlRoot, this._vmlEl);\n\t\n\t        this._vmlEl = null;\n\t        this._cropEl = null;\n\t        this._imageEl = null;\n\t\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    ZImage.prototype.onAdd = function (vmlRoot) {\n\t        append(vmlRoot, this._vmlEl);\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t\n\t\n\t    /***************************************************\n\t     * TEXT\n\t     **************************************************/\n\t\n\t    var DEFAULT_STYLE_NORMAL = 'normal';\n\t\n\t    var fontStyleCache = {};\n\t    var fontStyleCacheCount = 0;\n\t    var MAX_FONT_CACHE_SIZE = 100;\n\t    var fontEl = document.createElement('div');\n\t\n\t    var getFontStyle = function (fontString) {\n\t        var fontStyle = fontStyleCache[fontString];\n\t        if (!fontStyle) {\n\t            // Clear cache\n\t            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n\t                fontStyleCacheCount = 0;\n\t                fontStyleCache = {};\n\t            }\n\t\n\t            var style = fontEl.style;\n\t            var fontFamily;\n\t            try {\n\t                style.font = fontString;\n\t                fontFamily = style.fontFamily.split(',')[0];\n\t            }\n\t            catch (e) {\n\t            }\n\t\n\t            fontStyle = {\n\t                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n\t                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n\t                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n\t                size: parseFloat(style.fontSize || 12) | 0,\n\t                family: fontFamily || 'Microsoft YaHei'\n\t            };\n\t\n\t            fontStyleCache[fontString] = fontStyle;\n\t            fontStyleCacheCount++;\n\t        }\n\t        return fontStyle;\n\t    };\n\t\n\t    var textMeasureEl;\n\t    // Overwrite measure text method\n\t    textContain.measureText = function (text, textFont) {\n\t        var doc = vmlCore.doc;\n\t        if (!textMeasureEl) {\n\t            textMeasureEl = doc.createElement('div');\n\t            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n\t                + 'padding:0;margin:0;border:none;white-space:pre;';\n\t            vmlCore.doc.body.appendChild(textMeasureEl);\n\t        }\n\t\n\t        try {\n\t            textMeasureEl.style.font = textFont;\n\t        } catch (ex) {\n\t            // Ignore failures to set to invalid font.\n\t        }\n\t        textMeasureEl.innerHTML = '';\n\t        // Don't use innerHTML or innerText because they allow markup/whitespace.\n\t        textMeasureEl.appendChild(doc.createTextNode(text));\n\t        return {\n\t            width: textMeasureEl.offsetWidth\n\t        };\n\t    };\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\t\n\t        var style = this.style;\n\t        var text = style.text;\n\t        if (!text) {\n\t            return;\n\t        }\n\t\n\t        var x;\n\t        var y;\n\t        var align = style.textAlign;\n\t        var fontStyle = getFontStyle(style.textFont);\n\t        // FIXME encodeHtmlAttribute ?\n\t        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n\t            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\t\n\t        var baseline = style.textBaseline;\n\t        var verticalAlign = style.textVerticalAlign;\n\t\n\t        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t        // Transform rect to view space\n\t        var m = this.transform;\n\t        // Ignore transform for text in other element\n\t        if (m && !fromTextEl) {\n\t            tmpRect.copy(rect);\n\t            tmpRect.applyTransform(m);\n\t            rect = tmpRect;\n\t        }\n\t\n\t        if (!fromTextEl) {\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t        }\n\t        else {\n\t            x = rect.x;\n\t            y = rect.y;\n\t        }\n\t        if (verticalAlign) {\n\t            switch (verticalAlign) {\n\t                case 'middle':\n\t                    y -= textRect.height / 2;\n\t                    break;\n\t                case 'bottom':\n\t                    y -= textRect.height;\n\t                    break;\n\t                // 'top'\n\t            }\n\t            // Ignore baseline\n\t            baseline = 'top';\n\t        }\n\t\n\t        var fontSize = fontStyle.size;\n\t        // 1.75 is an arbitrary number, as there is no info about the text baseline\n\t        switch (baseline) {\n\t            case 'hanging':\n\t            case 'top':\n\t                y += fontSize / 1.75;\n\t                break;\n\t            case 'middle':\n\t                break;\n\t            default:\n\t            // case null:\n\t            // case 'alphabetic':\n\t            // case 'ideographic':\n\t            // case 'bottom':\n\t                y -= fontSize / 2.25;\n\t                break;\n\t        }\n\t        switch (align) {\n\t            case 'left':\n\t                break;\n\t            case 'center':\n\t                x -= textRect.width / 2;\n\t                break;\n\t            case 'right':\n\t                x -= textRect.width;\n\t                break;\n\t            // case 'end':\n\t                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n\t                // break;\n\t            // case 'start':\n\t                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n\t                // break;\n\t            // default:\n\t            //     align = 'left';\n\t        }\n\t\n\t        var createNode = vmlCore.createNode;\n\t\n\t        var textVmlEl = this._textVmlEl;\n\t        var pathEl;\n\t        var textPathEl;\n\t        var skewEl;\n\t        if (!textVmlEl) {\n\t            textVmlEl = createNode('line');\n\t            pathEl = createNode('path');\n\t            textPathEl = createNode('textpath');\n\t            skewEl = createNode('skew');\n\t\n\t            // FIXME Why here is not cammel case\n\t            // Align 'center' seems wrong\n\t            textPathEl.style['v-text-align'] = 'left';\n\t\n\t            initRootElStyle(textVmlEl);\n\t\n\t            pathEl.textpathok = true;\n\t            textPathEl.on = true;\n\t\n\t            textVmlEl.from = '0 0';\n\t            textVmlEl.to = '1000 0.05';\n\t\n\t            append(textVmlEl, skewEl);\n\t            append(textVmlEl, pathEl);\n\t            append(textVmlEl, textPathEl);\n\t\n\t            this._textVmlEl = textVmlEl;\n\t        }\n\t        else {\n\t            // 这里是在前面 appendChild 保证顺序的前提下\n\t            skewEl = textVmlEl.firstChild;\n\t            pathEl = skewEl.nextSibling;\n\t            textPathEl = pathEl.nextSibling;\n\t        }\n\t\n\t        var coords = [x, y];\n\t        var textVmlElStyle = textVmlEl.style;\n\t        // Ignore transform for text in other element\n\t        if (m && fromTextEl) {\n\t            applyTransform(coords, coords, m);\n\t\n\t            skewEl.on = true;\n\t\n\t            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n\t            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\t\n\t            // Text position\n\t            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n\t            // Left top point as origin\n\t            skewEl.origin = '0 0';\n\t\n\t            textVmlElStyle.left = '0px';\n\t            textVmlElStyle.top = '0px';\n\t        }\n\t        else {\n\t            skewEl.on = false;\n\t            textVmlElStyle.left = round(x) + 'px';\n\t            textVmlElStyle.top = round(y) + 'px';\n\t        }\n\t\n\t        textPathEl.string = encodeHtmlAttribute(text);\n\t        // TODO\n\t        try {\n\t            textPathEl.style.font = font;\n\t        }\n\t        // Error font format\n\t        catch (e) {}\n\t\n\t        updateFillAndStroke(textVmlEl, 'fill', {\n\t            fill: fromTextEl ? style.fill : style.textFill,\n\t            opacity: style.opacity\n\t        }, this);\n\t        updateFillAndStroke(textVmlEl, 'stroke', {\n\t            stroke: fromTextEl ? style.stroke : style.textStroke,\n\t            opacity: style.opacity,\n\t            lineDash: style.lineDash\n\t        }, this);\n\t\n\t        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\t\n\t        // Attached to root\n\t        append(vmlRoot, textVmlEl);\n\t    };\n\t\n\t    var removeRectText = function (vmlRoot) {\n\t        remove(vmlRoot, this._textVmlEl);\n\t        this._textVmlEl = null;\n\t    };\n\t\n\t    var appendRectText = function (vmlRoot) {\n\t        append(vmlRoot, this._textVmlEl);\n\t    };\n\t\n\t    var list = [RectText, Displayable, ZImage, Path, Text];\n\t\n\t    // In case Displayable has been mixed in RectText\n\t    for (var i = 0; i < list.length; i++) {\n\t        var proto = list[i].prototype;\n\t        proto.drawRectText = drawRectText;\n\t        proto.removeRectText = removeRectText;\n\t        proto.appendRectText = appendRectText;\n\t    }\n\t\n\t    Text.prototype.brushVML = function (vmlRoot) {\n\t        var style = this.style;\n\t        if (style.text) {\n\t            this.drawRectText(vmlRoot, {\n\t                x: style.x || 0, y: style.y || 0,\n\t                width: 0, height: 0\n\t            }, this.getBoundingRect(), true);\n\t        }\n\t        else {\n\t            this.removeRectText(vmlRoot);\n\t        }\n\t    };\n\t\n\t    Text.prototype.onRemove = function (vmlRoot) {\n\t        this.removeRectText(vmlRoot);\n\t    };\n\t\n\t    Text.prototype.onAdd = function (vmlRoot) {\n\t        this.appendRectText(vmlRoot);\n\t    };\n\t}\n\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tif (!__webpack_require__(60).canvasSupported) {\n\t    var urn = 'urn:schemas-microsoft-com:vml';\n\t\n\t    var createNode;\n\t    var win = window;\n\t    var doc = win.document;\n\t\n\t    var vmlInited = false;\n\t\n\t    try {\n\t        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n\t        };\n\t    }\n\t    catch (e) {\n\t        createNode = function (tagName) {\n\t            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n\t        };\n\t    }\n\t\n\t    // From raphael\n\t    var initVML = function () {\n\t        if (vmlInited) {\n\t            return;\n\t        }\n\t        vmlInited = true;\n\t\n\t        var styleSheets = doc.styleSheets;\n\t        if (styleSheets.length < 31) {\n\t            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t        else {\n\t            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n\t            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n\t        }\n\t    };\n\t\n\t    // Not useing return to avoid error when converting to CommonJS module\n\t    module.exports = {\n\t        doc: doc,\n\t        initVML: initVML,\n\t        createNode: createNode\n\t    };\n\t}\n\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * VML Painter.\n\t *\n\t * @module zrender/vml/Painter\n\t */\n\t\n\t\n\t\n\t    var zrLog = __webpack_require__(20);\n\t    var vmlCore = __webpack_require__(119);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/vml/Painter\n\t     */\n\t    function VMLPainter(root, storage) {\n\t\n\t        vmlCore.initVML();\n\t\n\t        this.root = root;\n\t\n\t        this.storage = storage;\n\t\n\t        var vmlViewport = document.createElement('div');\n\t\n\t        var vmlRoot = document.createElement('div');\n\t\n\t        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\t\n\t        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\t\n\t        root.appendChild(vmlViewport);\n\t\n\t        this._vmlRoot = vmlRoot;\n\t        this._vmlViewport = vmlViewport;\n\t\n\t        this.resize();\n\t\n\t        // Modify storage\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            if (el) {\n\t                el.onRemove && el.onRemove(vmlRoot);\n\t            }\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            // Displayable already has a vml node\n\t            el.onAdd && el.onAdd(vmlRoot);\n\t\n\t            oldAddToMap.call(storage, el);\n\t        };\n\t\n\t        this._firstPaint = true;\n\t    }\n\t\n\t    VMLPainter.prototype = {\n\t\n\t        constructor: VMLPainter,\n\t\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._vmlViewport;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         */\n\t        refresh: function () {\n\t\n\t            var list = this.storage.getDisplayList(true, true);\n\t\n\t            this._paintList(list);\n\t        },\n\t\n\t        _paintList: function (list) {\n\t            var vmlRoot = this._vmlRoot;\n\t            for (var i = 0; i < list.length; i++) {\n\t                var el = list[i];\n\t                if (el.invisible || el.ignore) {\n\t                    if (!el.__alreadyNotVisible) {\n\t                        el.onRemove(vmlRoot);\n\t                    }\n\t                    // Set as already invisible\n\t                    el.__alreadyNotVisible = true;\n\t                }\n\t                else {\n\t                    if (el.__alreadyNotVisible) {\n\t                        el.onAdd(vmlRoot);\n\t                    }\n\t                    el.__alreadyNotVisible = false;\n\t                    if (el.__dirty) {\n\t                        el.beforeBrush && el.beforeBrush();\n\t                        (el.brushVML || el.brush).call(el, vmlRoot);\n\t                        el.afterBrush && el.afterBrush();\n\t                    }\n\t                }\n\t                el.__dirty = false;\n\t            }\n\t\n\t            if (this._firstPaint) {\n\t                // Detached from document at first time\n\t                // to avoid page refreshing too many times\n\t\n\t                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n\t                this._vmlViewport.appendChild(vmlRoot);\n\t                this._firstPaint = false;\n\t            }\n\t        },\n\t\n\t        resize: function () {\n\t            var width = this._getWidth();\n\t            var height = this._getHeight();\n\t\n\t            if (this._width != width && this._height != height) {\n\t                this._width = width;\n\t                this._height = height;\n\t\n\t                var vmlViewportStyle = this._vmlViewport.style;\n\t                vmlViewportStyle.width = width + 'px';\n\t                vmlViewportStyle.height = height + 'px';\n\t            }\n\t        },\n\t\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this._vmlRoot =\n\t            this._vmlViewport =\n\t            this.storage = null;\n\t        },\n\t\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        clear: function () {\n\t            this.root.removeChild(this.vmlViewport);\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientWidth || parseInt10(stl.width))\n\t                    - parseInt10(stl.paddingLeft)\n\t                    - parseInt10(stl.paddingRight)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = root.currentStyle;\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height))\n\t                    - parseInt10(stl.paddingTop)\n\t                    - parseInt10(stl.paddingBottom)) | 0;\n\t        }\n\t    };\n\t\n\t    // Not supported methods\n\t    function createMethodNotSupport(method) {\n\t        return function () {\n\t            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n\t        };\n\t    }\n\t\n\t    var notSupportedMethods = [\n\t        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n\t        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n\t    ];\n\t\n\t    for (var i = 0; i < notSupportedMethods.length; i++) {\n\t        var name = notSupportedMethods[i];\n\t        VMLPainter.prototype[name] = createMethodNotSupport(name);\n\t    }\n\t\n\t    module.exports = VMLPainter;\n\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d162046e59caad2d42f4\n **/","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-network/lib/FishTopoNetwork.js');\r\n\r\n//兼容IE8 引入VML 如果不需要兼容IE8请删除\r\nrequire('zrender/lib/vml/vml');\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.network.js\n ** module id = 1\n ** module chunks = 0\n **/","\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var ExtensionAPI = require('./ExtensionAPI');\r\n    var Eventful = require('zrender/lib/mixin/Eventful');\r\n    var zrender = require('zrender/lib/zrender');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var NetworkModel = require(\"./model/NetworkModel.js\");\r\n    var NetworkNode = require(\"./node/NetworkNode.js\");\r\n    var RackNode = require(\"./node/rack/RackNode.js\");\r\n    var NetworkUtil = require(\"./NetworkUtil.js\");\r\n\r\n    function FishTopoNetwork (dom, opts) {\r\n        /**\r\n         * @type {string}\r\n         */\r\n        this.id;\r\n        /**\r\n         * Group id\r\n         * @type {string}\r\n         */\r\n        this.group;\r\n\r\n        /**\r\n         * @type {HTMLDomElement}\r\n         * @private\r\n         */\r\n        this._dom = dom;\r\n\r\n        this.allNodes = [];\r\n\r\n        this._api = new ExtensionAPI(this);\r\n\r\n        this.tipNode = null;\r\n\r\n        /**\r\n         * @type {module:zrender/ZRender}\r\n         * @private\r\n         */\r\n        this._zr = init(this, opts); \r\n\r\n        Eventful.call(this);\r\n        if ( !NetworkNode.hasClass(\"RackNode\")) {\r\n            NetworkUtil.registerNetworkNode(); \r\n        }     \r\n    }\r\n\r\n    function init(p_this, p_opts) {\r\n\r\n        var topoDiv = '<div class=\"topoDiv\" id = \"topoDiv\" style=\"width:100%; height:100%; overflow:auto;\"></div>';\r\n        p_this._dom.innerHTML = topoDiv;\r\n        \r\n        var dom = document.getElementById(\"topoDiv\");\r\n\r\n        var zRenderer = zrender.init(dom, {\r\n            renderer: p_opts.renderer || 'canvas',\r\n            devicePixelRatio: p_opts.devicePixelRatio\r\n        });\r\n        return zRenderer;    \r\n    };\r\n\r\n    var fishTopoProto = FishTopoNetwork.prototype;\r\n\r\n    /**\r\n     * @return {HTMLDomElement}\r\n     */\r\n    fishTopoProto.getDom = function () {\r\n        return this._dom;\r\n    };\r\n\r\n    /**\r\n     * @return {module:zrender~ZRender}\r\n     */\r\n    fishTopoProto.getZr = function () {\r\n        return this._zr;\r\n    };\r\n    /**\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getWidth = function () {\r\n        return this._zr.getWidth();\r\n    };\r\n\r\n    /**\r\n     * @return {number}\r\n     */\r\n    fishTopoProto.getHeight = function () {\r\n        return this._zr.getHeight();\r\n    };\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     */\r\n    fishTopoProto.resize = function ( p_width, p_height) {\r\n        p_width = p_width !== undefined ? p_width : this.getWidth;\r\n        p_height = p_height !== undefined ? p_height : this.getHeight() - 50;\r\n        this._zr.painter.resize(p_width, p_height);\r\n    }; \r\n\r\n    /**\r\n     * 根据模型增加节点\r\n     * @param {[type]} model [description]\r\n     */\r\n    fishTopoProto.addNodeByModel = function(model) {\r\n        var that = this;\r\n        var Shape = NetworkNode.getClass(model.get(\"stencil.type\"));\r\n        if (Shape) {\r\n            node = new Shape(model, this._api);\r\n            this._zr.add(node); \r\n            node.on('click',function(e){\r\n                that._api.trigger(e, {});  \r\n            });         \r\n        }         \r\n             \r\n    };  \r\n\r\n    fishTopoProto.getNodeClass = function (className) {\r\n        return NetworkNode.getClass(className);\r\n    };\r\n\r\n    /**\r\n     * 鼠标悬停提示框展示\r\n     * @param {[type]} model [description]\r\n     */\r\n    fishTopoProto.showTipWindow = function(model) {\r\n        var Shape = NetworkNode.getClass(\"TipWindowNode\");\r\n        if (Shape) {\r\n            var height = this._zr.getHeight();           \r\n            if( this.allWidth != undefined ) {\r\n                this._zr.painter.resize( this.allWidth + model.width, 730);\r\n            }\r\n            \r\n            var node = new Shape(model, this._api);\r\n            this._zr.add(node); \r\n            this.tipNode = node;\r\n            // node.on('mousedown',function(e){\r\n            //     //that.newDrag(this,e.event.clientX,e.event.clientY);   \r\n            // });         \r\n        }         \r\n\r\n    };\r\n\r\n    /**\r\n     * 鼠标悬停提示框展示\r\n     * @param {[type]} model [description]\r\n     */\r\n    fishTopoProto.hideTipWindow = function(model) { \r\n        if (this.tipNode && this.tipNode !== null ) {\r\n            this._zr.remove(this.tipNode);      \r\n        }         \r\n    };\r\n\r\n    fishTopoProto.init = function () {\r\n        var isSelected = this.isSelected;\r\n                \r\n    };\r\n\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n    };   \r\n\r\n    fishTopoProto.exportJson = function() {\r\n        var networkModel = new NetworkModel({});\r\n        networkModel.set(\"resourceId\", util.getUUID());\r\n        return NetworkUtil.exportJson(networkModel, this.allNodes);\r\n    };\r\n\r\n    fishTopoProto.drawFromJson = function(json) {\r\n        var topoType = json.type;\r\n        if ( topoType === \"rack\" ) {\r\n            var clientWidth = this._zr.getWidth();\r\n            if ( (50 + (json.data.length * 250)) > clientWidth ) {\r\n                this._zr.painter.resize( 50 + (json.data.length * 250), 730);\r\n                if ( clientWidth < this._zr.getWidth() ) {\r\n                    this.allWidth = this._zr.getWidth();\r\n                }\r\n            } \r\n        } else if ( topoType === \"topo\" ) {\r\n            var clientWidth = this._zr.getWidth();\r\n            var clientHeight = 700;\r\n            this.width = clientWidth;\r\n            this.height = clientHeight;\r\n        }\r\n        else if ( topoType === \"cluster\" ) {\r\n            var clientWidth = this._zr.getWidth();\r\n            var clientHeight = 630;\r\n            this.width = clientWidth;\r\n            this.height = clientHeight;\r\n        }\r\n        return NetworkUtil.fromJson(this, json);\r\n    };  \r\n\r\n    zrUtil.mixin(FishTopoNetwork, Eventful);\r\n\r\n    // ---------对外暴露fishTopoNetWork------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoNetwork_instance_';\r\n    var fishTopoNetWork = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '1.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoNetWork.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        zrUtil.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoNetWork = new FishTopoNetwork(dom, opts);\r\n        fishTopoNetWork.init();\r\n\r\n        fishTopoNetWork.id = 'ft_' + idBase++;\r\n        instances[fishTopoNetWork.id] = fishTopoNetWork;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoNetWork.id);\r\n\r\n        return fishTopoNetWork;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoNetWork.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoNetWork.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoNetWork.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoNetWork) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoNetWork;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/FishTopoNetwork.js\n ** module id = 2\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n    var Draggable = require('zrender/lib/mixin/Draggable');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        Draggable.call(path);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n\r\n        zrUtil.inherits(path, Draggable);\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath;\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    graphic.setNormalStyle = function(el, options) {\r\n        if (el.__normalStl) {\r\n            for (var name in options) {\r\n                if (el.__normalStl.hasOwnProperty(name)) {\r\n                    el.__normalStl[name] = options[name];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/graphic.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * @module zrender/core/util\n */\n\n\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1,\n        '[object CanvasPattern]': 1,\n        // In node-canvas Image can be Canvas.Image\n        '[object Image]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * @param {*} source\n     * @return {*} 拷贝后的新对象\n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n            else if (\n                !isBuildInObject(source)\n                // 是否为 dom 对象\n                && !isDom(source)\n            ) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        return source;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @memberOf module:zrender/core/util\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     * @memberOf module:zrender/core/util\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     * @memberOf module:zrender/core/util\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @memberOf module:zrender/core/util\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/core/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/core/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Function} func\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1\n               && typeof(value.nodeName) == 'string';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @memberOf module:zrender/core/util\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @memberOf module:zrender/core/util\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/util.js\n ** module id = 4\n ** module chunks = 0\n **/","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n            this.dirty(true);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            for (var i = 0; i < len; i++) {\n                var pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape, true);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/path.js\n ** module id = 5\n ** module chunks = 0\n **/","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Pattern = require('./Pattern');\n    var getCanvasPattern = Pattern.prototype.getCanvasPattern;\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = style.hasStroke();\n            var hasFill = style.hasFill();\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!(fill.colorStops);\n            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);\n            var hasFillPattern = hasFill && !!(fill.image);\n            var hasStrokePattern = hasStroke && !!(stroke.image);\n\n            style.bind(ctx, this, prevEl);\n            this.setTransform(ctx);\n\n            if (this.__dirty) {\n                var rect = this.getBoundingRect();\n                // Update gradient because bounding rect may changed\n                if (hasFillGradient) {\n                    this._fillGradient = style.getGradient(ctx, fill, rect);\n                }\n                if (hasStrokeGradient) {\n                    this._strokeGradient = style.getGradient(ctx, stroke, rect);\n                }\n            }\n            // Use the gradient or pattern\n            if (hasFillGradient) {\n                // PENDING If may have affect the state\n                ctx.fillStyle = this._fillGradient;\n            }\n            else if (hasFillPattern) {\n                ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = this._strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n            }\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Update path sx, sy\n            var scale = this.getGlobalScale();\n            path.setScale(scale[0], scale[1]);\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape, false);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            if (lineDash && ctxLineDash) {\n                // PENDING\n                // Remove lineDash\n                ctx.setLineDash([]);\n            }\n\n\n            this.restoreTransform(ctx);\n\n            // Draw rect text\n            if (style.text || style.text === 0) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n        },\n\n        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n        // Like in circle\n        buildPath: function (ctx, shapeCfg, inBundle) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n\n            if (style.hasStroke()) {\n                // Needs update rect with stroke lineWidth when\n                // 1. Element changes scale or lineWidth\n                // 2. Shape is changed\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    // FIXME Must after updateTransform\n                    var w = style.lineWidth;\n                    // PENDING, Min line width is needed when line is horizontal or vertical\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                    // Only add extra hover lineWidth when there are no fill\n                    if (!style.hasFill()) {\n                        w = Math.max(w, this.strokeContainThreshold || 4);\n                    }\n                    // Consider line width\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n\n                // Return rect with stroke\n                return rectWithStroke;\n            }\n\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (style.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!style.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (style.hasFill()) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (dirtyPath == null) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n                this.__dirtyPath = true;\n                this._rect = null;\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Path.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        /**\n         * Render the element progressively when the value >= 0,\n         * usefull for large data.\n         * @type {number}\n         */\n        progressive: -1,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx, prevEl) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty(false);\n            return this;\n        },\n\n        /**\n         * Use given style object\n         * @param  {Object} obj\n         */\n        useStyle: function (obj) {\n            this.style = new Style(obj);\n            this.dirty(false);\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Displayable.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/Style\n */\n\n\n    var STYLE_COMMON_PROPS = [\n        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n\n    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    function createLinearGradient(ctx, obj, rect) {\n        // var size =\n        var x = obj.x;\n        var x2 = obj.x2;\n        var y = obj.y;\n        var y2 = obj.y2;\n\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n        return canvasGradient;\n    }\n\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n\n        var x = obj.x;\n        var y = obj.y;\n        var r = obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n        return canvasGradient;\n    }\n\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * Only useful in Path and Image element\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * If transform text\n         * Only useful in Path and Image element\n         * @type {boolean}\n         */\n        textTransform: false,\n\n        /**\n         * Text rotate around position of Path or Image\n         * Only useful in Path and Image element and textTransform is false.\n         */\n        textRotation: 0,\n\n        /**\n         * @type {string}\n         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n         */\n        blend: null,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el, prevEl) {\n            var style = this;\n            var prevStyle = prevEl && prevEl.style;\n            var firstDraw = !prevStyle;\n\n            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n                var prop = STYLE_COMMON_PROPS[i];\n                var styleName = prop[0];\n\n                if (firstDraw || style[styleName] !== prevStyle[styleName]) {\n                    // FIXME Invalid property value will cause style leak from previous element.\n                    ctx[styleName] = style[styleName] || prop[1];\n                }\n            }\n\n            if ((firstDraw || style.fill !== prevStyle.fill)) {\n                ctx.fillStyle = style.fill;\n            }\n            if ((firstDraw || style.stroke !== prevStyle.stroke)) {\n                ctx.strokeStyle = style.stroke;\n            }\n            if ((firstDraw || style.opacity !== prevStyle.opacity)) {\n                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n            }\n\n            if ((firstDraw || style.blend !== prevStyle.blend)) {\n                ctx.globalCompositeOperation = style.blend || 'source-over';\n            }\n            if (this.hasStroke()) {\n                var lineWidth = style.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n        },\n\n        hasFill: function () {\n            var fill = this.fill;\n            return fill != null && fill !== 'none';\n        },\n\n        hasStroke: function () {\n            var stroke = this.stroke;\n            return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        },\n\n        getGradient: function (ctx, obj, rect) {\n            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n            var canvasGradient = method(ctx, obj, rect);\n            var colorStops = obj.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n            return canvasGradient;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n        var prop = STYLE_COMMON_PROPS[i];\n        if (!(prop[0] in styleProto)) {\n            styleProto[prop[0]] = prop[1];\n        }\n    }\n\n    // Provide for others\n    Style.getGradient = styleProto.getGradient;\n\n    module.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Style.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty(false);\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n\n            this.dirty(false);\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty(false);\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty(false);\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Element.js\n ** module id = 9\n ** module chunks = 0\n **/","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n    var idStart = 0x0907;\n\n    module.exports = function () {\n        return idStart++;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/guid.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Eventful.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    };\n\n    transformableProto.restoreTransform = function (ctx) {\n        var m = this.transform;\n        var dpr = ctx.dpr || 1;\n        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    }\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * Get global scale\n     * @return {Array.<number>}\n     */\n    transformableProto.getGlobalScale = function () {\n        var m = this.transform;\n        if (!m) {\n            return [1, 1];\n        }\n        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        return [sx, sy];\n    };\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Transformable.js\n ** module id = 12\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/matrix.js\n ** module id = 13\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            if (x == null) {\n                x = 0;\n            }\n            if (y == null) {\n                y = 0;\n            }\n            out[0] = x;\n            out[1] = y;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/vector.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Animatable.js\n ** module id = 15\n ** module chunks = 0\n **/","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    // arr0 is source array, arr1 is target array.\n    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            // FIXME Not work for TypedArray\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                // Cut the previous\n                arr0.length = arr1Len;\n            }\n            else {\n                // Fill the previous\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(\n                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                    );\n                }\n            }\n        }\n        // Handling NaN value\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        var lastValue = kfValues[trackLen - 1];\n        // Polyfill array and NaN value\n        for (var i = 0; i < trackLen - 1; i++) {\n            if (isValueArray) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            else {\n                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n                    kfValues[i] = lastValue;\n                }\n            }\n        }\n        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            // In the easing function like elasticOut, percent may less than 0\n            if (percent < 0) {\n                frame = 0;\n            }\n            else if (percent < lastFramePercent) {\n                // Start from next key\n                // PENDING start from lastFrame ?\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                // PENDING really need to do this ?\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animator.js\n ** module id = 16\n ** module chunks = 0\n **/","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (globalTime) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (globalTime - this._startTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart (globalTime);\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function (globalTime) {\n            var remainder = (globalTime - this._startTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Clip.js\n ** module id = 17\n ** module chunks = 0\n **/","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/easing.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/color.js\n ** module id = 19\n ** module chunks = 0\n **/","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/log.js\n ** module id = 20\n ** module chunks = 0\n **/","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/config.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n\n            // FIXME\n            ctx.save();\n\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            if (!style.textTransform) {\n                if (transform) {\n                    tmpRect.copy(rect);\n                    tmpRect.applyTransform(transform);\n                    rect = tmpRect;\n                }\n            }\n            else {\n                this.setTransform(ctx);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n\n                if (verticalAlign) {\n                    switch (verticalAlign) {\n                        case 'middle':\n                            y -= textRect.height / 2 - textRect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= textRect.height - textRect.lineHeight / 2;\n                            break;\n                        default:\n                            y += textRect.lineHeight / 2;\n                    }\n                    // Force bseline to be middle\n                    baseline = 'middle';\n                }\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            // Use canvas default left textAlign. Giving invalid value will cause state not change\n            ctx.textAlign = align || 'left';\n            // Use canvas default alphabetic baseline\n            ctx.textBaseline = baseline || 'alphabetic';\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n\n            // TODO Invalid font\n            ctx.font = font || '12px sans-serif';\n\n            // Text shadow\n            // Always set shadowBlur and shadowOffset to avoid leak from displayable\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowColor = style.textShadowColor || 'transparent';\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n\n            if (style.textRotation) {\n                transform && ctx.translate(transform[4], transform[5]);\n                ctx.rotate(style.textRotation);\n                transform && ctx.translate(-transform[4], -transform[5]);\n            }\n\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            ctx.restore();\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/mixin/RectText.js\n ** module id = 22\n ** module chunks = 0\n **/","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n    var retrieve = util.retrieve;\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} containerWidth\n     * @param  {string} textFont\n     * @param  {number} [ellipsis='...']\n     * @param  {Object} [options]\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minChar=0] If truncate result are less\n     *                  then minChar, ellipsis will not show, which is\n     *                  better for user hint in some cases.\n     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n     * @return {string}\n     */\n    function truncateText(text, containerWidth, textFont, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = options || {};\n\n        ellipsis = retrieve(ellipsis, '...');\n        var maxIterations = retrieve(options.maxIterations, 2);\n        var minChar = retrieve(options.minChar, 0);\n        // FIXME\n        // Other languages?\n        var cnCharWidth = getTextWidth('国', textFont);\n        // FIXME\n        // Consider proportional font?\n        var ascCharWidth = getTextWidth('a', textFont);\n        var placeholder = retrieve(options.placeholder, '');\n\n        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n\n        var ellipsisWidth = getTextWidth(ellipsis);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n\n        contentWidth = containerWidth - ellipsisWidth;\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            var textLine = textLines[i];\n            var lineWidth = getTextWidth(textLine, textFont);\n\n            if (lineWidth <= containerWidth) {\n                continue;\n            }\n\n            for (var j = 0;; j++) {\n                if (lineWidth <= contentWidth || j >= maxIterations) {\n                    textLine += ellipsis;\n                    break;\n                }\n\n                var subLength = j === 0\n                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)\n                    : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n\n                textLine = textLine.substr(0, subLength);\n                lineWidth = getTextWidth(textLine, textFont);\n            }\n\n            if (textLine === '') {\n                textLine = placeholder;\n            }\n\n            textLines[i] = textLine;\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        truncateText: truncateText,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont || '12px sans-serif';\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/text.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n\n    module.exports = BoundingRect;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/BoundingRect.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n    var dpr = require('../config').devicePixelRatio;\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n    var mathAbs = Math.abs;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n\n        // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n        this._ux = 0;\n        this._uy = 0;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        /**\n         * @readOnly\n         */\n        setScale: function (sx, sy) {\n            this._ux = mathAbs(1 / dpr / sx) || 0;\n            this._uy = mathAbs(1 / dpr / sy) || 0;\n        },\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            ctx && (this.dpr = ctx.dpr);\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                // Force draw the first segment\n                || this._len < 5;\n\n            this.addData(CMD.L, x, y);\n\n            if (this._ctx && exceedUnit) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            var x0, y0;\n            var xi, yi;\n            var x, y;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            for (var i = 0; i < len;) {\n                var cmd = d[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = d[i];\n                    yi = d[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L:\n                        x = d[i++];\n                        y = d[i++];\n                        // Not draw too small seg between\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        xi = d[i - 2];\n                        yi = d[i - 1];\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        var endAngle = theta + dTheta;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n                        }\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(theta) * rx + cx;\n                            y0 = mathSin(theta) * ry + cy;\n                        }\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/PathProxy.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/curve.js\n ** module id = 26\n ** module chunks = 0\n **/","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    var xDim = [];\n    var yDim = [];\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n\n        for (i = 0; i < n; i++) {\n            var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin(x, min[0]);\n            max[0] = mathMax(x, max[0]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin(y, min[1]);\n            max[1] = mathMax(y, max[1]);\n        }\n\n        min[0] = mathMin(x0, min[0]);\n        max[0] = mathMax(x0, max[0]);\n        min[0] = mathMin(x3, min[0]);\n        max[0] = mathMax(x3, max[0]);\n\n        min[1] = mathMin(y0, min[1]);\n        max[1] = mathMax(y0, max[1]);\n        min[1] = mathMin(y3, min[1]);\n        max[1] = mathMax(y3, max[1]);\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/bbox.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n\n                // Avoid winding error when intersection point is the connect point of two line of polygon\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    // Remove one endpoint.\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {   // Quick reject\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                // Remove one endpoint.\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {   // Quick reject\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                // if (w !== 0) {\n                //     return true;\n                // }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        // FIXME subpaths may overlap\n                        // if (w !== 0) {\n                        //     return true;\n                        // }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/path.js\n ** module id = 28\n ** module chunks = 0\n **/","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/line.js\n ** module id = 29\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/cubic.js\n ** module id = 30\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/quadratic.js\n ** module id = 31\n ** module chunks = 0\n **/","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/arc.js\n ** module id = 32\n ** module chunks = 0\n **/","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/util.js\n ** module id = 33\n ** module chunks = 0\n **/","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        // Ignore horizontal line\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n\n        // Avoid winding error when intersection point is the connect point of two line of polygon\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/windingLine.js\n ** module id = 34\n ** module chunks = 0\n **/","\n\n    var Pattern = function (image, repeat) {\n        this.image = image;\n        this.repeat = repeat;\n\n        // Can be cloned\n        this.type = 'pattern';\n    };\n\n    Pattern.prototype.getCanvasPattern = function (ctx) {\n\n        return this._canvasPattern\n            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));\n    };\n\n    module.exports = Pattern;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Pattern.js\n ** module id = 35\n ** module chunks = 0\n **/","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/transformPath.js\n ** module id = 36\n ** module chunks = 0\n **/","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Gradient.js\n ** module id = 37\n ** module chunks = 0\n **/","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this.dispatchToElement(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this.dispatchToElement(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.dispatchToElement(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this.dispatchToElement(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this.dispatchToElement(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Draggable.js\n ** module id = 38\n ** module chunks = 0\n **/","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        isGroup: true,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * 所有子孙元素是否响应鼠标事件\n         * @name module:/zrender/container/Group#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/container/Group.js\n ** module id = 39\n ** module chunks = 0\n **/","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function ZImage(opts) {\n        Displayable.call(this, opts);\n    }\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n\n            // Must bind each time\n            style.bind(ctx, this, prevEl);\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                // 设置transform\n                this.setTransform(ctx);\n\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                this.restoreTransform(ctx);\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Image.js\n ** module id = 40\n ** module chunks = 0\n **/","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/LRU.js\n ** module id = 41\n ** module chunks = 0\n **/","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n *\n * Text not support gradient\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx, prevEl) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n\n            // Convert to string\n            text != null && (text += '');\n\n            // Always bind style\n            style.bind(ctx, this, prevEl);\n\n            if (text) {\n\n                this.setTransform(ctx);\n\n                var textBaseline;\n                var textAlign = style.textAlign;\n                var font = style.textFont || style.font;\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    textBaseline = 'middle';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2 - rect.lineHeight / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height - rect.lineHeight / 2;\n                            break;\n                        default:\n                            y += rect.lineHeight / 2;\n                    }\n                }\n                else {\n                    textBaseline = style.textBaseline;\n                }\n\n                // TODO Invalid font\n                ctx.font = font || '12px sans-serif';\n                ctx.textAlign = textAlign || 'left';\n                // Use canvas default left textAlign. Giving invalid value will cause state not change\n                if (ctx.textAlign !== textAlign) {\n                    ctx.textAlign = 'left';\n                }\n                ctx.textBaseline = textBaseline || 'alphabetic';\n                // Use canvas default alphabetic baseline\n                if (ctx.textBaseline !== textBaseline) {\n                    ctx.textBaseline = 'alphabetic';\n                }\n\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    style.hasFill() && ctx.fillText(textLines[i], x, y);\n                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                this.restoreTransform(ctx);\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var textVerticalAlign = style.textVerticalAlign;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign,\n                    textVerticalAlign ? 'top' : style.textBaseline\n                );\n                switch (textVerticalAlign) {\n                    case 'middle':\n                        rect.y -= rect.height / 2;\n                        break;\n                    case 'bottom':\n                        rect.y -= rect.height;\n                        break;\n                }\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Text.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n\n        buildPath : function (ctx, shape, inBundle) {\n            // Better stroking in ShapeBundle\n            // Always do it may have performence issue ( fill may be 2x more cost)\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            // Better stroking in ShapeBundle\n            // ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Circle.js\n ** module id = 43\n ** module chunks = 0\n **/","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Sector.js\n ** module id = 44\n ** module chunks = 0\n **/","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Ring.js\n ** module id = 45\n ** module chunks = 0\n **/","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polygon.js\n ** module id = 46\n ** module chunks = 0\n **/","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/poly.js\n ** module id = 47\n ** module chunks = 0\n **/","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothSpline.js\n ** module id = 48\n ** module chunks = 0\n **/","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothBezier.js\n ** module id = 49\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polyline.js\n ** module id = 50\n ** module chunks = 0\n **/","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Rect.js\n ** module id = 51\n ** module chunks = 0\n **/","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/roundRect.js\n ** module id = 52\n ** module chunks = 0\n **/","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Line.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var vec2 = require('../../core/vector');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;\n    var cubicDerivativeAt = curveTool.cubicDerivativeAt;\n\n    var out = [];\n\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        pointAt: function (t) {\n            return someVectorAt(this.shape, t, false);\n        },\n\n        /**\n         * Get tangent at percent\n         * @param  {number} t\n         * @return {Array.<number>}\n         */\n        tangentAt: function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return vec2.normalize(p, p);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/BezierCurve.js\n ** module id = 54\n ** module chunks = 0\n **/","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Arc.js\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     * @param {boolean} [globalCoord=false]\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        // Can be cloned\n        this.type = 'linear';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/LinearGradient.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     * @param {boolean} [globalCoord=false]\n     */\n    var RadialGradient = function (x, y, r, colorStops, globalCoord) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        // Can be cloned\n        this.type = 'radial';\n\n        // If use global coord\n        this.global = globalCoord || false;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/RadialGradient.js\n ** module id = 57\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var apiList = [\r\n        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction',\r\n        'on', 'off', 'trigger', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getNodeClass', 'showTipWindow', 'hideTipWindow', 'resize', 'clear'\r\n    ];\r\n\r\n    function ExtensionAPI(instance) {\r\n        zrUtil.each(apiList, function (name) {\r\n            this[name] = zrUtil.bind(instance[name], instance);\r\n        }, this);\r\n    }\r\n\r\n    module.exports = ExtensionAPI;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/ExtensionAPI.js\n ** module id = 58\n ** module chunks = 0\n **/","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n    var HandlerProxy = require('./dom/HandlerProxy');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.1.3';\n\n    /**\n     * Initializing a zrender instance\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * Get zrender instance by id\n     * @param {string} id zrender instance id\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n\n        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;\n        this.handler = new Handler(storage, painter, handerProxy);\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                    if (self._needsRefreshHover) {\n                        self.refreshHoverImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Change configuration of layer\n         * @param {string} zLevel\n         * @param {Object} config\n         * @param {string} [config.clearColor=0] Clear color\n         * @param {string} [config.motionBlur=false] If enable motion blur\n         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Repaint the canvas immediately\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * Mark and repaint the canvas in the next frame of browser\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * Add element to hover layer\n         * @param  {module:zrender/Element} el\n         * @param {Object} style\n         */\n        addHover: function (el, style) {\n            if (this.painter.addHover) {\n                this.painter.addHover(el, style);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Add element from hover layer\n         * @param  {module:zrender/Element} el\n         */\n        removeHover: function (el) {\n            if (this.painter.removeHover) {\n                this.painter.removeHover(el);\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Clear all hover elements in hover layer\n         * @param  {module:zrender/Element} el\n         */\n        clearHover: function () {\n            if (this.painter.clearHover) {\n                this.painter.clearHover();\n                this.refreshHover();\n            }\n        },\n\n        /**\n         * Refresh hover in next frame\n         */\n        refreshHover: function () {\n            this._needsRefreshHover = true;\n        },\n\n        /**\n         * Refresh hover immediately\n         */\n        refreshHoverImmediately: function () {\n            this._needsRefreshHover = false;\n            this.painter.refreshHover && this.painter.refreshHover();\n        },\n\n        /**\n         * Resize the canvas.\n         * Should be invoked when container size is changed\n         */\n        resize: function() {\n            this.painter.resize();\n            this.handler.resize();\n        },\n\n        /**\n         * Stop and clear all animation immediately\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * Get container width\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * Get container height\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * Export the canvas as Base64 URL\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff']\n         * @return {string} Base64 URL\n         */\n        // toDataURL: function(type, backgroundColor) {\n        //     return this.painter.getRenderedCanvas({\n        //         backgroundColor: backgroundColor\n        //     }).toDataURL(type);\n        // },\n\n        /**\n         * Converting a path to image.\n         * It has much better performance of drawing image rather than drawing a vector path.\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * Set default cursor\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        },\n\n        /**\n         * Bind event\n         *\n         * @param {string} eventName Event name\n         * @param {Function} eventHandler Handler function\n         * @param {Object} [context] Context object\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * Unbind event\n         * @param {string} eventName Event name\n         * @param {Function} [eventHandler] Handler function\n         */\n        off: function(eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * Trigger event manually\n         *\n         * @param {string} eventName Event name\n         * @param {event=} event Event object\n         */\n        trigger: function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * Clear all objects and the canvas.\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * Dispose self.\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/zrender.js\n ** module id = 59\n ** module chunks = 0\n **/","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        // var touchpad = webos && ua.match(/TouchPad/);\n        // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        // var silk = ua.match(/Silk\\/([\\d._]+)/);\n        // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        // var playbook = ua.match(/PlayBook/);\n        // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        // if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        // if (android) os.android = true, os.version = android[2];\n        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        // if (webos) os.webos = true, os.version = webos[2];\n        // if (touchpad) os.touchpad = true;\n        // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        // if (bb10) os.bb10 = true, os.version = bb10[2];\n        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        // if (playbook) browser.playbook = true;\n        // if (kindle) os.kindle = true, os.version = kindle[1];\n        // if (silk) browser.silk = true, browser.version = silk[1];\n        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        // if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) browser.firefox = true, browser.version = firefox[1];\n        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        // if (webview) browser.webview = true;\n        if (ie) {\n            browser.ie = true; browser.version = ie[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n        }\n\n        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/env.js\n ** module id = 60\n ** module chunks = 0\n **/","'use strict';\n/**\n * Handler\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n\n    var Eventful = require('./mixin/Eventful');\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n\n    function EmptyProxy () {}\n    EmptyProxy.prototype.dispose = function () {};\n\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove'\n    ];\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function(storage, painter, proxy) {\n        Eventful.call(this);\n\n        this.storage = storage;\n\n        this.painter = painter;\n\n        proxy = proxy || new EmptyProxy();\n        /**\n         * Proxy of event. can be Dom, WebGLSurface, etc.\n         */\n        this.proxy = proxy;\n\n        // Attach handler\n        proxy.handler = this;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n\n        Draggable.call(this);\n\n        util.each(handlerNames, function (name) {\n            proxy.on && proxy.on(name, this[name], this);\n        }, this);\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        mousemove: function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n            var proxy = this.proxy;\n\n            this._hovered = hovered;\n\n            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');\n\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this.dispatchToElement(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        },\n\n        mouseout: function (event) {\n            this.dispatchToElement(this._hovered, 'mouseout', event);\n\n            this.trigger('globalout', {\n                event: event\n            });\n        },\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n\n            this.proxy.dispose();\n\n            this.storage =\n            this.proxy =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} [cursorStyle='default'] 例如 crosshair\n         */\n        setCursorStyle: function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetEl 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        dispatchToElement: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n        Handler.prototype[name] = function (event) {\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n\n            if (name === 'mousedown') {\n                this._downel = hovered;\n                // In case click triggered before mouseup\n                this._upel = hovered;\n            }\n            else if (name === 'mosueup') {\n                this._upel = hovered;\n            }\n            else if (name === 'click') {\n                if (this._downel !== this._upel) {\n                    return;\n                }\n            }\n\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            while (el) {\n                // If ancestor is silent or clipped by ancestor\n                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {\n                    return false;\n                }\n                el = el.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Handler.js\n ** module id = 61\n ** module chunks = 0\n **/","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n    var env = require('./core/env');\n\n    var Group = require('./container/Group');\n\n    // Use timsort because in most case elements are partially sorted\n    // https://jsfiddle.net/pissang/jr4x7mdm/8/\n    var timsort = require('./core/timsort');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                // if (a.z2 === b.z2) {\n                //     // FIXME Slow has renderidx compare\n                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n                //     return a.__renderidx - b.__renderidx;\n                // }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * @param  {Function} cb\n         *\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        },\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            // for (var i = 0, len = displayList.length; i < len; i++) {\n            //     displayList[i].__renderidx = i;\n            // }\n\n            // displayList.sort(shapeCompareFunc);\n            env.canvasSupported && timsort(displayList, shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            if (el.__dirty) {\n\n                el.update();\n\n            }\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.isGroup) {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    if (el.__dirty) {\n                        child.__dirty = true;\n                    }\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty(false);\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        },\n\n        displayableSortFunc: shapeCompareFunc\n    };\n\n    module.exports = Storage;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Storage.js\n ** module id = 62\n ** module chunks = 0\n **/","// https://github.com/mziccard/node-timsort\n\n    var DEFAULT_MIN_MERGE = 32;\n\n    var DEFAULT_MIN_GALLOPING = 7;\n\n    var DEFAULT_TMP_STORAGE_LENGTH = 256;\n\n    function minRunLength(n) {\n        var r = 0;\n\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n\n        return n + r;\n    }\n\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n\n        if (runHi === hi) {\n            return 1;\n        }\n\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n\n        return runHi - lo;\n    }\n\n    function reverseRun(array, lo, hi) {\n        hi--;\n\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n\n        for (; start < hi; start++) {\n            var pivot = array[start];\n\n            var left = lo;\n            var right = start;\n            var mid;\n\n            while (left < right) {\n                mid = left + right >>> 1;\n\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n\n            var n = start - left;\n\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n\n                case 2:\n                    array[left + 2] = array[left + 1];\n\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n\n            array[left] = pivot;\n        }\n    }\n\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n\n            lastOffset += hint;\n            offset += hint;\n        }\n\n        lastOffset++;\n\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n\n        return offset;\n    }\n\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n        var stackLength = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n\n        length = array.length;\n\n        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n            tmpStorageLength = length >>> 1;\n        }\n\n        var tmp = [];\n\n        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n\n        runStart = [];\n        runLength = [];\n\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n\n                mergeAt(n);\n            }\n        }\n\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n\n            runLength[i] = length1 + length2;\n\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n\n            stackSize--;\n\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n\n            if (length1 === 0) {\n                return;\n            }\n\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n            if (length2 === 0) {\n                return;\n            }\n\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n\n            array[dest++] = array[cursor2++];\n\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n\n            var _minGallop = minGallop;\n            var count1, count2, exit;\n\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest++] = array[cursor2++];\n\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            minGallop < 1 && (minGallop = 1);\n\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n                // throw new Error('mergeLow preconditions were not respected');\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n\n        function mergeHigh (start1, length1, start2, length2) {\n            var i = 0;\n\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n\n            array[dest--] = array[cursor1--];\n\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n\n                return;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n                return;\n            }\n\n            var _minGallop = minGallop;\n\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n\n                if (exit) {\n                    break;\n                }\n\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = tmp[cursor2--];\n\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n\n                    array[dest--] = array[cursor1--];\n\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n                if (exit) {\n                    break;\n                }\n\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n\n                _minGallop += 2;\n            }\n\n            minGallop = _minGallop;\n\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n                // throw new Error('mergeHigh preconditions were not respected');\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n\n        this.mergeRuns = mergeRuns;\n        this.forceMergeRuns = forceMergeRuns;\n        this.pushRun = pushRun;\n    }\n\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n\n        var remaining = hi - lo;\n\n        if (remaining < 2) {\n            return;\n        }\n\n        var runLength = 0;\n\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n\n        var ts = new TimSort(array, compare);\n\n        var minRun = minRunLength(remaining);\n\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n\n        ts.forceMergeRuns();\n    }\n\n    module.exports = sort;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/timsort.js\n ** module id = 63\n ** module chunks = 0\n **/","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = require('./requestAnimationFrame');\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time;\n\n        this._pausedTime;\n\n        this._pauseStart;\n\n        this._paused = false;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n\n        _startLoop: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    !self._paused && self._update();\n                }\n            }\n\n            requestAnimationFrame(step);\n        },\n\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n\n            this._startLoop();\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n\n        /**\n         * Pause\n         */\n        pause: function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        },\n\n        /**\n         * Resume\n         */\n        resume: function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        },\n\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        // TODO Gap\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animation.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};\n    }\n\n    function clientToLocal(el, e, out) {\n        // clientX/clientY is according to view port.\n        var box = getBoundingClientRect(el);\n        out = out || {};\n        out.zrX = e.clientX - box.left;\n        out.zrY = e.clientY - box.top;\n        return out;\n    }\n\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n     */\n    function normalizeEvent(el, e) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            clientToLocal(el, e, e);\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e);\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        clientToLocal: clientToLocal,\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/event.js\n ** module id = 65\n ** module chunks = 0\n **/","\n\n    module.exports = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/requestAnimationFrame.js\n ** module id = 66\n ** module chunks = 0\n **/","\n\n    var eventTool = require('../core/event');\n    var zrUtil = require('../core/util');\n    var Eventful = require('../mixin/Eventful');\n    var env = require('../core/env');\n    var GestureMgr = require('../core/GestureMgr');\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove'\n    ];\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    function processGesture(proxy, event, stage) {\n        var gestureMgr = proxy._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            proxy.handler.findHover(event.zrX, event.zrY, null),\n            proxy.dom\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            this.trigger('mousemove', event);\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.dom) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.dom) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this.trigger('mouseout', event);\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // Default mouse behaviour should not be disabled here.\n            // For example, page may needs to be slided.\n\n            event = normalizeEvent(this.dom, event);\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // 平板补充一次findHover\n            // this._mobileFindFixed(event);\n            // Trigger mousemove and mousedown\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n\n            event = normalizeEvent(this.dom, event);\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        for (var i = 0; i < touchHandlerNames.length; i++) {\n            var name = touchHandlerNames[i];\n            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n\n    function HandlerDomProxy(dom) {\n        Eventful.call(this);\n\n        this.dom = dom;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        this._handlers = {};\n\n        initDomHandler(this);\n\n        if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        function mountHandlers(handlerNames, instance) {\n            zrUtil.each(handlerNames, function (name) {\n                addEventListener(dom, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    }\n\n    var handlerDomProxyProto = HandlerDomProxy.prototype;\n    handlerDomProxyProto.dispose = function () {\n        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);\n        }\n    };\n\n    handlerDomProxyProto.setCursor = function (cursorStyle) {\n        this.dom.style.cursor = cursorStyle || 'default';\n    };\n\n    zrUtil.mixin(HandlerDomProxy, Eventful);\n\n    module.exports = HandlerDomProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/dom/HandlerProxy.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var eventUtil = require('./event');\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target, root) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = eventUtil.clientToLocal(root, touch);\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/GestureMgr.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n    var timsort = require('./core/timsort');\n\n    var Layer = require('./Layer');\n\n    var requestAnimationFrame = require('./animation/requestAnimationFrame');\n\n    // PENDIGN\n    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.\n    //\n    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.\n    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths == prevClipPaths) { // Can both be null or undefined\n            return false;\n        }\n\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var path = clipPath.path;\n\n            clipPath.setTransform(ctx);\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            clipPath.restoreTransform(ctx);\n        }\n    }\n\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        var domRootStyle = domRoot.style;\n\n        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n        domRootStyle.position = 'relative';\n        domRootStyle.overflow = 'hidden';\n        domRootStyle.width = width + 'px';\n        domRootStyle.height = height + 'px';\n        return domRoot;\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        // In node environment using node-canvas\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        opts = opts || {};\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] =\n            rootStyle['user-select'] =\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        var zlevelList = this._zlevelList = [];\n\n        /**\n         * @type {Object.<string, module:zrender/Layer>}\n         * @private\n         */\n        var layers = this._layers = {};\n\n        /**\n         * @type {Object.<string, Object>}\n         * @type {private}\n         */\n        this._layerConfig = {};\n\n        if (!singleCanvas) {\n            this._width = this._getWidth();\n            this._height = this._getHeight();\n\n            var domRoot = this._domRoot = createRoot(\n                this._width, this._height\n            );\n            root.appendChild(domRoot);\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            layers[0] = mainLayer;\n            zlevelList.push(0);\n        }\n\n        this.pathToImage = this._createPathToImage();\n\n        // Layers for progressive rendering\n        this._progressiveLayers = [];\n\n        /**\n         * @type {module:zrender/Layer}\n         * @private\n         */\n        this._hoverlayer;\n\n        this._hoverElements = [];\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n\n            var list = this.storage.getDisplayList(true);\n\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            this.refreshHover();\n\n            if (this._progressiveLayers.length) {\n                this._startProgessive();\n            }\n\n            return this;\n        },\n\n        addHover: function (el, hoverStyle) {\n            if (el.__hoverMir) {\n                return;\n            }\n            var elMirror = new el.constructor({\n                style: el.style,\n                shape: el.shape\n            });\n            elMirror.__from = el;\n            el.__hoverMir = elMirror;\n            elMirror.setStyle(hoverStyle);\n            this._hoverElements.push(elMirror);\n        },\n\n        removeHover: function (el) {\n            var elMirror = el.__hoverMir;\n            var hoverElements = this._hoverElements;\n            var idx = util.indexOf(hoverElements, elMirror);\n            if (idx >= 0) {\n                hoverElements.splice(idx, 1);\n            }\n            el.__hoverMir = null;\n        },\n\n        clearHover: function (el) {\n            var hoverElements = this._hoverElements;\n            for (var i = 0; i < hoverElements.length; i++) {\n                var from = hoverElements[i].__from;\n                if (from) {\n                    from.__hoverMir = null;\n                }\n            }\n            hoverElements.length = 0;\n        },\n\n        refreshHover: function () {\n            var hoverElements = this._hoverElements;\n            var len = hoverElements.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n\n            if (!len) {\n                return;\n            }\n            timsort(hoverElements, this.storage.displayableSortFunc);\n\n            // Use a extream large zlevel\n            // FIXME?\n            if (!hoverLayer) {\n                hoverLayer = this._hoverlayer = this.getLayer(1e5);\n            }\n\n            var scope = {};\n            hoverLayer.ctx.save();\n            for (var i = 0; i < len;) {\n                var el = hoverElements[i];\n                var originalEl = el.__from;\n                // Original el is removed\n                // PENDING\n                if (!(originalEl && originalEl.__zr)) {\n                    hoverElements.splice(i, 1);\n                    originalEl.__hoverMir = null;\n                    len--;\n                    continue;\n                }\n                i++;\n\n                // Use transform\n                // FIXME style and shape ?\n                if (!originalEl.invisible) {\n                    el.transform = originalEl.transform;\n                    el.invTransform = originalEl.invTransform;\n                    el.__clipPaths = originalEl.__clipPaths;\n                    // el.\n                    this._doPaintEl(el, hoverLayer, true, scope);\n                }\n            }\n            hoverLayer.ctx.restore();\n        },\n\n        _startProgessive: function () {\n            var self = this;\n\n            if (!self._furtherProgressive) {\n                return;\n            }\n\n            // Use a token to stop progress steps triggered by\n            // previous zr.refresh calling.\n            var token = self._progressiveToken = +new Date();\n\n            self._progress++;\n            requestAnimationFrame(step);\n\n            function step() {\n                // In case refreshed or disposed\n                if (token === self._progressiveToken && self.storage) {\n\n                    self._doPaintList(self.storage.getDisplayList());\n\n                    if (self._furtherProgressive) {\n                        self._progress++;\n                        requestAnimationFrame(step);\n                    }\n                    else {\n                        self._progressiveToken = -1;\n                    }\n                }\n            }\n        },\n\n        _clearProgressive: function () {\n            this._progressiveToken = -1;\n            this._progress = 0;\n            util.each(this._progressiveLayers, function (layer) {\n                layer.__dirty && layer.clear();\n            });\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            this._clearProgressive();\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            this._doPaintList(list, paintAll);\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        _doPaintList: function (list, paintAll) {\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            // var invTransform = [];\n            var scope;\n\n            var progressiveLayerIdx = 0;\n            var currentProgressiveLayer;\n\n            var width = this._width;\n            var height = this._height;\n            var layerProgress;\n            var frame = this._progress;\n            function flushProgressiveLayer(layer) {\n                var dpr = ctx.dpr || 1;\n                ctx.save();\n                ctx.globalAlpha = 1;\n                ctx.shadowBlur = 0;\n                // Avoid layer don't clear in next progressive frame\n                currentLayer.__dirty = true;\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);\n                ctx.restore();\n            }\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\n                var elFrame = el.__frame;\n\n                // Flush at current context\n                // PENDING\n                if (elFrame < 0 && currentProgressiveLayer) {\n                    flushProgressiveLayer(currentProgressiveLayer);\n                    currentProgressiveLayer = null;\n                }\n\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    if (ctx) {\n                        ctx.restore();\n                    }\n\n                    // Reset scope\n                    scope = {};\n\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n                    ctx.save();\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (!(currentLayer.__dirty || paintAll)) {\n                    continue;\n                }\n\n                if (elFrame >= 0) {\n                    // Progressive layer changed\n                    if (!currentProgressiveLayer) {\n                        currentProgressiveLayer = this._progressiveLayers[\n                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)\n                        ];\n\n                        currentProgressiveLayer.ctx.save();\n                        currentProgressiveLayer.renderScope = {};\n\n                        if (currentProgressiveLayer\n                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)\n                        ) {\n                            // flushProgressiveLayer(currentProgressiveLayer);\n                            // Quick jump all progressive elements\n                            // All progressive element are not dirty, jump over and flush directly\n                            i = currentProgressiveLayer.__nextIdxNotProg - 1;\n                            // currentProgressiveLayer = null;\n                            continue;\n                        }\n\n                        layerProgress = currentProgressiveLayer.__progress;\n\n                        if (!currentProgressiveLayer.__dirty) {\n                            // Keep rendering\n                            frame = layerProgress;\n                        }\n\n                        currentProgressiveLayer.__progress = frame + 1;\n                    }\n\n                    if (elFrame === frame) {\n                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);\n                    }\n                }\n                else {\n                    this._doPaintEl(el, currentLayer, paintAll, scope);\n                }\n\n                el.__dirty = false;\n            }\n\n            if (currentProgressiveLayer) {\n                flushProgressiveLayer(currentProgressiveLayer);\n            }\n\n            // Restore the lastLayer ctx\n            ctx && ctx.restore();\n            // If still has clipping state\n            // if (scope.prevElClipPaths) {\n            //     ctx.restore();\n            // }\n\n            this._furtherProgressive = false;\n            util.each(this._progressiveLayers, function (layer) {\n                if (layer.__maxProgress >= layer.__progress) {\n                    this._furtherProgressive = true;\n                }\n            }, this);\n        },\n\n        _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n            var ctx = currentLayer.ctx;\n            var m = el.transform;\n            if (\n                (currentLayer.__dirty || forcePaint)\n                // Ignore invisible element\n                && !el.invisible\n                // Ignore transparent element\n                && el.style.opacity !== 0\n                // Ignore scale 0 element, in some environment like node-canvas\n                // Draw a scale 0 element can cause all following draw wrong\n                // And setTransform with scale 0 will cause set back transform failed.\n                && !(m && !m[0] && !m[3])\n                // Ignore culled element\n                && !(el.culling && isDisplayableCulled(el, this._width, this._height))\n            ) {\n\n                var clipPaths = el.__clipPaths;\n\n                // Optimize when clipping on group with several elements\n                if (scope.prevClipLayer !== currentLayer\n                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)\n                ) {\n                    // If has previous clipping state, restore from it\n                    if (scope.prevElClipPaths) {\n                        scope.prevClipLayer.ctx.restore();\n                        scope.prevClipLayer = scope.prevElClipPaths = null;\n\n                        // Reset prevEl since context has been restored\n                        scope.prevEl = null;\n                    }\n                    // New clipping state\n                    if (clipPaths) {\n                        ctx.save();\n                        doClip(clipPaths, ctx);\n                        scope.prevClipLayer = currentLayer;\n                        scope.prevElClipPaths = clipPaths;\n                    }\n                }\n                el.beforeBrush && el.beforeBrush(ctx);\n\n                el.brush(ctx, scope.prevEl || null);\n                scope.prevEl = el;\n\n                el.afterBrush && el.afterBrush(ctx);\n            }\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n            var progressiveLayers = this._progressiveLayers;\n\n            var elCountsLastFrame = {};\n            var progressiveElCountsLastFrame = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCountsLastFrame[z] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            util.each(progressiveLayers, function (layer, idx) {\n                progressiveElCountsLastFrame[idx] = layer.elCount;\n                layer.elCount = 0;\n                layer.__dirty = false;\n            });\n\n            var progressiveLayerCount = 0;\n            var currentProgressiveLayer;\n            var lastProgressiveKey;\n            var frameCount = 0;\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                var elProgress = el.progressive;\n                if (layer) {\n                    layer.elCount++;\n                    layer.__dirty = layer.__dirty || el.__dirty;\n                }\n\n                /////// Update progressive\n                if (elProgress >= 0) {\n                    // Fix wrong progressive sequence problem.\n                    if (lastProgressiveKey !== elProgress) {\n                        lastProgressiveKey = elProgress;\n                        frameCount++;\n                    }\n                    var elFrame = el.__frame = frameCount - 1;\n                    if (!currentProgressiveLayer) {\n                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);\n                        currentProgressiveLayer = progressiveLayers[idx];\n                        if (!currentProgressiveLayer) {\n                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(\n                                'progressive', this, this.dpr\n                            );\n                            currentProgressiveLayer.initContext();\n                        }\n                        currentProgressiveLayer.__maxProgress = 0;\n                    }\n                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;\n                    currentProgressiveLayer.elCount++;\n\n                    currentProgressiveLayer.__maxProgress = Math.max(\n                        currentProgressiveLayer.__maxProgress, elFrame\n                    );\n\n                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {\n                        // Should keep rendering this  layer because progressive rendering is not finished yet\n                        layer.__dirty = true;\n                    }\n                }\n                else {\n                    el.__frame = -1;\n\n                    if (currentProgressiveLayer) {\n                        currentProgressiveLayer.__nextIdxNotProg = i;\n                        progressiveLayerCount++;\n                        currentProgressiveLayer = null;\n                    }\n                }\n            }\n\n            if (currentProgressiveLayer) {\n                progressiveLayerCount++;\n                currentProgressiveLayer.__nextIdxNotProg = i;\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCountsLastFrame[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n\n            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);\n            util.each(progressiveLayers, function (layer, idx) {\n                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {\n                    el.__dirty = true;\n                }\n                if (layer.__dirty) {\n                    layer.__progress = 0;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            var scope = {};\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                this._doPaintEl(el, imageLayer, true, scope);\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n                    - (parseInt10(stl.paddingLeft) || 0)\n                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n                    - (parseInt10(stl.paddingTop) || 0)\n                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Painter.js\n ** module id = 69\n ** module chunks = 0\n **/","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n    var Style = require('./graphic/Style');\n    var Pattern = require('./graphic/Pattern');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            this.ctx.dpr = this.dpr;\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var clearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            if (clearColor) {\n                var clearColorGradientOrPattern;\n                // Gradient\n                if (clearColor.colorStops) {\n                    // Cache canvas gradient\n                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n                        x: 0,\n                        y: 0,\n                        width: width,\n                        height: height\n                    });\n\n                    clearColor.__canvasGradient = clearColorGradientOrPattern;\n                }\n                // Pattern\n                else if (clearColor.image) {\n                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n                }\n                ctx.save();\n                ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                ctx.fillRect(0, 0, width, height);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width, height);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Layer.js\n ** module id = 70\n ** module chunks = 0\n **/","/**\r\n * 工具方法类\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Point = require(\"./Point.js\");\r\n    var Line = require(\"./LineStruct.js\");\r\n    var graphic = require(\"./graphic.js\");\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    /**\r\n     * 构造类继承关系\r\n     *\r\n     * @param {Function} clazz 源类\r\n     * @param {Function} baseClazz 基类\r\n     */\r\n    function inherits(clazz, baseClazz) {\r\n        var clazzPrototype = clazz.prototype;\r\n\r\n        function F() {}\r\n        F.prototype = baseClazz.prototype;\r\n        clazz.prototype = new F();\r\n\r\n        for (var prop in clazzPrototype) {\r\n            clazz.prototype[prop] = clazzPrototype[prop];\r\n        }\r\n        clazz.prototype.constructor = clazz;\r\n        clazz.superClass = baseClazz;\r\n    }\r\n\r\n    function getUUID() {\r\n        var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),\r\n            uuid = new Array(36),\r\n            rnd = 0,\r\n            r;\r\n        for (var i = 0; i < 36; i++) {\r\n            if (i == 8 || i == 13 || i == 18 || i == 23) {\r\n                uuid[i] = '-';\r\n            } else if (i == 14) {\r\n                uuid[i] = '4';\r\n            } else {\r\n                if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\r\n                r = rnd & 0xf;\r\n                rnd = rnd >> 4;\r\n                uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\r\n            }\r\n        }\r\n        return \"sid-\" + uuid.join('');\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算两点之间的距离\r\n     *@param {Point} p1 - first {Point}\r\n     *@param {Point} p2 - second {Point}\r\n     *@return {Number} - the distance between those 2 points. It is always positive.\r\n     **/\r\n    function distance(p1, p2) {\r\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 返回一条折线 最长的两个点\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function getMaxLineLength(points) {\r\n        var m = distance(points[0], points[1]);\r\n        var result = [points[0], points[1]];\r\n        for (var i = 1; i < points.length - 1; i++) {\r\n\r\n            if (m < distance(points[i], points[i + 1])) {\r\n                m = distance(points[i], points[i + 1])\r\n                result = [points[i], points[i + 1]];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**Returns the length of a Polyline that would be created with a set of points\r\n     *@param {Array} v - an {Array} of {Points}\r\n     *@return {Number} - a positive number equal with total length*/\r\n    function getPolylineLength(v) {\r\n        var l = 0;\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            l += distance(v[i], v[i + 1]);\r\n        }\r\n\r\n        return l;\r\n    }\r\n\r\n\r\n    /**Returns the max of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the maximum number from the vector or NaN if vector is empty\r\n     **/\r\n    function max(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m < v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n\r\n    /**Returns the min of a vector\r\n     *@param {Array} v - vector of {Number}s\r\n     *@return {Number} - the minimum number from the vector or NaN if vector is empty\r\n     *@author alex@scriptoid.com\r\n     **/\r\n    function min(v) {\r\n        if (v.lenght == 0) {\r\n            return NaN;\r\n        } else {\r\n            var m = v[0];\r\n            for (var i = 0; i < v.length; i++) {\r\n                if (m > v[i]) {\r\n                    m = v[i];\r\n                }\r\n            }\r\n\r\n            return m;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是否正交直线路径\r\n     *Tests if a vector of points is an orthogonal path (moving in multiples of 90 degrees)\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function orthogonalPath(v) {\r\n        if (v.length <= 1) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 1; i++) {\r\n            if (v[i].x != v[i + 1].x && v[i].y != v[i + 1].y) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     *Test to see if 2 {Line}s intersects. They are considered finite segments\r\n     *and not the infinite lines from geometry\r\n     *@param {Line} l1 - fist line/segment\r\n     *@param {Line} l2 - last line/segment\r\n     *@return {Boolean} true - if the lines intersect or false if not\r\n     **/\r\n    function lineIntersectsLine(l1, l2) {\r\n        // check for two vertical lines\r\n        if (l1.startPoint.x == l1.endPoint.x && l2.startPoint.x == l2.endPoint.x) {\r\n            return l1.startPoint.x == l2.startPoint.x ? // if 'infinite 'lines do coincide,\r\n                // then check segment bounds for overlapping\r\n                l1.contains(l2.startPoint.x, l2.startPoint.y) ||\r\n                l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                // lines are paralel\r\n                false;\r\n        }\r\n        // if one line is vertical, and another line is not vertical\r\n        else if (l1.startPoint.x == l1.endPoint.x || l2.startPoint.x == l2.endPoint.x) {\r\n            // let assume l2 is vertical, otherwise exchange them\r\n            if (l1.startPoint.x == l1.endPoint.x) {\r\n                var l = l1;\r\n                l1 = l2;\r\n                l2 = l;\r\n            }\r\n            // finding intersection of 'infinite' lines\r\n            // equation of the first line is y = ax + b, second: x = c\r\n            var a = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b = l1.startPoint.y - a * l1.startPoint.x;\r\n            var x0 = l2.startPoint.x;\r\n            var y0 = a * x0 + b;\r\n            return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n        }\r\n\r\n        // check normal case - both lines are not vertical\r\n        else {\r\n            //line equation is : y = a*x + b, b = y - a * x\r\n            var a1 = (l1.endPoint.y - l1.startPoint.y) / (l1.endPoint.x - l1.startPoint.x);\r\n            var b1 = l1.startPoint.y - a1 * l1.startPoint.x;\r\n\r\n            var a2 = (l2.endPoint.y - l2.startPoint.y) / (l2.endPoint.x - l2.startPoint.x);\r\n            var b2 = l2.startPoint.y - a2 * l2.startPoint.x;\r\n\r\n            if (a1 == a2) { //paralel lines\r\n                return b1 == b2 ?\r\n                    // for coincide lines, check for segment bounds overlapping\r\n                    l1.contains(l2.startPoint.x, l2.startPoint.y) || l1.contains(l2.endPoint.x, l2.endPoint.y) :\r\n                    // not coincide paralel lines have no chance to intersect\r\n                    false;\r\n            } else { //usual case - non paralel, the 'infinite' lines intersects...we only need to know if inside the segment\r\n\r\n                /*\r\n                 * if one of the lines are vertical, then x0 is equal to their x,\r\n                 * otherwise:\r\n                 * y1 = a1 * x + b1\r\n                 * y2 = a2 * x + b2\r\n                 * => x0 = (b2 - b1) / (a1 - a2)\r\n                 * => y0 = a1 * x0 + b1\r\n                 **/\r\n                x0 = (b2 - b1) / (a1 - a2);\r\n                y0 = a1 * x0 + b1;\r\n                return l1.contains(x0, y0) && l2.contains(x0, y0);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     *Tests if a a polyline defined by a set of points intersects a rectangle\r\n     *@param {Array} points - and {Array} of {Point}s\r\n     *@param {Array} bounds - the bounds of the rectangle defined by (x1, y1, x2, y2)\r\n     *@param {Boolean} closedPolyline - incase polyline is closed figure then true, else false\r\n     *\r\n     *@return true - if line intersects the rectangle, false - if not\r\n     **/\r\n    function polylineIntersectsRectangle(points, bounds, closedPolyline) {\r\n\r\n\r\n        //get the 4 lines/segments represented by the bounds\r\n        var lines = [];\r\n        lines.push(new Line(new Point(bounds[0], bounds[1]), new Point(bounds[2], bounds[1])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[1]), new Point(bounds[2], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[2], bounds[3]), new Point(bounds[0], bounds[3])));\r\n        lines.push(new Line(new Point(bounds[0], bounds[3]), new Point(bounds[0], bounds[1])));\r\n\r\n        for (var k = 0; k < points.length - 1; k++) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine = new Line(points[k], points[k + 1]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var i = 0; i < lines.length; i++) {\r\n                if (lineIntersectsLine(tempLine, lines[i])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //check the closed figure - that is last point connected to the first\r\n        if (closedPolyline) {\r\n            //create a line out of each 2 consecutive points\r\n            var tempLine1 = new Line(points[points.length - 1], points[0]);\r\n\r\n            //see if that line intersect any of the line on bounds border\r\n            for (var j = 0; j < lines.length; j++) {\r\n                if (lineIntersectsLine(tempLine1, lines[j])) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 计算路径的分数\r\n     * Score a ortogonal path made out of Points\r\n     *Iterates over a set of points (minimum 3)\r\n     *For each 3 points (i, i+1, i+2) :\r\n     *  - if the 3rd one is after the 2nd on the same line we add +1\r\n     *  - if the 3rd is up or down related to the 2nd we do not do anything +0\r\n     *  - if the 3rd goes back we imediatelly return -1\r\n     *@param {Array} v - an array of {Point}s\r\n     *@return {Number} - -1 if the path is wrong (goes back) or something >= 0 if is fine\r\n     *  The bigger the number the smooth the path is\r\n     **/\r\n    function scorePath(v) {\r\n        if (v.length <= 2) {\r\n            return -1;\r\n        }\r\n\r\n        var score = 0;\r\n        for (var i = 1; i < v.length - 1; i++) {\r\n            if (v[i - 1].x == v[i].x && v[i].x == v[i + 1].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) == signum(v[i].y - v[i - 1].y)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else if (v[i - 1].y == v[i].y && v[i].y == v[i + 1].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) == signum(v[i].x - v[i - 1].x)) { //same direction\r\n                    score++;\r\n                } else { //going back - no good\r\n                    return -1;\r\n                }\r\n            } else { //not on same vertical nor horizontal\r\n                score--;\r\n            }\r\n        }\r\n\r\n        return score;\r\n    }\r\n\r\n    /**\r\n     * 返回数字符号（+ -)\r\n     * Returns the sign of a number\r\n     *@param {Number} x - the number\r\n     *@returns {Number}\r\n     *@see <a href=\"http://en.wikipedia.org/wiki/Sign_function\">http://en.wikipedia.org/wiki/Sign_function</a>\r\n     **/\r\n    function signum(x) {\r\n        if (x > 0)\r\n            return 1;\r\n        else if (x < 0)\r\n            return -1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    /**\r\n     * 判断 点数组 是不是有效路径（没有回路）\r\n     *Tests if a vector of points is a valid path (not going back)\r\n     *There are a few problems here. If you have p1, p2, p3 and p4 and p2 = p3 you need to ignore that\r\n     *@param {Array} v - an {Array} of {Point}s\r\n     *@return {Boolean} - true if path is valid, false otherwise\r\n     **/\r\n    function forwardPath(v) {\r\n        if (v.length <= 2) {\r\n            return true;\r\n        }\r\n\r\n        for (var i = 0; i < v.length - 2; i++) {\r\n            if (v[i].x == v[i + 1].x && v[i + 1].x == v[i + 2].x) { //on the same vertical\r\n                if (signum(v[i + 1].y - v[i].y) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].y - v[i].y) == -1 * signum(v[i + 2].y - v[i + 1].y)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (v[i].y == v[i + 1].y && v[i + 1].y == v[i + 2].y) { //on the same horizontal\r\n                if (signum(v[i + 1].x - v[i].x) != 0) { //test only we have a progressing path\r\n                    if (signum(v[i + 1].x - v[i].x) == -1 * signum(v[i + 2].x - v[i + 1].x)) { //going back (ignore zero)\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * 将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n     * @param  {[type]} points [description]\r\n     * @param  {[type]} isRevert [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    function traslatePoints(points, isRevert) {\r\n        var newPoints = [];\r\n        if (isRevert) {\r\n            for (var i = 0; i < points.length; i++) {\r\n                var point = points[i];\r\n                newPoints.push(new Point(point[0], point[1]));\r\n            }\r\n            return newPoints;\r\n        } else {\r\n            for (var j = 0; j < points.length; j++) {\r\n                var point1 = points[j];\r\n                newPoints.push([point1.x, point1.y]);\r\n            }\r\n            return newPoints;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    function rotationMatrix(angle) {\r\n        var mReturn = [\r\n            [Math.cos(angle), -Math.sin(angle), 0],\r\n            [Math.sin(angle), Math.cos(angle), 0],\r\n            [0, 0, 1]\r\n        ];\r\n        return mReturn;\r\n    }\r\n\r\n    function translationMatrix(dx, dy) {\r\n        return [\r\n            [1, 0, dx],\r\n            [0, 1, dy],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    function scaleMatrix(sx, sy) {\r\n        if (sy == null) {\r\n            sy = sx;\r\n        }\r\n        return [\r\n            [sx, 0, 0],\r\n            [0, sy, 0],\r\n            [0, 0, 1]\r\n        ];\r\n    }\r\n\r\n    /** It will return the end point of a line on a given angle (clockwise).\r\n     * @param {Point} startPoint - the start of the line\r\n     * @param {Number} length - the length of the line\r\n     * @param {Number} angle - the angle of the line in radians\r\n     * @return {Point} - the endPoint of the line\r\n     */\r\n    function getEndPoint(startPoint, length, angle) {\r\n        var endPoint = startPoint.clone();\r\n        endPoint.transform(translationMatrix(-startPoint.x, -startPoint.y));\r\n        endPoint.y -= length;\r\n        endPoint.transform(rotationMatrix(angle));\r\n        endPoint.transform(translationMatrix(startPoint.x, startPoint.y));\r\n        return endPoint;\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getConnectorPoints(node) {\r\n        return {\r\n            left: new Point(node.x, node.y + node.height / 2), //矩形 左中的位置\r\n            top: new Point(node.x + node.width / 2, node.y), //矩形 上中的位置\r\n            right: new Point(node.x + node.width, node.y + node.height / 2), //矩形 右中的位置\r\n            bottom: new Point(node.x + node.width / 2, node.y + node.height), //矩形 下中的位置\r\n            center: new Point(node.x + node.width / 2, node.y + node.height / 2) //中间位置\r\n\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 获取获取两个图形的外面四个连接点\r\n     * @param  {[type]} node [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    function getSoltPoints(node) {\r\n        return [\r\n            //top\r\n            [Math.round(node.getRect().width / 3 /10)*10, 0 ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, 0 ],\r\n            //right\r\n            [node.getRect().width, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [node.getRect().width, Math.round(2*node.getRect().height / 3 /10)*10 ],\r\n            //bottom\r\n            [Math.round(node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            [Math.round(2*node.getRect().width / 3 /10)*10, node.getRect().height ],\r\n            //left\r\n            [0, Math.round(node.getRect().height / 3 /10)*10 ],\r\n            [0, Math.round(2*node.getRect().height / 3 /10)*10 ]\r\n\r\n        ]\r\n    }\r\n\r\n    /**\r\n     * 计算 p1 p2两点所连接的直线的角度\r\n     * @param  {[type]} p1 [description]\r\n     * @param  {[type]} p2 [description]\r\n     * @return {[type]}    [description]\r\n     */\r\n    function tangentRotation(p1, p2) {\r\n        return -Math.PI / 2 - Math.atan2(\r\n            p2.y - p1.y, p2.x - p1.x\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 判断3点是否在一条直线上\r\n     * Tests if 3 points are coliniar with matrix determinants.\r\n     * If the determinat of matrix\r\n     * /         \\\r\n     * | x1 y1 1 |\r\n     * | x2 y2 1 |\r\n     * | x3 y3 1 |\r\n     * \\         /\r\n     * is zero it means that the points are colinear\r\n     *@param {Point} p1 - first point\r\n     *@param {Point} p2 - second point\r\n     *@param {Point} p3 - third point\r\n     * @param {Number} precission\r\n     *@return {Boolean} - true if coliniar and false if not\r\n     *@author Alex\r\n     *@see http://en.wikipedia.org/wiki/Determinant\r\n     *@see https://people.richland.edu/james/lecture/m116/matrices/applications.html\r\n     **/\r\n    function collinearity(p1, p2, p3, precission) {\r\n        var determinant = (p1.x * p2.y + p1.y * p3.x + p2.x * p3.y) - (p2.y * p3.x + p1.y * p2.x + p1.x * p3.y);\r\n\r\n        if (precission) {\r\n            return Math.abs(determinant) <= precission;\r\n        } else {\r\n            return determinant === 0;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 四舍五入 保存decimals的小数\r\n     **/\r\n    function enhancedRound(number, decimals) {\r\n        return Math.round(number * Math.pow(10, decimals)) / Math.pow(10, decimals);\r\n    }\r\n\r\n    /**\r\n     * 获取两点之间的长度\r\n     **/\r\n    function getLength(startPoint, endPoint) {\r\n        return Math.sqrt(Math.pow(startPoint.x - endPoint.x, 2) + Math.pow(startPoint.y - endPoint.y, 2));\r\n    }\r\n\r\n    /**\r\n     * 获取角度\r\n     * @param  {[type]} centerPoint  [description]\r\n     * @param  {[type]} outsidePoint [description]\r\n     * @param  {[type]} round        [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function getAngle(centerPoint, outsidePoint, round) {\r\n        centerPoint.x = enhancedRound(centerPoint.x, 5);\r\n        centerPoint.y = enhancedRound(centerPoint.y, 5);\r\n        outsidePoint.x = enhancedRound(outsidePoint.x, 5);\r\n        outsidePoint.y = enhancedRound(outsidePoint.y, 5);\r\n        var angle = Math.atan((outsidePoint.x - centerPoint.x) / (outsidePoint.y - centerPoint.y));\r\n        angle = -angle;\r\n\r\n        //endAngle+=90;\r\n        if (outsidePoint.x >= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y >= centerPoint.y) {\r\n            angle += Math.PI;\r\n        } else if (outsidePoint.x <= centerPoint.x && outsidePoint.y <= centerPoint.y) {\r\n            angle += Math.PI * 2;\r\n        }\r\n        while (angle >= Math.PI * 2) {\r\n            angle -= Math.PI * 2;\r\n        }\r\n        if (isNaN(angle)) { //Nan\r\n            angle = 0; //we are at center point;\r\n        }\r\n        if (round) {\r\n            angle = Math.round(angle / round) * round\r\n        }\r\n        return angle;\r\n    }\r\n\r\n    function getRect(node) {\r\n        var boundingRect = node.getBoundingRect();\r\n        //创建最小包围盒虚线\r\n        var points = [];\r\n        points[0] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[1] = [boundingRect.width / 2, -boundingRect.height / 2];\r\n        points[2] = [boundingRect.width / 2, boundingRect.height / 2];\r\n        points[3] = [-boundingRect.width / 2, boundingRect.height / 2];\r\n        points[4] = [-boundingRect.width / 2, -boundingRect.height / 2];\r\n\r\n        var boundRect, cx, cy;\r\n        if (node instanceof graphic.Circle) {\r\n            //注: 因事件为圆形  所以 x y 为圆心的位置  包围矩形要减去宽度一半\r\n            boundRect = new BoundingRect(Number(node.position[0]) - Number(boundingRect.width / 2),\r\n                Number(node.position[1]) - Number(boundingRect.height / 2),\r\n                Number(boundingRect.width), Number(boundingRect.height));\r\n            cx = Number(node.position[0]);\r\n            cy = Number(node.position[1]);\r\n        } else {\r\n            boundRect = new BoundingRect(Number(node.position[0]),\r\n                Number(node.position[1]),\r\n                Number(boundingRect.width), Number(boundingRect.height));\r\n            cx = Number(node.position[0]) + Number(boundingRect.width) / 2;\r\n            cy = Number(node.position[1]) + Number(boundingRect.height) / 2;\r\n        }\r\n        return {\r\n            x: Number(cx),\r\n            y: Number(cy),\r\n            width: Number(boundingRect.width),\r\n            height: Number(boundingRect.height),\r\n            points: points,\r\n            boundingRect: boundRect\r\n        };\r\n    }\r\n\r\n    var StackedMap = {\r\n        createNew: function() {\r\n            var stack = [];\r\n\r\n            return {\r\n                add: function(key, value) {\r\n                    var arrKey = this.get(key);\r\n                    arrKey.push(value)\r\n\r\n                },\r\n                get: function(key) {\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            return stack[i].value;\r\n                        }\r\n                    }\r\n                    //如果没有找到的话，则创建一个新的数组\r\n                    var value = [];\r\n                    stack.push({ key: key, value: value });\r\n                    return value;\r\n                },\r\n                keys: function() {\r\n                    var keys = [];\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        keys.push(stack[i].key);\r\n                    }\r\n                    return keys;\r\n                },\r\n                top: function() {\r\n                    return stack[stack.length - 1];\r\n                },\r\n                remove: function(key) {\r\n                    var idx = -1;\r\n                    for (var i = 0; i < stack.length; i++) {\r\n                        if (key == stack[i].key) {\r\n                            idx = i;\r\n                            break;\r\n                        }\r\n                    }\r\n                    return stack.splice(idx, 1)[0];\r\n                },\r\n                removeItem: function(key, item) {\r\n                    var arrKey = this.get(key);\r\n                    var index = zrUtil.indexOf(arrKey, item);\r\n                    arrKey.splice(index, 1);\r\n\r\n                },\r\n                removeTop: function() {\r\n                    return stack.splice(stack.length - 1, 1)[0];\r\n                },\r\n                length: function() {\r\n                    return stack.length;\r\n                },\r\n                clear: function() {\r\n                    stack.splice(0, stack.length);\r\n                }\r\n            };\r\n        }\r\n    };\r\n\r\n    function randomColor() {\r\n        var arrHex = [\"0\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\"],\r\n            strHex = \"#\",\r\n            index;\r\n        for (var i = 0; i < 6; i++) {\r\n            index = Math.round(Math.random() * 15);\r\n            strHex += arrHex[index];\r\n        }\r\n        return strHex;\r\n    }\r\n\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n    function collinearReduction (v) {\r\n        var r = [];\r\n\r\n        if(v.length < 3){\r\n            return Point.cloneArray(v);\r\n        }\r\n\r\n        r.push( v[0].clone() );\r\n        for(var i=1; i < v.length-1; i++){\r\n            if( (v[i-1].x == v[i].x && v[i].x == v[i+1].x)  ||  (v[i-1].y == v[i].y && v[i].y == v[i+1].y) )\r\n            {\r\n                continue;\r\n            }\r\n            else{\r\n                r.push( v[i].clone() );\r\n            }\r\n        }\r\n        r.push( v[v.length-1].clone() );\r\n\r\n        return r;\r\n    }\r\n\r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n        \"'\": \"'\",\r\n        '\\\\': '\\\\',\r\n        '\\r': 'r',\r\n        '\\n': 'n',\r\n        '\\u2028': 'u2028',\r\n        '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\r\n\r\n    var escapeChar = function(match) {\r\n        return '\\\\' + escapes[match];\r\n    };\r\n\r\n    // JavaScript micro-templating, similar to John Resig's implementation.\r\n    // Underscore templating handles arbitrary delimiters, preserves whitespace,\r\n    // and correctly escapes quotes within interpolated code.\r\n    // NB: `oldSettings` only exists for backwards compatibility.\r\n    function template(text, settings, oldSettings) {\r\n        if (!settings && oldSettings) settings = oldSettings;\r\n        settings = settings || {};\r\n        settings = zrUtil.defaults(settings, templateSettings, true);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n            (settings.escape || noMatch).source,\r\n            (settings.interpolate || noMatch).source,\r\n            (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n            source += text.slice(index, offset).replace(escaper, escapeChar);\r\n            index = offset + match.length;\r\n\r\n            if (escape) {\r\n                source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n            } else if (interpolate) {\r\n                source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n            } else if (evaluate) {\r\n                source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n            }\r\n\r\n            // Adobe VMs need the match returned to produce the correct offest.\r\n            return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n            \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n            source + 'return __p;\\n';\r\n\r\n        try {\r\n            var render = new Function(settings.variable || 'obj', source);\r\n        } catch (e) {\r\n            e.source = source;\r\n            throw e;\r\n        }\r\n\r\n        var template = function(data) {\r\n            return render.call(this, data);\r\n        };\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    function isEmpty(obj) {\r\n        if (obj == null) return true;\r\n        if (zrUtil.isArrayLike(obj) && (zrUtil.isArray(obj) || zrUtil.isString(obj))) return obj.length === 0;\r\n    }\r\n\r\n    module.exports = {\r\n        inherits: inherits,\r\n        getUUID: getUUID,\r\n        distance: distance,\r\n        getPolylineLength: getPolylineLength,\r\n        max: max,\r\n        min: min,\r\n        isEmpty: isEmpty,\r\n        orthogonalPath: orthogonalPath,\r\n        polylineIntersectsRectangle: polylineIntersectsRectangle,\r\n        scorePath: scorePath,\r\n        forwardPath: forwardPath,\r\n        traslatePoints: traslatePoints,\r\n        getEndPoint: getEndPoint,\r\n        getConnectorPoints: getConnectorPoints,\r\n        tangentRotation: tangentRotation,\r\n        collinearity: collinearity,\r\n        translationMatrix: translationMatrix,\r\n        scaleMatrix: scaleMatrix,\r\n        round: enhancedRound,\r\n        getLength: getLength,\r\n        getAngle: getAngle,\r\n        getRect: getRect,\r\n        StackedMap: StackedMap,\r\n        getMaxLineLength: getMaxLineLength,\r\n        randomColor: randomColor,\r\n        template: template,\r\n        isUndefined: isUndefined,\r\n        getSoltPoints:getSoltPoints,\r\n        collinearReduction: collinearReduction\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/util.js\n ** module id = 71\n ** module chunks = 0\n **/","\r\n\r\n    /**\r\n      * Creates an instance of Point\r\n      *\r\n      *\r\n      * @constructor\r\n      * @this {Point}\r\n      * @param {Number} x The x coordinate of point.\r\n      * @param {Number} y The y coordinate of point.\r\n      * Note: Even if it is named Point this class should be named Dot as Dot is closer\r\n      * then Point from math perspective.\r\n      **/\r\n    function Point(x, y){\r\n        /**The x coordinate of point*/\r\n        this.x = x;\r\n        \r\n        /**The y coordinate of point*/\r\n        this.y = y;\r\n        \r\n\r\n    }\r\n\r\n    /**Creates a {Point} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Point} a newly constructed Point\r\n     **/\r\n    Point.load = function(o){\r\n        var newPoint = new Point(Number(o.x), Number(o.y));\r\n        return newPoint;\r\n    };\r\n\r\n\r\n    /**Creates an array of points from an array of {JSONObject}s\r\n     *@param {Array} v - the array of JSONObjects\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.loadArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(Point.load(v[i]));\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n\r\n    /**Clones an array of points\r\n     *@param {Array} v - the array of {Point}s\r\n     *@return an {Array} of {Point}s\r\n     **/\r\n    Point.cloneArray = function(v){\r\n        var newPoints = [];\r\n        for(var i=0; i< v.length; i++){\r\n            newPoints.push(v[i].clone());\r\n        }\r\n        return newPoints;\r\n    };\r\n\r\n    Point.prototype = {\r\n        constructor : Point,\r\n        \r\n        transform:function(matrix){\r\n            var oldX = this.x;\r\n            var oldY = this.y;\r\n            this.x = matrix[0][0] * oldX + matrix[0][1] * oldY + matrix[0][2];\r\n            this.y = matrix[1][0] * oldX + matrix[1][1] * oldY + matrix[1][2];\r\n        },\r\n        \r\n        /**Tests if this point is similar to other point\r\n         *@param {Point} anotherPoint - the other point\r\n         **/\r\n        equals:function(anotherPoint){\r\n            if(! (anotherPoint instanceof Point) ){\r\n                return false;\r\n            }\r\n            return (this.x == anotherPoint.x)\r\n            && (this.y == anotherPoint.y)\r\n        },\r\n\r\n        /**Clone current Point\r\n         **/\r\n        clone: function(){\r\n            var newPoint = new Point(this.x, this.y);\r\n            return newPoint;\r\n        },\r\n\r\n        /**Tests to see if a point (x, y) is within a range of current Point\r\n         *@param {Numeric} x - the x coordinate of tested point\r\n         *@param {Numeric} y - the x coordinate of tested point\r\n         *@param {Numeric} radius - the radius of the vicinity\r\n         **/\r\n        near:function(x, y, radius){\r\n            var distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));\r\n\r\n            return (distance <= radius);\r\n        },\r\n\r\n        contains: function(x,y){\r\n            return this.x == x && this.y == y;\r\n        },\r\n\r\n        toString:function(){\r\n            return '[' + this.x + ',' + this.y + ']';\r\n        },\r\n\r\n        getPoints:function(){\r\n            return [this];\r\n        }\r\n    };\r\n    module.exports = Point;\r\n    \n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Point.js\n ** module id = 72\n ** module chunks = 0\n **/","\r\n\r\n    /**\r\n      * Creates an instance of a Line. A Line is actually a segment and not a pure\r\n      * geometrical Line\r\n      *\r\n      * @constructor\r\n      * @this {Line}\r\n      * @param {Point} startPoint - starting point of the line\r\n      * @param {Point} endPoint - the ending point of the line\r\n      **/\r\n    function Line(startPoint, endPoint){\r\n        /**Starting {@link Point} of the line*/\r\n        this.startPoint = startPoint;\r\n\r\n        /**Ending {@link Point} of the line*/\r\n        this.endPoint = endPoint;\r\n\r\n        /**Serialization type*/\r\n        this.oType = 'Line'; //object type used for JSON deserialization\r\n    }\r\n\r\n    /**Creates a {Line} out of JSON parsed object\r\n     *@param {JSONObject} o - the JSON parsed object\r\n     *@return {Line} a newly constructed Line\r\n     **/\r\n    Line.load = function(o){\r\n        var newLine = new Line(\r\n            Point.load(o.startPoint),\r\n            Point.load(o.endPoint)\r\n        );\r\n\r\n        return newLine;\r\n    };\r\n\r\n    Line.prototype = {\r\n        contructor: Line,\r\n\r\n\r\n\r\n        clone:function(){\r\n            var ret = new Line(this.startPoint.clone(), this.endPoint.clone());\r\n            return ret;\r\n        },\r\n\r\n        equals:function(anotherLine){\r\n            if(!anotherLine instanceof Line){\r\n                return false;\r\n            }\r\n            return this.startPoint.equals(anotherLine.startPoint)\r\n            && this.endPoint.equals(anotherLine.endPoint)\r\n        },\r\n\r\n        /** Tests to see if a point belongs to this line (not as infinite line but more like a segment)\r\n         * Algorithm: Compute line's equation and see if (x, y) verifies it.\r\n         * @param {Number} x - the X coordinates\r\n         * @param {Number} y - the Y coordinates\r\n         **/\r\n        contains: function(x, y){\r\n            // if the point is inside rectangle bounds of the segment\r\n            if (Math.min(this.startPoint.x, this.endPoint.x) <= x\r\n                && x <= Math.max(this.startPoint.x, this.endPoint.x)\r\n                && Math.min(this.startPoint.y, this.endPoint.y) <= y\r\n                && y <= Math.max(this.startPoint.y, this.endPoint.y)) {\r\n\r\n                // check for vertical line\r\n                if (this.startPoint.x == this.endPoint.x) {\r\n                    return x == this.startPoint.x;\r\n                } else { // usual (not vertical) line can be represented as y = a * x + b\r\n                    var a = (this.endPoint.y - this.startPoint.y) / (this.endPoint.x - this.startPoint.x);\r\n                    var b = this.startPoint.y - a * this.startPoint.x;\r\n                    return y == a * x + b;\r\n                }\r\n            } else {\r\n                return false;\r\n            }\r\n        },\r\n\r\n        /*\r\n         *See if we are near a {Line} by a certain radius (also includes the extremities into computation)\r\n         *@param {Number} x - the x coordinates\r\n         *@param {Number} y - the y coordinates\r\n         *@param {Number} radius - the radius to search for\r\n         *@see http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n         *@see \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n         **/\r\n        near:function(x,y,radius){\r\n\r\n            if(this.endPoint.x === this.startPoint.x){ //Vertical line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.y-radius<=y && this.endPoint.y+radius>=y)\r\n                        || (this.endPoint.y-radius<=y && this.startPoint.y+radius>=y))\r\n                && x > this.startPoint.x - radius && x < this.startPoint.x + radius ;\r\n            }\r\n\r\n            if(this.startPoint.y === this.endPoint.y){ //Horizontal line, so the vicinity area is a rectangle\r\n                return ( (this.startPoint.x - radius<=x && this.endPoint.x+radius>=x)\r\n                        || (this.endPoint.x-radius<=x && this.startPoint.x+radius>=x))\r\n                        && y>this.startPoint.y-radius && y<this.startPoint.y+radius ;\r\n            }\r\n\r\n\r\n            var startX = Math.min(this.endPoint.x,this.startPoint.x);\r\n            var startY = Math.min(this.endPoint.y,this.startPoint.y);\r\n            var endX = Math.max(this.endPoint.x,this.startPoint.x);\r\n            var endY = Math.max(this.endPoint.y,this.startPoint.y);\r\n\r\n            /*We will compute the distance from point to the line\r\n             * by using the algorithm from\r\n             * http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\r\n             * */\r\n\r\n            //First we need to find a,b,c of the line equation ax + by + c = 0\r\n            var a = this.endPoint.y - this.startPoint.y;\r\n            var b = this.startPoint.x - this.endPoint.x;\r\n            var c = -(this.startPoint.x * this.endPoint.y - this.endPoint.x * this.startPoint.y);\r\n\r\n            //Secondly we get the distance \"Mathematics for Computer Graphics, 2nd Ed., by John Vice, page 227\"\r\n            var d = Math.abs( (a*x + b*y + c) / Math.sqrt(Math.pow(a,2) + Math.pow(b,2)) );\r\n\r\n            //Thirdly we get coordinates of closest line's point to target point\r\n            //http://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Cartesian_coordinates\r\n            var closestX = (b * (b*x - a*y) - a*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n            var closestY = (a * (-b*x + a*y) - b*c) / ( Math.pow(a,2) + Math.pow(b,2) );\r\n\r\n            var r = ( d <= radius && endX>=closestX && closestX>=startX && endY>=closestY && closestY>=startY ) //the projection of the point falls INSIDE of the segment\r\n                || this.startPoint.near(x,y,radius) || this.endPoint.near(x,y,radius); //the projection of the point falls OUTSIDE of the segment\r\n\r\n            return  r;\r\n\r\n        },\r\n\r\n        /**we need to create a new array each time, or we will affect the actual shape*/\r\n        getPoints:function(){\r\n            var points = [];\r\n            points.push(this.startPoint);\r\n            points.push(this.endPoint);\r\n            return points;\r\n        },\r\n\r\n        /**Return the {Point} corresponding the t certain t value\r\n         * @param {Number} t the value of parameter t, where t in [0,1], t is like a percent*/\r\n        getPoint: function(t){\r\n            var Xp = t * (this.endPoint.x - this.startPoint.x) + this.startPoint.x;\r\n            var Yp = t * (this.endPoint.y - this.startPoint.y) + this.startPoint.y;\r\n\r\n            return new Point(Xp, Yp);\r\n        },\r\n\r\n        // /**\r\n        //  * Returns the middle of the line\r\n        //  * @return {Point} the middle point\r\n        //  * */\r\n        // getMiddle : function(){\r\n        //     return Util.getMiddle(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n\r\n        // getLength : function(){\r\n        //     return Util.getLength(this.startPoint, this.endPoint);\r\n        // },\r\n\r\n        // /**\r\n        //  *Get bounds for this line\r\n        //  *@author Alex Gheorghiu <alex@scriptoid.com>\r\n        //  **/\r\n        // getBounds:function(){\r\n        //     return Util.getBounds(this.getPoints());\r\n        // },\r\n\r\n        /**String representation*/\r\n        toString:function(){\r\n            return 'line(' + this.startPoint + ',' + this.endPoint + ')';\r\n        }\r\n    };\r\n    module.exports = Line;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/LineStruct.js\n ** module id = 73\n ** module chunks = 0\n **/","/**\r\n * Network model\r\n *\r\n */\r\n\r\n\r\n    var Model = require('../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var NetworkModel = Model.extend({\r\n        /**\r\n         * @type {Object}\r\n         * @protected\r\n         */\r\n        defaultOption: {\r\n        \tresourceId: \"\",  //资源ID\r\n            properties: {\r\n                type: -1,  //类型\r\n                name: \"\", //名称\r\n                notes: \"\",  //备注\r\n                //no: \"\"\r\n                extProperties: {\r\n                },  //扩展属性\r\n                bounds: {\r\n                    upperLeft: {x: 0, y: 0},  //左上角坐标\r\n                    lowerRight: {x: 0, y: 0} //右下角坐标\r\n                }\r\n            },\r\n            stencil: {type: \"NextworkNode\"},\r\n            showTip: false\r\n        },\r\n\r\n        init: function (option, parentModel, extraOpt) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        }\r\n\r\n    });\r\n    module.exports = NetworkModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/NetworkModel.js\n ** module id = 74\n ** module chunks = 0\n **/","/**\r\n * 节点等的模型\r\n * 里面存的数据用来处理序列化和反序列化\r\n * @class fish.topo.model\r\n */\r\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var clazzUtil = require('./clazz');\r\n\r\n    function Model(option, parentModel,  extraOpt) {\r\n        this.parentModel = parentModel;\r\n        this.option = option;\r\n\r\n        // Simple optimization\r\n        if (this.init) {\r\n            if (arguments.length <= 3) {\r\n                this.init(option, parentModel,  extraOpt);\r\n            }\r\n            else {\r\n                this.init.apply(this, arguments);\r\n            }\r\n        }\r\n    }\r\n\r\n    Model.prototype = {\r\n\r\n        constructor: Model,\r\n\r\n        /**\r\n         * Model 的初始化函数\r\n         * @private\r\n         * @param {Object} option\r\n         */\r\n        init: function (option) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        mergeOption: function (option) {\r\n            zrUtil.merge(this.option, option, true);\r\n        },\r\n\r\n        /**\r\n         * 获取model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.get(\"options.text\");\r\n         */\r\n        get: function (path, ignoreParent) {\r\n            if (!path) {\r\n                return this.option;\r\n            }\r\n\r\n            if (typeof path === 'string') {\r\n                path = path.split('.');\r\n            }\r\n\r\n            var obj = this.option;\r\n            var parentModel = this.parentModel;\r\n            for (var i = 0; i < path.length; i++) {\r\n                // obj could be number/string/... (like 0)\r\n                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;\r\n                if (obj == null) {\r\n                    break;\r\n                }\r\n            }\r\n            if (obj == null && parentModel && !ignoreParent) {\r\n                obj = parentModel.get(path);\r\n            }\r\n            return obj;\r\n        },\r\n\r\n        /**\r\n         * 设置model的某个属性的值\r\n         * @param {string} path model中的属性\r\n         * @param {String} value 所需要设置的值\r\n         * @return {String}\r\n         *\r\n         * **使用范例**：\r\n         *\r\n         *      @example\r\n         *          node.model.set(\"options.text\",\"例子\");\r\n         */\r\n        set: function (path, value) {\r\n            var obj = this.option;\r\n\r\n            if (path.indexOf(\".\") == -1) {\r\n                obj[path] = value;\r\n            } else {\r\n                var fieldArray  = path.split('.');\r\n                var n = fieldArray.length;\r\n                var currentRef = obj;\r\n                var fieldName;\r\n\r\n                for (var i = 0; i < n - 1; i++) {\r\n                    fieldName = fieldArray[i];\r\n                    if(currentRef[fieldName] == null) {\r\n                        currentRef[fieldName] = {};\r\n                    }\r\n                    currentRef = currentRef[fieldName];\r\n                }\r\n                fieldName = fieldArray[n-1];\r\n                currentRef[fieldName] = value;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getShallow: function (key, ignoreParent) {\r\n            var option = this.option;\r\n            var val = option && option[key];\r\n            var parentModel = this.parentModel;\r\n            if (val == null && parentModel && !ignoreParent) {\r\n                val = parentModel.getShallow(key);\r\n            }\r\n            return val;\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        getModel: function (path, parentModel) {\r\n            var obj = this.get(path, true);\r\n            var thisParentModel = this.parentModel;\r\n            var model = new Model(\r\n                obj, parentModel || (thisParentModel && thisParentModel.getModel(path))\r\n            );\r\n            return model;\r\n        },\r\n\r\n        /**\r\n         *清空model的option\r\n         * @private\r\n         */\r\n        isEmpty: function () {\r\n            return this.option == null;\r\n        },\r\n\r\n        restoreData: function () {},\r\n\r\n        /**\r\n         * @private\r\n         */\r\n        clone: function () {\r\n            var Ctor = this.constructor;\r\n            return new Ctor(zrUtil.clone(this.option));\r\n        }\r\n    };\r\n\r\n    // Enable Model.extend.\r\n    clazzUtil.enableClassExtend(Model);\r\n\r\n    module.exports = Model;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Model.js\n ** module id = 75\n ** module chunks = 0\n **/","\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var clazz = {};\r\n\r\n    var TYPE_DELIMITER = '.';\r\n    var IS_CONTAINER = '___FT__COMPONENT__CONTAINER___';\r\n    /**\r\n     * @public\r\n     */\r\n    var parseClassType = clazz.parseClassType = function (componentType) {\r\n        var ret = {main: '', sub: ''};\r\n        if (componentType) {\r\n            componentType = componentType.split(TYPE_DELIMITER);\r\n            ret.main = componentType[0] || '';\r\n            ret.sub = componentType[1] || '';\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * @public  相比 直接用zrUtil.inherits 好处是  可以直接调用父类的构造函数\r\n     */\r\n    clazz.enableClassExtend = function (RootClass, preConstruct) {\r\n        RootClass.extend = function (proto) {\r\n            var ExtendedClass = function () {\r\n                preConstruct && preConstruct.apply(this, arguments);\r\n                RootClass.apply(this, arguments);\r\n            };\r\n\r\n            zrUtil.extend(ExtendedClass.prototype, proto);\r\n\r\n            ExtendedClass.extend = this.extend;\r\n            ExtendedClass.superCall = superCall;\r\n            ExtendedClass.superApply = superApply;\r\n            zrUtil.inherits(ExtendedClass, this);\r\n            ExtendedClass.superClass = this;\r\n\r\n            return ExtendedClass;\r\n        };\r\n    };\r\n\r\n    // superCall should have class info, which can not be fetch from 'this'.\r\n    // Consider this case:\r\n    // class A has method f,\r\n    // class B inherits class A, overrides method f, f call superApply('f'),\r\n    // class C inherits class B, do not overrides method f,\r\n    // then when method of class C is called, dead loop occured.\r\n    function superCall(context, methodName) {\r\n        var args = zrUtil.slice(arguments, 2);\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    function superApply(context, methodName, args) {\r\n        return this.superClass.prototype[methodName].apply(context, args);\r\n    }\r\n\r\n    /**\r\n     * @param {Object} entity\r\n     * @param {Object} options\r\n     * @param {boolean} [options.registerWhenExtend]\r\n     * @public\r\n     */\r\n    clazz.enableClassManagement = function (entity, options) {\r\n        options = options || {};\r\n\r\n        /**\r\n         * Component model classes\r\n         * key: componentType,\r\n         * value:\r\n         *     componentClass, when componentType is 'xxx'\r\n         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'\r\n         * @type {Object}\r\n         */\r\n        var storage = {};\r\n\r\n        entity.registerClass = function (Clazz, componentType) {\r\n            if (componentType) {\r\n                componentType = parseClassType(componentType);\r\n\r\n                if (!componentType.sub) {\r\n                    if (storage[componentType.main]) {\r\n                        //已经注册过了，直接返回\r\n                        return;\r\n                    }\r\n                    storage[componentType.main] = Clazz;\r\n                }\r\n                else if (componentType.sub !== IS_CONTAINER) {\r\n                    var container = makeContainer(componentType);\r\n                    container[componentType.sub] = Clazz;\r\n                }\r\n            }\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {\r\n            var Clazz = storage[componentTypeMain];\r\n\r\n            if (Clazz && Clazz[IS_CONTAINER]) {\r\n                Clazz = subType ? Clazz[subType] : null;\r\n            }\r\n\r\n            if (throwWhenNotFound && !Clazz) {\r\n                throw new Error(\r\n                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'\r\n                );\r\n            }\r\n\r\n            return Clazz;\r\n        };\r\n\r\n        entity.getClassesByMainType = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n\r\n            var result = [];\r\n            var obj = storage[componentType.main];\r\n\r\n            if (obj && obj[IS_CONTAINER]) {\r\n                zrUtil.each(obj, function (o, type) {\r\n                    type !== IS_CONTAINER && result.push(o);\r\n                });\r\n            }\r\n            else {\r\n                result.push(obj);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        entity.hasClass = function (componentType) {\r\n            // Just consider componentType.main.\r\n            componentType = parseClassType(componentType);\r\n            return !!storage[componentType.main];\r\n        };\r\n\r\n        /**\r\n         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']\r\n         */\r\n        entity.getAllClassMainTypes = function () {\r\n            var types = [];\r\n            zrUtil.each(storage, function (obj, type) {\r\n                types.push(type);\r\n            });\r\n            return types;\r\n        };\r\n\r\n        /**\r\n         * If a main type is container and has sub types\r\n         * @param  {string}  componentType\r\n         * @return {boolean}\r\n         */\r\n        entity.hasSubTypes = function (componentType) {\r\n            componentType = parseClassType(componentType);\r\n            var obj = storage[componentType.main];\r\n            return obj && obj[IS_CONTAINER];\r\n        };\r\n\r\n        entity.parseClassType = parseClassType;\r\n\r\n        function makeContainer(componentType) {\r\n            var container = storage[componentType.main];\r\n            if (!container || !container[IS_CONTAINER]) {\r\n                container = storage[componentType.main] = {};\r\n                container[IS_CONTAINER] = true;\r\n            }\r\n            return container;\r\n        }\r\n\r\n        if (options.registerWhenExtend) {\r\n            var originalExtend = entity.extend;\r\n            if (originalExtend) {\r\n                entity.extend = function (proto) {\r\n                    var ExtendedClass = originalExtend.call(this, proto);\r\n                    return entity.registerClass(ExtendedClass, proto.type);\r\n                };\r\n            }\r\n        }\r\n\r\n        return entity;\r\n    };\r\n\r\n    module.exports = clazz;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/clazz.js\n ** module id = 76\n ** module chunks = 0\n **/","\r\n\tvar Node = require(\"../../../fish-topo-core/lib/Node\");\r\n\tvar zrUtil = require('zrender/lib/core/util');\r\n\tvar graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\tvar clazzUtil = require('../../../fish-topo-core/lib/clazz');\r\n\t\r\n\t//创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\tfunction NetworkNode(model, api) {\r\n\t\tNode.call(this);\r\n\t\tthis.model = model;\t\t\r\n\t\tthis.options =\r\n\t\t{\r\n\t\t\toutline: {\r\n\t\t\t\tenable: true, // 是否有外框\r\n\t\t\t\tradius: true, // 是否圆角\r\n\t\t\t\tinitVisible: false\r\n\t\t\t},\r\n\t\t\ttext: {\r\n\t\t\t\tcolor: '#000000', // 文本颜色\r\n\t\t\t\tlineHeight: 24 // 文本行高\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.nextworkInfo = {type: -1, name:\"NextworkNode\" };    //节点信息\r\n\t\tthis.portNodeList = [];\r\n\t\tthis.cardNodeList = [];\r\n\t\tthis.initEvent(api);\r\n\t};\r\n\r\n    NetworkNode.prototype.initEvent = function(api) {\r\n        var that = this;\r\n        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n        //     that.on(eveName, function (e) {\r\n\t       //      var params = {};\r\n\t       //      params.event = e;\r\n\t       //      params.type = eveName;\r\n\t       //      params.model = that.model\r\n\t       //      api.trigger(eveName, params); \r\n        //     }, this);\r\n        // }, this);\r\n    };\t\r\n\r\n\tNetworkNode.prototype.render = function() {\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * drawText\r\n\t * @description 画一个文本\r\n\t * @param {string} content\r\n\t * @param {number} x\r\n\t * @param {number} y\r\n\t * @param {string} color\r\n\t */\r\n\tNetworkNode.prototype.drawText = function (content, x, y, color) {\r\n\t\tvar text = new graphic.Text({\r\n\t\t\tstyle: {\r\n\t\t\t\ttext: content,\r\n\t\t\t\tx: x,\r\n\t\t\t\ty: y + 6,\r\n\t\t\t\tcolor: color ? color : this.options.text.color,\r\n\t\t\t\ttextFont: '12px Microsoft YaHei'\r\n\t\t\t},\r\n\t\t\tzlevel: 20\r\n\t\t});\r\n\t\treturn {\r\n\t\t\ttext: text,\r\n\t\t\trect: text.getBoundingRect()\r\n\t\t};\r\n\t};\t\r\n\r\n\r\n\tNetworkNode.prototype.toJSON = function() {\r\n\t\tthis.model.set(\"resourceId\", this.resourceId);\r\n\t\tthis.model.set(\"properties.type\", this.nextworkInfo.type);\r\n\t\tthis.model.set(\"stencil.type\", this.nextworkInfo.name);\r\n\t\tthis.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n\t\tthis.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n\t\tthis.model.set(\"bounds.lowerRight.x\", this.position[0] + this.getBoundingRect().width);\r\n\t\tthis.model.set(\"bounds.lowerRight.y\", this.position[1] + this.getBoundingRect().height);\r\n\t\treturn this.model.option;\r\n\t};\r\n\tzrUtil.inherits(NetworkNode, Node);\r\n\r\n\tclazzUtil.enableClassManagement(NetworkNode, {\r\n        registerWhenExtend: true\r\n    });\r\n\tmodule.exports = NetworkNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/NetworkNode.js\n ** module id = 77\n ** module chunks = 0\n **/","\r\n    var graphic = require('./graphic');\r\n    var util = require(\"./util.js\")\r\n    //创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n    function Node() {\r\n        this.resourceId = util.getUUID(); // 生成节点ID\r\n        graphic.Group.call(this);\r\n    }\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.render = function() {};\r\n\r\n    /**\r\n     * 由父类实现\r\n     * @param  {[type]} json [description]\r\n     * @return {[type]}      [description]\r\n     */\r\n    Node.prototype.getRect = function(json) {};\r\n\r\n    /**\r\n     * drawText\r\n     * @description 画一个文本\r\n     * @param {string} name\r\n     * @param {string} color\r\n     */\r\n    Node.prototype.drawText = function(name,color) {\r\n        var textName = this.bpmnInfo.name;\r\n        if(name != null){\r\n            textName = name;\r\n        }\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: textName,\r\n                color: color ? color : this.options.text.color,\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            zlevel: 20\r\n        });\r\n        //文字绘制的位置  \r\n        //x = 中心点.x - 起始位置.x - 文字宽度的一半\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        //y = 中心点.y - 起始位置.y + 节点高度的一半 + 偏移值（6）\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n    /**\r\n     * refreshText\r\n     * @description 刷新文本\r\n     */\r\n    Node.prototype.refreshText = function() {\r\n        var text = this.childOfName(\"Title\");\r\n        var x = this.getRect().x - this.position[0] - text.getBoundingRect().width / 2;\r\n        var y = this.getRect().y - this.position[1] + this.getBoundingRect().height / 2 + text.getBoundingRect().height + 6;\r\n        text.attr(\"style\", { x: x, y: y });\r\n    };\r\n    /**\r\n     * 由父类实现\r\n     * @return {[type]} [description]\r\n     */\r\n    Node.prototype.toJSON = function() {};\r\n\r\n    graphic.Util.inherits(Node, graphic.Group);\r\n    module.exports = Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/Node.js\n ** module id = 78\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function RackNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"RackNode\" };    \r\n        this.model = model;\r\n        this.render(model, api);\r\n    };\r\n\r\n    RackNode.prototype.render = function(model,api) {\r\n        this.model = model;\r\n        var _UData = model.get(\"UData\");\r\n        var _showTip = model.get(\"showTip\");\r\n        var _rackName = model.get(\"rack\");\r\n        var _rackId = model.get(\"id\");\r\n        var _description = model.get(\"description\");\r\n        //title\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: 80,\r\n                y: -30,\r\n                text: _rackName + '  42U',\r\n                width: 80,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '18px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true,\r\n            parmDate: { operation: \"detailRack\", rack: _rackName, id:_rackId, description: _description}\r\n        });\r\n        this.add(_title);\r\n\r\n        var afterButtonNode = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 40,\r\n                y: -27,\r\n                image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/delete.png',\r\n                width: 18,\r\n                height: 18\r\n            },\r\n            z: 1000,\r\n            draggable: false,\r\n            parmDate: { operation: \"deleteRack\", rack: _rackName, id:_rackId }\r\n        }); \r\n        this.add(afterButtonNode);\r\n\r\n        //绑定悬浮事件\r\n        var MOUSE_EVENT_NAMES = ['click'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n\r\n            _title.on(eveName, function (e) {\r\n                var params = {};\r\n                if (eveName === \"click\") {\r\n                    var _parmDate = e.target.parmDate;\r\n                    params.event = _parmDate;\r\n                }  \r\n                api.trigger(eveName, params); \r\n            }, this);\r\n\r\n            afterButtonNode.on(eveName, function (e) {\r\n                var params = {};\r\n                if (eveName === \"click\") {\r\n                    var _parmDate = e.target.parmDate;\r\n                    params.event = _parmDate;\r\n                }  \r\n                api.trigger(eveName, params); \r\n            }, this);\r\n\r\n\r\n        }, this);\r\n  \r\n        var rectOut = new graphic.Rect({\r\n            shape: {\r\n                x: 0,\r\n                y: 0,\r\n                width: model.get(\"width\"),\r\n                height: model.get(\"height\")\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '1'//,\r\n            }          \r\n        });        \r\n        this.add(rectOut);\r\n        var rectIn = new graphic.Rect({\r\n            shape: {\r\n                x: 5,\r\n                y: 5,\r\n                width: model.get(\"width\") - 10,\r\n                height: model.get(\"height\") - 10\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '1'//,\r\n            }          \r\n        });        \r\n        this.add(rectIn);\r\n\r\n        var j = 1;\r\n        var _startY =  635;\r\n        while( j < 43 ) { \r\n            var _floorNum = 1;\r\n            // var _y =  5 + ((42 - j ) * 15);\r\n            var _y =  _startY - (j * 15);\r\n            var _isnullFloor = false;\r\n            for ( var f = 0; f < _UData.length; f++ ) {\r\n                if ( j === parseInt(_UData[f].floor) ) {\r\n                    _floorNum = parseInt(_UData[f].height);\r\n                    _y = _y - (_floorNum - 1) * 15;\r\n                    var _server = \"Server\";\r\n                    if (_UData[f].type.toUpperCase() === \"SWITCH\") {\r\n                        _server = \"Switch\";\r\n                    }\r\n                    var modelObj = {\r\n                        resourceId: util.getUUID(),  \r\n                        properties: {\r\n                            type: \"Server\",         \r\n                            extProperties: {\r\n                            }  \r\n                        },\r\n                        bounds: {\r\n                            upperLeft: {x: 5, y: _y}  \r\n                        },\r\n                        stencil: {type: _server + \"Node\"}\r\n                    };\r\n                    modelObj.height =  15 * _floorNum - 1;\r\n                    modelObj.width = model.get(\"width\") - 10;\r\n                    modelObj.parmDate = _UData[f];\r\n                    modelObj.floor = _UData[f].floor;\r\n                    modelObj.status = _UData[f].status;\r\n                    modelObj.floorNum = _floorNum;\r\n                    // if () {\r\n\r\n                    // }\r\n                    modelObj.serverType =  (_UData[f].vendor === undefined || _UData[f].vendor === \"Unknown\") ? \"Server\": _UData[f].vendor;\r\n                    if( _UData[f].column !== undefined) {\r\n                        modelObj.column = _UData[f].column;\r\n                    }\r\n                    //判断是否band悬浮事件\r\n                    modelObj.showTip = _showTip;\r\n                    var serverModel = new NetworkModel(modelObj);\r\n                    this.addNodeByModel(serverModel, api);\r\n\r\n                    var rectTray = new graphic.Rect({\r\n                        shape: {\r\n                            x: 5,\r\n                            y: _y + (15 * _floorNum) - 1 ,\r\n                            width: model.get(\"width\") - 10,\r\n                            height: 1\r\n                        },\r\n                        style: {\r\n                            fill: '#FFFFFF',\r\n                            stroke: '#B3B3B3',\r\n                            lineWidth: '0.5'//,\r\n                        }          \r\n                    });        \r\n                    this.add(rectTray);\r\n                    _isnullFloor = true;\r\n                }\r\n            }\r\n            if( !_isnullFloor ) {\r\n                //   var rectTray = new graphic.Rect({\r\n                //     shape: {\r\n                //         x: 5,\r\n                //         y: 5 + ((42 - j ) * 15) ,\r\n                //         width: model.get(\"width\") - 10,\r\n                //         height: 15\r\n                //     },\r\n                //     style: {\r\n                //         fill: '#FFFFFF',\r\n                //         stroke: '#B3B3B3',\r\n                //         lineDash: [3],  \r\n                //         lineWidth: '1'//,\r\n                //     }          \r\n                // });        \r\n                // this.add(rectTray);\r\n\r\n                var modelObj = {\r\n                    resourceId: util.getUUID(),  \r\n                    properties: {\r\n                        type: \"EmptyFloor\",         \r\n                        extProperties: {\r\n                        }  \r\n                    },\r\n                    bounds: {\r\n                        upperLeft: {x: 5, y: _y}  \r\n                    },\r\n                    width: model.get(\"width\"),\r\n                    height: 15,\r\n                    stencil: {type: \"EmptyFloorNode\"}\r\n                };\r\n                modelObj.showTip = _showTip;\r\n                modelObj.parmDate = {nodeType: 'EmptyFloorNode', floor: j};\r\n                var emptyFloorModel = new NetworkModel(modelObj);\r\n                this.addNodeByModel(emptyFloorModel, api);\r\n\r\n            }\r\n            j = j + _floorNum;\r\n        }\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    RackNode.prototype.addNodeByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this.api);\r\n            this.add(node);\r\n            var MOUSE_EVENT_NAMES = ['click'];\r\n            if ( p_model.get(\"showTip\") ) {\r\n                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n            }\r\n\r\n            if ( p_model.get(\"properties.type\") === \"EmptyFloorNode\" ) {\r\n                 MOUSE_EVENT_NAMES = ['click'];\r\n            }\r\n\r\n            //绑定悬浮事件\r\n            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n                node.on(eveName, function (e) {\r\n                    var params = {};\r\n                    if ( eveName === \"mouseover\") {\r\n                        // var _h = e.target.style.height !== undefined ?  (e.target.style.height / 2) : (15 / 2);\r\n                        var _ew = e.target.style.width !== undefined ?  (e.target.style.width + 5) : 205;\r\n                        params = {};\r\n                        params.event = e;\r\n                        // params.x = node.parent.position[0] + e.target.position[0];\r\n                        // params.y = node.parent.position[1] + e.target.position[1] + _h;\r\n                        params.x = e.offsetX;\r\n                        params.y = e.offsetY;\r\n                        params.width = 150;\r\n                        params.height = 170;\r\n                        params.eWidth =  5 ;\r\n                        // params.eWidth = _ew ;\r\n                        params.parmDate = e.target.parmDate;\r\n                        if ( api.getHeight() - params.y > params.height ) {\r\n                            params.layout = \"down\";\r\n                        } else {\r\n                            params.layout = \"up\";\r\n                        }\r\n                        // api.showTipWindow(params);\r\n                    } else if (eveName === \"mouseout\") {\r\n                        api.hideTipWindow(e.event.target);\r\n                    }  else if (eveName === \"click\") {\r\n                        var _parmDate = e.target.parmDate;\r\n                        if ( e.target.parent.rackkInfo !== undefined ) {\r\n                            _parmDate.rackId = e.target.parent.model.option.id;\r\n                            _parmDate.rackName = e.target.parent.model.option.rack;\r\n                        }  \r\n                        params.event =_parmDate;\r\n                    }  else if (eveName === \"dbclick\") {\r\n                        params.event = e.target.parmDate;\r\n                    } \r\n                    api.trigger(eveName, params); \r\n                }, this);\r\n            }, this);\r\n\r\n        }\r\n    };\r\n\r\n    // RackNode.prototype.toJSON = function() {\r\n    //     // body...\r\n    //     return this.model.option;\r\n    // };\r\n    zrUtil.inherits(RackNode, NetworkNode);\r\n    module.exports = RackNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/rack/RackNode.js\n ** module id = 79\n ** module chunks = 0\n **/","/**\r\n */\r\n\r\n    var util = require(\"../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"./node/NetworkNode.js\");\r\n    var NetworkModel = require(\"./model/NetworkModel.js\");\r\n    var RackNode = require(\"./node/rack/RackNode\");\r\n    var TipWindowNode = require(\"./node/TipWindowNode\");\r\n    var ServerNode = require(\"./node/rack/ServerNode\");\r\n    var SwitchNode = require(\"./node/rack/SwitchNode\");\r\n    var EmptyFloorNode = require(\"./node/rack/EmptyFloorNode\");\r\n    \r\n\r\n    var PointNode = require(\"./node/topo/PointNode\");\r\n    var CardNode =  require(\"./node/topo/CardNode\");\r\n    var TopoDrawNode = require(\"./node/topo/TopoDrawNode\");\r\n    var ServerTopoNode = require(\"./node/topo/ServerTopoNode\");\r\n    var ServerR630Node = require(\"./node/topo/ServerR630Node\");\r\n    var ServerR730Node = require(\"./node/topo/ServerR730Node\");\r\n    var ServerX3550Node = require(\"./node/topo/ServerX3550Node\");\r\n    var ServerX3650Node = require(\"./node/topo/ServerX3650Node\");\r\n    var ServerRD350Node = require(\"./node/topo/ServerRD350Node\");\r\n    var ServerRD650Node = require(\"./node/topo/ServerRD650Node\");\r\n    var SwitchTopoNode = require(\"./node/topo/SwitchTopoNode\");\r\n    var SwitchHalfIBNode = require(\"./node/topo/SwitchHalfIBNode\");\r\n    var SwitchFullIBNode = require(\"./node/topo/SwitchFullIBNode\");\r\n    var SwitchGMNode = require(\"./node/topo/SwitchGMNode\");\r\n    var SwitchKMNode = require(\"./node/topo/SwitchKMNode\");\r\n\r\n    var ClusterDrawNode = require(\"./node/cluster/ClusterDrawNode\");\r\n    var ClusterDatabaseNode = require(\"./node/cluster/ClusterDatabaseNode\");\r\n    var ClusterAsmNode = require(\"./node/cluster/ClusterAsmNode\");\r\n    var ClusterAsmCellNode = require(\"./node/cluster/ClusterAsmCellNode\");\r\n    var ClusterIseNode = require(\"./node/cluster/ClusterIseNode\");\r\n    var ClusterIseCellNode =  require(\"./node/cluster/ClusterIseCellNode\");\r\n \r\n    /**\r\n     * 根据结点数组 导出JSON格式的数据\r\n     *\r\n     * @param {Array} nodes 结点数组\r\n     * @return {JSON} JSON格式的数据\r\n     */\r\n    function exportJson(networkModel, nodes) {\r\n        var jsonArr = [];\r\n        for(var i = 0; i < nodes.length;i++){\r\n            var node = nodes[i];\r\n            if( node && node.toJSON) {\r\n                jsonArr.push(node.toJSON());\r\n            }\r\n        }\r\n        networkModel.set(\"childShapes\", jsonArr)  \r\n\r\n        return networkModel.option;\r\n    };\r\n\r\n    /**\r\n     * 根据 JSON 生成节点\r\n     * @param  {[type]} fishTopoBpmn [description]\r\n     * @param  {[type]} json         [description]\r\n     * @return {[type]}              [description]\r\n     */\r\n    function fromJson(fishTopoNetwork, json) {\r\n        // 1.清空画布\r\n        fishTopoNetwork.clear();\r\n        if ( json.type === \"rack\" ) {\r\n            var _x = 50;\r\n            for(var i = 0; i < json.data.length; i++) {\r\n                var modelObj = {\r\n                    resourceId: util.getUUID(),\r\n                    properties: {\r\n                        type: json.data[i].rack\r\n                    },\r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: 50} \r\n                    },\r\n                    stencil: {type: \"RackNode\"}\r\n                };\r\n                modelObj.height =  json.data[i].height != undefined ? json.data[i].height: 640;\r\n                modelObj.width = json.data[i].width != undefined ? json.data[i].width: 200;\r\n                modelObj.UData = json.data[i].UData;\r\n                modelObj.rack = json.data[i].name;\r\n                modelObj.id =  json.data[i].rack;\r\n                modelObj.description =  json.data[i].desc;\r\n                modelObj.showTip = json.showTip;\r\n                var rackModel = new NetworkModel(modelObj);\r\n                fishTopoNetwork.addNodeByModel(rackModel);\r\n                _x += 250;\r\n           }\r\n        } else if( json.type === \"topo\" ) {\r\n            var modelObj = {\r\n                resourceId: util.getUUID(),\r\n                bounds: {\r\n                    upperLeft: {x: 0, y: 0} \r\n                },\r\n                stencil: {type: \"TopoDrawNode\"}\r\n            };\r\n            modelObj.height =  fishTopoNetwork.height;\r\n            modelObj.width = fishTopoNetwork.width;\r\n            modelObj.nodeList = json.data;\r\n            modelObj.showTip = json.showTip;\r\n            var topoModel = new NetworkModel(modelObj);\r\n            fishTopoNetwork.addNodeByModel(topoModel);\r\n        } else if( json.type === \"cluster\" ) {\r\n            var modelObj = {\r\n                resourceId: util.getUUID(),\r\n                bounds: {\r\n                    upperLeft: {x: 0, y: 0} \r\n                },\r\n                stencil: {type: \"ClusterDrawNode\"}\r\n            };\r\n            modelObj.height =  fishTopoNetwork.height;\r\n            modelObj.width = fishTopoNetwork.width;\r\n            modelObj.nodeList = json.data;\r\n            modelObj.showTip = json.showTip;\r\n            var clusterModel = new NetworkModel(modelObj);\r\n            fishTopoNetwork.addNodeByModel(clusterModel);\r\n        }\r\n        \r\n    }\r\n\r\n    function registerNetworkNode () {\r\n        NetworkNode.registerClass(RackNode, \"RackNode\");\r\n        NetworkNode.registerClass(TipWindowNode, \"TipWindowNode\");\r\n        NetworkNode.registerClass(ServerNode, \"ServerNode\");\r\n        NetworkNode.registerClass(SwitchNode, \"SwitchNode\");\r\n        NetworkNode.registerClass(EmptyFloorNode, \"EmptyFloorNode\");\r\n\r\n        NetworkNode.registerClass(ServerTopoNode, \"ServerTopoNode\");\r\n        NetworkNode.registerClass(TopoDrawNode, \"TopoDrawNode\");\r\n        NetworkNode.registerClass(ServerR630Node, \"ServerR630Node\");\r\n        NetworkNode.registerClass(ServerR730Node, \"ServerR730Node\");\r\n        NetworkNode.registerClass(PointNode, \"PointNode\"); \r\n        NetworkNode.registerClass(CardNode, \"CardNode\"); \r\n        NetworkNode.registerClass(ServerX3550Node, \"ServerX3550Node\"); \r\n        NetworkNode.registerClass(ServerX3650Node, \"ServerX3650Node\"); \r\n        NetworkNode.registerClass(ServerRD350Node, \"ServerRD350Node\");\r\n        NetworkNode.registerClass(ServerRD650Node, \"ServerRD650Node\");\r\n        NetworkNode.registerClass(SwitchFullIBNode, \"SwitchFullIBNode\");\r\n        NetworkNode.registerClass(SwitchHalfIBNode, \"SwitchHalfIBNode\");\r\n        NetworkNode.registerClass(SwitchKMNode, \"SwitchKMNode\");\r\n        NetworkNode.registerClass(SwitchGMNode, \"SwitchGMNode\"); \r\n        \r\n        NetworkNode.registerClass(ClusterDrawNode, \"ClusterDrawNode\"); \r\n        NetworkNode.registerClass(ClusterDatabaseNode, \"ClusterDatabaseNode\"); \r\n        NetworkNode.registerClass(ClusterAsmNode, \"ClusterAsmNode\");  \r\n        NetworkNode.registerClass(ClusterAsmCellNode, \"ClusterAsmCellNode\"); \r\n        NetworkNode.registerClass(ClusterIseNode, \"ClusterIseNode\"); \r\n        NetworkNode.registerClass(ClusterIseCellNode, \"ClusterIseCellNode\"); \r\n                     \r\n    }   \r\n\r\n    var NextWorkUtil = {\r\n        exportJson: exportJson,\r\n        fromJson: fromJson,\r\n        registerNetworkNode: registerNetworkNode\r\n    };\r\n    module.exports = NextWorkUtil;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/NetworkUtil.js\n ** module id = 80\n ** module chunks = 0\n **/","\r\n\tvar Node = require(\"../../../fish-topo-core/lib/Node\");\r\n\tvar zrUtil = require('zrender/lib/core/util');\r\n\tvar graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\tvar clazzUtil = require('../../../fish-topo-core/lib/clazz');\r\n\t\r\n\t//创建Node类 所有形状都继承Node  包括fromJSON toJSON\r\n\tfunction TipWindowNode(model, api) {\r\n\t\tNode.call(this);\r\n\t\tthis.model = model;\t\t\r\n\t\tthis.nextworkInfo = {type: -1, name:\"TipWindowNodeDiagram\" };    //节点信息\r\n\t\tthis.initEvent(api);\r\n        this.render(model, api);\r\n\t};\r\n\r\n    TipWindowNode.prototype.initEvent = function(api) {\r\n        // var that = this;\r\n        // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n        // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n        //     that.on(eveName, function (e) {\r\n\t       //      var params = {};\r\n\t       //      params.event = e;\r\n\t       //      params.type = eveName;\r\n\t       //      params.model = that.model\r\n\t       //      api.trigger(eveName, params); \r\n        //     }, this);\r\n        // }, this);\r\n    };\t\r\n\r\n\tTipWindowNode.prototype.render = function(model, api) {\r\n\t\tvar _x = model.x;\r\n        var _y = model.y;\r\n        var _xWidth = model.eWidth;\r\n        var _width = model.width;\r\n        var _height = model.height;\r\n\t\tvar points = [\r\n\t\t\t\t[_x + _xWidth + 20, _y],\r\n\t\t\t\t[_x + _xWidth, _y],\r\n\t\t\t\t[_x + _xWidth + 20, _y + 15],\t\r\n\t\t\t\t[_x + _xWidth + 20, _y + _height],\r\n\t\t\t\t[_x + _xWidth + _width, _y + _height],\r\n\t\t\t\t[_x + _xWidth + _width, _y]\r\n\t\t\t];\r\n\t\tif ( model.layout != undefined && model.layout === \"up\" ) {\r\n\t\t\tpoints = [\r\n\t\t\t\t[_x + _xWidth + 20, _y],\r\n\t\t\t\t[_x + _xWidth, _y],\r\n\t\t\t\t[_x + _xWidth + 20, _y - 15],\t\r\n\t\t\t\t[_x + _xWidth + 20, _y - _height],\r\n\t\t\t\t[_x + _xWidth + _width, _y - _height],\r\n\t\t\t\t[_x + _xWidth + _width, _y]\r\n\t\t\t];\r\n\t\t} \r\n\r\n\t\tif ( model.layout != undefined && model.layout === \"left\" ) {\r\n\t\t\tpoints = [\r\n\t\t\t\t[_x - 2 * _width - 10, _y],\r\n\t\t\t\t[_x - 2 * _width + 10, _y],\r\n\t\t\t\t[_x - 2 * _width - 10, _y + 15],\t\r\n\t\t\t\t[_x - 2 * _width - 10, _y + _height],\r\n\t\t\t\t[_x - 2 * _width - _width, _y + _height],\r\n\t\t\t\t[_x - 2 * _width - _width, _y]\r\n\t\t\t];\r\n\t\t}\t\r\n\t\tvar _tipContext = \"请查询数据\";\r\n\t\tif ( model.parmDate !== undefined ) {\r\n\t\t\tif( model.parmDate.type === \"switch\" ) {\r\n\t\t\t\t_tipContext = 'hostname: '+ model.parmDate.hostname +' \\n status: ' + model.parmDate.status + ' \\n floor: ' + model.parmDate.floor +  '\\n height: ' + model.parmDate.height + \"\\n vendor:\" +  model.parmDate.vendor;\r\n\t\t\t\r\n\t\t\t} else if( model.parmDate.nodeType === \"EmptyFloorNode\" ) {\r\n\t\t\t\t_tipContext = 'floor: ' + model.parmDate.floor;\r\n\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t_tipContext = 'hostname: '+ model.parmDate.hostname +' \\n status: ' + model.parmDate.status + ' \\n  Ip: ' + model.parmDate.ipaddress +  '\\n floor: ' + model.parmDate.floor +  '\\n height: ' + model.parmDate.height + \"\\n vendor:\" +  model.parmDate.vendor;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif ( model.parmDate.tipContext !== undefined ) {\r\n\t\t\t\t_tipContext = model.parmDate.tipContext;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar tip = new graphic.Polygon({\r\n            shape: {\r\n                points: points\r\n            },\r\n            style: {\r\n\t\t\t\tstroke: 'rgba(174, 174,174, 1.0)',\r\n\t\t\t\tfill: 'rgba(255, 255, 255, 1.0)',\r\n\t\t\t\tlineWidth: 1,\r\n\t\t\t\ttext: _tipContext,\r\n\t\t\t\ttextAlign: 'center'//,\r\n\t\t\t\t//textPosition: 'left',\r\n\t\t\t\t//smooth: 'bezier'\t\r\n\t\t\t},   \r\n\t\t\tz: 1000     \r\n        });        \r\n        this.add(tip);\r\n\t};\r\n\r\n\tzrUtil.inherits(TipWindowNode, Node);\r\n\r\n\r\n\tmodule.exports = TipWindowNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/TipWindowNode.js\n ** module id = 81\n ** module chunks = 0\n **/","\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n     var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    function ServerNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.serverInfo = {type: -1, name: \"ServerNode\" };    //\r\n        this.model = model;\r\n        return this.render(model,api);\r\n    };\r\n\r\n    \r\n        \r\n    ServerNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var status = model.get(\"status\");\r\n        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"serverType\") ;\r\n        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n        //      imageUrl += status;\r\n        // }\r\n        imageUrl += '.png';\r\n\r\n        //״̬ \r\n        var cellStateNode = new graphic.Circle({\r\n             shape: {\r\n                cx: 10,\r\n                cy: (15 * model.get(\"floorNum\") - 3) / 2,\r\n                r: 4\r\n            },\r\n            style: {\r\n                fill: '#077826',\r\n                opacity: 1,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            },\r\n            z: 1000 \r\n        });\r\n        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n            cellStateNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(cellStateNode);\r\n\r\n        var rectServer = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: model.get(\"width\"),\r\n                height:  15 * model.get(\"floorNum\") - 3\r\n            },\r\n            draggable: false,\r\n            parmDate: model.get(\"parmDate\")    \r\n        }); \r\n        //rectServer.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n        this.add(rectServer);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n        // return rectServer;\r\n    };\r\n\r\n    zrUtil.inherits(ServerNode, NetworkNode);\r\n    module.exports = ServerNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/rack/ServerNode.js\n ** module id = 82\n ** module chunks = 0\n **/","\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    function SwitchNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.serverInfo = {type: -1, name: \"SwitchNode\" };    //\r\n        this.model = model;\r\n        return this.render(model,api);\r\n    };\r\n\r\n    SwitchNode.prototype.render = function(model,api) {\r\n        this.model = model;\r\n        var _px = model.get(\"bounds.upperLeft.x\");\r\n        var _py = model.get(\"bounds.upperLeft.y\");\r\n        var _height = model.get(\"height\");\r\n        var _width = model.get(\"width\");\r\n        if(model.get(\"column\") === undefined || model.get(\"column\") === \"all\" ) {\r\n            \r\n        } else {\r\n            _width = model.get(\"width\") / 2 - 5;\r\n            if ( model.get(\"column\") === \"right\" ) {\r\n                 _px = 5 + _width + 5;\r\n            }      \r\n        }\r\n        var rectSwitch = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/IBSwitchFull.png',\r\n                width: _width,\r\n                height:  _height\r\n            },\r\n            draggable: false,\r\n            parmDate : model.get(\"parmDate\")    \r\n            // _parmDate : \"111\"       \r\n        }); \r\n        rectSwitch.position = [ _px, _py]; \r\n        return rectSwitch;\r\n    };\r\n\r\n    zrUtil.inherits(SwitchNode, NetworkNode);\r\n    module.exports = SwitchNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/rack/SwitchNode.js\n ** module id = 83\n ** module chunks = 0\n **/","\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    function EmptyFloorNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.serverInfo = {type: -1, name: \"EmptyFloorNode\" };    //\r\n        this.model = model;\r\n        return this.render(model,api);\r\n    };\r\n\r\n    EmptyFloorNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var rectTray = new graphic.Rect({\r\n                shape: {\r\n                    x: 0,\r\n                    y: 0,\r\n                    width: model.get(\"width\") - 10,\r\n                    height: 15\r\n                },\r\n                style: {\r\n                    fill: '#FFFFFF',\r\n                    stroke: '#B3B3B3',\r\n                    lineDash: [3],  \r\n                    lineWidth: '1'//,\r\n                }  ,\r\n                draggable: false,\r\n                parmDate: model.get(\"parmDate\")            \r\n            });        \r\n        this.add(rectTray);\r\n        rectTray.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")]; \r\n        return rectTray;\r\n\r\n        // var rectServer = new graphic.Image({\r\n        //     position: [0, 0],\r\n        //     scale: [1, 1],\r\n        //     style: {\r\n        //         x: 0,\r\n        //         y: 0,\r\n        //         image: './frm/fish-desktop/third-party/fish-topo/fish-topo-network/src/images/lenovoRd650a.png',\r\n        //         width: model.get(\"width\") - 10,\r\n        //         height:  15\r\n        //     },\r\n        //     draggable: false\r\n        // }); \r\n        // rectServer.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n        // return rectServer;\r\n\r\n    };\r\n    zrUtil.inherits(EmptyFloorNode, NetworkNode);\r\n    module.exports = EmptyFloorNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/rack/EmptyFloorNode.js\n ** module id = 84\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function PointNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"PointNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.render(model,api);\r\n    };\r\n\r\n    PointNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        // this.add(_title);\r\n\r\n        var portNode = new graphic.Rect({\r\n            shape: {\r\n                x: 0,\r\n                y: 0,\r\n                width: model.get(\"width\"),\r\n                height: model.get(\"height\")\r\n            },\r\n            style: {\r\n                fill: '#E2E3D9',\r\n                stroke: '#B3B3B3',\r\n                opacity: 0.1,\r\n                lineWidth: '1'//,\r\n            }          \r\n        });              \r\n        this.add(portNode);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n   \r\n\r\n    zrUtil.inherits(PointNode, NetworkNode);\r\n    module.exports = PointNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/PointNode.js\n ** module id = 85\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function CardNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"CardNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.pointList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    CardNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _portData = model.get(\"portData\");\r\n        var _type = model.get(\"type\");\r\n        var _direction = model.get(\"direction\");\r\n        var imgUrl = \"\";\r\n        if( _type === \"1\" || _type === \"3\" ) {\r\n            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/IB1.jpg';\r\n        }else if ( _type === \"5\" ) {\r\n            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km2.jpg';\r\n        } else if( _type === \"6\" ) {\r\n            imgUrl = '../../../src/third-party/fish-topo/fish-topo-network/src/images/km4.jpg';\r\n        }\r\n\r\n\r\n         var rectServer = new graphic.Image({\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imgUrl,\r\n                width: model.get(\"width\"),\r\n                height: model.get(\"height\")\r\n            },\r\n            draggable: false,\r\n            invisible: false,\r\n            parmDate: _portData\r\n        }); \r\n        this.add(rectServer);\r\n        rectServer.hide();\r\n\r\n        var _resourcesName = model.get(\"resourcesName\");\r\n        var _resourceNodeType = model.get(\"resourceNodeType\");\r\n        var _No = model.get(\"No\");\r\n        if ( _direction === \"leftRight\" ) {\r\n            var _x = 4;\r\n            var _y = 2;\r\n            var _width = 8;\r\n            var _height = 5; \r\n            if ( _type === \"1\" ||  _type === \"2\" ||  _type === \"3\" ||  _type === \"4\" ) {\r\n                _width = 20;\r\n            }\r\n            for( var i = 0; i < _portData.length; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = _height;\r\n                portModel.width = _width;\r\n\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = _resourcesName;\r\n                _linInfo.sourceCardNo = _No;\r\n                _linInfo.sourcePort = i;\r\n                _linInfo.nodetype = _resourceNodeType; \r\n                _linInfo.sourceStatus =  _portData[i].status;        \r\n                _linInfo.targetReource = _portData[i].target.resourceName ;\r\n                _linInfo.targetPort = _portData[i].target.port;\r\n\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                 _x = _x + _width + 2;\r\n            }    \r\n        } \r\n        \r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n   CardNode.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, api);\r\n            this.pointList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(CardNode, NetworkNode);\r\n    module.exports = CardNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/CardNode.js\n ** module id = 86\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var NetWorkLineNode = require(\"../NetWorkLineNode.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var NetWorkLineModel = require(\"../../model/NetWorkLineModel.js\");\r\n\r\n    function TopoDrawNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.topoInfo = {type: -1, name: \"TopoDrawNode\" };    \r\n        this.model = model;\r\n        this.portList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    TopoDrawNode.prototype.render = function(model, api) {\r\n        var nodeList = model.get(\"nodeList\");\r\n        var serverWidth = 160; //服务器宽度\r\n        var switchWidth = 300; //交换机宽度\r\n        //根据Node数量计算实际画布宽度\r\n        var clentWidth = this.getWidth(nodeList, serverWidth, switchWidth);\r\n        clentWidth = clentWidth > model.get(\"width\") ? clentWidth : model.get(\"width\");\r\n        api.resize(clentWidth, model.get(\"height\"));\r\n\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _startX = 100,\r\n            _textW = 30,\r\n            _startY = 10,\r\n            _textH = 20;\r\n        var textKM = new graphic.Text({\r\n            style: {\r\n                x: _startX,\r\n                y: _startY,\r\n                text: '千兆',\r\n                width: _textW,\r\n                height: _textH,\r\n                fill: '#8F8B8A',\r\n                textFont: '10px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(textKM);\r\n\r\n        var lineKM = new graphic.Line({\r\n            shape: {\r\n                x1 : _startX + _textW,\r\n                y1 : _startY + 10,\r\n                x2 : _startX + _textW + 100,\r\n                y2 : _startY + 10,\r\n                lineWidth : 5,  \r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#0704EC',\r\n                lineType : 'solid',// default solid\r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineKM);\r\n\r\n        _startY = _startY + _textH;\r\n        var textGB = new graphic.Text({\r\n            style: {\r\n                x: _startX,\r\n                y: _startY,\r\n                text: '万兆',\r\n                width: _textW,\r\n                height: _textH,\r\n                fill: '#8F8B8A',\r\n                textFont: '10px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(textGB);\r\n\r\n        var lineGB = new graphic.Line({\r\n            shape: {\r\n                x1 : _startX + _textW,\r\n                y1 : _startY + 10 ,\r\n                x2 : _startX + _textW + 100,\r\n                y2 : _startY + 10,\r\n                lineWidth : 5,  \r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#070413',\r\n                lineType : 'solid',// default solid\r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineGB);\r\n\r\n        _startY =  _startY + _textH;\r\n        var textIB = new graphic.Text({\r\n            style: {\r\n                x: _startX,\r\n                y: _startY,\r\n                text: 'IB',\r\n                width: _textW,\r\n                height: _textH,\r\n                fill: '#8F8B8A',\r\n                textFont: '10px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(textIB);\r\n\r\n        var lineIB = new graphic.Line({\r\n            shape: {\r\n                x1 : _startX + _textW,\r\n                y1 : _startY + 10,\r\n                x2 : _startX + _textW + 100,\r\n                y2 : _startY + 10,\r\n                lineWidth : 5,  \r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#62A4DD',\r\n                lineType : 'solid',// default solid\r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineIB);\r\n\r\n        //主线布局\r\n        var lineOut = new graphic.Line({\r\n            shape: {\r\n                x1 : 50,\r\n                y1 : 70,\r\n                x2 : 50,\r\n                y2 : 700,\r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#000',\r\n                lineType : 'solid',// default solid\r\n                lineWidth : 3,  \r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineOut);\r\n\r\n        var lineUp = new graphic.Line({\r\n            shape: {\r\n                x1 : 50,\r\n                y1 : 250,\r\n                x2 : clentWidth - 50,\r\n                y2 : 250,\r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#000',\r\n                lineType : 'solid',// default solid\r\n                lineWidth : 3,  \r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineUp);\r\n\r\n        var lineDown = new graphic.Line({\r\n            shape: {\r\n                x1 : 50,\r\n                y1 : 450,\r\n                x2 : clentWidth - 50,\r\n                y2 : 450, \r\n                text : 'line'\r\n            },\r\n            style: {\r\n                stroke: '#000',\r\n                lineType : 'solid',// default solid\r\n                lineWidth : 3,  \r\n                fill: null\r\n            }        \r\n        });        \r\n        this.add(lineDown);\r\n\r\n         //循环添加topo图上的节点\r\n        var startComputeX = 70;\r\n        var startStorageX = 110; \r\n        var startSwitchX = 90; \r\n        for ( var i = 0; i < nodeList.length; i++ ) {\r\n            var nodeY = 145;\r\n            var modelObj = {};\r\n            var _typeNode = \"TopoDrawNode\";\r\n            if ( nodeList[i].nodetype === \"compute\" ) {\r\n                if (nodeList[i].type  === \"ServerR730\" || nodeList[i].type  === \"ServerX3650\") {\r\n                    nodeY = 125;\r\n                }\r\n                _typeNode = nodeList[i].type + \"Node\";\r\n                modelObj = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startComputeX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: _typeNode}\r\n                };\r\n                modelObj.name = nodeList[i].resourceName;\r\n                modelObj.width = serverWidth;\r\n                startComputeX += serverWidth + 20;\r\n            } else if (nodeList[i].nodetype === \"storage\" ) {           \r\n                nodeY = 550;\r\n                _typeNode = nodeList[i].type + \"Node\";\r\n                modelObj = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startStorageX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: _typeNode}\r\n                };\r\n                modelObj.name = nodeList[i].resourceName;\r\n                modelObj.width = serverWidth;\r\n                startStorageX += serverWidth + 20;\r\n            } else if (nodeList[i].nodetype === \"switch\" ) {\r\n                var type = nodeList[i].type !== undefined && nodeList[i].type !== null ? nodeList[i].type : \"\";\r\n                var switchType = \"SwitchHalfIB\";\r\n                if ( type.toUpperCase() === \"FULL\" ) {\r\n                    switchType = \"SwitchFullIB\";\r\n                }\r\n                _typeNode = switchType + \"Node\";\r\n                nodeY = 335;\r\n                modelObj = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startSwitchX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: _typeNode}\r\n                }; \r\n                if ( nodeList[i].type  === \"Half\" ) {\r\n                    modelObj.width = switchWidth / 2;\r\n                    startSwitchX += switchWidth / 2 + 50;\r\n                } else {\r\n                    modelObj.width = switchWidth;\r\n                    startSwitchX += switchWidth + 50;\r\n                } \r\n                modelObj.name = \"Name: \"  + nodeList[i].resourceName + \", No：\" + nodeList[i].manager_ipaddr;\r\n                modelObj.portNum = nodeList[i].portTotal;\r\n            } else if (nodeList[i].nodetype === \"ESwitch\" ) {\r\n                nodeY = 335;\r\n                modelObj = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startSwitchX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: \"SwitchKMNode\"}\r\n                }; \r\n                modelObj.name = nodeList[i].resourceName;\r\n                modelObj.width = switchWidth;\r\n                startSwitchX += switchWidth + 50;       \r\n            }\r\n            if ( modelObj.stencil !== undefined && modelObj.stencil.type !== undefined ) {\r\n                if ( modelObj.stencil.type !== undefined &&  modelObj.stencil.type !== \"ServerR730Node\" &&\r\n                     modelObj.stencil.type !== \"ServerR630Node\" &&\r\n                     modelObj.stencil.type !== \"SwitchFullIBNode\" &&\r\n                     modelObj.stencil.type !== \"SwitchHalfIBNode\" &&\r\n                     modelObj.stencil.type !== \"SwitchKMNode\"\r\n                 ) {\r\n                    modelObj.stencil.type = \"ServerTopoNode\";\r\n                }\r\n            }\r\n            \r\n            modelObj.status =  nodeList[i].status;\r\n            modelObj.nodetype = nodeList[i].nodetype;\r\n            modelObj.type = nodeList[i].type;\r\n            var _parmDate = {};\r\n            _parmDate.hostId = nodeList[i].host_id;\r\n            _parmDate.name = nodeList[i].resourceName;\r\n            _parmDate.noteType = nodeList[i].nodetype;\r\n            _parmDate.status = nodeList[i].status;\r\n            _parmDate.type = nodeList[i].type;\r\n            _parmDate.key = nodeList[i].manager_ipaddr ? nodeList[i].manager_ipaddr : \"\";\r\n\r\n\r\n            modelObj.parmDate = _parmDate;\r\n            modelObj.height =  15;\r\n            if ( nodeList[i].ports != undefined ) {\r\n                modelObj.ports = nodeList[i].ports;\r\n            }\r\n            //判断是否band悬浮事件\r\n            modelObj.showTip = _showTip;\r\n            var serverModel = new NetworkModel(modelObj);\r\n            this.addNodeByModel(serverModel, api);\r\n        }\r\n\r\n        //连线\r\n        for ( var ps = 0; ps < this.portList.length; ps++ ) {\r\n            var startNode = this.portList[ps];\r\n            var endNode = null;\r\n            for ( var pe = 0; pe < this.portList.length; pe++ ) {\r\n                if (startNode.lineInfo.targetReource === this.portList[pe].lineInfo.sourceReource \r\n                    && startNode.lineInfo.targetPort === this.portList[pe].lineInfo.sourcePort ) {\r\n                    endNode = this.portList[pe];\r\n                    break;\r\n                }\r\n            }\r\n            //连线\r\n            if( endNode !== null && startNode != null ) {\r\n                this.drawLine(startNode, endNode, api);\r\n            }\r\n\r\n\r\n        }\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    TopoDrawNode.prototype.getWidth = function( p_nodeList, p_serverW, p_switchW ) {\r\n        // var computeCount = 0;\r\n        // var storageCount = 0; \r\n        // var switchCount = 0; \r\n        // for ( var i = 0; i < p_nodeList.length; i++ ) {\r\n        //     if ( p_nodeList[i].nodetype === \"1\" ) {\r\n        //        computeCount++;\r\n        //     } else if (p_nodeList[i].nodetype === \"2\" ) {           \r\n        //         storageCount++;\r\n        //     } else if (p_nodeList[i].nodetype === \"3\" ) {\r\n        //         switchCount++;\r\n        //     }\r\n        // }\r\n        // var serverCount = computeCount > storageCount ? computeCount : storageCount; \r\n        // var w1 = 60 + serverCount * (p_serverW + 50) + 150;\r\n        // var s1 = 40 + switchCount * (p_switchW + 50) + 150;\r\n        var computeWidth = 210;\r\n        var storageWidth = 210; \r\n        var switchWidth = 190; \r\n        for ( var i = 0; i < p_nodeList.length; i++ ) {\r\n            if ( p_nodeList[i].nodetype === \"compute\" ) {\r\n               computeWidth += p_serverW + 50;\r\n            } else if (p_nodeList[i].nodetype === \"storage\" ) {           \r\n                storageWidth += p_serverW + 50;\r\n            } else if (p_nodeList[i].nodetype === \"switch\" ) {\r\n                if( p_nodeList[i].portTotal > 12 ) {\r\n                    switchWidth += p_switchW + 50; \r\n                } else {\r\n                    switchWidth += (p_switchW / 2) + 50; \r\n                }\r\n            } else if (p_nodeList[i].nodetype === \"ESwitch\" ) {\r\n                switchWidth += p_switchW + 50; \r\n            }\r\n        }\r\n        var serverWidth = computeWidth > storageWidth ? computeWidth : storageWidth;\r\n        return serverWidth > switchWidth ? serverWidth : switchWidth;\r\n    };\r\n\r\n    TopoDrawNode.prototype.addNodeByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, api);\r\n            this.add(node);\r\n            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {\r\n                for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n                    this.portList.push(node.portNodeList[i]);\r\n                }\r\n                //this.portList.concat(node.portNodeList);\r\n            }\r\n\r\n             //绑定事件\r\n            var MOUSE_EVENT_NAMES = ['click'];\r\n            if ( p_model.get(\"showTip\") ) {\r\n                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n            }\r\n            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n                node.on(eveName, function (e) {\r\n                    var params = {};\r\n                    if ( eveName === \"mouseover\") {\r\n                        params.event = e;\r\n                        params.x = e.offsetX;\r\n                        params.y = e.offsetY;\r\n                        params.width = 150;\r\n                        params.height = 170;\r\n                        params.eWidth =  5 ;\r\n                        params.parmDate = e.target.parent.parmDate;\r\n                        params.type = \"lineTip\";\r\n                        if (params.parmDate !== undefined ) {\r\n                            var _name = params.parmDate.name;\r\n                            var text = \"name: \" + _name + \"\\n\" +\r\n                                       \"noteType: \"+ params.parmDate.noteType + \"\\n\";\r\n                            if ( params.parmDate.status !== null && params.parmDate.status !== undefined ) {\r\n                                text += \"status: \"+ params.parmDate.status + \"\\n\";\r\n                            }\r\n                             if ( params.parmDate.type !== null && params.parmDate.type !== undefined ) {\r\n                                text += \"type: \"+ params.parmDate.type + \"\\n\";\r\n                            }\r\n                            params.parmDate.tipContext = text; \r\n                        } \r\n                        \r\n                        if ( api.getHeight() - params.y > params.height ) {\r\n                            params.layout = \"down\";\r\n                        } else {\r\n                            params.layout = \"up\";\r\n                        }\r\n\r\n                        //api.showTipWindow(params);\r\n                    } else if (eveName === \"mouseout\") {\r\n                        api.hideTipWindow(e.event.target);\r\n                    } else if (eveName === \"click\") {\r\n                        var _parmDate = e.target.parmDate;\r\n                        params.event =_parmDate;\r\n                    } \r\n                    api.trigger(eveName, params); \r\n                }, this);\r\n             }, this);\r\n        }\r\n    };\r\n\r\n    TopoDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {\r\n        var fleftx = p_startNode.position[0] + p_startNode.parent.position[0] + p_startNode.parent.parent.position[0];\r\n        var flefty = p_startNode.position[1] + p_startNode.parent.position[1] + p_startNode.parent.parent.position[1];\r\n        var fwidth = p_startNode.model.get(\"width\");\r\n        var fheight = p_startNode.model.get(\"height\");\r\n\r\n        var torightx = p_endNode.position[0] + p_endNode.parent.position[0];\r\n        var torighty = p_endNode.position[1] + p_endNode.parent.position[1];\r\n        var towidth = p_endNode.model.get(\"width\");\r\n        var toheight = p_endNode.model.get(\"height\");\r\n        var moddleY = 250;\r\n        var nodetype = p_startNode.model.get(\"lineInfo\").nodetype;\r\n        if( nodetype === \"storage\" ) {\r\n            moddleY = 450;\r\n        }\r\n        var _lindColor = \"#62A4DD\";\r\n        var _lineInfo = p_startNode.model.get(\"lineInfo\");\r\n        if ( _lineInfo.portType === \"1\") {\r\n            _lindColor = \"#62A4DD\";\r\n        } else if ( _lineInfo.portType === \"2\")  {\r\n             _lindColor = \"#070413\";\r\n        } else if ( _lineInfo.portType === \"3\")  {\r\n            _lindColor = \"#0704EC\";\r\n        } \r\n        if ( _lineInfo.portState.toUpperCase() !== \"UP\" ) {\r\n            _lindColor = \"#FFCC00\";\r\n        }\r\n        if ( p_endNode.model.get(\"lineInfo\").sourceReourceName !== undefined && p_endNode.model.get(\"lineInfo\").sourceReourceName !== null ) {\r\n            _lineInfo.sourceReourceName = p_endNode.model.get(\"lineInfo\").sourceReourceName;\r\n        }\r\n        var _moddleX = p_startNode.lineInfo.moddleX;\r\n        var defaultOption = {\r\n            fromBounds : {x: fleftx, y: flefty, width: fwidth, height: fheight},\r\n            toBounds: {x: torightx, y: torighty, width: towidth, height: toheight},\r\n            moddleY: moddleY,\r\n            style : {\r\n                lineWidth : 1,\r\n                stroke: _lindColor//,\r\n                //fill: '#9699DD'\r\n            },\r\n            hoverStyle : {\r\n                lineWidth : 1,\r\n                stroke: '#47D930'//,\r\n                //fill:'#2FDE92'\r\n            }\r\n        };\r\n        if ( _moddleX !== undefined ) {\r\n            defaultOption.moddleX =  _moddleX;\r\n        }\r\n\r\n        defaultOption.parmData = _lineInfo;\r\n        var netWorkLineModel = new NetWorkLineModel(defaultOption);\r\n        var netWorkLineNode = new NetWorkLineNode(netWorkLineModel);\r\n        this.add(netWorkLineNode);\r\n\r\n\r\n        //绑定事件\r\n        var MOUSE_EVENT_NAMES = ['mouseover', 'mouseout'];\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            netWorkLineNode.on(eveName, function (e) {\r\n                var params = {};\r\n                if ( eveName === \"mouseover\") {\r\n                    params.event = e;\r\n                    params.x = e.offsetX;\r\n                    params.y = e.offsetY;\r\n                    params.width = 200;\r\n                    params.height = 170;\r\n                    params.eWidth =  5 ;\r\n                    params.parmDate = e.target.parent.parent.parmData;\r\n                    params.type = \"lineTip\";\r\n                    var text = \"Status: \"+  params.parmDate.portState + \"\\n\";\r\n                        text += \"Source Reource: \"+  params.parmDate.sourceReource + \"\\n\";\r\n                        text += \"Source Port: \"+  params.parmDate.sourcePort + \"\\n\";\r\n                    if ( params.parmDate.ip !== undefined && params.parmDate.ip !== null ) {\r\n                        text += \"IP: \"+  params.parmDate.ip+ \"\\n\";\r\n                    }  \r\n                    if ( params.parmDate.portType !== undefined && params.parmDate.portType !== null ) {\r\n                        if ( params.parmDate.portType === \"1\" ) {\r\n                            text += \"Port Type: IB口\\n\";\r\n                        } else if ( params.parmDate.portType === \"2\" ) {\r\n                            text += \"Port Type: 万兆口\\n\";\r\n                        } else if ( params.parmDate.portType === \"3\" ) {\r\n                            text += \"Port Type: 千兆口\\n\";\r\n                        }\r\n                    }  \r\n                \r\n                    if ( params.parmDate.targetReource !== undefined && params.parmDate.targetReource !== null ) {\r\n                        if ( params.parmDate.sourceReourceName !== undefined && params.parmDate.sourceReourceName !== null ) {\r\n                            text += \"Target Reource: \" +  params.parmDate.sourceReourceName + \"\\n\";\r\n                        } else {\r\n                            text += \"Target Reource: \" +  params.parmDate.targetReource + \"\\n\";\r\n                        }   \r\n                    }  \r\n\r\n                    if ( params.parmDate.targetPort !== undefined && params.parmDate.targetPort !== null ) {\r\n                        text += \"Target Port: \" +  params.parmDate.targetPort + \"\\n\";\r\n                    }  \r\n\r\n                    \r\n\r\n                    params.parmDate.tipContext = text;\r\n\r\n                    if ( api.getHeight() - params.y > params.height ) {\r\n                        params.layout = \"down\";\r\n                    } else {\r\n                        params.layout = \"up\";\r\n                    }\r\n\r\n\r\n                    api.showTipWindow(params);\r\n                } else if (eveName === \"mouseout\") {\r\n                    api.hideTipWindow(e.event.target);\r\n                }\r\n                //api.trigger(eveName, params); \r\n            }, this);\r\n         }, this);\r\n    }\r\n    zrUtil.inherits(TopoDrawNode, NetworkNode);\r\n    module.exports = TopoDrawNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/TopoDrawNode.js\n ** module id = 87\n ** module chunks = 0\n **/","\r\n\tvar Node = require(\"../../../fish-topo-core/lib/Node\");\r\n    var NetworkNode = require(\"./NetworkNode\");\r\n\tvar Util = require('../../../fish-topo-core/lib/util');\r\n\tvar graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var Point = require(\"../../../fish-topo-core/lib/Point.js\");\r\n    var Connector = require(\"../../../fish-topo-core/lib/shapes/Connector.js\");\r\n\r\n\tfunction NetWorkLineNode(model,api) {\r\n\t\tNode.call(this);\r\n        this.model = model;  // NetWorkLineModal\r\n        this.con = null;        \r\n\t\tthis.render();\r\n\t\tthis.refreshLine();\r\n        this.lineType = this.model.get(\"lineType\");\r\n        this.parmData = this.model.get(\"parmData\");\r\n        \r\n\t};\r\n\r\n\tNetWorkLineNode.prototype.render = function() {\r\n            var parmData = {};\r\n            if ( this.model.get(\"isVector\") ) {\r\n                 parmData.symbol = {type:\"arrow\", size: 10, color:\"#000000\"};\r\n            } else {\r\n                 parmData.symbol = {type:\"\"};\r\n            }\r\n            var _style = this.model.get(\"style\");\r\n            if ( this.lineType ?  this.lineType : this.model.option.lineType) {\r\n                _style.lineType = this.lineType ?  this.lineType : this.model.option.lineType;\r\n            }\r\n            var _hoverStyle = this.model.get(\"hoverStyle\");\r\n            parmData.style = _style;\r\n            parmData.hoverStyle = _hoverStyle;\r\n            \r\n            var _isEdit = this.model.get(\"isEdit\");\r\n            parmData.isEdit = _isEdit;\r\n            this.con =  new Connector(parmData);  //\"arrow\"\r\n            this.add(this.con);\r\n\t};\r\n\r\n    NetWorkLineNode.prototype.refreshLine = function () {\r\n        var moddleY = this.model.get(\"moddleY\");\r\n        var moddleX = this.model.get(\"moddleX\");\r\n\r\n        var sRect = this.model.get(\"fromBounds\");\r\n        var sBounds = [sRect.x, sRect.y, sRect.x + sRect.width, sRect.y + sRect.height];\r\n\r\n        var eRect = this.model.get(\"toBounds\");\r\n        var eBounds = [eRect.x, eRect.y, eRect.x + eRect.width, eRect.y + eRect.height];\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        var startPoint = null;\r\n        var endPoint = null;\r\n        if (sRect.y < eRect.y) {\r\n            startPoint = sConnectorPoint.bottom;\r\n            endPoint = eConnectorPoint.top;\r\n        } else {\r\n            startPoint = sConnectorPoint.top;\r\n            endPoint = eConnectorPoint.bottom;\r\n        }\r\n\r\n        var solutions = this.connector2Points(startPoint, endPoint, moddleX, \r\n                        moddleY, sBounds, eBounds);\r\n            //adjust connector\r\n        //  console.info(\"connector2Points() -> Solution: \" + solutions[0][2]);\r\n        // var points = Util.traslatePoints(solutions[0][2]);\r\n\r\n        //this.line.attr('shape', {points: points});\r\n        this.con.refresh(solutions[0][2]);\r\n    };\r\n\r\n    NetWorkLineNode.prototype.connector2Points = function(startPoint, endPoint, moddleX, middleY, sBounds, eBounds ){\r\n        var solutions = [];\r\n        //Basic solution 最基本的解决方案   为其他解决方案做准备\r\n        var s = [startPoint];\r\n        if ( moddleX !== undefined && moddleX !== null ) {\r\n             s.push(new Point(startPoint.x - moddleX, startPoint.y));\r\n             s.push(new Point(startPoint.x - moddleX, middleY));\r\n             s.push(new Point(endPoint.x, middleY)); \r\n        } else {\r\n            s.push(new Point(startPoint.x, middleY));\r\n            s.push(new Point(endPoint.x, middleY)); \r\n        }\r\n        s.push(endPoint);        \r\n\r\n        //SO - no additional points     S0 解决方案 \r\n        var s0 = Point.cloneArray(s);\r\n        solutions.push(['s0', 's0', s0]);\r\n        return solutions;\r\n        \r\n    };\r\n\r\n\tUtil.inherits(NetWorkLineNode, Node);\r\n\r\n\tmodule.exports = NetWorkLineNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/NetWorkLineNode.js\n ** module id = 88\n ** module chunks = 0\n **/","/**\r\n * 连接线\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var Util = require(\"../util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../graphic.js\");\r\n    var Node = require(\"../Node.js\");\r\n    var symbolUtil = require(\"./Symbol.js\");\r\n    var Handle = require(\"./Handle.js\");\r\n    var EffectLine = require(\"./EffectLine.js\");\r\n    var ConnectionPoint = require(\"./ConnectionPoint.js\");\r\n    var Point = require(\"../Point.js\");\r\n    /**\r\n     * 构造函数\r\n     * @param {[type]} options [description]\r\n     */\r\n    function Connector(options) {\r\n        Node.call(this);\r\n        if(options.model&&options.model.option&&options.model.option.resourceId){\r\n            this.resourceId = options.model.option.resourceId;\r\n        }else{\r\n            this.resourceId = Util.getUUID();// 生成节点ID\r\n        }\r\n        var defaultOptions = {\r\n            symbol: {type:\"arrow\" , size: 10, color:\"#000000\"},  //箭头  可选值为： 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'\r\n            style: {lineWidth:1, stroke:\"#000000\", lineType:Connector.TYPE_STRAIGHT},    //样式\r\n            hoverStyle: {lineWidth:2, stroke:\"lime\"}, //移上去的样式\r\n            arrowHoverStyle: {fill:\"lime\"},\r\n            shape: {points:null, smooth:false, smoothConstraint:null},//形状\r\n            position: [0,0],\r\n            isEdit: true,  //是否可编辑\r\n            text: {\r\n                text: \"\",\r\n                color: '#000000', // 文本颜色\r\n                textFont: '12px Microsoft YaHei'\r\n            },\r\n            z: 0\r\n        }\r\n        var opt = options || {};\r\n        this.options = zrUtil.merge(defaultOptions, opt, true);\r\n        this.model = options.model;\r\n        this.handles = [];\r\n        this.connectionPoints = [];\r\n        this.conPointsGroup = null;\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n        this.autoChangePosition = false\r\n        this.line = null;\r\n        this.groupCurve = new graphic.Group();\r\n        this.icons = [];  // 用于存储线段上面的操作图标\r\n        this.render();\r\n    }\r\n\r\n    Connector.TYPE_STRAIGHT = 'straight';\r\n\r\n    Connector.TYPE_JAGGED = 'jagged';\r\n\r\n    Connector.TYPE_CURVE = 'curve';\r\n\r\n    Connector.RADIUS = 3;\r\n\r\n    Connector.START_NODE = \"startNode\";\r\n\r\n    Connector.END_NODE = \"endNode\";\r\n\r\n    Connector.LEFT = \"left\";\r\n\r\n    Connector.RIGHT = \"right\";\r\n\r\n    Connector.TOP = \"top\";\r\n\r\n    Connector.BOTTOM = \"bottom\";\r\n\r\n    Connector.BOTTOM = \"bottom\";\r\n\r\n    Connector.SEPERATOR = \"-\";\r\n    /**\r\n     * 重新画线，如果传空则根据turningPoints 重新画线\r\n     * @param  {[type]} points [description]\r\n     * @return {[type]}        [description]\r\n     */\r\n    Connector.prototype.refresh = function(points) {\r\n        if(points) {\r\n            this.turningPoints = points;\r\n        }\r\n        //将[x:0,y:0]转化为[0, 0]  给zrender使用\r\n        var points = Util.traslatePoints(this.turningPoints);\r\n\r\n        if((this.options.style.lineType == Connector.TYPE_CURVE) && (points.length > 2)) {\r\n            this.modifyCurve(this.turningPoints);\r\n        } else {\r\n            this.line.attr('shape', {points: points});\r\n        }\r\n\r\n        var lineText = this.childOfName('lineText');\r\n        //开始没有创建文本，后来传进来text了，需要先创建文本\r\n        if (!lineText  && this.options.text.text) {\r\n            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n            this.add(text.text);\r\n            lineText = this.childOfName('lineText');\r\n        }\r\n        if (lineText) {\r\n            lineText.setStyle(\"text\", this.options.text.text);\r\n\r\n            var textPoint = this.getTextPostion(this.options.text);\r\n\r\n            // if (this.options.style.lineType == Connector.TYPE_STRAIGHT ) {\r\n            //     lineText.attr('rotation', this.getTextRotation(textPoint));\r\n            // }\r\n\r\n            lineText.attr(\"position\", textPoint);\r\n        }\r\n        var symbolTo = this.childOfName('toSymbol');\r\n        if(symbolTo) {\r\n            if(this.options.effect&&this.options.effect.show){\r\n                new EffectLine(symbolTo,this.options,this.groupCurve,this.polyLine);\r\n            }else{\r\n                symbolTo.attr('position', points[points.length -1]);\r\n                symbolTo.attr('rotation', Util.tangentRotation(this.turningPoints[this.turningPoints.length-2], this.turningPoints[this.turningPoints.length-1]));\r\n            }\r\n        }\r\n   };\r\n    /**\r\n     * 渲染\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.render = function() {\r\n        var that = this;\r\n        //1.创建箭头\r\n        var symbolTo = this.createSymbol('toSymbol', this.options); //arrow,triangle\r\n        if (symbolTo) {\r\n            this.add(symbolTo);\r\n        }\r\n\r\n        //2.创建线\r\n        this.curveLine = new graphic.BezierCurve({\r\n            position: this.options.position,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.groupCurve.add(this.curveLine);\r\n        this.add(this.groupCurve);\r\n\r\n        this.polyLine = new graphic.Polyline({\r\n            position: this.options.position,\r\n            shape: this.options.shape,\r\n            style: this.options.style,\r\n            z: this.options.z\r\n        });\r\n        this.add(this.polyLine);\r\n\r\n        if((this.options.style.lineType == Connector.TYPE_CURVE)) {\r\n            this.line = this.groupCurve;\r\n            this.createHoverStyle(this.curveLine);\r\n            this.polyLine.hide();\r\n        }\r\n        else {\r\n            this.line = this.polyLine;\r\n            this.createHoverStyle(this.polyLine);\r\n            this.curveLine.hide();\r\n        }\r\n\r\n        //3.侦听线事件\r\n        var MOUSE_EVENT_NAMES = ['dblclick', 'click'];//'click', 'dblclick', 'mouseover', 'mouseout'\r\n        zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            this.line.on(eveName, zrUtil.bind(function (e) {\r\n                e.cancelBubble = true;\r\n                var params = {};\r\n                params.event = e;\r\n                params.type = \"Connector:\" + eveName;\r\n                params.target = that;\r\n                this.trigger(params.type, params);\r\n                if(this.options.isEdit == false){return;}\r\n\r\n                if(this.options.isEdit && this.connectionPoints.length < 1 && this.turningPoints.length >=2) {\r\n                    this.createAllconnectionPoint()\r\n                }\r\n                if(this.handles.length < 1 ) {\r\n                    this.shapeSetHandle();\r\n                }\r\n            }, this));\r\n        }, this);\r\n\r\n        //3.创建调整线的连接点\r\n        if(this.options.isEdit) {\r\n            this.conPointsGroup = new graphic.Group();\r\n            this.add(this.conPointsGroup);\r\n        }\r\n\r\n        //4.创建线上文本\r\n        if (this.options.text.text && this.options.text.text != \"\") {\r\n            var text = this.drawText(\"lineText\", this.options.text.text,0, 0);\r\n            this.add(text.text);\r\n        }\r\n\r\n\r\n    };\r\n\r\n    //设置style\r\n    Connector.prototype.setStyle = function(options) {\r\n        if(options.color){\r\n            if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n                this.groupCurve.eachChild(function(curve) {\r\n                    curve.attr(\"style\",{stroke:options.color});\r\n                    graphic.setNormalStyle(curve, {stroke:options.color});\r\n                });\r\n            }else{\r\n                this.polyLine.attr(\"style\",{stroke:options.color});\r\n                graphic.setNormalStyle(this.polyLine, {stroke:options.color});\r\n            }\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                symbolTo.attr(\"style\",{fill:options.color});\r\n                graphic.setNormalStyle(symbolTo, {fill:options.color});\r\n            }\r\n            this.options.style.stroke = options.color;\r\n            this.model.set(\"options.style.stroke\", options.color);\r\n            this.model.set(\"options.symbol.color\", options.color);\r\n            this.options.symbol.color = options.color;\r\n        }\r\n\r\n        if(options.text){\r\n             var lineText = this.childOfName('lineText');\r\n            //开始没有创建文本，后来传进来text了，需要先创建文本\r\n            if (!lineText  && options.text.text) {\r\n                var text = this.drawText(\"lineText\", options.text.text,0, 0);\r\n                this.add(text.text);\r\n                lineText = this.childOfName('lineText');\r\n            }\r\n\r\n            if(options.text.text || options.text.text == \"\"){\r\n                lineText.setStyle(\"text\", options.text.text);\r\n                this.options.text.text = options.text.text;\r\n            }\r\n            var textPoint = this.getTextPostion(options.text);\r\n            lineText.attr(\"position\", textPoint);\r\n            if(options.text.textPos){\r\n                this.options.text.textPos = options.text.textPos;\r\n            }else{\r\n                this.options.text.textPos = 'center';\r\n            }\r\n            if(options.text.color){\r\n                lineText.attr(\"style\",{\r\n                    fill: options.text.color\r\n                });\r\n                this.options.text.color = options.text.color;\r\n            }\r\n            this.model.set(\"options.text\", options.text);\r\n        }\r\n\r\n        if(options.symbol){\r\n            if(options.symbol.type){\r\n                this.options.symbol.type = options.symbol.type;\r\n                this.model.set(\"options.symbol.type\", options.symbol.type);\r\n            }\r\n            if(options.symbol.size){\r\n                this.options.symbol.size = options.symbol.size;\r\n                this.model.set(\"options.symbol.size\", options.symbol.size);\r\n            }\r\n            if(options.symbol.color){\r\n                this.options.symbol.color = options.symbol.color;\r\n                this.model.set(\"options.symbol.color\", options.symbol.color);\r\n            }\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if (symbolTo) {\r\n                this.remove(symbolTo);\r\n            }\r\n            var symbol = this.createSymbol(\"toSymbol\",this.model.get(\"options\"))\r\n            if (symbol) {\r\n                this.add(symbol);\r\n            }\r\n            this.refresh();\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 获取线段的位置\r\n     * @param  {Object} text {text:'', color:'', textPos:''}\r\n     * @return {Object}      {x,y}\r\n     */\r\n    Connector.prototype.getTextPostion = function(text) {\r\n        var textPostion = [];\r\n        var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n        if(text&&text.textPos){\r\n            if(text.textPos == 'start'){\r\n                var xOffset = text.xOffset || 0;\r\n                textPostion = [this.turningPoints[0].x + xOffset,this.turningPoints[0].y];\r\n            }else if(text.textPos == 'end'){\r\n                var points  = Util.getMaxLineLength([this.turningPoints[this.turningPoints.length-2],this.turningPoints[this.turningPoints.length-1]]);\r\n                var angle = Util.getAngle(points[0],points[1]);\r\n                var length =  Util.distance(points[0],points[1]) - textWidth;\r\n                var newPoint = Util.getEndPoint(points[0], length, angle);\r\n                textPostion = [newPoint.x,newPoint.y];\r\n            }else{\r\n                textPostion = this.middle(text);\r\n            }\r\n        }else{\r\n            var position = this.middle(text);\r\n            textPostion = [position[0]-textWidth/2,position[1]];\r\n        }\r\n\r\n        return textPostion;\r\n    };\r\n\r\n    /**\r\n     * 获取线段的旋转角度\r\n     * @param  {Object} textPostion {x,y}\r\n     * @return {Number}             角度值\r\n     */\r\n    Connector.prototype.getTextRotation = function(textPostion) {\r\n        //计算出极坐标的角度\r\n        var points  = Util.getMaxLineLength(this.turningPoints);\r\n        var angle = - Math.atan2(points[1].y - textPostion[1], points[1].x - textPostion[0]);  //,Math.PI/2\r\n        return angle;\r\n    };\r\n\r\n    Connector.prototype.createHoverStyle = function(el) {\r\n        if (this.options.hoverStyle) {\r\n            graphic.setElementHoverStl(el, this.options.hoverStyle);\r\n\r\n            var symbolTo = this.childOfName('toSymbol');\r\n            if(symbolTo){graphic.setElementHoverStl(symbolTo, this.options.arrowHoverStyle);}\r\n\r\n            el.on('mouseover', zrUtil.bind(function() {\r\n                graphic.doEnterHover(el);\r\n                if(symbolTo){graphic.doEnterHover(symbolTo);}\r\n\r\n                this.groupCurve.eachChild(function(line) {\r\n                    graphic.doEnterHover(line);\r\n                });\r\n            },this))\r\n              .on('mouseout', zrUtil.bind(function() {\r\n                graphic.doLeaveHover(el);\r\n                if(symbolTo){graphic.doLeaveHover(symbolTo);}\r\n                this.groupCurve.eachChild(function(line) {\r\n                    graphic.doLeaveHover(line);\r\n                });\r\n            },this));\r\n        }\r\n    };\r\n    /**\r\n     * 创建Node的连接点\r\n     * @private\r\n     *\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.createAllconnectionPoint = function() {\r\n        var sRect = this.startNode.getRect? this.startNode.getRect().boundingRect : Util.getRect(this.startNode).boundingRect;\r\n\r\n        var eRect = this.endNode.getRect? this.endNode.getRect().boundingRect : Util.getRect(this.endNode).boundingRect;\r\n\r\n        var sConnectorPoint = Util.getConnectorPoints(sRect);\r\n        var eConnectorPoint = Util.getConnectorPoints(eRect);\r\n\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.left, Connector.START_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.right, Connector.START_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.top, Connector.START_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.startNode, sConnectorPoint.bottom, Connector.START_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.left, Connector.END_NODE + Connector.SEPERATOR + Connector.LEFT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.right, Connector.END_NODE + Connector.SEPERATOR + Connector.RIGHT);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.top, Connector.END_NODE + Connector.SEPERATOR + Connector.TOP);\r\n        this.connectionPointCreate(this.endNode, eConnectorPoint.bottom, Connector.END_NODE + Connector.SEPERATOR + Connector.BOTTOM);\r\n\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[0].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n\r\n        this.connectionPointCreate(this, this.turningPoints[this.turningPoints.length-1].clone(), ConnectionPoint.TYPE_CONNECTOR);\r\n    };\r\n\r\n    /**\r\n     * 创建连接点\r\n     * @private\r\n     * @param  {[type]} shape [description]\r\n     * @param  {[type]} point [description]\r\n     * @param  {[type]} type  [description]\r\n     * @return {[type]}       [description]\r\n     */\r\n    Connector.prototype.connectionPointCreate = function(shape, point, type) {\r\n        var conPoint = new ConnectionPoint(this, point, type, this.options);\r\n        this.conPointsGroup.add(conPoint.shape);\r\n    };\r\n\r\n    /**\r\n     * 清空控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.clearHandles = function() {\r\n        for (var i = 0; i < this.handles.length; i++) {\r\n            this.remove(this.handles[i].handleShape);\r\n        }\r\n        this.handles = [];\r\n        if (this.conPointsGroup) {\r\n            this.conPointsGroup.removeAll();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 创建拆线 线断的控制点\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.shapeSetHandle = function() {\r\n        for(var i=1; i<this.turningPoints.length-2; i++){\r\n            var h;\r\n            var x, y;\r\n            //是否在一条线上\r\n            var isCollineaityFirst = Util.collinearity(this.turningPoints[i-1], this.turningPoints[i], this.turningPoints[i+1]);\r\n            var isCollineaitySecond = Util.collinearity(this.turningPoints[i], this.turningPoints[i+1], this.turningPoints[i+2]);\r\n            if( (!isCollineaityFirst && (!isCollineaitySecond || this.turningPoints[i+1].equals(this.turningPoints[i+2])))\r\n                || ( (!isCollineaityFirst || this.turningPoints[i-1].equals(this.turningPoints[i])) && !isCollineaitySecond )) {\r\n\r\n                if(this.turningPoints[i].x === this.turningPoints[i+1].x){ //same vertical\r\n                    x = this.turningPoints[i].x;\r\n                    y = (this.turningPoints[i].y + this.turningPoints[i+1].y) / 2;\r\n\r\n                    h = new Handle('h',x,y,this);\r\n\r\n\r\n                }\r\n                else if(this.turningPoints[i].y === this.turningPoints[i+1].y){ // same horizontal\r\n                    x = (this.turningPoints[i].x +  this.turningPoints[i+1].x) / 2;\r\n                    y = this.turningPoints[i].y;\r\n                    h =  new  Handle('v',x,y,this);\r\n                }\r\n                if (h) {\r\n                    this.add(h.handleShape);\r\n                    this.handles.push(h);\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 创建箭头\r\n     * @param  {[type]} name       [description]\r\n     * @param  {[type]} options [description]\r\n     * @return {[type]}            [description]\r\n     */\r\n    Connector.prototype.createSymbol = function(name, options) {\r\n        var symbolType = options.symbol.type;\r\n        var symbolSize =this.options.symbol.size;\r\n        if (symbolType === 'none') {\r\n            return;\r\n        }\r\n\r\n        if (!zrUtil.isArray(symbolSize)) {\r\n            symbolSize = [symbolSize, symbolSize];\r\n        }\r\n        var symbolPath = symbolUtil.createSymbol(\r\n            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,\r\n            symbolSize[0], symbolSize[1], this.options.symbol.color, this.options.z\r\n        );\r\n        symbolPath.name = name;\r\n\r\n        return symbolPath;\r\n    };\r\n\r\n    /**\r\n     * 绘制线段上的文本\r\n     * @param  {[type]} content [description]\r\n     * @param  {[type]} name [description]\r\n     * @param  {[type]} x       [description]\r\n     * @param  {[type]} y       [description]\r\n     * @param  {[type]} color   [description]\r\n     * @return {[type]}         [description]\r\n     */\r\n    Connector.prototype.drawText = function (name,content, x, y, color) {\r\n        var text = new graphic.Text({\r\n            style: {\r\n                text: content,\r\n                x: x,\r\n                y: y,\r\n                fill: color ? color : this.options.text.color,\r\n                textFont: this.options.text.textFont\r\n            },\r\n            zlevel: 20\r\n        });\r\n        text.name = name;\r\n        return {\r\n            text: text,\r\n            rect: text.getBoundingRect()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * 获取线段的中间值\r\n     * @return {[type]} text\r\n     */\r\n    Connector.prototype.middle = function(text){\r\n\r\n        if(this.options.style.lineType == Connector.TYPE_STRAIGHT){\r\n            var points  = Util.getMaxLineLength(this.turningPoints);\r\n            //如果是求线段上的文字的中间值\r\n            // if(text) {\r\n            //     //取出字的长度，计算角度，\r\n            //     var textWidth = graphic.textContain.getWidth(text.text, text.textFont);\r\n            //     var angle = Util.getAngle(points[0],points[1]);\r\n            //     var length =  Util.distance(points[0],points[1])/2 - textWidth/2;\r\n            //     var newPoint = Util.getEndPoint(points[0], length, angle);\r\n            //     return [newPoint.x, newPoint.y];\r\n            // } else {\r\n            //     var middleX = (points[0].x + points[1].x)/2;\r\n            //     var middleY = (points[0].y + points[1].y) /2;\r\n            //     return [middleX, middleY];\r\n            // }\r\n            var middleX = (points[0].x + points[1].x)/2;\r\n            var middleY = (points[0].y + points[1].y) /2;\r\n            return [middleX, middleY];\r\n        }\r\n        else if(this.options.style.lineType == Connector.TYPE_JAGGED){\r\n\r\n            //find total distance\r\n            var distance = this.getLength();\r\n\r\n            //find between what turning points the half distance is\r\n            var index = -1;\r\n            var ellapsedDistance = 0;\r\n            for(var i=0; i<this.turningPoints.length-1; i++){\r\n                index = i;\r\n                var segment = Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n                if(ellapsedDistance + segment < distance /2){\r\n                    ellapsedDistance += segment;\r\n                }\r\n                else{\r\n                    break;\r\n                }\r\n            }\r\n\r\n            //we have the middle distance somewhere between i(ndex) and i(ndex)+1\r\n            if(index != -1){\r\n                var missingDistance = distance / 2 - ellapsedDistance;\r\n                if( Util.round(this.turningPoints[index].x, 3) == Util.round(this.turningPoints[index + 1].x, 3) ){ //vertical segment (same x)\r\n                    return [this.turningPoints[index].x, Math.min(this.turningPoints[index].y, this.turningPoints[index + 1].y) + missingDistance];\r\n                } else if( Util.round(this.turningPoints[index].y, 3) == Util.round(this.turningPoints[index + 1].y, 3) ) { //horizontal segment (same y)\r\n                    return [Math.min(this.turningPoints[index].x, this.turningPoints[index + 1].x) + missingDistance, this.turningPoints[index].y];\r\n                } else{\r\n                    console.error(\"Connector:middle() - this should never happen \" + this.turningPoints[index] + \" \" + this.turningPoints[index + 1]\r\n                        + \" nr of points \" + this.turningPoints.length\r\n                        );\r\n                }\r\n\r\n            }\r\n        }\r\n        else if(this.options.style.lineType == Connector.TYPE_CURVE){\r\n            var t = 0.5;\r\n            var l = this.getLength();\r\n\r\n            var walked = 0;\r\n            for(var j =0; j< this.turningPoints.length-1; j++){\r\n                if( walked + Util.distance(this.turningPoints[j], this.turningPoints[j+1]) > l * t ){\r\n                    break;\r\n                }\r\n\r\n                walked += Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n            }\r\n\r\n            var rest = l * t - walked;\r\n            var currentSegmentLength = Util.distance(this.turningPoints[j], this.turningPoints[j+1]);\r\n\r\n            //find the position/ration of the middle of Polyline on current segment\r\n            var segmentPercent = rest / currentSegmentLength;\r\n\r\n            var Xp = segmentPercent * (this.turningPoints[j+1].x - this.turningPoints[j].x) + this.turningPoints[j].x;\r\n            var Yp = segmentPercent * (this.turningPoints[j+1].y - this.turningPoints[j].y) + this.turningPoints[j].y;\r\n\r\n            return [Xp, Yp];\r\n\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * find total distance\r\n     * @return {Number} [description]\r\n     */\r\n    Connector.prototype.getLength = function() {\r\n            //find total distance\r\n        var distance = 0;\r\n        for(var i=0; i<this.turningPoints.length-1; i++){\r\n            distance += Util.getLength(this.turningPoints[i], this.turningPoints[i+1]);\r\n        }\r\n        return distance;\r\n    };\r\n\r\n    /**\r\n     * 转JSON对象\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.toJSON = function() {\r\n\r\n        this.model.set(\"resourceId\", this.resourceId);\r\n        this.model.set(\"properties.type\", 14);\r\n\r\n        this.model.set(\"bounds.upperLeft.x\", this.position[0]);\r\n        this.model.set(\"bounds.upperLeft.y\", this.position[1]);\r\n        this.model.set(\"bounds.lowerRight.x\", parseInt(this.position[0] + this.getBoundingRect().width));\r\n        this.model.set(\"bounds.lowerRight.y\", parseInt(this.position[1] + this.getBoundingRect().height));\r\n        this.model.set(\"style.sPos\", this.sPos);\r\n        this.model.set(\"style.ePos\", this.ePos);\r\n        this.model.set(\"dockers\",this.turningPoints);\r\n        return this.model.option;\r\n    };\r\n\r\n     /**\r\n     * refreshModel\r\n     * @return {[type]} [description]\r\n     */\r\n    Connector.prototype.refreshModel = function() {\r\n        this.model.set(\"options.dockers\",this.turningPoints);\r\n        var icons = [];\r\n        for(var i = 0;i < this.icons.length;i++){\r\n            var iconNode = this.icons[i];\r\n            var option = [iconNode.key,{\r\n                icon:iconNode.style.image,\r\n                width: iconNode.style.width,\r\n                height: iconNode.style.height\r\n            }];\r\n            icons.push(option);\r\n        }\r\n        this.model.set(\"icons\",icons);\r\n    };\r\n\r\n    /**\r\n     * 调整曲线的形状\r\n     * @param  {array} points 点数组\r\n     * @return {void}\r\n     */\r\n    Connector.prototype.modifyCurve = function(points) {\r\n        var sol = this.getCurvePoint(points);\r\n\r\n        // 1. 如果曲线的数量 比数量的中数量要少 则删除多余的线段\r\n        var willDelCurves = [];\r\n        for (var j = sol.length, cntCurve = this.groupCurve.childCount(); j < cntCurve ; j++) {\r\n            willDelCurves.push(this.groupCurve.childAt(j));\r\n        }\r\n        zrUtil.each(willDelCurves, function(curve) {\r\n            this.groupCurve.remove(curve);\r\n        }, this);\r\n        // 2. 遍历曲线   如果存在则直接设置形状，否则创建\r\n        for (var i = 0; i < sol.length; i++) {\r\n            var line = this.groupCurve.childAt(i);\r\n            if (line) {\r\n                line.attr('shape', sol[i]);\r\n            } else {\r\n                var cure = new graphic.BezierCurve({\r\n                    position: this.options.position,\r\n                    style: this.options.style,\r\n                    shape: sol[i],\r\n                    z: this.options.z\r\n                });\r\n                this.groupCurve.add(cure);\r\n                this.createHoverStyle(cure);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 根据传入的点数组计算曲线的点\r\n     * @param  {array} P 点数组\r\n     * @return {object}        曲线的点数组\r\n     */\r\n    Connector.prototype.getCurvePoint = function(P) {\r\n        var n = P.length;\r\n        var sol = [];\r\n        if (n === 3) {\r\n            sol.push({x1: P[0].x,\r\n                   y1: P[0].y,\r\n                   cpx1: P[1].x,\r\n                   cpy1: P[1].y,\r\n                   x2: P[2].x,\r\n                   y2: P[2].y\r\n                });\r\n            return sol;\r\n        }\r\n        else if (n === 4) {\r\n            sol.push({x1: P[0].x,\r\n                   y1: P[0].y,\r\n                   cpx1: P[1].x,\r\n                   cpy1: P[1].y,\r\n                   cpx2: P[2].x,\r\n                   cpy2: P[2].y,\r\n                   x2: P[3].x,\r\n                   y2: P[3].y\r\n                });\r\n            return sol;\r\n        }\r\n\r\n        /**Computes factorial\r\n         * @param {Number} k the number\r\n         * */\r\n        function fact(k){\r\n            if(k===0 || k===1){\r\n                return 1;\r\n            }\r\n            else{\r\n                return k * fact(k-1);\r\n            }\r\n        }\r\n\r\n        /**Computes Bernstain*/\r\n        function B(i,n,u){\r\n            return fact(n) / (fact(i) * fact(n-i))* Math.pow(u, i) * Math.pow(1-u, n-i);\r\n        }\r\n\r\n        /**Computes the sum between two point\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function sum(p1, p2){\r\n            return new Point(p1.x + p2.x, p1.y + p2.y);\r\n        }\r\n\r\n        /**Computes the difference between first {Point} and second {Point}\r\n         *@param p1 - {Point}\r\n         *@param p2 - {Point}\r\n         *@return {Point} the sum of initial points\r\n         **/\r\n        function minus(p1, p2){\r\n            return new Point(p1.x - p2.x, p1.y - p2.y);\r\n        }\r\n\r\n        /**Computes the division of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function divide(p, nr){\r\n            if(nr == 0){\r\n                throw \"Division by zero not allowed (yet :) \" + this.callee ;\r\n            }\r\n            return new Point(p.x/nr, p.y/nr);\r\n        }\r\n\r\n        /**Computes the multiplication of a {Point} by a number\r\n         *@param p - {Point}\r\n         *@param nr - {Number}\r\n         *@return {Point}\r\n         **/\r\n        function multiply(p, nr){\r\n            return new Point (p.x * nr, p.y * nr);\r\n        }\r\n\r\n\r\n\r\n\r\n        /*\r\n         *I do not get why first 4 must be 0 and last 3 of same value.....\r\n         *but otherwise we will get division by zero\r\n         */\r\n        var k = [0,0,0];\r\n\r\n        var j;\r\n        for(j=0;j<=n-3;j++){\r\n            k.push(j);\r\n        }\r\n\r\n        k.push(n-3, n-3);\r\n\r\n\r\n\r\n        for(i=1; i<=n-3; i++){\r\n            //q1 - compute start point\r\n            var q1 = divide( sum( multiply(P[i], k[i+4] - k[i+2]), multiply(P[i+1], k[i+2] - k[i+1]) ), k[i+4] - k[i+1]);\r\n\r\n            //q0 - compute 1st controll point\r\n            var q_01 = (k[i+3] - k[i+2]) / (k[i+3] - k[i+1]);\r\n            var q_02 = divide( sum( multiply(P[i-1],k[i+3] - k[i+2]), multiply(P[i], k[i+2] - k[i])), k[i+3] - k[i]);\r\n            var q_03 = multiply(q1, ( k[i+2] - k[i+1])/ (k[i+3] - k[i+1]) );\r\n            var q0 = sum(multiply(q_02, q_01), q_03);\r\n\r\n            //q2 - compute 2nd controll point\r\n            var q2 = divide( sum( multiply(P[i], k[i+4] - k[i+3]), multiply(P[i+1], k[i+3] - k[i+1]) ), k[i+4] - k[i+1] );\r\n\r\n            //q3 - compute end point\r\n            var q_31 = (k[i+3] - k[i+2]) / (k[i+4] - k[i+2]);\r\n            var q_32 = divide( sum( multiply(P[i+1], k[i+5] - k[i+3]), multiply(P[i+2], k[i+3] - k[i+2]) ) , k[i+5] - k[i+2]);\r\n            var q_33 = multiply(q2, (k[i+4] - k[i+3])/(k[i+4] - k[i+2]) );\r\n            var q3 = sum(multiply(q_32, q_31), q_33);\r\n\r\n            //store solution\r\n            //\r\n            sol.push({x1: q0.x,\r\n                   y1: q0.y,\r\n                   cpx1: q1.x,\r\n                   cpy1: q1.y,\r\n                   cpx2: q2.x,\r\n                   cpy2: q2.y,\r\n                   x2: q3.x,\r\n                   y2: q3.y\r\n                });\r\n        }\r\n\r\n        return sol;\r\n    };\r\n\r\n\r\n    Util.inherits(Connector,Node);\r\n\r\n    module.exports = Connector;\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Connector.js\n ** module id = 89\n ** module chunks = 0\n **/","'use strict';\n// Symbol factory\r\n\r\n\r\n    var graphic = require('../graphic');\r\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\r\n    /**\r\n     * Triangle shape\r\n     * @inner\r\n     */\r\n    var Triangle = graphic.extendShape({\r\n        type: 'triangle',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy + height);\r\n            path.lineTo(cx - width, cy + height);\r\n            path.closePath();\r\n        }\r\n    });\r\n    /**\r\n     * Diamond shape\r\n     * @inner\r\n     */\r\n    var Diamond = graphic.extendShape({\r\n        type: 'diamond',\r\n        shape: {\r\n            cx: 0,\r\n            cy: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n        buildPath: function (path, shape) {\r\n            var cx = shape.cx;\r\n            var cy = shape.cy;\r\n            var width = shape.width / 2;\r\n            var height = shape.height / 2;\r\n            path.moveTo(cx, cy - height);\r\n            path.lineTo(cx + width, cy);\r\n            path.lineTo(cx, cy + height);\r\n            path.lineTo(cx - width, cy);\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Pin shape\r\n     * @inner\r\n     */\r\n    var Pin = graphic.extendShape({\r\n        type: 'pin',\r\n        shape: {\r\n            // x, y on the cusp\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (path, shape) {\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var w = shape.width / 5 * 3;\r\n            // Height must be larger than width\r\n            var h = Math.max(w, shape.height);\r\n            var r = w / 2;\r\n\r\n            // Dist on y with tangent point and circle center\r\n            var dy = r * r / (h - r);\r\n            var cy = y - h + r + dy;\r\n            var angle = Math.asin(dy / r);\r\n            // Dist on x with tangent point and circle center\r\n            var dx = Math.cos(angle) * r;\r\n\r\n            var tanX = Math.sin(angle);\r\n            var tanY = Math.cos(angle);\r\n\r\n            path.arc(\r\n                x, cy, r,\r\n                Math.PI - angle,\r\n                Math.PI * 2 + angle\r\n            );\r\n\r\n            var cpLen = r * 0.6;\r\n            var cpLen2 = r * 0.7;\r\n            path.bezierCurveTo(\r\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x, y - cpLen2,\r\n                x, y\r\n            );\r\n            path.bezierCurveTo(\r\n                x, y - cpLen2,\r\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\r\n                x - dx, cy + dy\r\n            );\r\n            path.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Arrow shape\r\n     * @inner\r\n     */\r\n    var Arrow = graphic.extendShape({\r\n\r\n        type: 'arrow',\r\n\r\n        shape: {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var height = shape.height;\r\n            var width = shape.width;\r\n            var x = shape.x;\r\n            var y = shape.y;\r\n            var dx = width / 3 * 2;\r\n            ctx.moveTo(x, y);\r\n            ctx.lineTo(x + dx, y + height);\r\n            ctx.lineTo(x, y + height / 4 * 3);\r\n            ctx.lineTo(x - dx, y + height);\r\n            ctx.lineTo(x, y);\r\n            ctx.closePath();\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Map of path contructors\r\n     * @type {Object.<string, module:zrender/graphic/Path>}\r\n     */\r\n    var symbolCtors = {\r\n        line: graphic.Line,\r\n\r\n        rect: graphic.Rect,\r\n\r\n        roundRect: graphic.Rect,\r\n\r\n        square: graphic.Rect,\r\n\r\n        circle: graphic.Circle,\r\n\r\n        diamond: Diamond,\r\n\r\n        pin: Pin,\r\n\r\n        arrow: Arrow,\r\n\r\n        triangle: Triangle\r\n    };\r\n\r\n    var symbolShapeMakers = {\r\n\r\n        line: function (x, y, w, h, shape) {\r\n            // FIXME\r\n            shape.x1 = x;\r\n            shape.y1 = y + h / 2;\r\n            shape.x2 = x + w;\r\n            shape.y2 = y + h / 2;\r\n        },\r\n\r\n        rect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        roundRect: function (x, y, w, h, shape) {\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = w;\r\n            shape.height = h;\r\n            shape.r = Math.min(w, h) / 4;\r\n        },\r\n\r\n        square: function (x, y, w, h, shape) {\r\n            var size = Math.min(w, h);\r\n            shape.x = x;\r\n            shape.y = y;\r\n            shape.width = size;\r\n            shape.height = size;\r\n        },\r\n\r\n        circle: function (x, y, w, h, shape) {\r\n            // Put circle in the center of square\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.r = Math.min(w, h) / 2;\r\n        },\r\n\r\n        diamond: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        pin: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        arrow: function (x, y, w, h, shape) {\r\n            shape.x = x + w / 2;\r\n            shape.y = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        },\r\n\r\n        triangle: function (x, y, w, h, shape) {\r\n            shape.cx = x + w / 2;\r\n            shape.cy = y + h / 2;\r\n            shape.width = w;\r\n            shape.height = h;\r\n        }\r\n    };\r\n\r\n    var symbolBuildProxies = {};\r\n    for (var name in symbolCtors) {\r\n        symbolBuildProxies[name] = new symbolCtors[name]();\r\n    }\r\n\r\n    var Symbol = graphic.extendShape({\r\n\r\n        type: 'symbol',\r\n\r\n        shape: {\r\n            symbolType: '',\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0\r\n        },\r\n\r\n        beforeBrush: function () {\r\n            var style = this.style;\r\n            var shape = this.shape;\r\n            // FIXME\r\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\r\n                style.textPosition = ['50%', '40%'];\r\n                style.textAlign = 'center';\r\n                style.textVerticalAlign = 'middle';\r\n            }\r\n        },\r\n\r\n        buildPath: function (ctx, shape) {\r\n            var symbolType = shape.symbolType;\r\n            var proxySymbol = symbolBuildProxies[symbolType];\r\n            if (shape.symbolType !== 'none') {\r\n                if (!proxySymbol) {\r\n                    // Default rect\r\n                    symbolType = 'rect';\r\n                    proxySymbol = symbolBuildProxies[symbolType];\r\n                }\r\n                symbolShapeMakers[symbolType](\r\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\r\n                );\r\n                proxySymbol.buildPath(ctx, proxySymbol.shape);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\r\n    var symbolPathSetColor = function (color) {\r\n        if (this.type !== 'image') {\r\n            var symbolStyle = this.style;\r\n            var symbolShape = this.shape;\r\n            if (symbolShape && symbolShape.symbolType === 'line') {\r\n                symbolStyle.stroke = color;\r\n            }\r\n            else if (this.__isEmptyBrush) {\r\n                symbolStyle.stroke = color;\r\n                symbolStyle.fill = '#fff';\r\n            }\r\n            else {\r\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\r\n                symbolStyle.fill && (symbolStyle.fill = color);\r\n                symbolStyle.stroke && (symbolStyle.stroke = color);\r\n            }\r\n            this.dirty();\r\n        }\r\n    };\r\n\r\n    var symbolUtil = {\r\n        /**\r\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\r\n         * @param {string} symbolType\r\n         * @param {number} x\r\n         * @param {number} y\r\n         * @param {number} w\r\n         * @param {number} h\r\n         * @param {number} z\r\n         * @param {string} color\r\n         */\r\n        createSymbol: function (symbolType, x, y, w, h, color, z) {\r\n            var isEmpty = symbolType.indexOf('empty') === 0;\r\n            if (isEmpty) {\r\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\r\n            }\r\n            var symbolPath;\r\n\r\n            if (symbolType.indexOf('image://') === 0) {\r\n                symbolPath = new graphic.Image({\r\n                    style: {\r\n                        image: symbolType.slice(8),\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n            else if (symbolType.indexOf('path://') === 0) {\r\n                symbolPath = graphic.makePath(symbolType.slice(7), {z: z}, new BoundingRect(x, y, w, h));\r\n            }\r\n            else {\r\n                symbolPath = new Symbol({\r\n                    shape: {\r\n                        symbolType: symbolType,\r\n                        x: x,\r\n                        y: y,\r\n                        width: w,\r\n                        height: h\r\n                    },\r\n                    z: z\r\n                });\r\n            }\r\n\r\n            symbolPath.__isEmptyBrush = isEmpty;\r\n\r\n            symbolPath.setColor = symbolPathSetColor;\r\n\r\n            symbolPath.setColor(color);\r\n\r\n            return symbolPath;\r\n        }\r\n    };\r\n\r\n    module.exports = symbolUtil;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Symbol.js\n ** module id = 90\n ** module chunks = 0\n **/","/**\r\n * 画句柄\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function Handle(type, x, y, connector){\r\n        this.type = type;\r\n\r\n        this.x = x;\r\n\r\n        this.y = y;\r\n\r\n        this.visible = true;\r\n\r\n        this.connector = connector;\r\n\r\n        this.handleShape = new graphic.Circle({\r\n            shape: {\r\n                cx: x,\r\n                cy: y,\r\n                r: Handle.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: \"rgb(0,255,0)\",\r\n                stroke:\"rgb(0,0,0)\"\r\n            },\r\n            z : connector.options.z + 2,  //节点Z为1 线段为0;\r\n            draggable:true\r\n        });\r\n\r\n        var that = this;\r\n        this.handleShape.on(\"drag\", function(e) {\r\n            that.actionConnector(e.offsetX,e.offsetY);\r\n        });\r\n       // return this.circle;\r\n    }\r\n\r\n    Handle.RADIUS = 4;\r\n\r\n    Handle.prototype = {\r\n\r\n        constructor : Handle,\r\n\r\n        equals : function(anotherHandle){\r\n            if(!anotherHandle instanceof Handle){\r\n                return false;\r\n            }\r\n\r\n            return this.type == anotherHandle.type\r\n            && this.x == anotherHandle.x\r\n            && this.y == anotherHandle.y\r\n            && this.visible == anotherHandle.visible;\r\n        },\r\n\r\n        /**\r\n         * 移动句柄\r\n         * @param  {[type]} newX [description]\r\n         * @param  {[type]} newY [description]\r\n         * @return {[type]}      [description]\r\n         */\r\n        actionConnector: function(newX, newY){\r\n            switch(this.type){\r\n                case 'v':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].y == this.connector.turningPoints[i].y\r\n                            && this.connector.turningPoints[i].y == this.y\r\n                            && Math.min(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) <= this.x\r\n                            && Math.max(this.connector.turningPoints[i].x, this.connector.turningPoints[i-1].x) >= this.x)\r\n                        {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaY = newY - this.y;\r\n                    var translationMatrix = Util.translationMatrix(0, deltaY);\r\n\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.y = newY;  //将句柄新的位置赋值给y\r\n\r\n                    break;\r\n\r\n                case 'h':\r\n                    var index;\r\n                    // 找出两个转折点（可移动句柄在这两个转折点中间）\r\n                    for(var i = 1; i < this.connector.turningPoints.length-1; i++){\r\n                        if(this.connector.turningPoints[i-1].x == this.connector.turningPoints[i].x\r\n                            && this.connector.turningPoints[i].x == this.x\r\n                            && Math.min(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) <= this.y\r\n                            && Math.max(this.connector.turningPoints[i].y, this.connector.turningPoints[i-1].y) >= this.y)\r\n                            {\r\n                            index = i;\r\n                        }\r\n                    }\r\n                    var deltaX = newX-this.x;\r\n                    var translationMatrix = Util.translationMatrix(deltaX, 0);\r\n                    this.connector.turningPoints[index-1].transform(translationMatrix);\r\n                    this.connector.turningPoints[index].transform(translationMatrix);\r\n                    this.connector.refresh();\r\n                    this.x = newX; //将句柄新的位置赋值给x\r\n\r\n                    break;\r\n            }\r\n           //. this.shape.updateMiddleText();\r\n        }\r\n    };\r\n    module.exports = Handle;\r\n\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/Handle.js\n ** module id = 91\n ** module chunks = 0\n **/","/**\r\n * 连线动态效果\r\n * @author miao.cunzhi\r\n */\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var vec2 = require('zrender/lib/core/vector');\r\n    var curveUtil = require('zrender/lib/core/curve');\r\n    var symbolUtil = require('./Symbol.js');\r\n\r\n    function EffectLine(symbol, options, groupCurve, polyLine) {\r\n        this._lastFrame = 0;\r\n        this._lastFramePercent = 0;\r\n        this.symbol = symbol;\r\n        this.groupCurve = groupCurve;\r\n        this.initSymbol(options, polyLine);\r\n    }\r\n    var EffectLineProto = EffectLine.prototype;\r\n\r\n    EffectLineProto.initSymbol = function(options, polyLine) {\r\n        var that = this;\r\n        this.symbol.z2 = 100;\r\n        this.symbol.culling = true;\r\n        var period = options.effect.period * 1000;\r\n        this.symbol.__t = 0;\r\n        this.symbol.stopAnimation();\r\n        if ((options.style.lineType == \"curve\")) {\r\n            if (this.groupCurve) {\r\n                var i = 0;\r\n                period = period / this.groupCurve._children.length;\r\n                this.groupCurveAnimate(this.groupCurve._children[0], i, period);\r\n            }\r\n\r\n        } else {\r\n            this.symbol.animate('', true)\r\n                .when(period, {\r\n                    __t: 1\r\n                })\r\n                .delay(0)\r\n                .during(function() {\r\n                    that.updateSymbolPositionPolyline();\r\n                })\r\n                .start();\r\n            this.setAnimationPointsPolyline(polyLine.shape.points);\r\n        }\r\n\r\n    };\r\n\r\n    EffectLineProto.groupCurveAnimate = function(curveLine, i, period) {\r\n        var that = this;\r\n        if (curveLine == undefined) {\r\n            curveLine = this.groupCurve._children[0];\r\n            i = 0;\r\n        }\r\n        var points;\r\n        var pos = curveLine.shape;\r\n        points = [\r\n            [pos.x1, pos.y1],\r\n            [pos.x2, pos.y2],\r\n            [pos.cpx1, pos.cpy1],\r\n            [pos.cpx2, pos.cpy2]\r\n        ];\r\n        this.setAnimationPointsBezierCurve(points);\r\n        this.symbol.animate('')\r\n            .when(period, {\r\n                __t: 1\r\n            })\r\n            .delay(0)\r\n            .during(function() {\r\n                that.updateSymbolPositionBezierCurve();\r\n            })\r\n            .done(function() {\r\n                that.symbol.__t = 0;\r\n                that.groupCurveAnimate(that.groupCurve._children[i + 1], i + 1, period);\r\n            })\r\n            .start();\r\n\r\n    };\r\n\r\n\r\n    EffectLineProto.setAnimationPointsBezierCurve = function(points) {\r\n        this.symbol.__p1 = points[0];\r\n        this.symbol.__p2 = points[1];\r\n        this.symbol.__cp1 = points[2] || [\r\n            (points[0][0] + points[1][0]) / 2,\r\n            (points[0][1] + points[1][1]) / 2\r\n        ];\r\n        this.symbol.__cp2 = points[3];\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionBezierCurve = function() {\r\n        var p1 = this.symbol.__p1;\r\n        var p2 = this.symbol.__p2;\r\n        var cp1 = this.symbol.__cp1;\r\n        var cp2 = this.symbol.__cp2;\r\n        var t = this.symbol.__t;\r\n        var pos = this.symbol.position;\r\n        var tx, ty;\r\n        if (cp2[0] != undefined) {\r\n            var cubicAt = curveUtil.cubicAt;\r\n            var cubicDerivativeAt = curveUtil.cubicDerivativeAt;\r\n            pos[0] = cubicAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            pos[1] = cubicAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n            // Tangent\r\n            tx = cubicDerivativeAt(p1[0], cp1[0], cp2[0], p2[0], t);\r\n            ty = cubicDerivativeAt(p1[1], cp1[1], cp2[1], p2[1], t);\r\n        } else {\r\n            var quadraticAt = curveUtil.quadraticAt;\r\n            var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;\r\n            pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);\r\n            pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);\r\n            // Tangent\r\n            tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);\r\n            ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);\r\n        }\r\n        this.symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\r\n\r\n        this.symbol.ignore = false;\r\n    };\r\n\r\n    EffectLineProto.setAnimationPointsPolyline = function(points) {\r\n        this._points = points;\r\n        var accLenArr = [0];\r\n        var len = 0;\r\n        for (var i = 1; i < points.length; i++) {\r\n            var p1 = points[i - 1];\r\n            var p2 = points[i];\r\n            len += vec2.dist(p1, p2);\r\n            accLenArr.push(len);\r\n        }\r\n        if (len === 0) {\r\n            return;\r\n        }\r\n\r\n        for (var j = 0; j < accLenArr.length; j++) {\r\n            accLenArr[j] /= len;\r\n        }\r\n        this._offsets = accLenArr;\r\n        this._length = len;\r\n        this.symbol._lastFrame = 0;\r\n        this.symbol.__lastFramePercent = 0;\r\n    };\r\n\r\n    EffectLineProto.updateSymbolPositionPolyline = function() {\r\n        var t = this.symbol.__t;\r\n        var points = this._points;\r\n        var offsets = this._offsets;\r\n        var len = points.length;\r\n\r\n        if (!offsets) {\r\n            // Has length 0\r\n            return;\r\n        }\r\n\r\n        var lastFrame = this._lastFrame;\r\n        var frame;\r\n\r\n        if (t < this._lastFramePercent) {\r\n            // Start from the next frame\r\n            // PENDING start from lastFrame ?\r\n            var start = Math.min(lastFrame + 1, len - 1);\r\n            for (frame = start; frame >= 0; frame--) {\r\n                if (offsets[frame] <= t) {\r\n                    break;\r\n                }\r\n            }\r\n            // PENDING really need to do this ?\r\n            frame = Math.min(frame, len - 2);\r\n        } else {\r\n            for (var frame = lastFrame; frame < len; frame++) {\r\n                if (offsets[frame] > t) {\r\n                    break;\r\n                }\r\n            }\r\n            frame = Math.min(frame - 1, len - 2);\r\n        }\r\n        vec2.lerp(\r\n            this.symbol.position, points[frame], points[frame + 1],\r\n            (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])\r\n        );\r\n\r\n        this._lastFrame = frame;\r\n        this._lastFramePercent = t;\r\n        var angle = -Math.atan2(points[frame + 1][1] - points[frame][1], points[frame + 1][0] - points[frame][0]);\r\n        this.symbol.rotation = angle - Math.PI / 2;\r\n        this.symbol.ignore = false;\r\n    };\r\n    module.exports = EffectLine;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/EffectLine.js\n ** module id = 92\n ** module chunks = 0\n **/","/**\r\n * 控制点\r\n * @author wang.xiaohu\r\n */\r\n\r\n    var graphic = require(\"../graphic.js\");\r\n    var Util = require(\"../util.js\");\r\n    function ConnectionPoint(connector, point, type, options){\r\n        this.connector = connector;\r\n\r\n        this.point = point.clone();\r\n\r\n        this.type = type;\r\n\r\n        this.color = ConnectionPoint.NORMAL_COLOR;\r\n\r\n        this.oType = 'ConnectionPoint';\r\n\r\n        this.shape = new graphic.Circle({\r\n            shape: {\r\n                cx: this.point.x,\r\n                cy: this.point.y,\r\n                r: ConnectionPoint.RADIUS\r\n            },\r\n\r\n            style: {\r\n                fill: this.color,\r\n                stroke:'#000000'\r\n            },\r\n            z : options.z + 2  //节点Z为1 线段为0;\r\n        });\r\n        this.shape.type =  this.type;\r\n\r\n        this.shape.connector = connector;\r\n        //return this.circle;\r\n    }\r\n\r\n    ConnectionPoint.NORMAL_COLOR = \"#FFFF33\"; //yellow.\r\n\r\n    ConnectionPoint.OVER_COLOR = \"#FF9900\"; //orange\r\n\r\n    ConnectionPoint.CONNECTED_COLOR = \"#ff0000\"; //red\r\n\r\n    ConnectionPoint.RADIUS = 4;\r\n\r\n    ConnectionPoint.TYPE_FIGURE = 'figure';\r\n\r\n    ConnectionPoint.TYPE_CONNECTOR = 'connector';\r\n\r\n    ConnectionPoint.prototype = {\r\n\r\n        constructor : ConnectionPoint,\r\n\r\n        equals : function(anotherConnectionPoint){\r\n            return this.point.equals(anotherConnectionPoint.point)\r\n            && this.connector == anotherConnectionPoint.connector\r\n            && this.type == anotherConnectionPoint.type\r\n            && this.color == anotherConnectionPoint.color\r\n            && this.radius == anotherConnectionPoint.radius;\r\n        }\r\n\r\n\r\n    };\r\n    module.exports = ConnectionPoint;\r\n\r\n\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/shapes/ConnectionPoint.js\n ** module id = 93\n ** module chunks = 0\n **/","/**\r\n * Network model\r\n *\r\n */\r\n\r\n\r\n    var Model = require('../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var NetWorkLineModel = Model.extend({\r\n        /**\r\n         * @type {Object}\r\n         * @protected\r\n         */\r\n        defaultOption: {\r\n            fromBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]\r\n            toBounds: {x:0, y:0, width:0, height:0},  // [左上角X, 左上角Y, 宽度 , 高度]\r\n            moddleX: 0,  // 中间线的Y坐标\r\n            moddleY: 0,  // 中间线的Y坐标\r\n            style: {\r\n                lineWidth:1,  // 线宽度\r\n                stroke: \"#FFFFFF\",  //线颜色\r\n            },\r\n            hoverStyle: {\r\n                lineWidth:1,  // 线宽度\r\n                stroke: \"#FFFFFF\",  //线颜色\r\n            },\r\n            isVector: false\r\n        },\r\n\r\n        init: function (option, parentModel, extraOpt) {\r\n            zrUtil.merge(option, this.getDefaultOption());\r\n        },\r\n\r\n        getDefaultOption: function () {\r\n            if (!this.hasOwnProperty('__defaultOption')) {\r\n                var optList = [];\r\n                var Class = this.constructor;\r\n                while (Class) {\r\n                    var opt = Class.prototype.defaultOption;\r\n                    opt && optList.push(opt);\r\n                    Class = Class.superClass;\r\n                }\r\n\r\n                var defaultOption = {};\r\n                for (var i = optList.length - 1; i >= 0; i--) {\r\n                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);\r\n                }\r\n                this.__defaultOption = defaultOption;\r\n            }\r\n            return this.__defaultOption;\r\n        }\r\n\r\n    });\r\n    module.exports = NetWorkLineModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/NetWorkLineModel.js\n ** module id = 94\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function ServerTopoNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerTopoNode\" };    \r\n        this.model = model;\r\n        this.portNodeList = [];\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerTopoNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n        var _width = model.get(\"width\");\r\n        var _height = 20;\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: _height,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var status = model.get(\"status\");\r\n        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n        //      imageUrl += status;\r\n        // }\r\n        imageUrl += '.png';\r\n        var cellStateNode = new graphic.Circle({\r\n             shape: {\r\n                cx: 10,\r\n                cy: 10,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: '#077826',\r\n                opacity: 1,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            } ,\r\n            z: 1000\r\n        });\r\n        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n            cellStateNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(cellStateNode);\r\n        \r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: _width,\r\n                height:  _height\r\n            },\r\n            //z: 1000,\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n        this.add(serverNodeB);\r\n\r\n        var portsList = model.get(\"ports\");\r\n        if ( portsList !== undefined ) {\r\n            var _kmx = 10;\r\n            for ( var i = 0; i < portsList.length; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 7;\r\n                portModel.width = 7;\r\n\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\");\r\n                _linInfo.sourcePort = i;\r\n                _linInfo.sourceCardNo = 0;\r\n                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n                     _linInfo.ip = portsList[i].ip;\r\n                }\r\n                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n                    if ( portsList[i].type === \"1\" ) {\r\n                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n                    } else {\r\n                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n                    }\r\n                }   \r\n                portModel.lineInfo = _linInfo;         \r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _kmx = _kmx + 5;      \r\n            }\r\n        }\r\n       \r\n        var ports = model.get('ports');\r\n        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {\r\n\r\n        }\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerTopoNode.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.portNodeList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerTopoNode, NetworkNode);\r\n    module.exports = ServerTopoNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerTopoNode.js\n ** module id = 95\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerR630Node(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerR630Node\" };    \r\n        this.model = model;\r\n        this.portNodeList = [];\r\n        this.cardNodeList = [];\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerR630Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n        var _width = model.get(\"width\");\r\n        var _height = 20;\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: _height,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var status = model.get(\"status\");\r\n        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n        //      imageUrl += status;\r\n        // }\r\n        imageUrl += '.png';\r\n\r\n        var cellStateNode = new graphic.Circle({\r\n             shape: {\r\n                cx: 10,\r\n                cy: 10,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: '#077826',\r\n                opacity: 1,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            } ,\r\n            z: 1000\r\n        });\r\n        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n            cellStateNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(cellStateNode);\r\n  \r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: _width,\r\n                height:  _height\r\n            },\r\n            //z: 1000,\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n        this.add(serverNodeB);\r\n\r\n        var portsList = model.get(\"ports\");\r\n        if ( portsList !== undefined ) {\r\n            var _kmx = 10;\r\n            for ( var i = 0; i < portsList.length; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 7;\r\n                portModel.width = 7;\r\n\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\");\r\n                _linInfo.sourcePort = i;\r\n                _linInfo.sourceCardNo = 0;\r\n                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n                if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n                     _linInfo.ip = portsList[i].ip;\r\n                }\r\n                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n                    if ( portsList[i].type === \"1\" ) {\r\n                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n                    } else {\r\n                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n                    }\r\n                }   \r\n                portModel.lineInfo = _linInfo;         \r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _kmx = _kmx + 5;      \r\n            }\r\n        }\r\n       \r\n        var ports = model.get('ports');\r\n        if ( ports !== undefined && ports.card1 !== undefined && ports.card1.length < 3) {\r\n\r\n        }\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerR630Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.portNodeList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerR630Node, NetworkNode);\r\n    module.exports = ServerR630Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerR630Node.js\n ** module id = 96\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var CardModel = require(\"../../model/topo/CardModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerR730Node(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerR730Node\" };    \r\n        this.model = model;\r\n        this.portNodeList = [];\r\n        this.cardNodeList = [];\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerR730Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n        var _height = 20;\r\n        var me = this;\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var status = model.get(\"status\");\r\n        var imageUrl = '../../../../fish-topo-network/src/images/' + model.get(\"type\");\r\n        // if ( status !== \"\" && status !== null && status !== undefined) {\r\n        //      imageUrl += status;\r\n        // }\r\n        imageUrl += '.png';\r\n        \r\n        var cellStateNode = new graphic.Circle({\r\n             shape: {\r\n                cx: 10,\r\n                cy: 20,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: '#077826',\r\n                opacity: 1,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            } ,\r\n            z: 1000\r\n        });\r\n        if ( status !== \"\" && status !== null && status === \"offline\") {\r\n            cellStateNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(cellStateNode);\r\n\r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: model.get(\"width\"),\r\n                height:  40,\r\n            },\r\n            //z: 1000,\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n        this.add(serverNodeB);\r\n        \r\n        var portsList = model.get(\"ports\");\r\n        if ( portsList !== undefined ) {\r\n            var _kmx = 10;\r\n            for ( var i = 0; i < portsList.length; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _kmx, y: _height / 2.5}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 7;\r\n                portModel.width = 7;\r\n\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\");\r\n                _linInfo.sourcePort = i;\r\n                _linInfo.sourceCardNo = 0;\r\n                _linInfo.nodetype = this.model.get(\"nodetype\");\r\n                _linInfo.portType = (portsList[i].type !== undefined && portsList[i].type !== null) ? portsList[i].type : \"1\"; \r\n                _linInfo.portState = (portsList[i].status !== undefined && portsList[i].status !== null) ? portsList[i].status : \"DOWN\";   \r\n                 if (portsList[i].ip !== null && portsList[i].ip !== undefined ) {\r\n                     _linInfo.ip = portsList[i].ip;\r\n                }\r\n                if ( portsList[i].target !== null && portsList[i].target !== undefined ) {\r\n                  \r\n                     if ( portsList[i].type === \"1\" ) {\r\n                        _linInfo.targetReource = portsList[i].target.resourceName !== undefined ? portsList[i].target.resourceName : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"\";\r\n                    } else {\r\n                        _linInfo.targetReource = portsList[i].target !== undefined ? portsList[i].target : \"\";\r\n                        _linInfo.targetPort = portsList[i].target.port !== undefined ? portsList[i].target.port : \"-1\";\r\n\r\n                    }\r\n                }  \r\n\r\n                portModel.lineInfo = _linInfo;         \r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _kmx = _kmx + 5;      \r\n            }\r\n        }       \r\n        \r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerR730Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.portNodeList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    ServerR730Node.prototype.addNodeByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, api);\r\n            var pointList = node.pointList;\r\n            if ( pointList !== undefined && pointList.length > 0 ) {\r\n                for( var i = 0; i < pointList.length; i++ ) {\r\n                    if ( pointList[i].lineInfo.sourceCardNo === \"1\" ) {\r\n                        pointList[i].lineInfo.moddleX = 35;\r\n                    } else if( pointList[i].lineInfo.sourceCardNo === \"2\" ) {\r\n                        pointList[i].lineInfo.moddleX = 25;\r\n                    } else if( pointList[i].lineInfo.sourceCardNo === \"3\" ) {\r\n\r\n                    } else if( pointList[i].lineInfo.sourceCardNo === \"4\" ) {\r\n                        pointList[i].lineInfo.moddleX = 25;\r\n                    }else if( pointList[i].lineInfo.sourceCardNo === \"5\" ) {\r\n\r\n                    }\r\n                  this.portNodeList.push(pointList[i]);   \r\n                }\r\n            }\r\n            this.add(node);\r\n            this.cardNodeList.push(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerR730Node, NetworkNode);\r\n    module.exports = ServerR730Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerR730Node.js\n ** module id = 97\n ** module chunks = 0\n **/","\r\n\r\n    var Model = require('../../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var NetworkModel = require('../NetworkModel');\r\n\r\n    var CardModel = NetworkModel.extend({\r\n        No: \"\",\r\n        resourcesName: \"\",\r\n        resourceNodeType : \"1\",\r\n        height: 5,\r\n        width: 5,\r\n        type: \"\",\r\n        direction: \"leftRight\",//updown\r\n        portData: []\r\n    });\r\n    module.exports = CardModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/topo/CardModel.js\n ** module id = 98\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerX3550Node(model,api) {\r\n        ServerTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerX3550Node\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerX3550Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/xIBMX3550b.png',\r\n                width: model.get(\"width\"),\r\n                height:  40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n        var serverNodeA = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/xIBMX3550a.png',\r\n                width: model.get(\"width\"),\r\n                height:  40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n\r\n        serverNodeB.on(\"mouseover\", function(params){\r\n            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeA.attr(\"position\", [0,0]);\r\n        });\r\n        serverNodeA.on(\"mouseout\", function(params){\r\n            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeB.attr(\"position\", [0,0]);\r\n        });\r\n\r\n        this.add(serverNodeA);\r\n        this.add(serverNodeB);\r\n        \r\n        //画默认的以太网端口\r\n        var _kmx = 95;\r\n        for (var i = 0; i < 4; i++ ) {\r\n            var portModel = {};\r\n            portModel = {\r\n                resourceId: util.getUUID(),  \r\n                bounds: {\r\n                    upperLeft: {x: _kmx, y: 15}  \r\n                },\r\n                stencil: {type: \"PointNode\"}\r\n            };\r\n            portModel.height = 8;\r\n            portModel.width = 8;\r\n            var pModel = new NetworkModel(portModel);\r\n            this.addPortByModel(pModel, api);\r\n            _kmx = _kmx + 13;\r\n        }\r\n\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerX3550Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerX3550Node, NetworkNode);\r\n    module.exports = ServerX3550Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerX3550Node.js\n ** module id = 99\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerX3650Node(model,api) {\r\n        ServerTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerX3650Node\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerX3650Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../..fish-topo-network/src/images/' + model.get(\"type\") + '.png',\r\n                width: model.get(\"width\"),\r\n                height:  80\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n        var serverNodeA = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/IBMX3650a.png',\r\n                width: model.get(\"width\"),\r\n                height:  80\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n\r\n        serverNodeB.on(\"mouseover\", function(params){\r\n            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeA.attr(\"position\", [0,0]);\r\n          //  serverNodeA.show();\r\n        });\r\n        serverNodeA.on(\"mouseout\", function(params){\r\n            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeB.attr(\"position\", [0,0]);\r\n        });\r\n\r\n        this.add(serverNodeA);\r\n        this.add(serverNodeB);\r\n        \r\n        //画默认的以太网端口\r\n        var _kmx = 165;\r\n        for (var i = 0; i < 4; i++ ) {\r\n            var portModel = {};\r\n            portModel = {\r\n                resourceId: util.getUUID(),  \r\n                bounds: {\r\n                    upperLeft: {x: _kmx, y: 55}  \r\n                },\r\n                stencil: {type: \"PointNode\"}\r\n            };\r\n            portModel.height = 10;\r\n            portModel.width = 10;\r\n            var pModel = new NetworkModel(portModel);\r\n            this.addPortByModel(pModel, api);\r\n            _kmx = _kmx + 13;\r\n        }\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerX3650Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerX3650Node, NetworkNode);\r\n    module.exports = ServerX3650Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerX3650Node.js\n ** module id = 100\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerRD350Node(model,api) {\r\n        ServerTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerRD350Node\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerRD350Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/lenovoRd350b.png',\r\n                width: model.get(\"width\"),\r\n                height:  40\r\n            },\r\n            draggable: false\r\n        }); \r\n\r\n        var serverNodeA = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/lenovoRd350a.png',\r\n                width: model.get(\"width\"),\r\n                height:  40\r\n            },\r\n            z: 1000,\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n\r\n        serverNodeB.on(\"mouseover\", function(params){\r\n            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeA.attr(\"position\", [0,0]);\r\n        });\r\n        serverNodeA.on(\"mouseout\", function(params){\r\n            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeB.attr(\"position\", [0,0]);\r\n        });\r\n\r\n        this.add(serverNodeA);\r\n        this.add(serverNodeB);\r\n        \r\n        //画默认的以太网端口\r\n        var _kmx = 95;\r\n        for (var i = 0; i < 4; i++ ) {\r\n            var portModel = {};\r\n            portModel = {\r\n                resourceId: util.getUUID(),  \r\n                bounds: {\r\n                    upperLeft: {x: _kmx, y: 15}  \r\n                },\r\n                stencil: {type: \"PointNode\"}\r\n            };\r\n            portModel.height = 8;\r\n            portModel.width = 8;\r\n            var pModel = new NetworkModel(portModel);\r\n            this.addPortByModel(pModel, api);\r\n            _kmx = _kmx + 13;\r\n        }\r\n\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerRD350Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerRD350Node, NetworkNode);\r\n    module.exports = ServerRD350Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerRD350Node.js\n ** module id = 101\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ServerTopoNode = require(\"./ServerTopoNode\");\r\n    \r\n    function ServerRD650Node(model,api) {\r\n        ServerTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ServerRD650Node\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    ServerRD650Node.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var serverNodeB = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/lenovoRd650b.png',\r\n                width: model.get(\"width\"),\r\n                height:  80\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n\r\n        var serverNodeA = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/lenovoRd650a.png',\r\n                width: model.get(\"width\"),\r\n                height:  80\r\n            },\r\n            z: 1000,\r\n            draggable: false\r\n        }); \r\n\r\n\r\n        serverNodeB.on(\"mouseover\", function(params){\r\n            serverNodeB.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeA.attr(\"position\", [0,0]);\r\n          //  serverNodeA.show();\r\n        });\r\n        serverNodeA.on(\"mouseout\", function(params){\r\n            serverNodeA.attr(\"position\" , [-1000, -1000]);\r\n            serverNodeB.attr(\"position\", [0,0]);\r\n        });\r\n\r\n        this.add(serverNodeA);\r\n        this.add(serverNodeB);\r\n        \r\n        //画默认的以太网端口\r\n        var portModel = {};\r\n        portModel = {\r\n            resourceId: util.getUUID(),  \r\n            bounds: {\r\n                upperLeft: {x: 88, y: 55}  \r\n            },\r\n            stencil: {type: \"PointNode\"}\r\n        };\r\n        portModel.height = 10;\r\n        portModel.width = 10;\r\n        var pModel = new NetworkModel(portModel);\r\n        this.addPortByModel(pModel, api);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ServerRD650Node.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(ServerRD650Node, NetworkNode);\r\n    module.exports = ServerRD650Node;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/ServerRD650Node.js\n ** module id = 102\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    \r\n    function SwitchTopoNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"SwitchTopoNode\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    SwitchTopoNode.prototype.render = function(model, api) {\r\n        \r\n    };\r\n\r\n    zrUtil.inherits(SwitchTopoNode, NetworkNode);\r\n    module.exports = SwitchTopoNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/SwitchTopoNode.js\n ** module id = 103\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var SwitchTopoNode = require(\"./SwitchTopoNode\");\r\n    \r\n    function SwitchHalfIBNode(model,api) {\r\n        SwitchTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"SwitchHalfIBNode\" };    \r\n        this.model = model;\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.portNodeList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    SwitchHalfIBNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n        var _portNum = model.get(\"portNum\");\r\n        var imageUrl = \"../../../../fish-topo-network/src/images/IBSwitchHalf\" + _portNum + \".png\";\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 130,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var switchNode = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: model.get(\"width\"),\r\n                height:  40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n        this.add(switchNode);\r\n\r\n        if ( _portNum === \"12\") {\r\n            var _y = 12;\r\n            var _x = 42;\r\n            for (var i = 1; i < 7; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 6;\r\n                portModel.width = 11;\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n                _linInfo.sourcePort = i.toString();\r\n                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _x = _x + portModel.width + 3;\r\n            }\r\n            \r\n            _y = 22;\r\n            _x = 42;\r\n            for (var i = 7; i < 13; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 6;\r\n                portModel.width = 11;\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n                _linInfo.sourcePort = i.toString();\r\n                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _x = _x + portModel.width + 3;     \r\n            }\r\n        } else if ( _portNum === \"8\" ) {\r\n            var _y = 12;\r\n            var _x = 70;\r\n            for (var i = 1; i < 5; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 6;\r\n                portModel.width = 11;\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n                _linInfo.sourcePort = i.toString();\r\n                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _x = _x + portModel.width + 3;\r\n            }\r\n            \r\n            _y = 22;\r\n            _x = 70;\r\n            for (var i = 5; i < 9; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 6;\r\n                portModel.width = 11;\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n                _linInfo.sourcePort = i.toString();\r\n                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2);\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                _x = _x + portModel.width + 3;     \r\n            }\r\n\r\n        }\r\n        \r\n\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    SwitchHalfIBNode.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.add(node);\r\n            this.portNodeList.push(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(SwitchHalfIBNode, NetworkNode);\r\n    module.exports = SwitchHalfIBNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/SwitchHalfIBNode.js\n ** module id = 104\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var SwitchTopoNode = require(\"./SwitchTopoNode\");\r\n    \r\n    function SwitchFullIBNode(model,api) {\r\n        SwitchTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"SwitchFullIBNode\" };    \r\n        this.model = model;\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.portNodeList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    SwitchFullIBNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n        var _portNum = model.get(\"portNum\");\r\n        var imageUrl = \"../../../../fish-topo-network/src/images/IBSwitchFull\" + _portNum + \".png\";\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: 20,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var switchNode = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: imageUrl,\r\n                width: model.get(\"width\"),\r\n                height: 40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n        this.add(switchNode);\r\n\r\n        var _y = 14;\r\n        var _x = 18;\r\n        for (var i = 1; i < 19; i++ ) {\r\n            var portModel = {};\r\n            portModel = {\r\n                resourceId: util.getUUID(),  \r\n                bounds: {\r\n                    upperLeft: {x: _x, y: _y}  \r\n                },\r\n                stencil: {type: \"PointNode\"}\r\n            };\r\n            portModel.height = 6;\r\n            portModel.width = 11;\r\n            var _linInfo = {};\r\n            _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n            _linInfo.sourcePort = i.toString();\r\n            _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2 );\r\n            portModel.lineInfo = _linInfo;\r\n            var pModel = new NetworkModel(portModel);\r\n            this.addPortByModel(pModel, api);\r\n            if (i % 3 === 0 ) {\r\n                _x = _x + portModel.width + 5;\r\n            } else {\r\n                _x = _x + portModel.width + 2;\r\n            }       \r\n        }\r\n        \r\n        if ( _portNum > 18 ) {\r\n            _y = 24;\r\n            _x = 18;\r\n            for (var i = 19; i < 37; i++ ) {\r\n                var portModel = {};\r\n                portModel = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: _x, y: _y}  \r\n                    },\r\n                    stencil: {type: \"PointNode\"}\r\n                };\r\n                portModel.height = 6;\r\n                portModel.width = 11;\r\n                var _linInfo = {};\r\n                _linInfo.sourceReource = this.model.get(\"name\").substring(this.model.get(\"name\").indexOf(\"No\") + 3 , this.model.get(\"name\").length);\r\n                _linInfo.sourcePort = i.toString();\r\n                _linInfo.sourceReourceName =  this.model.get(\"name\").substring(6, this.model.get(\"name\").indexOf(\"No\") - 2 );\r\n                portModel.lineInfo = _linInfo;\r\n                var pModel = new NetworkModel(portModel);\r\n                this.addPortByModel(pModel, api);\r\n                if (i % 3 === 0 ) {\r\n                    _x = _x + portModel.width + 5;\r\n                } else {\r\n                    _x = _x + portModel.width + 2;\r\n                }       \r\n            }\r\n        }\r\n        \r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n     SwitchFullIBNode.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.portNodeList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n    zrUtil.inherits(SwitchFullIBNode, NetworkNode);\r\n    module.exports = SwitchFullIBNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/SwitchFullIBNode.js\n ** module id = 105\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var SwitchTopoNode = require(\"./SwitchTopoNode\");\r\n    \r\n    function SwitchGMNode(model,api) {\r\n        SwitchTopoNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"SwitchGMNode\" };    \r\n        this.model = model;\r\n        this.render(model,api);\r\n    };\r\n\r\n    SwitchGMNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var switchNode = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/GMSwitch.png',\r\n                width: model.get(\"width\"),\r\n                height: 40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n        this.add(switchNode);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n   \r\n\r\n    zrUtil.inherits(SwitchGMNode, NetworkNode);\r\n    module.exports = SwitchGMNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/SwitchGMNode.js\n ** module id = 106\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var SwitchTopoNode = require(\"./SwitchTopoNode\");\r\n    \r\n    function SwitchKMNode(model,api) {\r\n        SwitchTopoNode.call(this, model, api);\r\n        //this.rackkInfo = {type: -1, name: \"SwitchKMNode\" };    \r\n        this.model = model;\r\n        this.parmDate = this.model.get(\"parmDate\");\r\n        this.portNodeList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    SwitchKMNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var _showTip = model.get(\"showTip\");\r\n\r\n        var _title = new graphic.Text({\r\n            style: {\r\n                x: model.get(\"width\") / 2 - 10,\r\n                y: -20,\r\n                text: model.get(\"name\"),\r\n                width: 200,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '12px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });\r\n        this.add(_title);\r\n\r\n        var switchNode = new graphic.Image({\r\n            position: [0, 0],\r\n            scale: [1, 1],\r\n            style: {\r\n                x: 0,\r\n                y: 0,\r\n                image: '../../../../fish-topo-network/src/images/KMSwitch.png',\r\n                width: model.get(\"width\"),\r\n                height: 40\r\n            },\r\n            draggable: false,\r\n            parmDate: this.model.get(\"parmDate\")\r\n        }); \r\n        this.add(switchNode);\r\n\r\n\r\n        //�˿�\r\n        var portModel = {};\r\n        portModel = {\r\n            resourceId: util.getUUID(),  \r\n            bounds: {\r\n                upperLeft: {x:model.get(\"width\") / 2, y: 10}  \r\n            },\r\n            stencil: {type: \"PointNode\"}\r\n        };\r\n        portModel.height = 6;\r\n        portModel.width = 11;\r\n        var _linInfo = {};\r\n        _linInfo.sourceReource = model.get(\"name\");\r\n        _linInfo.sourcePort = \"-1\";\r\n        portModel.lineInfo = _linInfo;\r\n        var pModel = new NetworkModel(portModel);\r\n        this.addPortByModel(pModel, api);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    SwitchKMNode.prototype.addPortByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this._api);\r\n            this.portNodeList.push(node);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n\r\n    zrUtil.inherits(SwitchKMNode, NetworkNode);\r\n    module.exports = SwitchKMNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/topo/SwitchKMNode.js\n ** module id = 107\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkNode = require(\"../NetworkNode.js\");\r\n    var NetWorkLineNode = require(\"../NetWorkLineNode.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var DatabaseModel = require(\"../../model/cluster/DatabaseModel.js\");\r\n\tvar AsmModel = require(\"../../model/cluster/AsmModel.js\");\r\n\tvar ISEModel = require(\"../../model/cluster/ISEModel.js\");\r\n    var NetWorkLineModel = require(\"../../model/NetWorkLineModel.js\");\r\n    var Connector = require(\"../../../../fish-topo-core/lib/shapes/Connector.js\");\r\n\r\n\r\n    function ClusterDrawNode(model, api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.info = {type: -1, name: \"ClusterDrawNode\" };    \r\n        this.model = model;\r\n        this.databaseList = [];\r\n        this.dgList = [];\r\n        this.render(model, api);\r\n    };\r\n\r\n    ClusterDrawNode.prototype.render = function(model, api) {\r\n    \tvar nodeList = model.get(\"nodeList\");\r\n        var _showTip = model.get(\"showTip\");\r\n        var dataModelData = {};\r\n    \tvar asmModelData = {};\r\n    \tvar storageModelData = {};\r\n    \tvar _dgList = [];\r\n    \tfor( var i = 0; i < nodeList.length; i++ ) {\r\n    \t\tvar nodeY = 10;\r\n            var startX = 0;\r\n    \t\tif ( nodeList[i].type === \"database\" ) {\r\n    \t\t\tvar dbData = nodeList[i].dbData;\r\n    \t\t\tif ( dbData != undefined && dbData.length > 0 ) {\r\n                    dataModelData = {\r\n                        resourceId: util.getUUID(),  \r\n                        bounds: {\r\n                            upperLeft: {x: startX, y: nodeY}  \r\n                        },\r\n                        stencil: {type: \"ClusterDatabaseNode\"}\r\n                    };\r\n                    dataModelData.dbData = dbData;\r\n                    dataModelData.showTip = _showTip;\r\n    \t\t\t}\t\r\n    \t\t} else if( nodeList[i].type === \"asm\") {\r\n    \t\t\tvar startX = 0;\r\n    \t\t\tnodeY = 250;\r\n    \t\t\tasmModelData = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: \"ClusterAsmNode\"}\r\n                };\r\n                asmModelData.name = nodeList[i].name;\r\n                asmModelData.asmData = nodeList[i].asmData;\r\n                asmModelData.dgData = nodeList[i].dgData;\r\n                asmModelData.status = nodeList[i].status;\r\n                asmModelData.showTip = _showTip;\r\n    \t\t} else if( nodeList[i].type === \"storage\" ) {\r\n    \t\t\tvar startX = 0;\r\n    \t\t\tnodeY = 550;\r\n    \t\t\tstorageModelData = {\r\n                    resourceId: util.getUUID(),  \r\n                    bounds: {\r\n                        upperLeft: {x: startX, y: nodeY}  \r\n                    },\r\n                    stencil: {type: \"ClusterIseNode\"}\r\n                };\r\n                storageModelData.childNodeList = nodeList[i].iseData;\r\n                storageModelData.showTip = _showTip;\r\n    \t\t}\r\n\r\n    \t}\r\n\r\n        var databaseModel = new DatabaseModel(dataModelData);\r\n        this.addNodeByModel(databaseModel, api);\r\n\r\n        \r\n        //画矩形\r\n        var mangerNode = new graphic.Rect({\r\n            shape: {\r\n                r: 20,\r\n                x: 50,\r\n                y: 300,\r\n                width: api.getWidth() - 100,\r\n                height: 300\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '1',\r\n                lineDash: [12]  \r\n            }          \r\n        });              \r\n        this.add(mangerNode);\r\n\r\n        asmModelData.database = dataModelData.dbData !== undefined ? dataModelData.dbData.length : 0;\r\n    \tvar asmModel = new AsmModel(asmModelData);\r\n        this.addNodeByModel(asmModel, api);\r\n\r\n        var iseModel = new ISEModel(storageModelData);\r\n        this.addNodeByModel(iseModel, api);\r\n\r\n\r\n\r\n        //连线\r\n        for (var l = 0; l < this.databaseList.length; l++ ) {\r\n            this.drawLine(this.databaseList[l], this.dgList[l], api);\r\n        }\r\n\r\n    };\r\n\r\n    ClusterDrawNode.prototype.addNodeByModel = function( p_model, api) {\r\n        \r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, api);\r\n            this.add(node);\r\n            var MOUSE_EVENT_NAMES = ['click'];\r\n            if ( p_model.get(\"showTip\") ) {\r\n                MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];\r\n            }\r\n            zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n                 node.on(eveName, function (e) {\r\n                     var params = {};\r\n                    if ( eveName === \"mouseover\") {\r\n                        params.event = e;\r\n                        params.x = node.parent.position[0] +  (e.target.shape ? e.target.shape.x : 0) + (e.target.shape ? e.target.shape.width : 0);\r\n                        params.y = node.parent.position[1] + (e.target.shape ? e.target.shape.y : 0) + (e.target.shape ? e.target.shape.height : 0) / 2;\r\n                        params.width = 150;\r\n                        params.height = 170;\r\n                        params.eWidth =  5 ;\r\n                        params.parmDate = e.target.parmDate;\r\n                        if ( api.getWidth() - params.x < params.width ) {\r\n                            params.layout = \"left\";\r\n                        } else {\r\n                            params.layout = \"right\";\r\n                        }\r\n                        //api.showTipWindow(params);\r\n                    } else if (eveName === \"mouseout\") {\r\n                        //api.hideTipWindow(e.event.target);\r\n                    } else if (eveName === \"click\") {\r\n                        params.event = e;\r\n                        params.parmDate = e.target.parmDate;\r\n                    } \r\n                    api.trigger(eveName, params);   \r\n                }, this);\r\n            });\r\n\r\n            if ( api.getWidth()  < node.clientWidth ) {\r\n                api.resize(node.clientWidth, api.getHeight());\r\n            }\r\n            if( node.portNodeList !== undefined && node.portNodeList.length > 0 ) {\r\n                if ( node.info.name === \"ClusterDatabaseNode\" ) {\r\n                    for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n                        this.databaseList.push(node.portNodeList[i]);\r\n                    }\r\n                } else if( node.info.name === \"ClusterAsmNode\" ) {\r\n                    for (var i = 0; i < node.portNodeList.length; i++ ) {\r\n                        this.dgList.push(node.portNodeList[i]);\r\n                    }\r\n                } \r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    ClusterDrawNode.prototype.drawLine = function( p_startNode, p_endNode, api ) {\r\n        var fleftx = p_startNode.parent.position[0] + p_startNode.shape.x;\r\n        var flefty = p_startNode.parent.position[1] + p_startNode.shape.y;\r\n        var fwidth =  p_startNode.shape.width;\r\n        var fheight = p_startNode.shape.height;\r\n\r\n        var torightx = p_endNode.parent.position[0] + p_endNode.shape.x;\r\n        var torighty = p_endNode.parent.position[1] + p_endNode.shape.y;\r\n        var towidth =  p_endNode.shape.width;\r\n        var toheight = p_endNode.shape.height;\r\n        var moddleY = 200;    \r\n        var moddleX = api.getWidth() / 2; \r\n        \r\n        var _toModdleY = moddleY;\r\n        if ( torightx + 25 > moddleX ) {\r\n            _toModdleY = moddleY - 15;\r\n        } else {\r\n            _toModdleY = moddleY + 15;\r\n        }\r\n\r\n        var defaultOptionDatabase = {\r\n            fromBounds : {x: fleftx - 15, y: flefty, width: fwidth, height: fheight},\r\n            toBounds: {x: torightx - 15, y: torighty, width: towidth, height: toheight},\r\n            moddleY: _toModdleY,\r\n            style : {\r\n                lineWidth : 3,\r\n                stroke: '#050505'//,\r\n                //fill: '#9699DD'\r\n            },\r\n            hoverStyle : {\r\n                lineWidth : 3,\r\n                stroke: '#0B8329'//,\r\n                //fill:'#2FDE92'\r\n            },\r\n            isEdit: false,\r\n            isVector: true,\r\n            lineType: Connector.TYPE_CURVE\r\n        }\r\n        var databaseModel = new NetWorkLineModel(defaultOptionDatabase);\r\n        var databaseNode = new NetWorkLineNode(databaseModel);\r\n        this.add(databaseNode);\r\n\r\n        var _backModdleY = moddleY;\r\n        if ( torightx + 25 > moddleX ) {\r\n            _backModdleY = moddleY + 15;\r\n        } else {\r\n            _backModdleY = moddleY - 15;\r\n        }\r\n         var defaultOptionDg = {\r\n            fromBounds : {x: torightx + 15, y: torighty, width: towidth, height: toheight},\r\n            toBounds: {x: fleftx + 15, y: flefty, width: fwidth, height: fheight},\r\n            moddleY: _backModdleY,\r\n            style : {\r\n                lineWidth : 3,\r\n                stroke: '#050505'//,\r\n                //fill: '#9699DD'\r\n            },\r\n            hoverStyle : {\r\n                lineWidth : 3,\r\n                stroke: '#0B8329'//,\r\n                //fill:'#2FDE92'\r\n            },\r\n            isEdit: false,\r\n            isVector: true,\r\n            lineType: Connector.TYPE_CURVE\r\n        }\r\n        var dgModel = new NetWorkLineModel(defaultOptionDg);\r\n        var dgNode = new NetWorkLineNode(dgModel);\r\n        this.add(dgNode);\r\n\r\n\r\n    };\r\n\r\n    ClusterDrawNode.prototype.bind = function( p_node, p_eventList, api) {\r\n        if ( p_eventList != undefined && p_eventList.length > 0 ) {\r\n            //绑定悬浮事件\r\n            zrUtil.each(p_eventList, function (eveName) {\r\n                p_node.on(eveName, function (e) {\r\n                    if ( eveName === \"mouseover\") {\r\n                        var params = {};\r\n                        params.event = e;\r\n                        params.x = p_node.position[0] + e.target.shape.width;\r\n                        params.y = p_node.position[1] + e.target.shape.height / 2;\r\n                        params.width = 150;\r\n                        params.height = 170;\r\n                        params.eWidth =  5 ;\r\n                        params.parmDate = e.target.parmDate;\r\n                        api.showTipWindow(params);\r\n                    } else {\r\n                        api.hideTipWindow(e.event.target);\r\n                    }    \r\n                }, this);\r\n            }, this);\r\n        }\r\n    }\r\n\r\n    zrUtil.inherits(ClusterDrawNode, NetworkNode);\r\n    module.exports = ClusterDrawNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterDrawNode.js\n ** module id = 108\n ** module chunks = 0\n **/","/**\r\n * Server DatabaseModel\r\n *\r\n */\r\n\r\n\r\n    var Model = require('../../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var NetworkModel = require('../NetworkModel');\r\n\r\n    var DatabaseModel = NetworkModel.extend({\r\n        name: \"\",\r\n    \theight: 200,\r\n        width: 190,\r\n        status : \"online\",\r\n        instanse: {},\r\n        dg: []\r\n    });\r\n    module.exports = DatabaseModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/cluster/DatabaseModel.js\n ** module id = 109\n ** module chunks = 0\n **/","/**\r\n * Server AsmModel\r\n *\r\n */\r\n\r\n\r\n    var Model = require('../../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var NetworkModel = require('../NetworkModel');\r\n\r\n    var AsmModel = NetworkModel.extend({\r\n        name: \"\",\r\n    \theight: 200,\r\n        width: 190,\r\n        status : \"online\",\r\n        asmData : [],\r\n        dg: []\r\n    });\r\n    module.exports = AsmModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/cluster/AsmModel.js\n ** module id = 110\n ** module chunks = 0\n **/","/**\r\n * ISE Model\r\n *\r\n */\r\n\r\n\r\n    var Model = require('../../../../fish-topo-core/lib/Model');\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var NetworkModel = require('../NetworkModel');\r\n\r\n    var ISEModel = NetworkModel.extend({\r\n        name: \"\",\r\n    \theight: 200,\r\n        width: 250,\r\n        status : \"online\",\r\n        childNodeList: []\r\n    });\r\n    module.exports = ISEModel;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/model/cluster/ISEModel.js\n ** module id = 111\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var ClusterDrawNode = require(\"./ClusterDrawNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function ClusterDatabaseNode(model, api) {\r\n        ClusterDrawNode.call(this, model, api);\r\n        this.info = {type: -1, name: \"ClusterDatabaseNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.portNodeList = [];\r\n        this.render(model,api);\r\n    };\r\n\r\n    ClusterDatabaseNode.prototype.render = function(model, api) {\r\n        this.model = model;\r\n        var dbData = model.get(\"dbData\");\r\n        var _width = 280;\r\n        var _height = 80;\r\n        var _interval = 50;\r\n        var _x = (api.getWidth() - dbData.length * (_width + _interval)) / 2 - 140;\r\n        var _y = 0;\r\n        for ( var d = 0 ; d < dbData.length; d++ ) {\r\n            var parmDate = dbData[d];\r\n            parmDate.type = \"database\";\r\n            //实例宽度\r\n            var _instanseWidth = 150;\r\n            _width = (_instanseWidth + 10) * (dbData[d].instanse.length + 1) + 10;\r\n\r\n             //创建数据库对象\r\n            var portNode = new graphic.Rect({\r\n                shape: {\r\n                    r: 10,\r\n                    x: _x,\r\n                    y: _y,\r\n                    width: _width,\r\n                    height: _height\r\n                },\r\n                style: {\r\n                    //fill: '#E2E3D9',\r\n                    //stroke: '#B3B3B3',\r\n                    fill: '#FFFFFF',\r\n                    stroke: '#88888B',\r\n                    opacity: 1,\r\n                    lineWidth: '2'//,\r\n                },\r\n                parmDate: parmDate       \r\n            });  \r\n            portNode.lineInfo = this.lineInfo;            \r\n            this.add(portNode);\r\n\r\n            // var MOUSE_EVENT_NAMES = ['click', 'mouseover', 'mouseout'];   \r\n            // zrUtil.each(MOUSE_EVENT_NAMES, function (eveName) {\r\n            //      portNode.on(eveName, function (e) {\r\n            //         if ( eveName === \"mouseover\") {\r\n            //             var params = {};\r\n            //             params.event = e;\r\n            //             params.x = portNode.parent.position[0] + e.target.shape.x + e.target.shape.width;\r\n            //             params.y = portNode.parent.position[1] + e.target.shape.y + e.target.shape.height / 2;\r\n            //             params.width = 150;\r\n            //             params.height = 170;\r\n            //             params.eWidth =  5 ;\r\n            //             params.parmDate = e.target.parmDate;\r\n            //             if ( api.getWidth() - params.x < params.width ) {\r\n            //                 params.layout = \"left\";\r\n            //             } else {\r\n            //                 params.layout = \"right\";\r\n            //             }\r\n            //             //api.showTipWindow(params);\r\n            //         } else {\r\n            //             //api.hideTipWindow(e.event.target);\r\n            //         }    \r\n            //     }, this);\r\n            // });\r\n           \r\n\r\n            this.portNodeList.push(portNode);\r\n\r\n            var _instanse = dbData[d].instanse;\r\n            //创建数据库实例对象\r\n            if( _instanse != undefined && _instanse.length > 0 ) {\r\n                 var _title = new graphic.Text({\r\n                    style: {\r\n                        x: _x + 70,\r\n                        y: 15,\r\n                        text: \"数据库实例: \",\r\n                        width: 70,\r\n                        height: 20,\r\n                        fill: '#8F8B8A',\r\n                        textFont: '14px Microsoft Yahei',\r\n                        textBaseline: 'top'\r\n                    },\r\n                    draggable: true\r\n                });\r\n                this.add(_title);\r\n\r\n                var _instanseX = _x + _instanseWidth + 10;\r\n                _instanseWidth = 150;\r\n                for (var i = 0; i < _instanse.length; i++ ) {\r\n\r\n                    var _instanseNode = new graphic.Rect({\r\n                        shape: {\r\n                            x: _instanseX,\r\n                            y: 10,\r\n                            width: _instanseWidth,\r\n                            height: 30\r\n                        },\r\n                        style: {\r\n                            fill: '#FFFFFF',\r\n                            stroke: '#88888B',\r\n                            opacity: 1,\r\n                            lineWidth: '2'//,\r\n                        }          \r\n                    }); \r\n                    this.add(_instanseNode);\r\n\r\n                     //状态 \r\n                    var _instansestatusNode = new graphic.Circle({\r\n                         shape: {\r\n                            cx: _instanseX + 15,\r\n                            cy: 25,\r\n                            r: 5\r\n                        },\r\n                        style: {\r\n                            fill: '#077826'/*,\r\n                            stroke: '#B3B3B3',\r\n                            lineWidth: '2'//,*/\r\n                        } \r\n                    });\r\n                    if ( _instanse[i].status === \"offline\") {\r\n                        _instansestatusNode.style.fill = \"#999999\";\r\n                    }\r\n                    this.add(_instansestatusNode);\r\n\r\n                    //文字\r\n                    var _instanseTitle = new graphic.Text({\r\n                        style: {\r\n                            x: _instanseX + 25,\r\n                            y: 15,\r\n                            text: _instanse[i].name,\r\n                            width: 200,\r\n                            height: 20,\r\n                            fill: '#8F8B8A',\r\n                            textFont: '14px Microsoft Yahei',\r\n                            textBaseline: 'top'\r\n                        },\r\n                        draggable: true\r\n                    });       \r\n                    this.add(_instanseTitle);\r\n                    _instanseX = _instanseWidth + _instanseX + 10;\r\n                }\r\n            }\r\n\r\n\r\n            // //物理状态 \r\n            // var _phyStatus = new graphic.Rect({\r\n            //     shape: {\r\n            //         x: _instanseX,\r\n            //         y: 32,\r\n            //         width: 280,\r\n            //         height: 50\r\n            //     },\r\n            //     style: {\r\n            //         fill: '#CCCCCC',\r\n            //         stroke: '#B3B3B3',\r\n            //         lineWidth: '2'//,\r\n            //     }          \r\n            // }); \r\n            // if ( model.get(\"status\") === \"offline\") {\r\n            //     _phyStatus.style.fill = \"#CFB624\";\r\n            // }\r\n            // this.add(_phyStatus);\r\n\r\n            //状态 \r\n            var _status = new graphic.Circle({\r\n                 shape: {\r\n                    cx: _x + _width / 2 - 30,\r\n                    cy: 60,\r\n                    r: 5\r\n                },\r\n                style: {\r\n                    fill: '#077826'/*,\r\n                    stroke: '#B3B3B3',\r\n                    lineWidth: '2'//,*/\r\n                } \r\n            });\r\n            if ( model.get(\"status\") === \"offline\") {\r\n                _status.style.fill = \"#999999\";\r\n            }\r\n            this.add(_status);\r\n\r\n            var _title = new graphic.Text({\r\n                style: {\r\n                    x: _x + _width / 2 - 20,\r\n                    y: 50,\r\n                    text: dbData[d].name,\r\n                    width: 200,\r\n                    height: 20,\r\n                    fill: '#020202',\r\n                    textFont: '18px Microsoft Yahei',\r\n                    textBaseline: 'top'\r\n                },\r\n                draggable: true\r\n            });\r\n            this.add(_title);\r\n            _x = _x + _width + _interval;\r\n        }\r\n        this.clientWidth = _x + 50;\r\n    \r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n   \r\n    zrUtil.inherits(ClusterDatabaseNode, NetworkNode);\r\n\r\n    module.exports = ClusterDatabaseNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterDatabaseNode.js\n ** module id = 112\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var ClusterDrawNode = require(\"./ClusterDrawNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function ClusterAsmNode(model,api) {\r\n        ClusterDrawNode.call(this, model, api);\r\n        this.info = {type: -1, name: \"ClusterAsmNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        return this.render(model,api);\r\n    };\r\n\r\n    ClusterAsmNode.prototype.render = function(model, api) {\r\n        var dgList = model.get(\"dgData\");\r\n        var _dgW = 150;\r\n        var _dgH = 30;\r\n        var fullDgHeight = this.getNodeHeight( dgList.length + 1, _dgH, 4 );\r\n        var fullDgWidth = (_dgW + 5) * 4 + 5;\r\n\r\n        var _startX = (api.getWidth() - fullDgWidth) / 2;\r\n        var _startY = 0;\r\n\r\n        //影藏连线点\r\n        var databaseList = model.get(\"database\");\r\n        if ( databaseList > 0 ) {\r\n            var _lSpace = ( fullDgWidth - (databaseList * 30) ) / (databaseList + 1) \r\n            var _lX = _startX + _lSpace;\r\n            var _lY = 0;\r\n            for ( var l = 0; l < databaseList; l++ ) {\r\n                var dgLineNode = new graphic.Rect({\r\n                    shape: {\r\n                        r: 10,\r\n                        x: _lX,\r\n                        y: 0,\r\n                        width: 5,\r\n                        height: 5\r\n                    },\r\n                    style: {\r\n                        fill: 'red',\r\n                        stroke: 'red',\r\n                        opacity: 0.001,\r\n                        lineWidth: '2'//,\r\n                    }          \r\n                });\r\n                this.add(dgLineNode);\r\n                this.portNodeList.push(dgLineNode); \r\n                _lX += _lSpace;\r\n            }\r\n        }\r\n              \r\n        var fullDgNode = new graphic.Rect({\r\n            shape: {\r\n                r: 10,\r\n                x: _startX,\r\n                y: _startY,\r\n                width: fullDgWidth,\r\n                height: fullDgHeight\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#88888B',\r\n                opacity: 1,\r\n                lineWidth: '2'//,\r\n            }          \r\n        }); \r\n        this.add(fullDgNode);\r\n\r\n        //添加DG 单元\r\n        var _dgCellX = _startX + 5;\r\n        var _dgCellY = _startY + 5;\r\n        for ( var i = -1 ; i < dgList.length; i++ ) { \r\n            if ( i === -1 ) {\r\n                var _title = new graphic.Text({\r\n                    style: {\r\n                        x: _dgCellX + 70,\r\n                        y: _dgCellY + 7,\r\n                        text: \"DG List: \",\r\n                        width: _dgW,\r\n                        height: _dgH,\r\n                        fill: '#8F8B8A',\r\n                        textFont: '14px Microsoft Yahei',\r\n                        textBaseline: 'top'\r\n                    },\r\n                    draggable: true\r\n                });\r\n                this.add(_title);\r\n\r\n            } else {\r\n                 var cellModelData = {\r\n                    resourceId: util.getUUID(), \r\n                    bounds: {\r\n                            upperLeft: {x: 0, y: 0}  \r\n                        }, \r\n                    stencil: {type: \"ClusterAsmCellNode\"}\r\n                };\r\n         \r\n                cellModelData.bounds.upperLeft.x = _dgCellX;\r\n                cellModelData.bounds.upperLeft.y = _dgCellY;\r\n\r\n                cellModelData.height = _dgH;\r\n                cellModelData.width = _dgW;\r\n                cellModelData.title = dgList[i].name;\r\n                cellModelData.status = dgList[i].status;\r\n                var cellModel = new NetworkModel(cellModelData);\r\n                this.addNodeByModel(cellModel, api); \r\n\r\n            }\r\n           \r\n            if ( (i + 2) % 4 !== 0 ) {\r\n                _dgCellX = _dgCellX + _dgW + 5;\r\n                _dgCellY = _dgCellY;\r\n            } else {\r\n                _dgCellX = _startX + 5;\r\n                _dgCellY = _dgCellY + _dgH + 5;\r\n            }\r\n\r\n        }\r\n\r\n        var parmDate = {};\r\n        parmDate.type = \"asm\";\r\n        var asmNode = new graphic.Rect({\r\n            shape: {\r\n                r: 10,\r\n                x: _startX,\r\n                y: _startY + fullDgHeight,\r\n                width: fullDgWidth,\r\n                height: 100\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#88888B',\r\n                opacity: 1,\r\n                lineWidth: '2'//,\r\n            },\r\n            parmDate: parmDate             \r\n        });              \r\n        this.add(asmNode);\r\n\r\n        //遍历ASM实例对象\r\n        var asmData = model.get(\"asmData\");\r\n        var fullAsmHeight = this.getNodeHeight(asmData.length, _dgH, 4);\r\n         //添加DG 单元\r\n        var _asmCellX = _startX + 5;\r\n        var _asmCellY = _startY + fullDgHeight + 5;\r\n\r\n        for ( var j = -1; j < asmData.length; j++ ) { \r\n            if ( j === -1) {\r\n                var _title = new graphic.Text({\r\n                    style: {\r\n                        x: _asmCellX + 70,\r\n                        y: _asmCellY + 7,\r\n                        text: \"ASM实例: \",\r\n                        width: _dgW,\r\n                        height: _dgH,\r\n                        fill: '#8F8B8A',\r\n                        textFont: '14px Microsoft Yahei',\r\n                        textBaseline: 'top'\r\n                    },\r\n                    draggable: true\r\n                });\r\n                this.add(_title);\r\n            } else {\r\n                var cellModelData = {\r\n                    resourceId: util.getUUID(), \r\n                    bounds: {\r\n                            upperLeft: {x: 0, y: 0}  \r\n                        }, \r\n                    stencil: {type: \"ClusterAsmCellNode\"}\r\n                };\r\n         \r\n                cellModelData.bounds.upperLeft.x = _asmCellX;\r\n                cellModelData.bounds.upperLeft.y = _asmCellY;\r\n\r\n                cellModelData.height = _dgH;\r\n                cellModelData.width = _dgW;\r\n                cellModelData.title = asmData[j].name;\r\n                cellModelData.status = asmData[j].status;\r\n                var cellModel = new NetworkModel(cellModelData);\r\n                this.addNodeByModel(cellModel, api); \r\n\r\n            }\r\n            \r\n            if ( (j + 2) % 4 !== 0 ) {\r\n                _asmCellX = _asmCellX + _dgW + 5;\r\n                _asmCellY = _asmCellY;\r\n            } else {\r\n                _asmCellX = _startX + 5;\r\n                _asmCellY = _asmCellY + _dgH + 5;\r\n            }\r\n\r\n        }\r\n        \r\n        var _fullAsmX = _startX + 200;\r\n        var _fullAsmY = _startY + fullDgHeight + fullAsmHeight + 10;\r\n        \r\n        //状态 \r\n        var _asmStatusNode = new graphic.Circle({\r\n             shape: {\r\n                cx: _fullAsmX,\r\n                cy: _fullAsmY + 10,\r\n                r: 7\r\n            },\r\n            style: {\r\n                fill: '#077826'/*,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            } \r\n        });\r\n        if ( model.get(\"status\") === \"offline\") {\r\n            _asmStatusNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(_asmStatusNode);\r\n\r\n        var _asmTitle = new graphic.Text({\r\n            style: {\r\n                x: _fullAsmX + 20,\r\n                y: _fullAsmY,\r\n                text: \"ASM\",\r\n                width: 190,\r\n                height: 20,\r\n                fill: '#8F8B8A',\r\n                textFont: '18px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });       \r\n        this.add(_asmTitle);\r\n        \r\n        \r\n        this.position = [model.get(\"bounds.upperLeft.x\") , model.get(\"bounds.upperLeft.y\")];\r\n        return _startY + fullDgHeight + 100;\r\n    };\r\n\r\n    ClusterAsmNode.prototype.addNodeByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this.api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n\r\n    ClusterAsmNode.prototype.getNodeHeight  = function( p_count, p_height, p_num) {\r\n        var returnValue = 0;\r\n        if(  p_count % p_num !== 0 ) {\r\n            returnValue =  ( (parseInt(p_count) - parseInt(p_count) %  p_num) / p_num  + 1) * (p_height + 5) + 5;\r\n        } else {\r\n            returnValue =  ( parseInt(p_count) / p_num) * (p_height + 5)  + 5;\r\n        }\r\n        return returnValue;\r\n    };\r\n\r\n    zrUtil.inherits(ClusterAsmNode, NetworkNode);\r\n    module.exports = ClusterAsmNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterAsmNode.js\n ** module id = 113\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function ClusterAsmCellNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ClusterAsmCellNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.render(model,api);\r\n    };\r\n\r\n    ClusterAsmCellNode.prototype.render = function(model, api) {\r\n        var _y = model.get(\"bounds.upperLeft.y\");\r\n        var _x = model.get(\"bounds.upperLeft.x\");\r\n        var _width = model.get(\"width\");\r\n        var _height = model.get(\"height\");\r\n        var cellNode = new graphic.Rect({\r\n            shape: {\r\n                r: 10,\r\n                x: 0,\r\n                y: 0,\r\n                width: _width,\r\n                height: _height\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#88888B',\r\n                opacity: 1,\r\n                lineWidth: '2'//,\r\n            }          \r\n        });              \r\n        this.add(cellNode);\r\n\r\n        //状态 \r\n        var cellStateNode = new graphic.Circle({\r\n             shape: {\r\n                cx: 10,\r\n                cy: 15,\r\n                r: _height / 2 - 10\r\n            },\r\n            style: {\r\n                fill: '#077826'/*,\r\n                stroke: '#B3B3B3',\r\n                lineWidth: '2'//,*/\r\n            } \r\n        });\r\n        if ( model.get(\"status\") === \"offline\") {\r\n            cellStateNode.style.fill = \"#999999\";\r\n        }\r\n        this.add(cellStateNode);\r\n\r\n        var cellTitle = new graphic.Text({\r\n            style: {\r\n                x: 20,\r\n                y: 5,\r\n                text: model.get(\"title\"),\r\n                width: 50,\r\n                height: 30,\r\n                fill: '#8F8B8A',\r\n                textFont: '14px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });       \r\n        this.add(cellTitle);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n\r\n    zrUtil.inherits(ClusterAsmCellNode, NetworkNode);\r\n    module.exports = ClusterAsmCellNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterAsmCellNode.js\n ** module id = 114\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    var ISEModel = require(\"../../model/cluster/ISEModel.js\");\r\n    function ClusterIseNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ClusterIseNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.render(model,api);\r\n    };\r\n\r\n    ClusterIseNode.prototype.render = function(model, api) {\r\n        var iseList = model.get(\"childNodeList\");\r\n        var startX = 0;\r\n        var startY = 0;\r\n        var nodeWidth = 0;\r\n        for ( var i = 0; i < iseList.length; i++ ) {\r\n            var isedata = {\r\n                resourceId: util.getUUID(),  \r\n                bounds: {\r\n                    upperLeft: {x: startX, y: startY}  \r\n                },\r\n                stencil: {type: \"ClusterIseCellNode\"}\r\n            };\r\n            isedata.width = 100;\r\n            isedata.height = 150;\r\n            isedata.status = iseList[i].status;\r\n            isedata.title = iseList[i].name;\r\n            isedata.childNodeList = iseList[i].disk;\r\n            var iseCellModel = new ISEModel(isedata);\r\n            this.addNodeByModel(iseCellModel, api);\r\n            startX = startX + 100 + 50;\r\n            nodeWidth = nodeWidth + 150;\r\n        }\r\n\r\n        var _x = (api.getWidth() - nodeWidth) / 2;\r\n        this.position = [_x , model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n    ClusterIseNode.prototype.addNodeByModel = function( p_model, api) {\r\n        var Shape = api.getNodeClass(p_model.get(\"stencil.type\"));\r\n        var node = null;\r\n        if ( Shape ) {\r\n            node = new Shape(p_model, this.api);\r\n            this.add(node);\r\n        }\r\n    };\r\n\r\n\r\n    ClusterIseNode.prototype.getDgNodeWidth  = function( p_count, p_height, p_space) {\r\n        var returnValue = 0;\r\n       \r\n        return returnValue;\r\n    };\r\n\r\n    zrUtil.inherits(ClusterIseNode, NetworkNode);\r\n    module.exports = ClusterIseNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterIseNode.js\n ** module id = 115\n ** module chunks = 0\n **/","\r\n    var util = require(\"../../../../fish-topo-core/lib/util.js\");\r\n    var NetworkNode = require(\"../NetworkNode\");\r\n    var zrUtil = require('zrender/lib/core/util');\r\n    var graphic = require(\"../../../../fish-topo-core/lib/graphic.js\");\r\n    var NetworkModel = require(\"../../model/NetworkModel.js\");\r\n    \r\n    function ClusterIseCellNode(model,api) {\r\n        NetworkNode.call(this, model, api);\r\n        this.rackkInfo = {type: -1, name: \"ClusterIseCellNode\" };    \r\n        this.model = model;\r\n        this.lineInfo = model.get('lineInfo');\r\n        this.render(model,api);\r\n    };\r\n\r\n    ClusterIseCellNode.prototype.render = function(model, api) {\r\n        var isecellNode = new graphic.Rect({\r\n            shape: {\r\n                r: 10,\r\n                x: 0,\r\n                y: 0,\r\n                width: 120,\r\n                height: 100\r\n            },\r\n            style: {\r\n                fill: '#FFFFFF',\r\n                stroke: '#88888B',\r\n                opacity: 1,\r\n                lineWidth: '2'//,\r\n            }          \r\n        });              \r\n        this.add(isecellNode);\r\n\r\n        //状态 \r\n        var isecellStatus = new graphic.Circle({\r\n             shape: {\r\n                cx: 15,\r\n                cy: 45,\r\n                r: 5\r\n            },\r\n            style: {\r\n                fill: '#077826'/*,\r\n                stroke: '#89898B',\r\n                lineWidth: '2'//,*/\r\n            } \r\n        });\r\n        if ( model.get(\"status\") === \"offline\") {\r\n            isecellStatus.style.fill = \"#999999\";\r\n        }\r\n        this.add(isecellStatus);\r\n\r\n        var isecellTitle = new graphic.Text({\r\n            style: {\r\n                x: 25,\r\n                y: 35,\r\n                text: \"ISE: \" + model.get(\"title\"),\r\n                width: 50,\r\n                height: 30,\r\n                fill: '#020202',\r\n                textFont: '14px Microsoft Yahei',\r\n                textBaseline: 'top'\r\n            },\r\n            draggable: true\r\n        });       \r\n        this.add(isecellTitle);\r\n\r\n        this.position = [model.get(\"bounds.upperLeft.x\"), model.get(\"bounds.upperLeft.y\")];\r\n    };\r\n\r\n\r\n    zrUtil.inherits(ClusterIseCellNode, NetworkNode);\r\n    module.exports = ClusterIseCellNode;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-network/lib/node/cluster/ClusterIseCellNode.js\n ** module id = 116\n ** module chunks = 0\n **/","\n    require('./graphic');\n    require('../zrender').registerPainter('vml', require('./Painter'));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/vml.js\n ** module id = 117\n ** module chunks = 0\n **/","// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\n\n\nif (!require('../core/env').canvasSupported) {\n    var vec2 = require('../core/vector');\n    var BoundingRect = require('../core/BoundingRect');\n    var CMD = require('../core/PathProxy').CMD;\n    var colorTool = require('../tool/color');\n    var textContain = require('../contain/text');\n    var RectText = require('../graphic/mixin/RectText');\n    var Displayable = require('../graphic/Displayable');\n    var ZImage = require('../graphic/Image');\n    var Text = require('../graphic/Text');\n    var Path = require('../graphic/Path');\n\n    var Gradient = require('../graphic/Gradient');\n\n    var vmlCore = require('./core');\n\n    var round = Math.round;\n    var sqrt = Math.sqrt;\n    var abs = Math.abs;\n    var cos = Math.cos;\n    var sin = Math.sin;\n    var mathMax = Math.max;\n\n    var applyTransform = vec2.applyTransform;\n\n    var comma = ',';\n    var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n\n    var Z = 21600;\n    var Z2 = Z / 2;\n\n    var ZLEVEL_BASE = 100000;\n    var Z_BASE = 1000;\n\n    var initRootElStyle = function (el) {\n        el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n        el.coordsize = Z + ','  + Z;\n        el.coordorigin = '0,0';\n    };\n\n    var encodeHtmlAttribute = function (s) {\n        return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n    };\n\n    var rgb2Str = function (r, g, b) {\n        return 'rgb(' + [r, g, b].join(',') + ')';\n    };\n\n    var append = function (parent, child) {\n        if (child && parent && child.parentNode !== parent) {\n            parent.appendChild(child);\n        }\n    };\n\n    var remove = function (parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    };\n\n    var getZIndex = function (zlevel, z, z2) {\n        // z 的取值范围为 [0, 1000]\n        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n    };\n\n    var parsePercent = function (value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    };\n\n    /***************************************************\n     * PATH\n     **************************************************/\n\n    var setColorAndOpacity = function (el, color, opacity) {\n        var colorArr = colorTool.parse(color);\n        opacity = +opacity;\n        if (isNaN(opacity)) {\n            opacity = 1;\n        }\n        if (colorArr) {\n            el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n            el.opacity = opacity * colorArr[3];\n        }\n    };\n\n    var getColorAndAlpha = function (color) {\n        var colorArr = colorTool.parse(color);\n        return [\n            rgb2Str(colorArr[0], colorArr[1], colorArr[2]),\n            colorArr[3]\n        ];\n    };\n\n    var updateFillNode = function (el, style, zrEl) {\n        // TODO pattern\n        var fill = style.fill;\n        if (fill != null) {\n            // Modified from excanvas\n            if (fill instanceof Gradient) {\n                var gradientType;\n                var angle = 0;\n                var focus = [0, 0];\n                // additional offset\n                var shift = 0;\n                // scale factor for offset\n                var expansion = 1;\n                var rect = zrEl.getBoundingRect();\n                var rectWidth = rect.width;\n                var rectHeight = rect.height;\n                if (fill.type === 'linear') {\n                    gradientType = 'gradient';\n                    var transform = zrEl.transform;\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                        applyTransform(p1, p1, transform);\n                    }\n                    var dx = p1[0] - p0[0];\n                    var dy = p1[1] - p0[1];\n                    angle = Math.atan2(dx, dy) * 180 / Math.PI;\n                    // The angle should be a non-negative number.\n                    if (angle < 0) {\n                        angle += 360;\n                    }\n\n                    // Very small angles produce an unexpected result because they are\n                    // converted to a scientific notation string.\n                    if (angle < 1e-6) {\n                        angle = 0;\n                    }\n                }\n                else {\n                    gradientType = 'gradientradial';\n                    var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n                    var transform = zrEl.transform;\n                    var scale = zrEl.scale;\n                    var width = rectWidth;\n                    var height = rectHeight;\n                    focus = [\n                        // Percent in bounding rect\n                        (p0[0] - rect.x) / width,\n                        (p0[1] - rect.y) / height\n                    ];\n                    if (transform) {\n                        applyTransform(p0, p0, transform);\n                    }\n\n                    width /= scale[0] * Z;\n                    height /= scale[1] * Z;\n                    var dimension = mathMax(width, height);\n                    shift = 2 * 0 / dimension;\n                    expansion = 2 * fill.r / dimension - shift;\n                }\n\n                // We need to sort the color stops in ascending order by offset,\n                // otherwise IE won't interpret it correctly.\n                var stops = fill.colorStops.slice();\n                stops.sort(function(cs1, cs2) {\n                    return cs1.offset - cs2.offset;\n                });\n\n                var length = stops.length;\n                // Color and alpha list of first and last stop\n                var colorAndAlphaList = [];\n                var colors = [];\n                for (var i = 0; i < length; i++) {\n                    var stop = stops[i];\n                    var colorAndAlpha = getColorAndAlpha(stop.color);\n                    colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n                    if (i === 0 || i === length - 1) {\n                        colorAndAlphaList.push(colorAndAlpha);\n                    }\n                }\n\n                if (length >= 2) {\n                    var color1 = colorAndAlphaList[0][0];\n                    var color2 = colorAndAlphaList[1][0];\n                    var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n                    var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n\n                    el.type = gradientType;\n                    el.method = 'none';\n                    el.focus = '100%';\n                    el.angle = angle;\n                    el.color = color1;\n                    el.color2 = color2;\n                    el.colors = colors.join(',');\n                    // When colors attribute is used, the meanings of opacity and o:opacity2\n                    // are reversed.\n                    el.opacity = opacity2;\n                    // FIXME g_o_:opacity ?\n                    el.opacity2 = opacity1;\n                }\n                if (gradientType === 'radial') {\n                    el.focusposition = focus.join(',');\n                }\n            }\n            else {\n                // FIXME Change from Gradient fill to color fill\n                setColorAndOpacity(el, fill, style.opacity);\n            }\n        }\n    };\n\n    var updateStrokeNode = function (el, style) {\n        // if (style.lineJoin != null) {\n        //     el.joinstyle = style.lineJoin;\n        // }\n        // if (style.miterLimit != null) {\n        //     el.miterlimit = style.miterLimit * Z;\n        // }\n        // if (style.lineCap != null) {\n        //     el.endcap = style.lineCap;\n        // }\n        if (style.lineDash != null) {\n            el.dashstyle = style.lineDash.join(' ');\n        }\n        if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n            setColorAndOpacity(el, style.stroke, style.opacity);\n        }\n    };\n\n    var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n        var isFill = type == 'fill';\n        var el = vmlEl.getElementsByTagName(type)[0];\n        // Stroke must have lineWidth\n        if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'true';\n            // FIXME Remove before updating, or set `colors` will throw error\n            if (style[type] instanceof Gradient) {\n                remove(vmlEl, el);\n            }\n            if (!el) {\n                el = vmlCore.createNode(type);\n            }\n\n            isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n            append(vmlEl, el);\n        }\n        else {\n            vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n            remove(vmlEl, el);\n        }\n    };\n\n    var points = [[], [], []];\n    var pathDataToString = function (data, m) {\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        var str = [];\n        var nPoint;\n        var cmdStr;\n        var cmd;\n        var i;\n        var xi;\n        var yi;\n        for (i = 0; i < data.length;) {\n            cmd = data[i++];\n            cmdStr = '';\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    cmdStr = ' m ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case L:\n                    cmdStr = ' l ';\n                    nPoint = 1;\n                    xi = data[i++];\n                    yi = data[i++];\n                    points[0][0] = xi;\n                    points[0][1] = yi;\n                    break;\n                case Q:\n                case C:\n                    cmdStr = ' c ';\n                    nPoint = 3;\n                    var x1 = data[i++];\n                    var y1 = data[i++];\n                    var x2 = data[i++];\n                    var y2 = data[i++];\n                    var x3;\n                    var y3;\n                    if (cmd === Q) {\n                        // Convert quadratic to cubic using degree elevation\n                        x3 = x2;\n                        y3 = y2;\n                        x2 = (x2 + 2 * x1) / 3;\n                        y2 = (y2 + 2 * y1) / 3;\n                        x1 = (xi + 2 * x1) / 3;\n                        y1 = (yi + 2 * y1) / 3;\n                    }\n                    else {\n                        x3 = data[i++];\n                        y3 = data[i++];\n                    }\n                    points[0][0] = x1;\n                    points[0][1] = y1;\n                    points[1][0] = x2;\n                    points[1][1] = y2;\n                    points[2][0] = x3;\n                    points[2][1] = y3;\n\n                    xi = x3;\n                    yi = y3;\n                    break;\n                case A:\n                    var x = 0;\n                    var y = 0;\n                    var sx = 1;\n                    var sy = 1;\n                    var angle = 0;\n                    if (m) {\n                        // Extract SRT from matrix\n                        x = m[4];\n                        y = m[5];\n                        sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n                        sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n                        angle = Math.atan2(-m[1] / sy, m[0] / sx);\n                    }\n\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++] + angle;\n                    var endAngle = data[i++] + startAngle + angle;\n                    // FIXME\n                    // var psi = data[i++];\n                    i++;\n                    var clockwise = data[i++];\n\n                    var x0 = cx + cos(startAngle) * rx;\n                    var y0 = cy + sin(startAngle) * ry;\n\n                    var x1 = cx + cos(endAngle) * rx;\n                    var y1 = cy + sin(endAngle) * ry;\n\n                    var type = clockwise ? ' wa ' : ' at ';\n                    if (Math.abs(x0 - x1) < 1e-10) {\n                        // IE won't render arches drawn counter clockwise if x0 == x1.\n                        if (Math.abs(endAngle - startAngle) > 1e-2) {\n                            // Offset x0 by 1/80 of a pixel. Use something\n                            // that can be represented in binary\n                            if (clockwise) {\n                                x0 += 270 / Z;\n                            }\n                        }\n                        else {\n                            // Avoid case draw full circle\n                            if (Math.abs(y0 - cy) < 1e-10) {\n                                if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) {\n                                    y1 -= 270 / Z;\n                                }\n                                else {\n                                    y1 += 270 / Z;\n                                }\n                            }\n                            else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) {\n                                x1 += 270 / Z;\n                            }\n                            else {\n                                x1 -= 270 / Z;\n                            }\n                        }\n                    }\n                    str.push(\n                        type,\n                        round(((cx - rx) * sx + x) * Z - Z2), comma,\n                        round(((cy - ry) * sy + y) * Z - Z2), comma,\n                        round(((cx + rx) * sx + x) * Z - Z2), comma,\n                        round(((cy + ry) * sy + y) * Z - Z2), comma,\n                        round((x0 * sx + x) * Z - Z2), comma,\n                        round((y0 * sy + y) * Z - Z2), comma,\n                        round((x1 * sx + x) * Z - Z2), comma,\n                        round((y1 * sy + y) * Z - Z2)\n                    );\n\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD.R:\n                    var p0 = points[0];\n                    var p1 = points[1];\n                    // x0, y0\n                    p0[0] = data[i++];\n                    p0[1] = data[i++];\n                    // x1, y1\n                    p1[0] = p0[0] + data[i++];\n                    p1[1] = p0[1] + data[i++];\n\n                    if (m) {\n                        applyTransform(p0, p0, m);\n                        applyTransform(p1, p1, m);\n                    }\n\n                    p0[0] = round(p0[0] * Z - Z2);\n                    p1[0] = round(p1[0] * Z - Z2);\n                    p0[1] = round(p0[1] * Z - Z2);\n                    p1[1] = round(p1[1] * Z - Z2);\n                    str.push(\n                        // x0, y0\n                        ' m ', p0[0], comma, p0[1],\n                        // x1, y0\n                        ' l ', p1[0], comma, p0[1],\n                        // x1, y1\n                        ' l ', p1[0], comma, p1[1],\n                        // x0, y1\n                        ' l ', p0[0], comma, p1[1]\n                    );\n                    break;\n                case CMD.Z:\n                    // FIXME Update xi, yi\n                    str.push(' x ');\n            }\n\n            if (nPoint > 0) {\n                str.push(cmdStr);\n                for (var k = 0; k < nPoint; k++) {\n                    var p = points[k];\n\n                    m && applyTransform(p, p, m);\n                    // 不 round 会非常慢\n                    str.push(\n                        round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2),\n                        k < nPoint - 1 ? comma : ''\n                    );\n                }\n            }\n        }\n\n        return str.join('');\n    };\n\n    // Rewrite the original path method\n    Path.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            vmlEl = vmlCore.createNode('shape');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        updateFillAndStroke(vmlEl, 'fill', style, this);\n        updateFillAndStroke(vmlEl, 'stroke', style, this);\n\n        var m = this.transform;\n        var needTransform = m != null;\n        var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n        if (strokeEl) {\n            var lineWidth = style.lineWidth;\n            // Get the line scale.\n            // Determinant of this.m_ means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            if (needTransform && !style.strokeNoScale) {\n                var det = m[0] * m[3] - m[1] * m[2];\n                lineWidth *= sqrt(abs(det));\n            }\n            strokeEl.weight = lineWidth + 'px';\n        }\n\n        var path = this.path;\n        if (this.__dirtyPath) {\n            path.beginPath();\n            this.buildPath(path, this.shape);\n            path.toStatic();\n            this.__dirtyPath = false;\n        }\n\n        vmlEl.path = pathDataToString(path.data, this.transform);\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Path.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n        this.removeRectText(vmlRoot);\n    };\n\n    Path.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n    /***************************************************\n     * IMAGE\n     **************************************************/\n    var isImage = function (img) {\n        // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n        return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG';\n        // return img instanceof Image;\n    };\n\n    // Rewrite the original path method\n    ZImage.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        var image = style.image;\n\n        // Image original width, height\n        var ow;\n        var oh;\n\n        if (isImage(image)) {\n            var src = image.src;\n            if (src === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n            else {\n                var imageRuntimeStyle = image.runtimeStyle;\n                var oldRuntimeWidth = imageRuntimeStyle.width;\n                var oldRuntimeHeight = imageRuntimeStyle.height;\n                imageRuntimeStyle.width = 'auto';\n                imageRuntimeStyle.height = 'auto';\n\n                // get the original size\n                ow = image.width;\n                oh = image.height;\n\n                // and remove overides\n                imageRuntimeStyle.width = oldRuntimeWidth;\n                imageRuntimeStyle.height = oldRuntimeHeight;\n\n                // Caching image original width, height and src\n                this._imageSrc = src;\n                this._imageWidth = ow;\n                this._imageHeight = oh;\n            }\n            image = src;\n        }\n        else {\n            if (image === this._imageSrc) {\n                ow = this._imageWidth;\n                oh = this._imageHeight;\n            }\n        }\n        if (!image) {\n            return;\n        }\n\n        var x = style.x || 0;\n        var y = style.y || 0;\n\n        var dw = style.width;\n        var dh = style.height;\n\n        var sw = style.sWidth;\n        var sh = style.sHeight;\n        var sx = style.sx || 0;\n        var sy = style.sy || 0;\n\n        var hasCrop = sw && sh;\n\n        var vmlEl = this._vmlEl;\n        if (!vmlEl) {\n            // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n            // vmlEl = vmlCore.createNode('group');\n            vmlEl = vmlCore.doc.createElement('div');\n            initRootElStyle(vmlEl);\n\n            this._vmlEl = vmlEl;\n        }\n\n        var vmlElStyle = vmlEl.style;\n        var hasRotation = false;\n        var m;\n        var scaleX = 1;\n        var scaleY = 1;\n        if (this.transform) {\n            m = this.transform;\n            scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n            scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n\n            hasRotation = m[1] || m[2];\n        }\n        if (hasRotation) {\n            // If filters are necessary (rotation exists), create them\n            // filters are bog-slow, so only create them if abbsolutely necessary\n            // The following check doesn't account for skews (which don't exist\n            // in the canvas spec (yet) anyway.\n            // From excanvas\n            var p0 = [x, y];\n            var p1 = [x + dw, y];\n            var p2 = [x, y + dh];\n            var p3 = [x + dw, y + dh];\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n            applyTransform(p2, p2, m);\n            applyTransform(p3, p3, m);\n\n            var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n            var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n\n            var transformFilter = [];\n            transformFilter.push('M11=', m[0] / scaleX, comma,\n                        'M12=', m[2] / scaleY, comma,\n                        'M21=', m[1] / scaleX, comma,\n                        'M22=', m[3] / scaleY, comma,\n                        'Dx=', round(x * scaleX + m[4]), comma,\n                        'Dy=', round(y * scaleY + m[5]));\n\n            vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';\n            // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n            vmlElStyle.filter = imageTransformPrefix + '.Matrix('\n                + transformFilter.join('') + ', SizingMethod=clip)';\n\n        }\n        else {\n            if (m) {\n                x = x * scaleX + m[4];\n                y = y * scaleY + m[5];\n            }\n            vmlElStyle.filter = '';\n            vmlElStyle.left = round(x) + 'px';\n            vmlElStyle.top = round(y) + 'px';\n        }\n\n        var imageEl = this._imageEl;\n        var cropEl = this._cropEl;\n\n        if (!imageEl) {\n            imageEl = vmlCore.doc.createElement('div');\n            this._imageEl = imageEl;\n        }\n        var imageELStyle = imageEl.style;\n        if (hasCrop) {\n            // Needs know image original width and height\n            if (! (ow && oh)) {\n                var tmpImage = new Image();\n                var self = this;\n                tmpImage.onload = function () {\n                    tmpImage.onload = null;\n                    ow = tmpImage.width;\n                    oh = tmpImage.height;\n                    // Adjust image width and height to fit the ratio destinationSize / sourceSize\n                    imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                    imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n\n                    // Caching image original width, height and src\n                    self._imageWidth = ow;\n                    self._imageHeight = oh;\n                    self._imageSrc = image;\n                };\n                tmpImage.src = image;\n            }\n            else {\n                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n            }\n\n            if (! cropEl) {\n                cropEl = vmlCore.doc.createElement('div');\n                cropEl.style.overflow = 'hidden';\n                this._cropEl = cropEl;\n            }\n            var cropElStyle = cropEl.style;\n            cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n            cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n            cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx='\n                    + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')';\n\n            if (! cropEl.parentNode) {\n                vmlEl.appendChild(cropEl);\n            }\n            if (imageEl.parentNode != cropEl) {\n                cropEl.appendChild(imageEl);\n            }\n        }\n        else {\n            imageELStyle.width = round(scaleX * dw) + 'px';\n            imageELStyle.height = round(scaleY * dh) + 'px';\n\n            vmlEl.appendChild(imageEl);\n\n            if (cropEl && cropEl.parentNode) {\n                vmlEl.removeChild(cropEl);\n                this._cropEl = null;\n            }\n        }\n\n        var filterStr = '';\n        var alpha = style.opacity;\n        if (alpha < 1) {\n            filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n        }\n        filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n\n        imageELStyle.filter = filterStr;\n\n        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Append to root\n        append(vmlRoot, vmlEl);\n\n        // Text\n        if (style.text) {\n            this.drawRectText(vmlRoot, this.getBoundingRect());\n        }\n    };\n\n    ZImage.prototype.onRemove = function (vmlRoot) {\n        remove(vmlRoot, this._vmlEl);\n\n        this._vmlEl = null;\n        this._cropEl = null;\n        this._imageEl = null;\n\n        this.removeRectText(vmlRoot);\n    };\n\n    ZImage.prototype.onAdd = function (vmlRoot) {\n        append(vmlRoot, this._vmlEl);\n        this.appendRectText(vmlRoot);\n    };\n\n\n    /***************************************************\n     * TEXT\n     **************************************************/\n\n    var DEFAULT_STYLE_NORMAL = 'normal';\n\n    var fontStyleCache = {};\n    var fontStyleCacheCount = 0;\n    var MAX_FONT_CACHE_SIZE = 100;\n    var fontEl = document.createElement('div');\n\n    var getFontStyle = function (fontString) {\n        var fontStyle = fontStyleCache[fontString];\n        if (!fontStyle) {\n            // Clear cache\n            if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n                fontStyleCacheCount = 0;\n                fontStyleCache = {};\n            }\n\n            var style = fontEl.style;\n            var fontFamily;\n            try {\n                style.font = fontString;\n                fontFamily = style.fontFamily.split(',')[0];\n            }\n            catch (e) {\n            }\n\n            fontStyle = {\n                style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n                variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n                weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n                size: parseFloat(style.fontSize || 12) | 0,\n                family: fontFamily || 'Microsoft YaHei'\n            };\n\n            fontStyleCache[fontString] = fontStyle;\n            fontStyleCacheCount++;\n        }\n        return fontStyle;\n    };\n\n    var textMeasureEl;\n    // Overwrite measure text method\n    textContain.measureText = function (text, textFont) {\n        var doc = vmlCore.doc;\n        if (!textMeasureEl) {\n            textMeasureEl = doc.createElement('div');\n            textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;'\n                + 'padding:0;margin:0;border:none;white-space:pre;';\n            vmlCore.doc.body.appendChild(textMeasureEl);\n        }\n\n        try {\n            textMeasureEl.style.font = textFont;\n        } catch (ex) {\n            // Ignore failures to set to invalid font.\n        }\n        textMeasureEl.innerHTML = '';\n        // Don't use innerHTML or innerText because they allow markup/whitespace.\n        textMeasureEl.appendChild(doc.createTextNode(text));\n        return {\n            width: textMeasureEl.offsetWidth\n        };\n    };\n\n    var tmpRect = new BoundingRect();\n\n    var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n\n        var style = this.style;\n        var text = style.text;\n        if (!text) {\n            return;\n        }\n\n        var x;\n        var y;\n        var align = style.textAlign;\n        var fontStyle = getFontStyle(style.textFont);\n        // FIXME encodeHtmlAttribute ?\n        var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' '\n            + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n\n        var baseline = style.textBaseline;\n        var verticalAlign = style.textVerticalAlign;\n\n        textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n        // Transform rect to view space\n        var m = this.transform;\n        // Ignore transform for text in other element\n        if (m && !fromTextEl) {\n            tmpRect.copy(rect);\n            tmpRect.applyTransform(m);\n            rect = tmpRect;\n        }\n\n        if (!fromTextEl) {\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n        }\n        else {\n            x = rect.x;\n            y = rect.y;\n        }\n        if (verticalAlign) {\n            switch (verticalAlign) {\n                case 'middle':\n                    y -= textRect.height / 2;\n                    break;\n                case 'bottom':\n                    y -= textRect.height;\n                    break;\n                // 'top'\n            }\n            // Ignore baseline\n            baseline = 'top';\n        }\n\n        var fontSize = fontStyle.size;\n        // 1.75 is an arbitrary number, as there is no info about the text baseline\n        switch (baseline) {\n            case 'hanging':\n            case 'top':\n                y += fontSize / 1.75;\n                break;\n            case 'middle':\n                break;\n            default:\n            // case null:\n            // case 'alphabetic':\n            // case 'ideographic':\n            // case 'bottom':\n                y -= fontSize / 2.25;\n                break;\n        }\n        switch (align) {\n            case 'left':\n                break;\n            case 'center':\n                x -= textRect.width / 2;\n                break;\n            case 'right':\n                x -= textRect.width;\n                break;\n            // case 'end':\n                // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n                // break;\n            // case 'start':\n                // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n                // break;\n            // default:\n            //     align = 'left';\n        }\n\n        var createNode = vmlCore.createNode;\n\n        var textVmlEl = this._textVmlEl;\n        var pathEl;\n        var textPathEl;\n        var skewEl;\n        if (!textVmlEl) {\n            textVmlEl = createNode('line');\n            pathEl = createNode('path');\n            textPathEl = createNode('textpath');\n            skewEl = createNode('skew');\n\n            // FIXME Why here is not cammel case\n            // Align 'center' seems wrong\n            textPathEl.style['v-text-align'] = 'left';\n\n            initRootElStyle(textVmlEl);\n\n            pathEl.textpathok = true;\n            textPathEl.on = true;\n\n            textVmlEl.from = '0 0';\n            textVmlEl.to = '1000 0.05';\n\n            append(textVmlEl, skewEl);\n            append(textVmlEl, pathEl);\n            append(textVmlEl, textPathEl);\n\n            this._textVmlEl = textVmlEl;\n        }\n        else {\n            // 这里是在前面 appendChild 保证顺序的前提下\n            skewEl = textVmlEl.firstChild;\n            pathEl = skewEl.nextSibling;\n            textPathEl = pathEl.nextSibling;\n        }\n\n        var coords = [x, y];\n        var textVmlElStyle = textVmlEl.style;\n        // Ignore transform for text in other element\n        if (m && fromTextEl) {\n            applyTransform(coords, coords, m);\n\n            skewEl.on = true;\n\n            skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma +\n            m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';\n\n            // Text position\n            skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);\n            // Left top point as origin\n            skewEl.origin = '0 0';\n\n            textVmlElStyle.left = '0px';\n            textVmlElStyle.top = '0px';\n        }\n        else {\n            skewEl.on = false;\n            textVmlElStyle.left = round(x) + 'px';\n            textVmlElStyle.top = round(y) + 'px';\n        }\n\n        textPathEl.string = encodeHtmlAttribute(text);\n        // TODO\n        try {\n            textPathEl.style.font = font;\n        }\n        // Error font format\n        catch (e) {}\n\n        updateFillAndStroke(textVmlEl, 'fill', {\n            fill: fromTextEl ? style.fill : style.textFill,\n            opacity: style.opacity\n        }, this);\n        updateFillAndStroke(textVmlEl, 'stroke', {\n            stroke: fromTextEl ? style.stroke : style.textStroke,\n            opacity: style.opacity,\n            lineDash: style.lineDash\n        }, this);\n\n        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);\n\n        // Attached to root\n        append(vmlRoot, textVmlEl);\n    };\n\n    var removeRectText = function (vmlRoot) {\n        remove(vmlRoot, this._textVmlEl);\n        this._textVmlEl = null;\n    };\n\n    var appendRectText = function (vmlRoot) {\n        append(vmlRoot, this._textVmlEl);\n    };\n\n    var list = [RectText, Displayable, ZImage, Path, Text];\n\n    // In case Displayable has been mixed in RectText\n    for (var i = 0; i < list.length; i++) {\n        var proto = list[i].prototype;\n        proto.drawRectText = drawRectText;\n        proto.removeRectText = removeRectText;\n        proto.appendRectText = appendRectText;\n    }\n\n    Text.prototype.brushVML = function (vmlRoot) {\n        var style = this.style;\n        if (style.text) {\n            this.drawRectText(vmlRoot, {\n                x: style.x || 0, y: style.y || 0,\n                width: 0, height: 0\n            }, this.getBoundingRect(), true);\n        }\n        else {\n            this.removeRectText(vmlRoot);\n        }\n    };\n\n    Text.prototype.onRemove = function (vmlRoot) {\n        this.removeRectText(vmlRoot);\n    };\n\n    Text.prototype.onAdd = function (vmlRoot) {\n        this.appendRectText(vmlRoot);\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/graphic.js\n ** module id = 118\n ** module chunks = 0\n **/","\n\nif (!require('../core/env').canvasSupported) {\n    var urn = 'urn:schemas-microsoft-com:vml';\n\n    var createNode;\n    var win = window;\n    var doc = win.document;\n\n    var vmlInited = false;\n\n    try {\n        !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n        createNode = function (tagName) {\n            return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n        };\n    }\n    catch (e) {\n        createNode = function (tagName) {\n            return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n        };\n    }\n\n    // From raphael\n    var initVML = function () {\n        if (vmlInited) {\n            return;\n        }\n        vmlInited = true;\n\n        var styleSheets = doc.styleSheets;\n        if (styleSheets.length < 31) {\n            doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n        else {\n            // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n            styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n        }\n    };\n\n    // Not useing return to avoid error when converting to CommonJS module\n    module.exports = {\n        doc: doc,\n        initVML: initVML,\n        createNode: createNode\n    };\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/core.js\n ** module id = 119\n ** module chunks = 0\n **/","/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\n\n\n\n    var zrLog = require('../core/log');\n    var vmlCore = require('./core');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    /**\n     * @alias module:zrender/vml/Painter\n     */\n    function VMLPainter(root, storage) {\n\n        vmlCore.initVML();\n\n        this.root = root;\n\n        this.storage = storage;\n\n        var vmlViewport = document.createElement('div');\n\n        var vmlRoot = document.createElement('div');\n\n        vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n\n        vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n\n        root.appendChild(vmlViewport);\n\n        this._vmlRoot = vmlRoot;\n        this._vmlViewport = vmlViewport;\n\n        this.resize();\n\n        // Modify storage\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            if (el) {\n                el.onRemove && el.onRemove(vmlRoot);\n            }\n        };\n\n        storage.addToMap = function (el) {\n            // Displayable already has a vml node\n            el.onAdd && el.onAdd(vmlRoot);\n\n            oldAddToMap.call(storage, el);\n        };\n\n        this._firstPaint = true;\n    }\n\n    VMLPainter.prototype = {\n\n        constructor: VMLPainter,\n\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._vmlViewport;\n        },\n\n        /**\n         * 刷新\n         */\n        refresh: function () {\n\n            var list = this.storage.getDisplayList(true, true);\n\n            this._paintList(list);\n        },\n\n        _paintList: function (list) {\n            var vmlRoot = this._vmlRoot;\n            for (var i = 0; i < list.length; i++) {\n                var el = list[i];\n                if (el.invisible || el.ignore) {\n                    if (!el.__alreadyNotVisible) {\n                        el.onRemove(vmlRoot);\n                    }\n                    // Set as already invisible\n                    el.__alreadyNotVisible = true;\n                }\n                else {\n                    if (el.__alreadyNotVisible) {\n                        el.onAdd(vmlRoot);\n                    }\n                    el.__alreadyNotVisible = false;\n                    if (el.__dirty) {\n                        el.beforeBrush && el.beforeBrush();\n                        (el.brushVML || el.brush).call(el, vmlRoot);\n                        el.afterBrush && el.afterBrush();\n                    }\n                }\n                el.__dirty = false;\n            }\n\n            if (this._firstPaint) {\n                // Detached from document at first time\n                // to avoid page refreshing too many times\n\n                // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n                this._vmlViewport.appendChild(vmlRoot);\n                this._firstPaint = false;\n            }\n        },\n\n        resize: function () {\n            var width = this._getWidth();\n            var height = this._getHeight();\n\n            if (this._width != width && this._height != height) {\n                this._width = width;\n                this._height = height;\n\n                var vmlViewportStyle = this._vmlViewport.style;\n                vmlViewportStyle.width = width + 'px';\n                vmlViewportStyle.height = height + 'px';\n            }\n        },\n\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this._vmlRoot =\n            this._vmlViewport =\n            this.storage = null;\n        },\n\n        getWidth: function () {\n            return this._width;\n        },\n\n        getHeight: function () {\n            return this._height;\n        },\n\n        clear: function () {\n            this.root.removeChild(this.vmlViewport);\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientWidth || parseInt10(stl.width))\n                    - parseInt10(stl.paddingLeft)\n                    - parseInt10(stl.paddingRight)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = root.currentStyle;\n\n            return ((root.clientHeight || parseInt10(stl.height))\n                    - parseInt10(stl.paddingTop)\n                    - parseInt10(stl.paddingBottom)) | 0;\n        }\n    };\n\n    // Not supported methods\n    function createMethodNotSupport(method) {\n        return function () {\n            zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    var notSupportedMethods = [\n        'getLayer', 'insertLayer', 'eachLayer', 'eachBuildinLayer', 'eachOtherLayer', 'getLayers',\n        'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'\n    ];\n\n    for (var i = 0; i < notSupportedMethods.length; i++) {\n        var name = notSupportedMethods[i];\n        VMLPainter.prototype[name] = createMethodNotSupport(name);\n    }\n\n    module.exports = VMLPainter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/vml/Painter.js\n ** module id = 120\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}