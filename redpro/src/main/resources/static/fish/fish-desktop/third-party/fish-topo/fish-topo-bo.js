(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fishTopoBo"] = factory();
	else
		root["fishTopoBo"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Export fishTopo as CommonJS module
	 */
	module.exports = __webpack_require__(2);
	


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by majianan on 16/5/19.
	 *
	 */
	
	    var zr = __webpack_require__(3);
	    var util = __webpack_require__(9);
	    var BoNode = __webpack_require__(37);
	    var Relation = __webpack_require__(72);
	    var Const = __webpack_require__(38);
	    var graphic = __webpack_require__(40);
	    var eventTool = __webpack_require__(7);
	
	    function FishTopoBo(dom, opts) {
	        /**
	         * 缩放
	         * @type {number}
	         */
	        this.nowZoom = 1;
	        this.canScale = true;
	
	        /**
	         * 初始化zrender
	         */
	        this._zr = zr.init(dom, {
	            renderer: opts.renderer || 'canvas',
	            devicePixelRatio: opts.devicePixelRatio
	        });
	    }
	
	    var fishTopoProto = FishTopoBo.prototype;
	
	    /**
	     * 初始化
	     */
	    fishTopoProto.init = function () {
	        this.group = new graphic.Group();
	        this.groupDrag(this.group);
	        this._zr.add(this.group);
	        this.zrScale();
	    };
	
	    /**
	     * 调整尺寸  在窗口大小发生改变时需要手工调用
	     */
	    fishTopoProto.resize = function () {
	        this._zr.resize();
	    };
	
	    /**
	     * 添加BO
	     * @param {Object} boData, bo数据
	     * @param {{
	     *          startPos: {x: number, y: number} 起始位置,
	     *          displayAttrDataType: boolean 是否显示属性数据类型,
	     *          displayAttrEvent: boolean 是否显示属性事件决策,
	     *          boClickable: boolean BO是否支持点击事件, 可空 默认false
	     *          boPopupUrl: String 点击BO弹出页面地址
	     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false
	     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址
	     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false
	     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址
	     *          isCurrent: boolean 是否为当前BO
	     *          }} opts
	     * @returns {*}
	     */
	    fishTopoProto.addBo = function (boData, opts) {
	        //设置BO父子关系，便于后续整体移动
	        this._setParent(boData);
	
	        //layout BO的布局信息，x,y左上角起始坐标, level:层级
	        boData.layout = {
	            x: opts.startPos.x,
	            y: opts.startPos.y,
	            level: 1
	        };
	
	        //计算BO的X坐标
	        this._bfs(boData);
	
	        //按照起始坐标整体左移
	        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);
	
	        //画BO
	        var boNode = new BoNode(boData, opts);
	        this.group.add(boNode.getShape());
	
	        //创建子BO
	        this.addChildBo(boNode, opts);
	
	        return boNode;
	    };
	
	    /**
	     * 设置BO的父子关系
	     * @param {Object} boData BO数据
	     * @private
	     */
	    fishTopoProto._setParent = function (boData) {
	        if (boData.child) {
	            var childCnt = boData.child.length,
	                childBoArr = boData.child;
	            for (var i = 0; i < childCnt; i++) {
	                childBoArr[i].parent = boData;
	                if (childBoArr[i + 1]) {
	                    childBoArr[i].next = childBoArr[i + 1];
	                }
	                //设置最后子节点的next=下一个父节点的第一个子节点
	                else if (boData.next && boData.next.child) {
	                    childBoArr[i].next = boData.next.child[0];
	                }
	                this._setParent(childBoArr[i]);
	            }
	        }
	    };
	
	
	    /**
	     * Breadth-First-Search 计算X坐标
	     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标
	     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标
	     * @param boData
	     * @private
	     */
	    fishTopoProto._bfs = function (boData) {
	        //用于保存每个level的最大坐标值
	        this._levelMaxPos = {};
	
	        this._queue = [];   //存放BO数据
	        this._queue.push(boData);
	
	        while (this._queue.length > 0) {
	            var tmp = this._queue.shift();
	            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');
	            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);
	
	            //该level第一个节点
	            if (!this._levelMaxPos[tmp.layout.level]) {
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	            //当前就是最右侧的节点
	            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动
	            else {
	                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)
	                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};
	            }
	
	            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);
	
	            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标
	            if (tmp.child) {
	                var childCnt = tmp.child.length;
	
	                for (var i = 0; i < childCnt; i++) {
	
	                    tmp.child[i].layout = {
	                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),
	                        level: tmp.layout.level + 1
	                    };
	
	                    this._queue.push(tmp.child[i]);
	                }
	            }
	        }
	    };
	
	    /**
	     * 子节点右移时，同时下一个子节点，以及父节点都同时移动
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByChild = function (boData, width) {
	        if (boData) {
	
	            if (!boData.layout.moved) {
	
	                if (boData.layout.level == 1) {
	                    boData.layout.x += width / 2;
	                } else {
	                    boData.layout.x += width;
	                }
	
	                boData.layout.moved = true;
	            }
	            //当前节点的下一节点整体右移
	            this._moveRightByPrevious(boData.next, width);
	            //当前节点的父节点整体右移
	            this._moveRightByChild(boData.parent, width);
	        }
	
	    };
	
	    /**
	     * 前一个节点右移的时候，所有后面的节点整体右移
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByPrevious = function (boData, width) {
	        if (boData) {
	            boData.layout.x += width;
	            boData.layout.moved = true;
	            //当前节点的所有后续节点整体右移
	            this._moveRightByPrevious(boData.next, width);
	        }
	    };
	
	    /**
	     * 父节点右移时，所有子节点整体右移
	     * @param boData
	     * @param width
	     * @private
	     */
	    fishTopoProto._moveRightByParent = function (boData, width) {
	        if (boData) {
	            boData.layout.x += width;
	            if (boData.child) {
	                for (var i = 0; i < boData.child.length; i++) {
	                    this._moveRightByParent(boData.child[i], width);
	                }
	            }
	        }
	    };
	
	    /**
	     * 添加子BO
	     * @param {BoNode} parentBoNode
	     * @param {Object} opts
	     * @private
	     */
	    fishTopoProto.addChildBo = function (parentBoNode, opts) {
	
	        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形
	        this._queue.push(parentBoNode);
	
	        while (this._queue.length > 0) {
	            var tmp = this._queue.shift(),
	                boNodeHeight = tmp.getShape().getBoundingRect().height;
	            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');
	            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);
	
	            //如果是该Level第一个节点，或者当低于原来的节点
	            if (!this._levelMaxPos[tmp.getLayout().level].y ||
	                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {
	                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;
	            }
	
	            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);
	
	            if (tmp.getData().child) {
	
	                var childBoArr = tmp.getData().child,
	                    childCnt = childBoArr.length,
	                    boNode,
	                    relationNode;
	
	                //该level所有子节点的起始Y坐标都相同
	                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;
	                for (var i = 0; i < childCnt; i++) {
	                    opts.startPos.x = childBoArr[i].layout.x;
	                    childBoArr[i].layout.y = opts.startPos.y;
	                    boNode = new BoNode(childBoArr[i], opts);
	                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');
	
	                    this.group.add(boNode.getShape());
	                    this._queue.push(boNode);
	
	                    //BO关系
	                    if (childBoArr[i].relation) {
	                        var _relationLen = childBoArr[i].relation.length;
	                        for (var j = 0; j < _relationLen; j++) {
	                            var sourceId = childBoArr[i].relation[j].sourceId,
	                                targetId = childBoArr[i].relation[j].targetId,
	                                sourceText = childBoArr[i].relation[j].sourceText,
	                                targetText = childBoArr[i].relation[j].targetText;
	
	                            relationNode = new Relation(
	                                boNode.getShape().childOfName(sourceId),
	                                tmp.getShape().childOfName(targetId),
	                                sourceText,
	                                targetText
	                            );
	                            this.group.add(relationNode.getShape());
	                        }
	                    }
	                }
	
	            }
	        }
	    };
	
	    /**
	     * 设置当前BO为特殊样式
	     * @param {String} boId, BO标识
	     * @param {Object} style, BO特殊样式,可空
	     */
	    fishTopoProto.setCurrentBo = function (boId, style) {
	        var length = this.group.childCount();
	        for (var i = 0; i < length; i++) {
	            if (this.group.childAt(i).name == boId) {
	                this.group.childAt(i).setCurrent(style);
	            }
	        }
	    };
	
	    /**
	     * 清空
	     */
	    fishTopoProto.clear = function () {
	        this._zr.clear();
	        this.group = new graphic.Group();
	        this._zr.add(this.group);
	    };
	
	    /**
	     * 缩放功能
	     * @param type
	     */
	    fishTopoProto.zrScale = function (type) {
	        var that = this;
	        if (type) {
	            if (type == "narrowing") {
	                var zoomDelta = 1 / 1.1;
	                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	            if (type == "enlarge") {
	                var zoomDelta = 1.1;
	                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);
	            }
	        } else {
	            that._zr.on('mousewheel', function (e) {
	                eventTool.stop(e.event);
	                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
	                zoom(zoomDelta, e.offsetX, e.offsetY);
	            });
	        }
	        ;
	        function zoom(zoomDelta, zoomX, zoomY) {
	            if (that.canScale == false) {
	                return;
	            }
	            var target = that.group;
	            if (target) {
	                var pos = target.position;
	                var scale = target.scale;
	                var newZoom = that._zoom = that._zoom || 1;
	                newZoom *= zoomDelta;
	                var zoomScale = newZoom / that._zoom;
	                // if(newZoom>2.6||newZoom<0.38){
	                //     return;
	                // };
	                that._zoom = newZoom;
	
	                that.nowZoom = newZoom;
	                // Keep the mouse center when scaling
	                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
	                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
	                scale[0] *= zoomScale;
	                scale[1] *= zoomScale;
	                target.attr("position", [pos[0], pos[1]]);
	                target.attr("scale", [scale[0], scale[1]]);
	                //that.minimap.updateSelectionPosition(pos,zoomScale);
	            }
	        }
	    };
	
	    /**
	     * 拖拽Group
	     */
	    fishTopoProto.groupDrag = function () {
	        var that = this;
	        that._zr.on("mousedown", function (e) {
	            groupDragFunction(e);
	            e.cancelBubble = true;
	        });
	        function groupDragFunction(e) {
	            var startX = e.event.clientX;
	            var startY = e.event.clientY;
	            var moveFunction = function (e) {
	                moveDrag(e);
	            }
	            var nowGroupPosition = that.group.position;
	            var groupPositionX = that.group.position[0];
	            var groupPositionY = that.group.position[1];
	            var alarmPositionX, alarmPositionY;
	
	            function moveDrag(e) {
	                var width = that.group.getBoundingRect().width * that.nowZoom;
	                var height = that.group.getBoundingRect().height * that.nowZoom;
	                var gx = that.group.getBoundingRect().x * that.nowZoom;
	                var gy = that.group.getBoundingRect().y * that.nowZoom;
	                var min = [10 - (width + gx), 10 - (height + gy)];
	                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];
	                var sX = (e.event.clientX - startX) * (that.nowZoom);
	                var sY = (e.event.clientY - startY) * (that.nowZoom);
	                nowGroupPosition[0] = groupPositionX + (sX);
	                nowGroupPosition[1] = groupPositionY + (sY);
	                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {
	                    return;
	                } else {
	                    that.group.attr("position", nowGroupPosition);
	                }
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function (e) {
	                endDrag(e);
	            }
	
	            function endDrag(e) {
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	    /**
	     * 拖拽
	     * @param node
	     */
	    fishTopoProto.drag = function (node) {
	        var that = this;
	        node.on("mousedown", function (e) {
	            if (this.isdraggable == false) {
	                return;
	            }
	            groupDragFunction(e);
	            e.cancelBubble = true;
	        });
	        function groupDragFunction(e) {
	            var startX = e.event.clientX;
	            var startY = e.event.clientY;
	            var moveFunction = function (e) {
	                moveDrag(e);
	            }
	            var nowGroupPosition = node.position;
	            var groupPositionX = node.position[0];
	            var groupPositionY = node.position[1];
	            var alarmPositionX, alarmPositionY;
	            if (node.alarm) {
	                var newAlarmPosition = node.alarm.position;
	                alarmPositionX = node.alarm.position[0];
	                alarmPositionY = node.alarm.position[1];
	            }
	            ;
	            function moveDrag(e) {
	                var sX = (e.event.clientX - startX) / (that.nowZoom);
	                var sY = (e.event.clientY - startY) / (that.nowZoom);
	                if (node.parent && node.parent instanceof GroupNode) {
	                    //放入node现有数值，用于重绘group
	                    var nodeMessage = {
	                        width: node.shape.width,
	                        height: node.shape.height,
	                        position: node.position,
	                        nodeXY: [node.shape.x, node.shape.y],
	                        movePosition: [groupPositionX, groupPositionY],
	                        moveX: sX,
	                        moveY: sY
	                    };
	                    var groupNode = node.parent;
	                    groupNode.reDraw(nodeMessage, node);
	                } else {
	                    nowGroupPosition[0] = groupPositionX + (sX);
	                    nowGroupPosition[1] = groupPositionY + (sY);
	                    node.attr("position", nowGroupPosition);
	                    if (node.alarm) {
	                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];
	                        node.alarm.attr("position", newAlarmPosition);
	                    }
	                    ;
	                }
	                ConnectionManager.refreshLineByNode(node);
	            }
	
	            that._zr.on('mousemove', moveFunction);
	            var upFunction = function (e) {
	                endDrag(e);
	            }
	            //拖拽结束
	            function endDrag(e) {
	                that._zr.off('mousemove', moveFunction);
	                that._zr.off('mouseup', upFunction);
	                that._zr.off("globalout", upFunction);
	                //布局重新计算
	                if (node.layout) {
	                    that.layoutNode("tree", {"node": node});
	                }
	                if (that.forceLayoutOption) {
	                    var nodes = that.forceLayoutOption.allNodes;
	                    if (_.indexOf(nodes, node) != -1) {
	                        that.layoutNode("force", this.forceLayoutOption);
	                    }
	                }
	                ;
	            }
	
	            that._zr.on('mouseup', upFunction);
	            that._zr.on("globalout", upFunction);
	        }
	    };
	
	
	    // ---------对外暴露fishTopoBo------------------
	    var idBase = new Date() - 0;
	    var instances = {};
	    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';
	    var fishTopoBo = {
	        /**
	         * @type {number}
	         */
	        version: '1.0.0',
	        dependencies: {
	            zrender: '3.0.4'
	        }
	    };
	
	    /**
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     */
	    fishTopoBo.init = function (dom, opts) {
	        if (!dom) {
	            throw new Error('Initialize failed: invalid dom.');
	        }
	
	        opts = opts || {};
	        // Default value
	        util.defaults(opts,
	            {
	                type: "bpmn",
	                showGridLine: true,
	                devicePixelRatio: 1,
	                gridLineSpacing:10
	            }
	        );
	
	        var fishTopoBo = new FishTopoBo(dom, opts);
	        fishTopoBo.init();
	
	        fishTopoBo.id = 'ft_' + idBase++;
	        instances[fishTopoBo.id] = fishTopoBo;
	
	        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);
	
	        return fishTopoBo;
	    };
	
	
	    /**
	     * @param  {HTMLDomElement} dom
	     * @return {fishTopo}
	     */
	    fishTopoBo.getInstanceByDom = function (dom) {
	        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
	        return instances[key];
	    };
	
	    /**
	     * Dispose a fishTopo instance
	     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo
	     */
	    fishTopoBo.dispose = function (chart) {
	        var topo;
	        if (zrUtil.isDom(chart)) {
	            topo = fishTopoBo.getInstanceByDom(chart);
	        }
	        else if (typeof chart === 'string') {
	            topo = instances[chart];
	        }
	        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {
	            topo.dispose();
	        }
	    };
	
	    module.exports = fishTopoBo;
	


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * ZRender, a high performance 2d drawing library.
	 *
	 * Copyright (c) 2013, Baidu Inc.
	 * All rights reserved.
	 *
	 * LICENSE
	 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	 */
	// Global defines
	
	    var guid = __webpack_require__(4);
	    var env = __webpack_require__(5);
	
	    var Handler = __webpack_require__(6);
	    var Storage = __webpack_require__(13);
	    var Animation = __webpack_require__(27);
	
	    var useVML = !env.canvasSupported;
	
	    var painterCtors = {
	        canvas: __webpack_require__(28)
	    };
	
	    var instances = {};    // ZRender实例map索引
	
	    var zrender = {};
	    /**
	     * @type {string}
	     */
	    zrender.version = '3.0.4';
	
	    /**
	     * @param {HTMLElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     * @return {module:zrender/ZRender}
	     */
	    zrender.init = function(dom, opts) {
	        var zr = new ZRender(guid(), dom, opts);
	        instances[zr.id] = zr;
	        return zr;
	    };
	
	    /**
	     * Dispose zrender instance
	     * @param {module:zrender/ZRender} zr
	     */
	    zrender.dispose = function (zr) {
	        if (zr) {
	            zr.dispose();
	        }
	        else {
	            for (var key in instances) {
	                instances[key].dispose();
	            }
	            instances = {};
	        }
	
	        return zrender;
	    };
	
	    /**
	     * 获取zrender实例
	     * @param {string} id ZRender对象索引
	     * @return {module:zrender/ZRender}
	     */
	    zrender.getInstance = function (id) {
	        return instances[id];
	    };
	
	    zrender.registerPainter = function (name, Ctor) {
	        painterCtors[name] = Ctor;
	    };
	
	    function delInstance(id) {
	        delete instances[id];
	    }
	
	    /**
	     * @module zrender/ZRender
	     */
	    /**
	     * @constructor
	     * @alias module:zrender/ZRender
	     * @param {string} id
	     * @param {HTMLDomElement} dom
	     * @param {Object} opts
	     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
	     * @param {number} [opts.devicePixelRatio]
	     */
	    var ZRender = function(id, dom, opts) {
	
	        opts = opts || {};
	
	        /**
	         * @type {HTMLDomElement}
	         */
	        this.dom = dom;
	
	        /**
	         * @type {string}
	         */
	        this.id = id;
	
	        var self = this;
	        var storage = new Storage();
	
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType || !painterCtors[rendererType]) {
	            rendererType = 'canvas';
	        }
	        var painter = new painterCtors[rendererType](dom, storage, opts);
	
	        this.storage = storage;
	        this.painter = painter;
	        if (!env.node) {
	            this.handler = new Handler(painter.getViewportRoot(), storage, painter);
	        }
	
	        /**
	         * @type {module:zrender/animation/Animation}
	         */
	        this.animation = new Animation({
	            stage: {
	                update: function () {
	                    if (self._needsRefresh) {
	                        self.refreshImmediately();
	                    }
	                }
	            }
	        });
	        this.animation.start();
	
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._needsRefresh;
	
	        // 修改 storage.delFromMap, 每次删除元素之前删除动画
	        // FIXME 有点ugly
	        var oldDelFromMap = storage.delFromMap;
	        var oldAddToMap = storage.addToMap;
	
	        storage.delFromMap = function (elId) {
	            var el = storage.get(elId);
	
	            oldDelFromMap.call(storage, elId);
	
	            el && el.removeSelfFromZr(self);
	        };
	
	        storage.addToMap = function (el) {
	            oldAddToMap.call(storage, el);
	
	            el.addSelfToZr(self);
	        };
	    };
	
	    ZRender.prototype = {
	
	        constructor: ZRender,
	        /**
	         * 获取实例唯一标识
	         * @return {string}
	         */
	        getId: function () {
	            return this.id;
	        },
	
	        /**
	         * 添加元素
	         * @param  {string|module:zrender/Element} el
	         */
	        add: function (el) {
	            this.storage.addRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 删除元素
	         * @param  {string|module:zrender/Element} el
	         */
	        remove: function (el) {
	            this.storage.delRoot(el);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 修改指定zlevel的绘制配置项
	         *
	         * @param {string} zLevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	        */
	        configLayer: function (zLevel, config) {
	            this.painter.configLayer(zLevel, config);
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 视图更新
	         */
	        refreshImmediately: function () {
	            // Clear needsRefresh ahead to avoid something wrong happens in refresh
	            // Or it will cause zrender refreshes again and again.
	            this._needsRefresh = false;
	            this.painter.refresh();
	            /**
	             * Avoid trigger zr.refresh in Element#beforeUpdate hook
	             */
	            this._needsRefresh = false;
	        },
	
	        /**
	         * 标记视图在浏览器下一帧需要绘制
	         */
	        refresh: function() {
	            this._needsRefresh = true;
	        },
	
	        /**
	         * 调整视图大小
	         */
	        resize: function() {
	            this.painter.resize();
	            this.handler && this.handler.resize();
	        },
	
	        /**
	         * 停止所有动画
	         */
	        clearAnimation: function () {
	            this.animation.clear();
	        },
	
	        /**
	         * 获取视图宽度
	         */
	        getWidth: function() {
	            return this.painter.getWidth();
	        },
	
	        /**
	         * 获取视图高度
	         */
	        getHeight: function() {
	            return this.painter.getHeight();
	        },
	
	        /**
	         * 图像导出
	         * @param {string} type
	         * @param {string} [backgroundColor='#fff'] 背景色
	         * @return {string} 图片的Base64 url
	         */
	        toDataURL: function(type, backgroundColor, args) {
	            return this.painter.toDataURL(type, backgroundColor, args);
	        },
	
	        /**
	         * 将常规shape转成image shape
	         * @param {module:zrender/graphic/Path} e
	         * @param {number} width
	         * @param {number} height
	         */
	        pathToImage: function(e, width, height) {
	            var id = guid();
	            return this.painter.pathToImage(id, e, width, height);
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} cursorStyle 例如 crosshair
	         */
	        setDefaultCursorStyle: function (cursorStyle) {
	            this.handler.setDefaultCursorStyle(cursorStyle);
	        },
	
	        /**
	         * 事件绑定
	         *
	         * @param {string} eventName 事件名称
	         * @param {Function} eventHandler 响应函数
	         * @param {Object} [context] 响应函数
	         */
	        on: function(eventName, eventHandler, context) {
	            this.handler && this.handler.on(eventName, eventHandler, context);
	        },
	
	        /**
	         * 事件解绑定，参数为空则解绑所有自定义事件
	         *
	         * @param {string} eventName 事件名称
	         * @param {Function} eventHandler 响应函数
	         */
	        off: function(eventName, eventHandler) {
	            this.handler && this.handler.off(eventName, eventHandler);
	        },
	
	        /**
	         * 事件触发
	         *
	         * @param {string} eventName 事件名称，resize，hover，drag，etc
	         * @param {event=} event event dom事件对象
	         */
	        trigger: function (eventName, event) {
	            this.handler && this.handler.trigger(eventName, event);
	        },
	
	
	        /**
	         * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用
	         */
	        clear: function () {
	            this.storage.delRoot();
	            this.painter.clear();
	        },
	
	        /**
	         * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用
	         */
	        dispose: function () {
	            this.animation.stop();
	
	            this.clear();
	            this.storage.dispose();
	            this.painter.dispose();
	            this.handler && this.handler.dispose();
	
	            this.animation =
	            this.storage =
	            this.painter =
	            this.handler = null;
	
	            delInstance(this.id);
	        }
	    };
	
	    module.exports = zrender;
	


/***/ },
/* 4 */
/***/ function(module, exports) {

	/**
	 * zrender: 生成唯一id
	 *
	 * @author errorrik (errorrik@gmail.com)
	 */
	
	
	        var idStart = 0x0907;
	
	        module.exports = function () {
	            return 'zr_' + (idStart++);
	        };
	    


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * echarts设备环境识别
	 *
	 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
	 * @author firede[firede@firede.us]
	 * @desc thanks zepto.
	 */
	
	    var env = {};
	    if (typeof navigator === 'undefined') {
	        // In node
	        env = {
	            browser: {},
	            os: {},
	            node: true,
	            // Assume canvas is supported
	            canvasSupported: true
	        };
	    }
	    else {
	        env = detect(navigator.userAgent);
	    }
	
	    module.exports = env;
	
	    // Zepto.js
	    // (c) 2010-2013 Thomas Fuchs
	    // Zepto.js may be freely distributed under the MIT license.
	
	    function detect(ua) {
	        var os = {};
	        var browser = {};
	        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
	        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
	        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
	        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
	        var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
	        var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
	        var touchpad = webos && ua.match(/TouchPad/);
	        var kindle = ua.match(/Kindle\/([\d.]+)/);
	        var silk = ua.match(/Silk\/([\d._]+)/);
	        var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
	        var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
	        var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
	        var playbook = ua.match(/PlayBook/);
	        var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
	        var firefox = ua.match(/Firefox\/([\d.]+)/);
	        var safari = webkit && ua.match(/Mobile\//) && !chrome;
	        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
	        var ie = ua.match(/MSIE\s([\d.]+)/)
	            // IE 11 Trident/7.0; rv:11.0
	            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+
	
	        // Todo: clean this up with a better OS/browser seperation:
	        // - discern (more) between multiple browsers on android
	        // - decide if kindle fire in silk mode is android or not
	        // - Firefox on Android doesn't specify the Android version
	        // - possibly devide in os, device and browser hashes
	
	        if (browser.webkit = !!webkit) browser.version = webkit[1];
	
	        if (android) os.android = true, os.version = android[2];
	        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
	        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
	        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
	        if (webos) os.webos = true, os.version = webos[2];
	        if (touchpad) os.touchpad = true;
	        if (blackberry) os.blackberry = true, os.version = blackberry[2];
	        if (bb10) os.bb10 = true, os.version = bb10[2];
	        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
	        if (playbook) browser.playbook = true;
	        if (kindle) os.kindle = true, os.version = kindle[1];
	        if (silk) browser.silk = true, browser.version = silk[1];
	        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
	        if (chrome) browser.chrome = true, browser.version = chrome[1];
	        if (firefox) browser.firefox = true, browser.version = firefox[1];
	        if (ie) browser.ie = true, browser.version = ie[1];
	        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
	        if (webview) browser.webview = true;
	        if (ie) browser.ie = true, browser.version = ie[1];
	        if (edge) browser.edge = true, browser.version = edge[1];
	
	        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
	            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
	        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||
	            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
	            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));
	
	        return {
	            browser: browser,
	            os: os,
	            node: false,
	            // 原生canvas支持，改极端点了
	            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
	            canvasSupported : document.createElement('canvas').getContext ? true : false,
	            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
	            // works on most browsers
	            // IE10/11 does not support touch event, and MS Edge supports them but not by
	            // default, so we dont check navigator.maxTouchPoints for them here.
	            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
	            // <http://caniuse.com/#search=pointer%20event>.
	            pointerEventsSupported: 'onpointerdown' in window
	                // Firefox supports pointer but not by default,
	                // only MS browsers are reliable on pointer events currently.
	                && (browser.edge || (browser.ie && browser.version >= 10))
	        };
	    }


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Handler控制模块
	 * @module zrender/Handler
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (shenyi.914@gmail.com)
	 */
	
	
	    var env = __webpack_require__(5);
	    var eventTool = __webpack_require__(7);
	    var util = __webpack_require__(9);
	    var Draggable = __webpack_require__(11);
	    var GestureMgr = __webpack_require__(12);
	
	    var Eventful = __webpack_require__(8);
	
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'mouseout'
	    ];
	    !usePointerEvent() && mouseHandlerNames.push(
	        'mouseup', 'mousedown', 'mousemove'
	    );
	
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	
	    var pointerHandlerNames = [
	        'pointerdown', 'pointerup', 'pointermove'
	    ];
	
	    var TOUCH_CLICK_DELAY = 300;
	
	    // touch指尖错觉的尝试偏移量配置
	    // var MOBILE_TOUCH_OFFSETS = [
	    //     { x: 10 },
	    //     { x: -20 },
	    //     { x: 10, y: 10 },
	    //     { y: -20 }
	    // ];
	
	    var addEventListener = eventTool.addEventListener;
	    var removeEventListener = eventTool.removeEventListener;
	    var normalizeEvent = eventTool.normalizeEvent;
	
	    function makeEventPacket(eveType, target, event) {
	        return {
	            type: eveType,
	            event: event,
	            target: target,
	            cancelBubble: false,
	            offsetX: event.zrX,
	            offsetY: event.zrY,
	            gestureEvent: event.gestureEvent,
	            pinchX: event.pinchX,
	            pinchY: event.pinchY,
	            pinchScale: event.pinchScale,
	            wheelDelta: event.zrDelta
	        };
	    }
	
	    var domHandlers = {
	        /**
	         * Mouse move handler
	         * @inner
	         * @param {Event} event
	         */
	        mousemove: function (event) {
	            event = normalizeEvent(this.root, event);
	
	            var x = event.zrX;
	            var y = event.zrY;
	
	            var hovered = this.findHover(x, y, null);
	            var lastHovered = this._hovered;
	
	            this._hovered = hovered;
	
	            this.root.style.cursor = hovered ? hovered.cursor : this._defaultCursorStyle;
	            // Mouse out on previous hovered element
	            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
	                this._dispatchProxy(lastHovered, 'mouseout', event);
	            }
	
	            // Mouse moving on one element
	            this._dispatchProxy(hovered, 'mousemove', event);
	
	            // Mouse over on a new element
	            if (hovered && hovered !== lastHovered) {
	                this._dispatchProxy(hovered, 'mouseover', event);
	            }
	        },
	
	        /**
	         * Mouse out handler
	         * @inner
	         * @param {Event} event
	         */
	        mouseout: function (event) {
	            event = normalizeEvent(this.root, event);
	
	            var element = event.toElement || event.relatedTarget;
	            if (element != this.root) {
	                while (element && element.nodeType != 9) {
	                    // 忽略包含在root中的dom引起的mouseOut
	                    if (element === this.root) {
	                        return;
	                    }
	
	                    element = element.parentNode;
	                }
	            }
	
	            this._dispatchProxy(this._hovered, 'mouseout', event);
	
	            this.trigger('globalout', {
	                event: event
	            });
	        },
	
	        /**
	         * Touch开始响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchstart: function (event) {
	            // FIXME
	            // 移动端可能需要default行为，例如静态图表时。
	            // eventTool.stop(event);// 阻止浏览器默认事件，重要
	            event = normalizeEvent(this.root, event);
	
	            this._lastTouchMoment = new Date();
	
	            processGesture(this, event, 'start');
	
	            // 平板补充一次findHover
	            // this._mobileFindFixed(event);
	            // Trigger mousemove and mousedown
	            domHandlers.mousemove.call(this, event);
	
	            domHandlers.mousedown.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch移动响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchmove: function (event) {
	            // eventTool.stop(event);// 阻止浏览器默认事件，重要
	            event = normalizeEvent(this.root, event);
	
	            processGesture(this, event, 'change');
	
	            // Mouse move should always be triggered no matter whether
	            // there is gestrue event, because mouse move and pinch may
	            // be used at the same time.
	            domHandlers.mousemove.call(this, event);
	
	            setTouchTimer(this);
	        },
	
	        /**
	         * Touch结束响应函数
	         * @inner
	         * @param {Event} event
	         */
	        touchend: function (event) {
	            // eventTool.stop(event);// 阻止浏览器默认事件，重要
	            event = normalizeEvent(this.root, event);
	
	            processGesture(this, event, 'end');
	
	            domHandlers.mouseup.call(this, event);
	
	            // click event should always be triggered no matter whether
	            // there is gestrue event. System click can not be prevented.
	            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
	                // this._mobileFindFixed(event);
	                domHandlers.click.call(this, event);
	            }
	
	            setTouchTimer(this);
	        }
	    };
	
	    // Common handlers
	    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {
	        domHandlers[name] = function (event) {
	            event = normalizeEvent(this.root, event);
	            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
	            var hovered = this.findHover(event.zrX, event.zrY, null);
	            this._dispatchProxy(hovered, name, event);
	        };
	    });
	
	    // Pointer event handlers
	    // util.each(['pointerdown', 'pointermove', 'pointerup'], function (name) {
	    //     domHandlers[name] = function (event) {
	    //         var mouseName = name.replace('pointer', 'mouse');
	    //         domHandlers[mouseName].call(this, event);
	    //     };
	    // });
	
	    function processGesture(zrHandler, event, stage) {
	        var gestureMgr = zrHandler._gestureMgr;
	
	        stage === 'start' && gestureMgr.clear();
	
	        var gestureInfo = gestureMgr.recognize(
	            event,
	            zrHandler.findHover(event.zrX, event.zrY, null)
	        );
	
	        stage === 'end' && gestureMgr.clear();
	
	        if (gestureInfo) {
	            // eventTool.stop(event);
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	
	            zrHandler._dispatchProxy(gestureInfo.target, type, gestureInfo.event);
	        }
	    }
	
	    /**
	     * 为控制类实例初始化dom 事件处理函数
	     *
	     * @inner
	     * @param {module:zrender/Handler} instance 控制类实例
	     */
	    function initDomHandler(instance) {
	        var handlerNames = touchHandlerNames.concat(pointerHandlerNames);
	        for (var i = 0; i < handlerNames.length; i++) {
	            var name = handlerNames[i];
	            instance._handlers[name] = util.bind(domHandlers[name], instance);
	        }
	
	        for (var i = 0; i < mouseHandlerNames.length; i++) {
	            var name = mouseHandlerNames[i];
	            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
	        }
	
	        function makeMouseHandler(fn, instance) {
	            return function () {
	                if (instance._touching) {
	                    return;
	                }
	                return fn.apply(instance, arguments);
	            };
	        }
	    }
	
	    /**
	     * @alias module:zrender/Handler
	     * @constructor
	     * @extends module:zrender/mixin/Eventful
	     * @param {HTMLElement} root Main HTML element for painting.
	     * @param {module:zrender/Storage} storage Storage instance.
	     * @param {module:zrender/Painter} painter Painter instance.
	     */
	    var Handler = function(root, storage, painter) {
	        Eventful.call(this);
	
	        this.root = root;
	        this.storage = storage;
	        this.painter = painter;
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._hovered;
	
	        /**
	         * @private
	         * @type {Date}
	         */
	        this._lastTouchMoment;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastX;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._lastY;
	
	        /**
	         * @private
	         * @type {string}
	         */
	        this._defaultCursorStyle = 'default';
	
	        /**
	         * @private
	         * @type {module:zrender/core/GestureMgr}
	         */
	        this._gestureMgr = new GestureMgr();
	
	        /**
	         * @private
	         * @type {Array.<Function>}
	         */
	        this._handlers = [];
	
	        /**
	         * @private
	         * @type {boolean}
	         */
	        this._touching = false;
	
	        /**
	         * @private
	         * @type {number}
	         */
	        this._touchTimer;
	
	        initDomHandler(this);
	
	        if (usePointerEvent()) {
	            mountHandlers(pointerHandlerNames, this);
	        }
	        else if (useTouchEvent()) {
	            mountHandlers(touchHandlerNames, this);
	
	            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
	            // addEventListener(root, 'mouseout', this._mouseoutHandler);
	        }
	
	        // Considering some devices that both enable touch and mouse event (like MS Surface
	        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
	        // mouse event can not be handle in those devices.
	        mountHandlers(mouseHandlerNames, this);
	
	        Draggable.call(this);
	
	        function mountHandlers(handlerNames, instance) {
	            util.each(handlerNames, function (name) {
	                addEventListener(root, eventNameFix(name), instance._handlers[name]);
	            }, instance);
	        }
	    };
	
	    Handler.prototype = {
	
	        constructor: Handler,
	
	        /**
	         * Resize
	         */
	        resize: function (event) {
	            this._hovered = null;
	        },
	
	        /**
	         * Dispatch event
	         * @param {string} eventName
	         * @param {event=} eventArgs
	         */
	        dispatch: function (eventName, eventArgs) {
	            var handler = this._handlers[eventName];
	            handler && handler.call(this, eventArgs);
	        },
	
	        /**
	         * Dispose
	         */
	        dispose: function () {
	            var root = this.root;
	
	            var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
	
	            for (var i = 0; i < handlerNames.length; i++) {
	                var name = handlerNames[i];
	                removeEventListener(root, eventNameFix(name), this._handlers[name]);
	            }
	
	            this.root =
	            this.storage =
	            this.painter = null;
	        },
	
	        /**
	         * 设置默认的cursor style
	         * @param {string} cursorStyle 例如 crosshair
	         */
	        setDefaultCursorStyle: function (cursorStyle) {
	            this._defaultCursorStyle = cursorStyle;
	        },
	
	        /**
	         * 事件分发代理
	         *
	         * @private
	         * @param {Object} targetEl 目标图形元素
	         * @param {string} eventName 事件名称
	         * @param {Object} event 事件对象
	         */
	        _dispatchProxy: function (targetEl, eventName, event) {
	            var eventHandler = 'on' + eventName;
	            var eventPacket = makeEventPacket(eventName, targetEl, event);
	
	            var el = targetEl;
	
	            while (el) {
	                el[eventHandler]
	                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
	
	                el.trigger(eventName, eventPacket);
	
	                el = el.parent;
	
	                if (eventPacket.cancelBubble) {
	                    break;
	                }
	            }
	
	            if (!eventPacket.cancelBubble) {
	                // 冒泡到顶级 zrender 对象
	                this.trigger(eventName, eventPacket);
	                // 分发事件到用户自定义层
	                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
	                this.painter && this.painter.eachOtherLayer(function (layer) {
	                    if (typeof(layer[eventHandler]) == 'function') {
	                        layer[eventHandler].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        },
	
	        /**
	         * @private
	         * @param {number} x
	         * @param {number} y
	         * @param {module:zrender/graphic/Displayable} exclude
	         * @method
	         */
	        findHover: function(x, y, exclude) {
	            var list = this.storage.getDisplayList();
	            for (var i = list.length - 1; i >= 0 ; i--) {
	                if (!list[i].silent
	                 && list[i] !== exclude
	                 // getDisplayList may include ignored item in VML mode
	                 && !list[i].ignore
	                 && isHover(list[i], x, y)) {
	                    return list[i];
	                }
	            }
	        }
	    };
	
	    function isHover(displayable, x, y) {
	        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	            var p = displayable.parent;
	            while (p) {
	                if (p.clipPath && !p.clipPath.contain(x, y))  {
	                    // Clipped by parents
	                    return false;
	                }
	                p = p.parent;
	            }
	            return true;
	        }
	
	        return false;
	    }
	
	    /**
	     * Prevent mouse event from being dispatched after Touch Events action
	     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
	     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
	     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
	     * Result: Blocking Mouse Events for 700ms.
	     */
	    function setTouchTimer(instance) {
	        instance._touching = true;
	        clearTimeout(instance._touchTimer);
	        instance._touchTimer = setTimeout(function () {
	            instance._touching = false;
	        }, 700);
	    }
	
	    /**
	     * Althought MS Surface support screen touch, IE10/11 do not support
	     * touch event and MS Edge supported them but not by default (but chrome
	     * and firefox do). Thus we use Pointer event on MS browsers to handle touch.
	     */
	    function usePointerEvent() {
	        // TODO
	        // pointermove event dont trigger when using finger.
	        // We may figger it out latter.
	        return false;
	        // return env.pointerEventsSupported
	            // In no-touch device we dont use pointer evnets but just
	            // use mouse event for avoiding problems.
	            // && window.navigator.maxTouchPoints;
	    }
	
	    function useTouchEvent() {
	        return env.touchEventsSupported;
	    }
	
	    function eventNameFix(name) {
	        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
	    }
	
	    util.mixin(Handler, Eventful);
	    util.mixin(Handler, Draggable);
	
	    module.exports = Handler;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 事件辅助类
	 * @module zrender/core/event
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 */
	
	
	    var Eventful = __webpack_require__(8);
	
	    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	
	    function getBoundingClientRect(el) {
	        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
	        return el.getBoundingClientRect ? el.getBoundingClientRect() : { left: 0, top: 0};
	    }
	    /**
	     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
	     */
	    function normalizeEvent(el, e) {
	
	        e = e || window.event;
	
	        if (e.zrX != null) {
	            return e;
	        }
	
	        var eventType = e.type;
	        var isTouch = eventType && eventType.indexOf('touch') >= 0;
	
	        if (!isTouch) {
	            var box = getBoundingClientRect(el);
	            e.zrX = e.clientX - box.left;
	            e.zrY = e.clientY - box.top;
	            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	        }
	        else {
	            var touch = eventType != 'touchend'
	                            ? e.targetTouches[0]
	                            : e.changedTouches[0];
	            if (touch) {
	                var rBounding = getBoundingClientRect(el);
	                // touch事件坐标是全屏的~
	                e.zrX = touch.clientX - rBounding.left;
	                e.zrY = touch.clientY - rBounding.top;
	            }
	        }
	
	        return e;
	    }
	
	    function addEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.addEventListener(name, handler);
	        }
	        else {
	            el.attachEvent('on' + name, handler);
	        }
	    }
	
	    function removeEventListener(el, name, handler) {
	        if (isDomLevel2) {
	            el.removeEventListener(name, handler);
	        }
	        else {
	            el.detachEvent('on' + name, handler);
	        }
	    }
	
	    /**
	     * 停止冒泡和阻止默认行为
	     * @memberOf module:zrender/core/event
	     * @method
	     * @param {Event} e : event对象
	     */
	    var stop = isDomLevel2
	        ? function (e) {
	            e.preventDefault();
	            e.stopPropagation();
	            e.cancelBubble = true;
	        }
	        : function (e) {
	            e.returnValue = false;
	            e.cancelBubble = true;
	        };
	
	    module.exports = {
	        normalizeEvent: normalizeEvent,
	        addEventListener: addEventListener,
	        removeEventListener: removeEventListener,
	
	        stop: stop,
	        // 做向上兼容
	        Dispatcher: Eventful
	    };
	


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 事件扩展
	 * @module zrender/mixin/Eventful
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	
	
	    var arrySlice = Array.prototype.slice;
	    var zrUtil = __webpack_require__(9);
	    var indexOf = zrUtil.indexOf;
	
	    /**
	     * 事件分发器
	     * @alias module:zrender/mixin/Eventful
	     * @constructor
	     */
	    var Eventful = function () {
	        this._$handlers = {};
	    };
	
	    Eventful.prototype = {
	
	        constructor: Eventful,
	
	        /**
	         * 单次触发绑定，trigger后销毁
	         *
	         * @param {string} event 事件名
	         * @param {Function} handler 响应函数
	         * @param {Object} context
	         */
	        one: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            if (indexOf(_h[event], event) >= 0) {
	                return this;
	            }
	
	            _h[event].push({
	                h: handler,
	                one: true,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 绑定事件
	         * @param {string} event 事件名
	         * @param {Function} handler 事件处理函数
	         * @param {Object} [context]
	         */
	        on: function (event, handler, context) {
	            var _h = this._$handlers;
	
	            if (!handler || !event) {
	                return this;
	            }
	
	            if (!_h[event]) {
	                _h[event] = [];
	            }
	
	            _h[event].push({
	                h: handler,
	                one: false,
	                ctx: context || this
	            });
	
	            return this;
	        },
	
	        /**
	         * 是否绑定了事件
	         * @param  {string}  event
	         * @return {boolean}
	         */
	        isSilent: function (event) {
	            var _h = this._$handlers;
	            return _h[event] && _h[event].length;
	        },
	
	        /**
	         * 解绑事件
	         * @param {string} event 事件名
	         * @param {Function} [handler] 事件处理函数
	         */
	        off: function (event, handler) {
	            var _h = this._$handlers;
	
	            if (!event) {
	                this._$handlers = {};
	                return this;
	            }
	
	            if (handler) {
	                if (_h[event]) {
	                    var newList = [];
	                    for (var i = 0, l = _h[event].length; i < l; i++) {
	                        if (_h[event][i]['h'] != handler) {
	                            newList.push(_h[event][i]);
	                        }
	                    }
	                    _h[event] = newList;
	                }
	
	                if (_h[event] && _h[event].length === 0) {
	                    delete _h[event];
	                }
	            }
	            else {
	                delete _h[event];
	            }
	
	            return this;
	        },
	
	        /**
	         * 事件分发
	         *
	         * @param {string} type 事件类型
	         */
	        trigger: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 3) {
	                    args = arrySlice.call(args, 1);
	                }
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(_h[i]['ctx']);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(_h[i]['ctx'], args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 带有context的事件分发, 最后一个参数是事件回调的context
	         * @param {string} type 事件类型
	         */
	        triggerWithContext: function (type) {
	            if (this._$handlers[type]) {
	                var args = arguments;
	                var argLen = args.length;
	
	                if (argLen > 4) {
	                    args = arrySlice.call(args, 1, args.length - 1);
	                }
	                var ctx = args[args.length - 1];
	
	                var _h = this._$handlers[type];
	                var len = _h.length;
	                for (var i = 0; i < len;) {
	                    // Optimize advise from backbone
	                    switch (argLen) {
	                        case 1:
	                            _h[i]['h'].call(ctx);
	                            break;
	                        case 2:
	                            _h[i]['h'].call(ctx, args[1]);
	                            break;
	                        case 3:
	                            _h[i]['h'].call(ctx, args[1], args[2]);
	                            break;
	                        default:
	                            // have more than 2 given arguments
	                            _h[i]['h'].apply(ctx, args);
	                            break;
	                    }
	
	                    if (_h[i]['one']) {
	                        _h.splice(i, 1);
	                        len--;
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	
	            return this;
	        }
	    };
	
	    // 对象可以通过 onxxxx 绑定事件
	    /**
	     * @event module:zrender/mixin/Eventful#onclick
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseout
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousemove
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousewheel
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmousedown
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#onmouseup
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragstart
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragend
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragenter
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragleave
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondragover
	     * @type {Function}
	     * @default null
	     */
	    /**
	     * @event module:zrender/mixin/Eventful#ondrop
	     * @type {Function}
	     * @default null
	     */
	
	    module.exports = Eventful;
	


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 */
	
	    var Gradient = __webpack_require__(10);
	    // 用于处理merge时无法遍历Date等对象的问题
	    var BUILTIN_OBJECT = {
	        '[object Function]': 1,
	        '[object RegExp]': 1,
	        '[object Date]': 1,
	        '[object Error]': 1,
	        '[object CanvasGradient]': 1
	    };
	
	    var objToString = Object.prototype.toString;
	
	    var arrayProto = Array.prototype;
	    var nativeForEach = arrayProto.forEach;
	    var nativeFilter = arrayProto.filter;
	    var nativeSlice = arrayProto.slice;
	    var nativeMap = arrayProto.map;
	    var nativeReduce = arrayProto.reduce;
	
	    /**
	     * @param {*} source
	     * @return {*} 拷贝后的新对象
	     */
	    function clone(source) {
	        if (typeof source == 'object' && source !== null) {
	            var result = source;
	            if (source instanceof Array) {
	                result = [];
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	            else if (
	                !isBuildInObject(source)
	                // 是否为 dom 对象
	                && !isDom(source)
	            ) {
	                result = {};
	                for (var key in source) {
	                    if (source.hasOwnProperty(key)) {
	                        result[key] = clone(source[key]);
	                    }
	                }
	            }
	
	            return result;
	        }
	
	        return source;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolean} [overwrite=false]
	     */
	    function merge(target, source, overwrite) {
	        // We should escapse that source is string
	        // and enter for ... in ...
	        if (!isObject(source) || !isObject(target)) {
	            return overwrite ? clone(source) : target;
	        }
	
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                var targetProp = target[key];
	                var sourceProp = source[key];
	
	                if (isObject(sourceProp)
	                    && isObject(targetProp)
	                    && !isArray(sourceProp)
	                    && !isArray(targetProp)
	                    && !isDom(sourceProp)
	                    && !isDom(targetProp)
	                    && !isBuildInObject(sourceProp)
	                    && !isBuildInObject(targetProp)
	                ) {
	                    // 如果需要递归覆盖，就递归调用merge
	                    merge(targetProp, sourceProp, overwrite);
	                }
	                else if (overwrite || !(key in target)) {
	                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
	                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
	                    target[key] = clone(source[key], true);
	                }
	            }
	        }
	
	        return target;
	    }
	
	    /**
	     * @param {Array} targetAndSources The first item is target, and the rests are source.
	     * @param {boolean} [overwrite=false]
	     * @return {*} target
	     */
	    function mergeAll(targetAndSources, overwrite) {
	        var result = targetAndSources[0];
	        for (var i = 1, len = targetAndSources.length; i < len; i++) {
	            result = merge(result, targetAndSources[i], overwrite);
	        }
	        return result;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     */
	    function extend(target, source) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    /**
	     * @param {*} target
	     * @param {*} source
	     * @param {boolen} [overlay=false]
	     */
	    function defaults(target, source, overlay) {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)
	                && (overlay ? source[key] != null : target[key] == null)
	            ) {
	                target[key] = source[key];
	            }
	        }
	        return target;
	    }
	
	    function createCanvas() {
	        return document.createElement('canvas');
	    }
	    // FIXME
	    var _ctx;
	    function getContext() {
	        if (!_ctx) {
	            // Use util.createCanvas instead of createCanvas
	            // because createCanvas may be overwritten in different environment
	            _ctx = util.createCanvas().getContext('2d');
	        }
	        return _ctx;
	    }
	
	    /**
	     * 查询数组中元素的index
	     */
	    function indexOf(array, value) {
	        if (array) {
	            if (array.indexOf) {
	                return array.indexOf(value);
	            }
	            for (var i = 0, len = array.length; i < len; i++) {
	                if (array[i] === value) {
	                    return i;
	                }
	            }
	        }
	        return -1;
	    }
	
	    /**
	     * 构造类继承关系
	     *
	     * @param {Function} clazz 源类
	     * @param {Function} baseClazz 基类
	     */
	    function inherits(clazz, baseClazz) {
	        var clazzPrototype = clazz.prototype;
	        function F() {}
	        F.prototype = baseClazz.prototype;
	        clazz.prototype = new F();
	
	        for (var prop in clazzPrototype) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	        clazz.prototype.constructor = clazz;
	        clazz.superClass = baseClazz;
	    }
	
	    /**
	     * @param {Object|Function} target
	     * @param {Object|Function} sorce
	     * @param {boolean} overlay
	     */
	    function mixin(target, source, overlay) {
	        target = 'prototype' in target ? target.prototype : target;
	        source = 'prototype' in source ? source.prototype : source;
	
	        defaults(target, source, overlay);
	    }
	
	    /**
	     * @param {Array|TypedArray} data
	     */
	    function isArrayLike(data) {
	        if (! data) {
	            return;
	        }
	        if (typeof data == 'string') {
	            return false;
	        }
	        return typeof data.length == 'number';
	    }
	
	    /**
	     * 数组或对象遍历
	     * @memberOf module:zrender/tool/util
	     * @param {Object|Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     */
	    function each(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.forEach && obj.forEach === nativeForEach) {
	            obj.forEach(cb, context);
	        }
	        else if (obj.length === +obj.length) {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                cb.call(context, obj[i], i, obj);
	            }
	        }
	        else {
	            for (var key in obj) {
	                if (obj.hasOwnProperty(key)) {
	                    cb.call(context, obj[key], key, obj);
	                }
	            }
	        }
	    }
	
	    /**
	     * 数组映射
	     * @memberOf module:zrender/tool/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function map(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.map && obj.map === nativeMap) {
	            return obj.map(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                result.push(cb.call(context, obj[i], i, obj));
	            }
	            return result;
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {Object} [memo]
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function reduce(obj, cb, memo, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.reduce && obj.reduce === nativeReduce) {
	            return obj.reduce(cb, memo, context);
	        }
	        else {
	            for (var i = 0, len = obj.length; i < len; i++) {
	                memo = cb.call(context, memo, obj[i], i, obj);
	            }
	            return memo;
	        }
	    }
	
	    /**
	     * 数组过滤
	     * @memberOf module:zrender/tool/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function filter(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        if (obj.filter && obj.filter === nativeFilter) {
	            return obj.filter(cb, context);
	        }
	        else {
	            var result = [];
	            for (var i = 0, len = obj.length; i < len; i++) {
	                if (cb.call(context, obj[i], i, obj)) {
	                    result.push(obj[i]);
	                }
	            }
	            return result;
	        }
	    }
	
	    /**
	     * 数组项查找
	     * @memberOf module:zrender/tool/util
	     * @param {Array} obj
	     * @param {Function} cb
	     * @param {*} [context]
	     * @return {Array}
	     */
	    function find(obj, cb, context) {
	        if (!(obj && cb)) {
	            return;
	        }
	        for (var i = 0, len = obj.length; i < len; i++) {
	            if (cb.call(context, obj[i], i, obj)) {
	                return obj[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {Function} func
	     * @param {*} context
	     * @return {Function}
	     */
	    function bind(func, context) {
	        var args = nativeSlice.call(arguments, 2);
	        return function () {
	            return func.apply(context, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {Function} func
	     * @param {...}
	     * @return {Function}
	     */
	    function curry(func) {
	        var args = nativeSlice.call(arguments, 1);
	        return function () {
	            return func.apply(this, args.concat(nativeSlice.call(arguments)));
	        };
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isArray(value) {
	        return objToString.call(value) === '[object Array]';
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isFunction(value) {
	        return typeof value === 'function';
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isString(value) {
	        return objToString.call(value) === '[object String]';
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isObject(value) {
	        // Avoid a V8 JIT bug in Chrome 19-20.
	        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	        var type = typeof value;
	        return type === 'function' || (!!value && type == 'object');
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isBuildInObject(value) {
	        return !!BUILTIN_OBJECT[objToString.call(value)]
	            || (value instanceof Gradient);
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {*} value
	     * @return {boolean}
	     */
	    function isDom(value) {
	        return value && value.nodeType === 1
	               && typeof(value.nodeName) == 'string';
	    }
	
	    /**
	     * If value1 is not null, then return value1, otherwise judget rest of values.
	     * @param  {*...} values
	     * @return {*} Final value
	     */
	    function retrieve(values) {
	        for (var i = 0, len = arguments.length; i < len; i++) {
	            if (arguments[i] != null) {
	                return arguments[i];
	            }
	        }
	    }
	
	    /**
	     * @memberOf module:zrender/tool/util
	     * @param {Array} arr
	     * @param {number} startIndex
	     * @param {number} endIndex
	     * @return {Array}
	     */
	    function slice() {
	        return Function.call.apply(nativeSlice, arguments);
	    }
	
	    /**
	     * @param {boolean} condition
	     * @param {string} message
	     */
	    function assert(condition, message) {
	        if (!condition) {
	            throw new Error(message);
	        }
	    }
	
	    var util = {
	        inherits: inherits,
	        mixin: mixin,
	        clone: clone,
	        merge: merge,
	        mergeAll: mergeAll,
	        extend: extend,
	        defaults: defaults,
	        getContext: getContext,
	        createCanvas: createCanvas,
	        indexOf: indexOf,
	        slice: slice,
	        find: find,
	        isArrayLike: isArrayLike,
	        each: each,
	        map: map,
	        reduce: reduce,
	        filter: filter,
	        bind: bind,
	        curry: curry,
	        isArray: isArray,
	        isString: isString,
	        isObject: isObject,
	        isFunction: isFunction,
	        isBuildInObject: isBuildInObject,
	        isDom: isDom,
	        retrieve: retrieve,
	        assert: assert,
	        noop: function () {}
	    };
	    module.exports = util;
	


/***/ },
/* 10 */
/***/ function(module, exports) {

	
	
	    /**
	     * @param {Array.<Object>} colorStops
	     */
	    var Gradient = function (colorStops) {
	
	        this.colorStops = colorStops || [];
	    };
	
	    Gradient.prototype = {
	
	        constructor: Gradient,
	
	        addColorStop: function (offset, color) {
	            this.colorStops.push({
	
	                offset: offset,
	
	                color: color
	            });
	        }
	    };
	
	    module.exports = Gradient;


/***/ },
/* 11 */
/***/ function(module, exports) {

	// TODO Draggable for group
	// FIXME Draggable on element which has parent rotation or scale
	
	    function Draggable() {
	
	        this.on('mousedown', this._dragStart, this);
	        this.on('mousemove', this._drag, this);
	        this.on('mouseup', this._dragEnd, this);
	        this.on('globalout', this._dragEnd, this);
	        // this._dropTarget = null;
	        // this._draggingTarget = null;
	
	        // this._x = 0;
	        // this._y = 0;
	    }
	
	    Draggable.prototype = {
	
	        constructor: Draggable,
	
	        _dragStart: function (e) {
	            var draggingTarget = e.target;
	            if (draggingTarget && draggingTarget.draggable) {
	                this._draggingTarget = draggingTarget;
	                draggingTarget.dragging = true;
	                this._x = e.offsetX;
	                this._y = e.offsetY;
	
	                this._dispatchProxy(draggingTarget, 'dragstart', e.event);
	            }
	        },
	
	        _drag: function (e) {
	            var draggingTarget = this._draggingTarget;
	            if (draggingTarget) {
	
	                var x = e.offsetX;
	                var y = e.offsetY;
	
	                var dx = x - this._x;
	                var dy = y - this._y;
	                this._x = x;
	                this._y = y;
	
	                draggingTarget.drift(dx, dy, e);
	                this._dispatchProxy(draggingTarget, 'drag', e.event);
	
	                var dropTarget = this.findHover(x, y, draggingTarget);
	                var lastDropTarget = this._dropTarget;
	                this._dropTarget = dropTarget;
	
	                if (draggingTarget !== dropTarget) {
	                    if (lastDropTarget && dropTarget !== lastDropTarget) {
	                        this._dispatchProxy(lastDropTarget, 'dragleave', e.event);
	                    }
	                    if (dropTarget && dropTarget !== lastDropTarget) {
	                        this._dispatchProxy(dropTarget, 'dragenter', e.event);
	                    }
	                }
	            }
	        },
	
	        _dragEnd: function (e) {
	            var draggingTarget = this._draggingTarget;
	
	            if (draggingTarget) {
	                draggingTarget.dragging = false;
	            }
	
	            this._dispatchProxy(draggingTarget, 'dragend', e.event);
	
	            if (this._dropTarget) {
	                this._dispatchProxy(this._dropTarget, 'drop', e.event);
	            }
	
	            this._draggingTarget = null;
	            this._dropTarget = null;
	        }
	
	    };
	
	    module.exports = Draggable;


/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';
	/**
	 * Only implements needed gestures for mobile.
	 */
	
	
	    var GestureMgr = function () {
	
	        /**
	         * @private
	         * @type {Array.<Object>}
	         */
	        this._track = [];
	    };
	
	    GestureMgr.prototype = {
	
	        constructor: GestureMgr,
	
	        recognize: function (event, target) {
	            this._doTrack(event, target);
	            return this._recognize(event);
	        },
	
	        clear: function () {
	            this._track.length = 0;
	            return this;
	        },
	
	        _doTrack: function (event, target) {
	            var touches = event.touches;
	
	            if (!touches) {
	                return;
	            }
	
	            var trackItem = {
	                points: [],
	                touches: [],
	                target: target,
	                event: event
	            };
	
	            for (var i = 0, len = touches.length; i < len; i++) {
	                var touch = touches[i];
	                trackItem.points.push([touch.clientX, touch.clientY]);
	                trackItem.touches.push(touch);
	            }
	
	            this._track.push(trackItem);
	        },
	
	        _recognize: function (event) {
	            for (var eventName in recognizers) {
	                if (recognizers.hasOwnProperty(eventName)) {
	                    var gestureInfo = recognizers[eventName](this._track, event);
	                    if (gestureInfo) {
	                        return gestureInfo;
	                    }
	                }
	            }
	        }
	    };
	
	    function dist(pointPair) {
	        var dx = pointPair[1][0] - pointPair[0][0];
	        var dy = pointPair[1][1] - pointPair[0][1];
	
	        return Math.sqrt(dx * dx + dy * dy);
	    }
	
	    function center(pointPair) {
	        return [
	            (pointPair[0][0] + pointPair[1][0]) / 2,
	            (pointPair[0][1] + pointPair[1][1]) / 2
	        ];
	    }
	
	    var recognizers = {
	
	        pinch: function (track, event) {
	            var trackLen = track.length;
	
	            if (!trackLen) {
	                return;
	            }
	
	            var pinchEnd = (track[trackLen - 1] || {}).points;
	            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
	
	            if (pinchPre
	                && pinchPre.length > 1
	                && pinchEnd
	                && pinchEnd.length > 1
	            ) {
	                var pinchScale = dist(pinchEnd) / dist(pinchPre);
	                !isFinite(pinchScale) && (pinchScale = 1);
	
	                event.pinchScale = pinchScale;
	
	                var pinchCenter = center(pinchEnd);
	                event.pinchX = pinchCenter[0];
	                event.pinchY = pinchCenter[1];
	
	                return {
	                    type: 'pinch',
	                    target: track[0].target,
	                    event: event
	                };
	            }
	        }
	
	        // Only pinch currently.
	    };
	
	    module.exports = GestureMgr;
	


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Storage内容仓库模块
	 * @module zrender/Storage
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 * @author errorrik (errorrik@gmail.com)
	 * @author pissang (https://github.com/pissang/)
	 */
	
	
	    var util = __webpack_require__(9);
	
	    var Group = __webpack_require__(14);
	
	    function shapeCompareFunc(a, b) {
	        if (a.zlevel === b.zlevel) {
	            if (a.z === b.z) {
	                if (a.z2 === b.z2) {
	                    return a.__renderidx - b.__renderidx;
	                }
	                return a.z2 - b.z2;
	            }
	            return a.z - b.z;
	        }
	        return a.zlevel - b.zlevel;
	    }
	    /**
	     * 内容仓库 (M)
	     * @alias module:zrender/Storage
	     * @constructor
	     */
	    var Storage = function () {
	        // 所有常规形状，id索引的map
	        this._elements = {};
	
	        this._roots = [];
	
	        this._displayList = [];
	
	        this._displayListLen = 0;
	    };
	
	    Storage.prototype = {
	
	        constructor: Storage,
	
	        /**
	         * 返回所有图形的绘制队列
	         * @param {boolean} [update=false] 是否在返回前更新该数组
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
	         *
	         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
	         * @return {Array.<module:zrender/graphic/Displayable>}
	         */
	        getDisplayList: function (update, includeIgnore) {
	            includeIgnore = includeIgnore || false;
	            if (update) {
	                this.updateDisplayList(includeIgnore);
	            }
	            return this._displayList;
	        },
	
	        /**
	         * 更新图形的绘制队列。
	         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
	         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
	         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
	         */
	        updateDisplayList: function (includeIgnore) {
	            this._displayListLen = 0;
	            var roots = this._roots;
	            var displayList = this._displayList;
	            for (var i = 0, len = roots.length; i < len; i++) {
	                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	            }
	            displayList.length = this._displayListLen;
	
	            for (var i = 0, len = displayList.length; i < len; i++) {
	                displayList[i].__renderidx = i;
	            }
	
	            displayList.sort(shapeCompareFunc);
	        },
	
	        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
	
	            if (el.ignore && !includeIgnore) {
	                return;
	            }
	
	            el.beforeUpdate();
	
	            el.update();
	
	            el.afterUpdate();
	
	            var clipPath = el.clipPath;
	            if (clipPath) {
	                // clipPath 的变换是基于 group 的变换
	                clipPath.parent = el;
	                clipPath.updateTransform();
	
	                // FIXME 效率影响
	                if (clipPaths) {
	                    clipPaths = clipPaths.slice();
	                    clipPaths.push(clipPath);
	                }
	                else {
	                    clipPaths = [clipPath];
	                }
	            }
	
	            if (el.type == 'group') {
	                var children = el._children;
	
	                for (var i = 0; i < children.length; i++) {
	                    var child = children[i];
	
	                    // Force to mark as dirty if group is dirty
	                    // FIXME __dirtyPath ?
	                    child.__dirty = el.__dirty || child.__dirty;
	
	                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	                }
	
	                // Mark group clean here
	                el.__dirty = false;
	
	            }
	            else {
	                el.__clipPaths = clipPaths;
	
	                this._displayList[this._displayListLen++] = el;
	            }
	        },
	
	        /**
	         * 添加图形(Shape)或者组(Group)到根节点
	         * @param {module:zrender/Element} el
	         */
	        addRoot: function (el) {
	            // Element has been added
	            if (this._elements[el.id]) {
	                return;
	            }
	
	            if (el instanceof Group) {
	                el.addChildrenToStorage(this);
	            }
	
	            this.addToMap(el);
	            this._roots.push(el);
	        },
	
	        /**
	         * 删除指定的图形(Shape)或者组(Group)
	         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
	         */
	        delRoot: function (elId) {
	            if (elId == null) {
	                // 不指定elId清空
	                for (var i = 0; i < this._roots.length; i++) {
	                    var root = this._roots[i];
	                    if (root instanceof Group) {
	                        root.delChildrenFromStorage(this);
	                    }
	                }
	
	                this._elements = {};
	                this._roots = [];
	                this._displayList = [];
	                this._displayListLen = 0;
	
	                return;
	            }
	
	            if (elId instanceof Array) {
	                for (var i = 0, l = elId.length; i < l; i++) {
	                    this.delRoot(elId[i]);
	                }
	                return;
	            }
	
	            var el;
	            if (typeof(elId) == 'string') {
	                el = this._elements[elId];
	            }
	            else {
	                el = elId;
	            }
	
	            var idx = util.indexOf(this._roots, el);
	            if (idx >= 0) {
	                this.delFromMap(el.id);
	                this._roots.splice(idx, 1);
	                if (el instanceof Group) {
	                    el.delChildrenFromStorage(this);
	                }
	            }
	        },
	
	        addToMap: function (el) {
	            if (el instanceof Group) {
	                el.__storage = this;
	            }
	            el.dirty();
	
	            this._elements[el.id] = el;
	
	            return this;
	        },
	
	        get: function (elId) {
	            return this._elements[elId];
	        },
	
	        delFromMap: function (elId) {
	            var elements = this._elements;
	            var el = elements[elId];
	            if (el) {
	                delete elements[elId];
	                if (el instanceof Group) {
	                    el.__storage = null;
	                }
	            }
	
	            return this;
	        },
	
	        /**
	         * 清空并且释放Storage
	         */
	        dispose: function () {
	            this._elements =
	            this._renderList =
	            this._roots = null;
	        }
	    };
	
	    module.exports = Storage;
	


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
	 * @module zrender/graphic/Group
	 * @example
	 *     var Group = require('zrender/lib/container/Group');
	 *     var Circle = require('zrender/lib/graphic/shape/Circle');
	 *     var g = new Group();
	 *     g.position[0] = 100;
	 *     g.position[1] = 100;
	 *     g.add(new Circle({
	 *         style: {
	 *             x: 100,
	 *             y: 100,
	 *             r: 20,
	 *         }
	 *     }));
	 *     zr.add(g);
	 */
	
	
	    var zrUtil = __webpack_require__(9);
	    var Element = __webpack_require__(15);
	    var BoundingRect = __webpack_require__(26);
	
	    /**
	     * @alias module:zrender/graphic/Group
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @extends module:zrender/mixin/Eventful
	     */
	    var Group = function (opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        for (var key in opts) {
	            this[key] = opts[key];
	        }
	
	        this._children = [];
	
	        this.__storage = null;
	
	        this.__dirty = true;
	    };
	
	    Group.prototype = {
	
	        constructor: Group,
	
	        /**
	         * @type {string}
	         */
	        type: 'group',
	
	        /**
	         * @return {Array.<module:zrender/Element>}
	         */
	        children: function () {
	            return this._children.slice();
	        },
	
	        /**
	         * 获取指定 index 的儿子节点
	         * @param  {number} idx
	         * @return {module:zrender/Element}
	         */
	        childAt: function (idx) {
	            return this._children[idx];
	        },
	
	        /**
	         * 获取指定名字的儿子节点
	         * @param  {string} name
	         * @return {module:zrender/Element}
	         */
	        childOfName: function (name) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                if (children[i].name === name) {
	                    return children[i];
	                }
	             }
	        },
	
	        /**
	         * @return {number}
	         */
	        childCount: function () {
	            return this._children.length;
	        },
	
	        /**
	         * 添加子节点到最后
	         * @param {module:zrender/Element} child
	         */
	        add: function (child) {
	            if (child && child !== this && child.parent !== this) {
	
	                this._children.push(child);
	
	                this._doAdd(child);
	            }
	
	            return this;
	        },
	
	        /**
	         * 添加子节点在 nextSibling 之前
	         * @param {module:zrender/Element} child
	         * @param {module:zrender/Element} nextSibling
	         */
	        addBefore: function (child, nextSibling) {
	            if (child && child !== this && child.parent !== this
	                && nextSibling && nextSibling.parent === this) {
	
	                var children = this._children;
	                var idx = children.indexOf(nextSibling);
	
	                if (idx >= 0) {
	                    children.splice(idx, 0, child);
	                    this._doAdd(child);
	                }
	            }
	
	            return this;
	        },
	
	        _doAdd: function (child) {
	            if (child.parent) {
	                child.parent.remove(child);
	            }
	
	            child.parent = this;
	
	            var storage = this.__storage;
	            var zr = this.__zr;
	            if (storage && storage !== child.__storage) {
	
	                storage.addToMap(child);
	
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	        },
	
	        /**
	         * 移除子节点
	         * @param {module:zrender/Element} child
	         */
	        remove: function (child) {
	            var zr = this.__zr;
	            var storage = this.__storage;
	            var children = this._children;
	
	            var idx = zrUtil.indexOf(children, child);
	            if (idx < 0) {
	                return this;
	            }
	            children.splice(idx, 1);
	
	            child.parent = null;
	
	            if (storage) {
	
	                storage.delFromMap(child.id);
	
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	
	            zr && zr.refresh();
	
	            return this;
	        },
	
	        /**
	         * 移除所有子节点
	         */
	        removeAll: function () {
	            var children = this._children;
	            var storage = this.__storage;
	            var child;
	            var i;
	            for (i = 0; i < children.length; i++) {
	                child = children[i];
	                if (storage) {
	                    storage.delFromMap(child.id);
	                    if (child instanceof Group) {
	                        child.delChildrenFromStorage(storage);
	                    }
	                }
	                child.parent = null;
	            }
	            children.length = 0;
	
	            return this;
	        },
	
	        /**
	         * 遍历所有子节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        eachChild: function (cb, context) {
	            var children = this._children;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                cb.call(context, child, i);
	            }
	            return this;
	        },
	
	        /**
	         * 深度优先遍历所有子孙节点
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                cb.call(context, child);
	
	                if (child.type === 'group') {
	                    child.traverse(cb, context);
	                }
	            }
	            return this;
	        },
	
	        addChildrenToStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.addToMap(child);
	                if (child instanceof Group) {
	                    child.addChildrenToStorage(storage);
	                }
	            }
	        },
	
	        delChildrenFromStorage: function (storage) {
	            for (var i = 0; i < this._children.length; i++) {
	                var child = this._children[i];
	                storage.delFromMap(child.id);
	                if (child instanceof Group) {
	                    child.delChildrenFromStorage(storage);
	                }
	            }
	        },
	
	        dirty: function () {
	            this.__dirty = true;
	            this.__zr && this.__zr.refresh();
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function (includeChildren) {
	            // TODO Caching
	            // TODO Transform
	            var rect = null;
	            var tmpRect = new BoundingRect(0, 0, 0, 0);
	            var children = includeChildren || this._children;
	            var tmpMat = [];
	
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (child.ignore || child.invisible) {
	                    continue;
	                }
	
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            return rect || tmpRect;
	        }
	    };
	
	    zrUtil.inherits(Group, Element);
	
	    module.exports = Group;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/Element
	 */
	
	
	    var guid = __webpack_require__(4);
	    var Eventful = __webpack_require__(8);
	    var Transformable = __webpack_require__(16);
	    var Animatable = __webpack_require__(19);
	    var zrUtil = __webpack_require__(9);
	
	    /**
	     * @alias module:zrender/Element
	     * @constructor
	     * @extends {module:zrender/mixin/Animatable}
	     * @extends {module:zrender/mixin/Transformable}
	     * @extends {module:zrender/mixin/Eventful}
	     */
	    var Element = function (opts) {
	
	        Transformable.call(this, opts);
	        Eventful.call(this, opts);
	        Animatable.call(this, opts);
	
	        /**
	         * 画布元素ID
	         * @type {string}
	         */
	        this.id = opts.id || guid();
	    };
	
	    Element.prototype = {
	
	        /**
	         * 元素类型
	         * Element type
	         * @type {string}
	         */
	        type: 'element',
	
	        /**
	         * 元素名字
	         * Element name
	         * @type {string}
	         */
	        name: '',
	
	        /**
	         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
	         * ZRender instance will be assigned when element is associated with zrender
	         * @name module:/zrender/Element#__zr
	         * @type {module:zrender/ZRender}
	         */
	        __zr: null,
	
	        /**
	         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
	         * If ignore drawing and events of the element object
	         * @name module:/zrender/Element#ignore
	         * @type {boolean}
	         * @default false
	         */
	        ignore: false,
	
	        /**
	         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
	         * 该路径会继承被裁减对象的变换
	         * @type {module:zrender/graphic/Path}
	         * @see http://www.w3.org/TR/2dcontext/#clipping-region
	         * @readOnly
	         */
	        clipPath: null,
	
	        /**
	         * Drift element
	         * @param  {number} dx dx on the global space
	         * @param  {number} dy dy on the global space
	         */
	        drift: function (dx, dy) {
	            switch (this.draggable) {
	                case 'horizontal':
	                    dy = 0;
	                    break;
	                case 'vertical':
	                    dx = 0;
	                    break;
	            }
	
	            var m = this.transform;
	            if (!m) {
	                m = this.transform = [1, 0, 0, 1, 0, 0];
	            }
	            m[4] += dx;
	            m[5] += dy;
	
	            this.decomposeTransform();
	            this.dirty();
	        },
	
	        /**
	         * Hook before update
	         */
	        beforeUpdate: function () {},
	        /**
	         * Hook after update
	         */
	        afterUpdate: function () {},
	        /**
	         * Update each frame
	         */
	        update: function () {
	            this.updateTransform();
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {},
	
	        /**
	         * @protected
	         */
	        attrKV: function (key, value) {
	            if (key === 'position' || key === 'scale' || key === 'origin') {
	                // Copy the array
	                if (value) {
	                    var target = this[key];
	                    if (!target) {
	                        target = this[key] = [];
	                    }
	                    target[0] = value[0];
	                    target[1] = value[1];
	                }
	            }
	            else {
	                this[key] = value;
	            }
	        },
	
	        /**
	         * Hide the element
	         */
	        hide: function () {
	            this.ignore = true;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * Show the element
	         */
	        show: function () {
	            this.ignore = false;
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * @param {string|Object} key
	         * @param {*} value
	         */
	        attr: function (key, value) {
	            if (typeof key === 'string') {
	                this.attrKV(key, value);
	            }
	            else if (zrUtil.isObject(key)) {
	                for (var name in key) {
	                    if (key.hasOwnProperty(name)) {
	                        this.attrKV(name, key[name]);
	                    }
	                }
	            }
	            this.dirty();
	
	            return this;
	        },
	
	        /**
	         * @param {module:zrender/graphic/Path} clipPath
	         */
	        setClipPath: function (clipPath) {
	            var zr = this.__zr;
	            if (zr) {
	                clipPath.addSelfToZr(zr);
	            }
	
	            // Remove previous clip path
	            if (this.clipPath && this.clipPath !== clipPath) {
	                this.removeClipPath();
	            }
	
	            this.clipPath = clipPath;
	            clipPath.__zr = zr;
	            clipPath.__clipTarget = this;
	
	            this.dirty();
	        },
	
	        /**
	         */
	        removeClipPath: function () {
	            var clipPath = this.clipPath;
	            if (clipPath) {
	                if (clipPath.__zr) {
	                    clipPath.removeSelfFromZr(clipPath.__zr);
	                }
	
	                clipPath.__zr = null;
	                clipPath.__clipTarget = null;
	                this.clipPath = null;
	
	                this.dirty();
	            }
	        },
	
	        /**
	         * Add self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        addSelfToZr: function (zr) {
	            this.__zr = zr;
	            // 添加动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.addAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.addSelfToZr(zr);
	            }
	        },
	
	        /**
	         * Remove self from zrender instance.
	         * Not recursively because it will be invoked when element added to storage.
	         * @param {module:zrender/ZRender} zr
	         */
	        removeSelfFromZr: function (zr) {
	            this.__zr = null;
	            // 移除动画
	            var animators = this.animators;
	            if (animators) {
	                for (var i = 0; i < animators.length; i++) {
	                    zr.animation.removeAnimator(animators[i]);
	                }
	            }
	
	            if (this.clipPath) {
	                this.clipPath.removeSelfFromZr(zr);
	            }
	        }
	    };
	
	    zrUtil.mixin(Element, Animatable);
	    zrUtil.mixin(Element, Transformable);
	    zrUtil.mixin(Element, Eventful);
	
	    module.exports = Element;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 提供变换扩展
	 * @module zrender/mixin/Transformable
	 * @author pissang (https://www.github.com/pissang)
	 */
	
	
	    var matrix = __webpack_require__(17);
	    var vector = __webpack_require__(18);
	    var mIdentity = matrix.identity;
	
	    var EPSILON = 5e-5;
	
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	
	    /**
	     * @alias module:zrender/mixin/Transformable
	     * @constructor
	     */
	    var Transformable = function (opts) {
	        opts = opts || {};
	        // If there are no given position, rotation, scale
	        if (!opts.position) {
	            /**
	             * 平移
	             * @type {Array.<number>}
	             * @default [0, 0]
	             */
	            this.position = [0, 0];
	        }
	        if (opts.rotation == null) {
	            /**
	             * 旋转
	             * @type {Array.<number>}
	             * @default 0
	             */
	            this.rotation = 0;
	        }
	        if (!opts.scale) {
	            /**
	             * 缩放
	             * @type {Array.<number>}
	             * @default [1, 1]
	             */
	            this.scale = [1, 1];
	        }
	        /**
	         * 旋转和缩放的原点
	         * @type {Array.<number>}
	         * @default null
	         */
	        this.origin = this.origin || null;
	    };
	
	    var transformableProto = Transformable.prototype;
	    transformableProto.transform = null;
	
	    /**
	     * 判断是否需要有坐标变换
	     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
	     */
	    transformableProto.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.position[0])
	            || isNotAroundZero(this.position[1])
	            || isNotAroundZero(this.scale[0] - 1)
	            || isNotAroundZero(this.scale[1] - 1);
	    };
	
	    transformableProto.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	
	        m = m || matrix.create();
	
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	
	        // 应用父节点变换
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        // 保存这个变换矩阵
	        this.transform = m;
	
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	
	    transformableProto.getLocalTransform = function (m) {
	        m = m || [];
	        mIdentity(m);
	
	        var origin = this.origin;
	
	        var scale = this.scale;
	        var rotation = this.rotation;
	        var position = this.position;
	        if (origin) {
	            // Translate to origin
	            m[4] -= origin[0];
	            m[5] -= origin[1];
	        }
	        matrix.scale(m, m, scale);
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        if (origin) {
	            // Translate back from origin
	            m[4] += origin[0];
	            m[5] += origin[1];
	        }
	
	        m[4] += position[0];
	        m[5] += position[1];
	
	        return m;
	    };
	    /**
	     * 将自己的transform应用到context上
	     * @param {Context2D} ctx
	     */
	    transformableProto.setTransform = function (ctx) {
	        var m = this.transform;
	        if (m) {
	            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	        }
	    };
	
	    var tmpTransform = [];
	
	    /**
	     * 分解`transform`矩阵到`position`, `rotation`, `scale`
	     */
	    transformableProto.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            // Get local transform and decompose them to position, scale, rotation
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        var position = this.position;
	        var scale = this.scale;
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        position[0] = m[4];
	        position[1] = m[5];
	        scale[0] = sx;
	        scale[1] = sy;
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	    };
	
	    /**
	     * 变换坐标位置到 shape 的局部坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	
	    /**
	     * 变换局部坐标位置到全局坐标空间
	     * @method
	     * @param {number} x
	     * @param {number} y
	     * @return {Array.<number>}
	     */
	    transformableProto.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	
	    module.exports = Transformable;
	


/***/ },
/* 17 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	    /**
	     * 3x2矩阵操作类
	     * @exports zrender/tool/matrix
	     */
	    var matrix = {
	        /**
	         * 创建一个单位矩阵
	         * @return {Float32Array|Array.<number>}
	         */
	        create : function() {
	            var out = new ArrayCtor(6);
	            matrix.identity(out);
	
	            return out;
	        },
	        /**
	         * 设置矩阵为单位矩阵
	         * @param {Float32Array|Array.<number>} out
	         */
	        identity : function(out) {
	            out[0] = 1;
	            out[1] = 0;
	            out[2] = 0;
	            out[3] = 1;
	            out[4] = 0;
	            out[5] = 0;
	            return out;
	        },
	        /**
	         * 复制矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m
	         */
	        copy: function(out, m) {
	            out[0] = m[0];
	            out[1] = m[1];
	            out[2] = m[2];
	            out[3] = m[3];
	            out[4] = m[4];
	            out[5] = m[5];
	            return out;
	        },
	        /**
	         * 矩阵相乘
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} m1
	         * @param {Float32Array|Array.<number>} m2
	         */
	        mul : function (out, m1, m2) {
	            // Consider matrix.mul(m, m2, m);
	            // where out is the same as m2.
	            // So use temp variable to escape error.
	            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	            out[0] = out0;
	            out[1] = out1;
	            out[2] = out2;
	            out[3] = out3;
	            out[4] = out4;
	            out[5] = out5;
	            return out;
	        },
	        /**
	         * 平移变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        translate : function(out, a, v) {
	            out[0] = a[0];
	            out[1] = a[1];
	            out[2] = a[2];
	            out[3] = a[3];
	            out[4] = a[4] + v[0];
	            out[5] = a[5] + v[1];
	            return out;
	        },
	        /**
	         * 旋转变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {number} rad
	         */
	        rotate : function(out, a, rad) {
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	            var st = Math.sin(rad);
	            var ct = Math.cos(rad);
	
	            out[0] = aa * ct + ab * st;
	            out[1] = -aa * st + ab * ct;
	            out[2] = ac * ct + ad * st;
	            out[3] = -ac * st + ct * ad;
	            out[4] = ct * atx + st * aty;
	            out[5] = ct * aty - st * atx;
	            return out;
	        },
	        /**
	         * 缩放变换
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         * @param {Float32Array|Array.<number>} v
	         */
	        scale : function(out, a, v) {
	            var vx = v[0];
	            var vy = v[1];
	            out[0] = a[0] * vx;
	            out[1] = a[1] * vy;
	            out[2] = a[2] * vx;
	            out[3] = a[3] * vy;
	            out[4] = a[4] * vx;
	            out[5] = a[5] * vy;
	            return out;
	        },
	        /**
	         * 求逆矩阵
	         * @param {Float32Array|Array.<number>} out
	         * @param {Float32Array|Array.<number>} a
	         */
	        invert : function(out, a) {
	
	            var aa = a[0];
	            var ac = a[2];
	            var atx = a[4];
	            var ab = a[1];
	            var ad = a[3];
	            var aty = a[5];
	
	            var det = aa * ad - ab * ac;
	            if (!det) {
	                return null;
	            }
	            det = 1.0 / det;
	
	            out[0] = ad * det;
	            out[1] = -ab * det;
	            out[2] = -ac * det;
	            out[3] = aa * det;
	            out[4] = (ac * aty - ad * atx) * det;
	            out[5] = (ab * atx - aa * aty) * det;
	            return out;
	        }
	    };
	
	    module.exports = matrix;
	


/***/ },
/* 18 */
/***/ function(module, exports) {

	
	    var ArrayCtor = typeof Float32Array === 'undefined'
	        ? Array
	        : Float32Array;
	
	    /**
	     * @typedef {Float32Array|Array.<number>} Vector2
	     */
	    /**
	     * 二维向量类
	     * @exports zrender/tool/vector
	     */
	    var vector = {
	        /**
	         * 创建一个向量
	         * @param {number} [x=0]
	         * @param {number} [y=0]
	         * @return {Vector2}
	         */
	        create: function (x, y) {
	            var out = new ArrayCtor(2);
	            out[0] = x || 0;
	            out[1] = y || 0;
	            return out;
	        },
	
	        /**
	         * 复制向量数据
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        copy: function (out, v) {
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 克隆一个向量
	         * @param {Vector2} v
	         * @return {Vector2}
	         */
	        clone: function (v) {
	            var out = new ArrayCtor(2);
	            out[0] = v[0];
	            out[1] = v[1];
	            return out;
	        },
	
	        /**
	         * 设置向量的两个项
	         * @param {Vector2} out
	         * @param {number} a
	         * @param {number} b
	         * @return {Vector2} 结果
	         */
	        set: function (out, a, b) {
	            out[0] = a;
	            out[1] = b;
	            return out;
	        },
	
	        /**
	         * 向量相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        add: function (out, v1, v2) {
	            out[0] = v1[0] + v2[0];
	            out[1] = v1[1] + v2[1];
	            return out;
	        },
	
	        /**
	         * 向量缩放后相加
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} a
	         */
	        scaleAndAdd: function (out, v1, v2, a) {
	            out[0] = v1[0] + v2[0] * a;
	            out[1] = v1[1] + v2[1] * a;
	            return out;
	        },
	
	        /**
	         * 向量相减
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        sub: function (out, v1, v2) {
	            out[0] = v1[0] - v2[0];
	            out[1] = v1[1] - v2[1];
	            return out;
	        },
	
	        /**
	         * 向量长度
	         * @param {Vector2} v
	         * @return {number}
	         */
	        len: function (v) {
	            return Math.sqrt(this.lenSquare(v));
	        },
	
	        /**
	         * 向量长度平方
	         * @param {Vector2} v
	         * @return {number}
	         */
	        lenSquare: function (v) {
	            return v[0] * v[0] + v[1] * v[1];
	        },
	
	        /**
	         * 向量乘法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        mul: function (out, v1, v2) {
	            out[0] = v1[0] * v2[0];
	            out[1] = v1[1] * v2[1];
	            return out;
	        },
	
	        /**
	         * 向量除法
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         */
	        div: function (out, v1, v2) {
	            out[0] = v1[0] / v2[0];
	            out[1] = v1[1] / v2[1];
	            return out;
	        },
	
	        /**
	         * 向量点乘
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        dot: function (v1, v2) {
	            return v1[0] * v2[0] + v1[1] * v2[1];
	        },
	
	        /**
	         * 向量缩放
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {number} s
	         */
	        scale: function (out, v, s) {
	            out[0] = v[0] * s;
	            out[1] = v[1] * s;
	            return out;
	        },
	
	        /**
	         * 向量归一化
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        normalize: function (out, v) {
	            var d = vector.len(v);
	            if (d === 0) {
	                out[0] = 0;
	                out[1] = 0;
	            }
	            else {
	                out[0] = v[0] / d;
	                out[1] = v[1] / d;
	            }
	            return out;
	        },
	
	        /**
	         * 计算向量间距离
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distance: function (v1, v2) {
	            return Math.sqrt(
	                (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1])
	            );
	        },
	
	        /**
	         * 向量距离平方
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @return {number}
	         */
	        distanceSquare: function (v1, v2) {
	            return (v1[0] - v2[0]) * (v1[0] - v2[0])
	                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	        },
	
	        /**
	         * 求负向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         */
	        negate: function (out, v) {
	            out[0] = -v[0];
	            out[1] = -v[1];
	            return out;
	        },
	
	        /**
	         * 插值两个点
	         * @param {Vector2} out
	         * @param {Vector2} v1
	         * @param {Vector2} v2
	         * @param {number} t
	         */
	        lerp: function (out, v1, v2, t) {
	            out[0] = v1[0] + t * (v2[0] - v1[0]);
	            out[1] = v1[1] + t * (v2[1] - v1[1]);
	            return out;
	        },
	
	        /**
	         * 矩阵左乘向量
	         * @param {Vector2} out
	         * @param {Vector2} v
	         * @param {Vector2} m
	         */
	        applyTransform: function (out, v, m) {
	            var x = v[0];
	            var y = v[1];
	            out[0] = m[0] * x + m[2] * y + m[4];
	            out[1] = m[1] * x + m[3] * y + m[5];
	            return out;
	        },
	        /**
	         * 求两个向量最小值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        min: function (out, v1, v2) {
	            out[0] = Math.min(v1[0], v2[0]);
	            out[1] = Math.min(v1[1], v2[1]);
	            return out;
	        },
	        /**
	         * 求两个向量最大值
	         * @param  {Vector2} out
	         * @param  {Vector2} v1
	         * @param  {Vector2} v2
	         */
	        max: function (out, v1, v2) {
	            out[0] = Math.max(v1[0], v2[0]);
	            out[1] = Math.max(v1[1], v2[1]);
	            return out;
	        }
	    };
	
	    vector.length = vector.len;
	    vector.lengthSquare = vector.lenSquare;
	    vector.dist = vector.distance;
	    vector.distSquare = vector.distanceSquare;
	
	    module.exports = vector;
	


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module zrender/mixin/Animatable
	 */
	
	
	    var Animator = __webpack_require__(20);
	    var util = __webpack_require__(9);
	    var isString = util.isString;
	    var isFunction = util.isFunction;
	    var isObject = util.isObject;
	    var log = __webpack_require__(24);
	
	    /**
	     * @alias modue:zrender/mixin/Animatable
	     * @constructor
	     */
	    var Animatable = function () {
	
	        /**
	         * @type {Array.<module:zrender/animation/Animator>}
	         * @readOnly
	         */
	        this.animators = [];
	    };
	
	    Animatable.prototype = {
	
	        constructor: Animatable,
	
	        /**
	         * 动画
	         *
	         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
	         * @param {boolean} [loop] 动画是否循环
	         * @return {module:zrender/animation/Animator}
	         * @example:
	         *     el.animate('style', false)
	         *         .when(1000, {x: 10} )
	         *         .done(function(){ // Animation done })
	         *         .start()
	         */
	        animate: function (path, loop) {
	            var target;
	            var animatingShape = false;
	            var el = this;
	            var zr = this.__zr;
	            if (path) {
	                var pathSplitted = path.split('.');
	                var prop = el;
	                // If animating shape
	                animatingShape = pathSplitted[0] === 'shape';
	                for (var i = 0, l = pathSplitted.length; i < l; i++) {
	                    if (!prop) {
	                        continue;
	                    }
	                    prop = prop[pathSplitted[i]];
	                }
	                if (prop) {
	                    target = prop;
	                }
	            }
	            else {
	                target = el;
	            }
	
	            if (!target) {
	                log(
	                    'Property "'
	                    + path
	                    + '" is not existed in element '
	                    + el.id
	                );
	                return;
	            }
	
	            var animators = el.animators;
	
	            var animator = new Animator(target, loop);
	
	            animator.during(function (target) {
	                el.dirty(animatingShape);
	            })
	            .done(function () {
	                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
	                animators.splice(util.indexOf(animators, animator), 1);
	            });
	
	            animators.push(animator);
	
	            // If animate after added to the zrender
	            if (zr) {
	                zr.animation.addAnimator(animator);
	            }
	
	            return animator;
	        },
	
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stopAnimation: function (forwardToLast) {
	            var animators = this.animators;
	            var len = animators.length;
	            for (var i = 0; i < len; i++) {
	                animators[i].stop(forwardToLast);
	            }
	            animators.length = 0;
	
	            return this;
	        },
	
	        /**
	         * @param {Object} target
	         * @param {number} [time=500] Time in ms
	         * @param {string} [easing='linear']
	         * @param {number} [delay=0]
	         * @param {Function} [callback]
	         *
	         * @example
	         *  // Animate position
	         *  el.animateTo({
	         *      position: [10, 10]
	         *  }, function () { // done })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
	         *  el.animateTo({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100, 'cubicOut', function () { // done })
	         */
	         // TODO Return animation key
	        animateTo: function (target, time, delay, easing, callback) {
	            // animateTo(target, time, easing, callback);
	            if (isString(delay)) {
	                callback = easing;
	                easing = delay;
	                delay = 0;
	            }
	            // animateTo(target, time, delay, callback);
	            else if (isFunction(easing)) {
	                callback = easing;
	                easing = 'linear';
	                delay = 0;
	            }
	            // animateTo(target, time, callback);
	            else if (isFunction(delay)) {
	                callback = delay;
	                delay = 0;
	            }
	            // animateTo(target, callback)
	            else if (isFunction(time)) {
	                callback = time;
	                time = 500;
	            }
	            // animateTo(target)
	            else if (!time) {
	                time = 500;
	            }
	            // Stop all previous animations
	            this.stopAnimation();
	            this._animateToShallow('', this, target, time, delay, easing, callback);
	
	            // Animators may be removed immediately after start
	            // if there is nothing to animate
	            var animators = this.animators.slice();
	            var count = animators.length;
	            function done() {
	                count--;
	                if (!count) {
	                    callback && callback();
	                }
	            }
	
	            // No animators. This should be checked before animators[i].start(),
	            // because 'done' may be executed immediately if no need to animate.
	            if (!count) {
	                callback && callback();
	            }
	            // Start after all animators created
	            // Incase any animator is done immediately when all animation properties are not changed
	            for (var i = 0; i < animators.length; i++) {
	                animators[i]
	                    .done(done)
	                    .start(easing);
	            }
	        },
	
	        /**
	         * @private
	         * @param {string} path=''
	         * @param {Object} source=this
	         * @param {Object} target
	         * @param {number} [time=500]
	         * @param {number} [delay=0]
	         *
	         * @example
	         *  // Animate position
	         *  el._animateToShallow({
	         *      position: [10, 10]
	         *  })
	         *
	         *  // Animate shape, style and position in 100ms, delayed 100ms
	         *  el._animateToShallow({
	         *      shape: {
	         *          width: 500
	         *      },
	         *      style: {
	         *          fill: 'red'
	         *      }
	         *      position: [10, 10]
	         *  }, 100, 100)
	         */
	        _animateToShallow: function (path, source, target, time, delay) {
	            var objShallow = {};
	            var propertyCount = 0;
	            for (var name in target) {
	                if (source[name] != null) {
	                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
	                        this._animateToShallow(
	                            path ? path + '.' + name : name,
	                            source[name],
	                            target[name],
	                            time,
	                            delay
	                        );
	                    }
	                    else {
	                        objShallow[name] = target[name];
	                        propertyCount++;
	                    }
	                }
	                else if (target[name] != null) {
	                    // Attr directly if not has property
	                    // FIXME, if some property not needed for element ?
	                    if (!path) {
	                        this.attr(name, target[name]);
	                    }
	                    else {  // Shape or style
	                        var props = {};
	                        props[path] = {};
	                        props[path][name] = target[name];
	                        this.attr(props);
	                    }
	                }
	            }
	
	            if (propertyCount > 0) {
	                this.animate(path, false)
	                    .when(time == null ? 500 : time, objShallow)
	                    .delay(delay || 0);
	            }
	
	            return this;
	        }
	    };
	
	    module.exports = Animatable;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module echarts/animation/Animator
	 */
	
	
	    var Clip = __webpack_require__(21);
	    var color = __webpack_require__(23);
	    var util = __webpack_require__(9);
	    var isArrayLike = util.isArrayLike;
	
	    var arraySlice = Array.prototype.slice;
	
	    function defaultGetter(target, key) {
	        return target[key];
	    }
	
	    function defaultSetter(target, key, value) {
	        target[key] = value;
	    }
	
	    /**
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} percent
	     * @return {number}
	     */
	    function interpolateNumber(p0, p1, percent) {
	        return (p1 - p0) * percent + p0;
	    }
	
	    /**
	     * @param  {string} p0
	     * @param  {string} p1
	     * @param  {number} percent
	     * @return {string}
	     */
	    function interpolateString(p0, p1, percent) {
	        return percent > 0.5 ? p1 : p0;
	    }
	
	    /**
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {number} percent
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function interpolateArray(p0, p1, percent, out, arrDim) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = interpolateNumber(p0[i], p1[i], percent);
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = interpolateNumber(
	                        p0[i][j], p1[i][j], percent
	                    );
	                }
	            }
	        }
	    }
	
	    function fillArr(arr0, arr1, arrDim) {
	        var arr0Len = arr0.length;
	        var arr1Len = arr1.length;
	        if (arr0Len === arr1Len) {
	            return;
	        }
	        // FIXME Not work for TypedArray
	        var isPreviousLarger = arr0Len > arr1Len;
	        if (isPreviousLarger) {
	            // Cut the previous
	            arr0.length = arr1Len;
	        }
	        else {
	            // Fill the previous
	            for (var i = arr0Len; i < arr1Len; i++) {
	                arr0.push(
	                    arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
	                );
	            }
	        }
	    }
	
	    /**
	     * @param  {Array} arr0
	     * @param  {Array} arr1
	     * @param  {number} arrDim
	     * @return {boolean}
	     */
	    function isArraySame(arr0, arr1, arrDim) {
	        if (arr0 === arr1) {
	            return true;
	        }
	        var len = arr0.length;
	        if (len !== arr1.length) {
	            return false;
	        }
	        if (arrDim === 1) {
	            for (var i = 0; i < len; i++) {
	                if (arr0[i] !== arr1[i]) {
	                    return false;
	                }
	            }
	        }
	        else {
	            var len2 = arr0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    if (arr0[i][j] !== arr1[i][j]) {
	                        return false;
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /**
	     * Catmull Rom interpolate array
	     * @param  {Array} p0
	     * @param  {Array} p1
	     * @param  {Array} p2
	     * @param  {Array} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @param  {Array} out
	     * @param  {number} arrDim
	     */
	    function catmullRomInterpolateArray(
	        p0, p1, p2, p3, t, t2, t3, out, arrDim
	    ) {
	        var len = p0.length;
	        if (arrDim == 1) {
	            for (var i = 0; i < len; i++) {
	                out[i] = catmullRomInterpolate(
	                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
	                );
	            }
	        }
	        else {
	            var len2 = p0[0].length;
	            for (var i = 0; i < len; i++) {
	                for (var j = 0; j < len2; j++) {
	                    out[i][j] = catmullRomInterpolate(
	                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
	                        t, t2, t3
	                    );
	                }
	            }
	        }
	    }
	
	    /**
	     * Catmull Rom interpolate number
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {number} t2
	     * @param  {number} t3
	     * @return {number}
	     */
	    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    function cloneValue(value) {
	        if (isArrayLike(value)) {
	            var len = value.length;
	            if (isArrayLike(value[0])) {
	                var ret = [];
	                for (var i = 0; i < len; i++) {
	                    ret.push(arraySlice.call(value[i]));
	                }
	                return ret;
	            }
	
	            return arraySlice.call(value);
	        }
	
	        return value;
	    }
	
	    function rgba2String(rgba) {
	        rgba[0] = Math.floor(rgba[0]);
	        rgba[1] = Math.floor(rgba[1]);
	        rgba[2] = Math.floor(rgba[2]);
	
	        return 'rgba(' + rgba.join(',') + ')';
	    }
	
	    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
	        var getter = animator._getter;
	        var setter = animator._setter;
	        var useSpline = easing === 'spline';
	
	        var trackLen = keyframes.length;
	        if (!trackLen) {
	            return;
	        }
	        // Guess data type
	        var firstVal = keyframes[0].value;
	        var isValueArray = isArrayLike(firstVal);
	        var isValueColor = false;
	        var isValueString = false;
	
	        // For vertices morphing
	        var arrDim = (
	                isValueArray
	                && isArrayLike(firstVal[0])
	            )
	            ? 2 : 1;
	        var trackMaxTime;
	        // Sort keyframe as ascending
	        keyframes.sort(function(a, b) {
	            return a.time - b.time;
	        });
	
	        trackMaxTime = keyframes[trackLen - 1].time;
	        // Percents of each keyframe
	        var kfPercents = [];
	        // Value of each keyframe
	        var kfValues = [];
	        var prevValue = keyframes[0].value;
	        var isAllValueEqual = true;
	        for (var i = 0; i < trackLen; i++) {
	            kfPercents.push(keyframes[i].time / trackMaxTime);
	            // Assume value is a color when it is a string
	            var value = keyframes[i].value;
	
	            // Check if value is equal, deep check if value is array
	            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
	                || (!isValueArray && value === prevValue))) {
	                isAllValueEqual = false;
	            }
	            prevValue = value;
	
	            // Try converting a string to a color array
	            if (typeof value == 'string') {
	                var colorArray = color.parse(value);
	                if (colorArray) {
	                    value = colorArray;
	                    isValueColor = true;
	                }
	                else {
	                    isValueString = true;
	                }
	            }
	            kfValues.push(value);
	        }
	        if (isAllValueEqual) {
	            return;
	        }
	
	        if (isValueArray) {
	            var lastValue = kfValues[trackLen - 1];
	            // Polyfill array
	            for (var i = 0; i < trackLen - 1; i++) {
	                fillArr(kfValues[i], lastValue, arrDim);
	            }
	            fillArr(getter(animator._target, propName), lastValue, arrDim);
	        }
	
	        // Cache the key of last frame to speed up when
	        // animation playback is sequency
	        var lastFrame = 0;
	        var lastFramePercent = 0;
	        var start;
	        var w;
	        var p0;
	        var p1;
	        var p2;
	        var p3;
	
	        if (isValueColor) {
	            var rgba = [0, 0, 0, 0];
	        }
	
	        var onframe = function (target, percent) {
	            // Find the range keyframes
	            // kf1-----kf2---------current--------kf3
	            // find kf2 and kf3 and do interpolation
	            var frame;
	            if (percent < lastFramePercent) {
	                // Start from next key
	                start = Math.min(lastFrame + 1, trackLen - 1);
	                for (frame = start; frame >= 0; frame--) {
	                    if (kfPercents[frame] <= percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame, trackLen - 2);
	            }
	            else {
	                for (frame = lastFrame; frame < trackLen; frame++) {
	                    if (kfPercents[frame] > percent) {
	                        break;
	                    }
	                }
	                frame = Math.min(frame - 1, trackLen - 2);
	            }
	            lastFrame = frame;
	            lastFramePercent = percent;
	
	            var range = (kfPercents[frame + 1] - kfPercents[frame]);
	            if (range === 0) {
	                return;
	            }
	            else {
	                w = (percent - kfPercents[frame]) / range;
	            }
	            if (useSpline) {
	                p1 = kfValues[frame];
	                p0 = kfValues[frame === 0 ? frame : frame - 1];
	                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
	                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
	                if (isValueArray) {
	                    catmullRomInterpolateArray(
	                        p0, p1, p2, p3, w, w * w, w * w * w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        value = catmullRomInterpolateArray(
	                            p0, p1, p2, p3, w, w * w, w * w * w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(p1, p2, w);
	                    }
	                    else {
	                        value = catmullRomInterpolate(
	                            p0, p1, p2, p3, w, w * w, w * w * w
	                        );
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	            else {
	                if (isValueArray) {
	                    interpolateArray(
	                        kfValues[frame], kfValues[frame + 1], w,
	                        getter(target, propName),
	                        arrDim
	                    );
	                }
	                else {
	                    var value;
	                    if (isValueColor) {
	                        interpolateArray(
	                            kfValues[frame], kfValues[frame + 1], w,
	                            rgba, 1
	                        );
	                        value = rgba2String(rgba);
	                    }
	                    else if (isValueString) {
	                        // String is step(0.5)
	                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    else {
	                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
	                    }
	                    setter(
	                        target,
	                        propName,
	                        value
	                    );
	                }
	            }
	        };
	
	        var clip = new Clip({
	            target: animator._target,
	            life: trackMaxTime,
	            loop: animator._loop,
	            delay: animator._delay,
	            onframe: onframe,
	            ondestroy: oneTrackDone
	        });
	
	        if (easing && easing !== 'spline') {
	            clip.easing = easing;
	        }
	
	        return clip;
	    }
	
	    /**
	     * @alias module:zrender/animation/Animator
	     * @constructor
	     * @param {Object} target
	     * @param {boolean} loop
	     * @param {Function} getter
	     * @param {Function} setter
	     */
	    var Animator = function(target, loop, getter, setter) {
	        this._tracks = {};
	        this._target = target;
	
	        this._loop = loop || false;
	
	        this._getter = getter || defaultGetter;
	        this._setter = setter || defaultSetter;
	
	        this._clipCount = 0;
	
	        this._delay = 0;
	
	        this._doneList = [];
	
	        this._onframeList = [];
	
	        this._clipList = [];
	    };
	
	    Animator.prototype = {
	        /**
	         * 设置动画关键帧
	         * @param  {number} time 关键帧时间，单位是ms
	         * @param  {Object} props 关键帧的属性值，key-value表示
	         * @return {module:zrender/animation/Animator}
	         */
	        when: function(time /* ms */, props) {
	            var tracks = this._tracks;
	            for (var propName in props) {
	                if (!tracks[propName]) {
	                    tracks[propName] = [];
	                    // Invalid value
	                    var value = this._getter(this._target, propName);
	                    if (value == null) {
	                        // zrLog('Invalid property ' + propName);
	                        continue;
	                    }
	                    // If time is 0
	                    //  Then props is given initialize value
	                    // Else
	                    //  Initialize value from current prop value
	                    if (time !== 0) {
	                        tracks[propName].push({
	                            time: 0,
	                            value: cloneValue(value)
	                        });
	                    }
	                }
	                tracks[propName].push({
	                    time: time,
	                    value: props[propName]
	                });
	            }
	            return this;
	        },
	        /**
	         * 添加动画每一帧的回调函数
	         * @param  {Function} callback
	         * @return {module:zrender/animation/Animator}
	         */
	        during: function (callback) {
	            this._onframeList.push(callback);
	            return this;
	        },
	
	        _doneCallback: function () {
	            // Clear all tracks
	            this._tracks = {};
	            // Clear all clips
	            this._clipList.length = 0;
	
	            var doneList = this._doneList;
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        },
	        /**
	         * 开始执行动画
	         * @param  {string|Function} easing
	         *         动画缓动函数，详见{@link module:zrender/animation/easing}
	         * @return {module:zrender/animation/Animator}
	         */
	        start: function (easing) {
	
	            var self = this;
	            var clipCount = 0;
	
	            var oneTrackDone = function() {
	                clipCount--;
	                if (!clipCount) {
	                    self._doneCallback();
	                }
	            };
	
	            var lastClip;
	            for (var propName in this._tracks) {
	                var clip = createTrackClip(
	                    this, easing, oneTrackDone,
	                    this._tracks[propName], propName
	                );
	                if (clip) {
	                    this._clipList.push(clip);
	                    clipCount++;
	
	                    // If start after added to animation
	                    if (this.animation) {
	                        this.animation.addClip(clip);
	                    }
	
	                    lastClip = clip;
	                }
	            }
	
	            // Add during callback on the last clip
	            if (lastClip) {
	                var oldOnFrame = lastClip.onframe;
	                lastClip.onframe = function (target, percent) {
	                    oldOnFrame(target, percent);
	
	                    for (var i = 0; i < self._onframeList.length; i++) {
	                        self._onframeList[i](target, percent);
	                    }
	                };
	            }
	
	            if (!clipCount) {
	                this._doneCallback();
	            }
	            return this;
	        },
	        /**
	         * 停止动画
	         * @param {boolean} forwardToLast If move to last frame before stop
	         */
	        stop: function (forwardToLast) {
	            var clipList = this._clipList;
	            var animation = this.animation;
	            for (var i = 0; i < clipList.length; i++) {
	                var clip = clipList[i];
	                if (forwardToLast) {
	                    // Move to last frame before stop
	                    clip.onframe(this._target, 1);
	                }
	                animation && animation.removeClip(clip);
	            }
	            clipList.length = 0;
	        },
	        /**
	         * 设置动画延迟开始的时间
	         * @param  {number} time 单位ms
	         * @return {module:zrender/animation/Animator}
	         */
	        delay: function (time) {
	            this._delay = time;
	            return this;
	        },
	        /**
	         * 添加动画结束的回调
	         * @param  {Function} cb
	         * @return {module:zrender/animation/Animator}
	         */
	        done: function(cb) {
	            if (cb) {
	                this._doneList.push(cb);
	            }
	            return this;
	        },
	
	        /**
	         * @return {Array.<module:zrender/animation/Clip>}
	         */
	        getClips: function () {
	            return this._clipList;
	        }
	    };
	
	    module.exports = Animator;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 动画主控制器
	 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
	 * @config life(1000) 动画时长
	 * @config delay(0) 动画延迟时间
	 * @config loop(true)
	 * @config gap(0) 循环的间隔时间
	 * @config onframe
	 * @config easing(optional)
	 * @config ondestroy(optional)
	 * @config onrestart(optional)
	 *
	 * TODO pause
	 */
	
	
	    var easingFuncs = __webpack_require__(22);
	
	    function Clip(options) {
	
	        this._target = options.target;
	
	        // 生命周期
	        this._life = options.life || 1000;
	        // 延时
	        this._delay = options.delay || 0;
	        // 开始时间
	        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
	        this._initialized = false;
	
	        // 是否循环
	        this.loop = options.loop == null ? false : options.loop;
	
	        this.gap = options.gap || 0;
	
	        this.easing = options.easing || 'Linear';
	
	        this.onframe = options.onframe;
	        this.ondestroy = options.ondestroy;
	        this.onrestart = options.onrestart;
	    }
	
	    Clip.prototype = {
	
	        constructor: Clip,
	
	        step: function (time) {
	            // Set startTime on first step, or _startTime may has milleseconds different between clips
	            // PENDING
	            if (!this._initialized) {
	                this._startTime = new Date().getTime() + this._delay;
	                this._initialized = true;
	            }
	
	            var percent = (time - this._startTime) / this._life;
	
	            // 还没开始
	            if (percent < 0) {
	                return;
	            }
	
	            percent = Math.min(percent, 1);
	
	            var easing = this.easing;
	            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
	            var schedule = typeof easingFunc === 'function'
	                ? easingFunc(percent)
	                : percent;
	
	            this.fire('frame', schedule);
	
	            // 结束
	            if (percent == 1) {
	                if (this.loop) {
	                    this.restart();
	                    // 重新开始周期
	                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
	                    return 'restart';
	                }
	
	                // 动画完成将这个控制器标识为待删除
	                // 在Animation.update中进行批量删除
	                this._needsRemove = true;
	                return 'destroy';
	            }
	
	            return null;
	        },
	
	        restart: function() {
	            var time = new Date().getTime();
	            var remainder = (time - this._startTime) % this._life;
	            this._startTime = new Date().getTime() - remainder + this.gap;
	
	            this._needsRemove = false;
	        },
	
	        fire: function(eventType, arg) {
	            eventType = 'on' + eventType;
	            if (this[eventType]) {
	                this[eventType](this._target, arg);
	            }
	        }
	    };
	
	    module.exports = Clip;
	


/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
	 * @see http://sole.github.io/tween.js/examples/03_graphs.html
	 * @exports zrender/animation/easing
	 */
	
	    var easing = {
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        linear: function (k) {
	            return k;
	        },
	
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticIn: function (k) {
	            return k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticOut: function (k) {
	            return k * (2 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quadraticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k;
	            }
	            return -0.5 * (--k * (k - 2) - 1);
	        },
	
	        // 三次方的缓动（t^3）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicIn: function (k) {
	            return k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicOut: function (k) {
	            return --k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        cubicInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k + 2);
	        },
	
	        // 四次方的缓动（t^4）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticIn: function (k) {
	            return k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticOut: function (k) {
	            return 1 - (--k * k * k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quarticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k;
	            }
	            return -0.5 * ((k -= 2) * k * k * k - 2);
	        },
	
	        // 五次方的缓动（t^5）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticIn: function (k) {
	            return k * k * k * k * k;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticOut: function (k) {
	            return --k * k * k * k * k + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        quinticInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return 0.5 * k * k * k * k * k;
	            }
	            return 0.5 * ((k -= 2) * k * k * k * k + 2);
	        },
	
	        // 正弦曲线的缓动（sin(t)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalIn: function (k) {
	            return 1 - Math.cos(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalOut: function (k) {
	            return Math.sin(k * Math.PI / 2);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        sinusoidalInOut: function (k) {
	            return 0.5 * (1 - Math.cos(Math.PI * k));
	        },
	
	        // 指数曲线的缓动（2^t）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialIn: function (k) {
	            return k === 0 ? 0 : Math.pow(1024, k - 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialOut: function (k) {
	            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        exponentialInOut: function (k) {
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if ((k *= 2) < 1) {
	                return 0.5 * Math.pow(1024, k - 1);
	            }
	            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	        },
	
	        // 圆形曲线的缓动（sqrt(1-t^2)）
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularIn: function (k) {
	            return 1 - Math.sqrt(1 - k * k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularOut: function (k) {
	            return Math.sqrt(1 - (--k * k));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        circularInOut: function (k) {
	            if ((k *= 2) < 1) {
	                return -0.5 * (Math.sqrt(1 - k * k) - 1);
	            }
	            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	        },
	
	        // 创建类似于弹簧在停止前来回振荡的动画
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticIn: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return -(a * Math.pow(2, 10 * (k -= 1)) *
	                        Math.sin((k - s) * (2 * Math.PI) / p));
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            return (a * Math.pow(2, -10 * k) *
	                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        elasticInOut: function (k) {
	            var s;
	            var a = 0.1;
	            var p = 0.4;
	            if (k === 0) {
	                return 0;
	            }
	            if (k === 1) {
	                return 1;
	            }
	            if (!a || a < 1) {
	                a = 1; s = p / 4;
	            }
	            else {
	                s = p * Math.asin(1 / a) / (2 * Math.PI);
	            }
	            if ((k *= 2) < 1) {
	                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p));
	            }
	            return a * Math.pow(2, -10 * (k -= 1))
	                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	
	        },
	
	        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backIn: function (k) {
	            var s = 1.70158;
	            return k * k * ((s + 1) * k - s);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backOut: function (k) {
	            var s = 1.70158;
	            return --k * k * ((s + 1) * k + s) + 1;
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        backInOut: function (k) {
	            var s = 1.70158 * 1.525;
	            if ((k *= 2) < 1) {
	                return 0.5 * (k * k * ((s + 1) * k - s));
	            }
	            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	        },
	
	        // 创建弹跳效果
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceIn: function (k) {
	            return 1 - easing.bounceOut(1 - k);
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceOut: function (k) {
	            if (k < (1 / 2.75)) {
	                return 7.5625 * k * k;
	            }
	            else if (k < (2 / 2.75)) {
	                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	            }
	            else if (k < (2.5 / 2.75)) {
	                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	            }
	            else {
	                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	            }
	        },
	        /**
	        * @param {number} k
	        * @return {number}
	        */
	        bounceInOut: function (k) {
	            if (k < 0.5) {
	                return easing.bounceIn(k * 2) * 0.5;
	            }
	            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	        }
	    };
	
	    module.exports = easing;
	
	


/***/ },
/* 23 */
/***/ function(module, exports) {

	/**
	 * @module zrender/tool/color
	 */
	
	
	    var kCSSColorTable = {
	        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
	        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
	        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
	        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
	        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
	        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
	        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
	        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
	        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
	        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
	        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
	        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
	        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
	        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
	        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
	        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
	        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
	        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
	        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
	        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
	        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
	        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
	        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
	        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
	        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
	        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
	        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
	        'gray': [128,128,128,1], 'green': [0,128,0,1],
	        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
	        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
	        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
	        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
	        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
	        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
	        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
	        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
	        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
	        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
	        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
	        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
	        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
	        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
	        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
	        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
	        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
	        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
	        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
	        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
	        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
	        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
	        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
	        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
	        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
	        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
	        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
	        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
	        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
	        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
	        'pink': [255,192,203,1], 'plum': [221,160,221,1],
	        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
	        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
	        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
	        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
	        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
	        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
	        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
	        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
	        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
	        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
	        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
	        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
	        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
	        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
	        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
	    };
	
	    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 255 ? 255 : i;
	    }
	
	    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
	        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
	        return i < 0 ? 0 : i > 360 ? 360 : i;
	    }
	
	    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
	        return f < 0 ? 0 : f > 1 ? 1 : f;
	    }
	
	    function parseCssInt(str) {  // int or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssByte(parseFloat(str) / 100 * 255);
	        }
	        return clampCssByte(parseInt(str, 10));
	    }
	
	    function parseCssFloat(str) {  // float or percentage.
	        if (str.length && str.charAt(str.length - 1) === '%') {
	            return clampCssFloat(parseFloat(str) / 100);
	        }
	        return clampCssFloat(parseFloat(str));
	    }
	
	    function cssHueToRgb(m1, m2, h) {
	        if (h < 0) {
	            h += 1;
	        }
	        else if (h > 1) {
	            h -= 1;
	        }
	
	        if (h * 6 < 1) {
	            return m1 + (m2 - m1) * h * 6;
	        }
	        if (h * 2 < 1) {
	            return m2;
	        }
	        if (h * 3 < 2) {
	            return m1 + (m2 - m1) * (2/3 - h) * 6;
	        }
	        return m1;
	    }
	
	    function lerp(a, b, p) {
	        return a + (b - a) * p;
	    }
	
	    /**
	     * @param {string} colorStr
	     * @return {Array.<number>}
	     * @memberOf module:zrender/util/color
	     */
	    function parse(colorStr) {
	        if (!colorStr) {
	            return;
	        }
	        // colorStr may be not string
	        colorStr = colorStr + '';
	        // Remove all whitespace, not compliant, but should just be more accepting.
	        var str = colorStr.replace(/ /g, '').toLowerCase();
	
	        // Color keywords (and transparent) lookup.
	        if (str in kCSSColorTable) {
	            return kCSSColorTable[str].slice();  // dup.
	        }
	
	        // #abc and #abc123 syntax.
	        if (str.charAt(0) === '#') {
	            if (str.length === 4) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xfff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
	                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
	                    (iv & 0xf) | ((iv & 0xf) << 4),
	                    1
	                ];
	            }
	            else if (str.length === 7) {
	                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
	                if (!(iv >= 0 && iv <= 0xffffff)) {
	                    return;  // Covers NaN.
	                }
	                return [
	                    (iv & 0xff0000) >> 16,
	                    (iv & 0xff00) >> 8,
	                    iv & 0xff,
	                    1
	                ];
	            }
	
	            return;
	        }
	        var op = str.indexOf('('), ep = str.indexOf(')');
	        if (op !== -1 && ep + 1 === str.length) {
	            var fname = str.substr(0, op);
	            var params = str.substr(op + 1, ep - (op + 1)).split(',');
	            var alpha = 1;  // To allow case fallthrough.
	            switch (fname) {
	                case 'rgba':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
	                // Fall through.
	                case 'rgb':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return [
	                        parseCssInt(params[0]),
	                        parseCssInt(params[1]),
	                        parseCssInt(params[2]),
	                        alpha
	                    ];
	                case 'hsla':
	                    if (params.length !== 4) {
	                        return;
	                    }
	                    params[3] = parseCssFloat(params[3]);
	                    return hsla2rgba(params);
	                case 'hsl':
	                    if (params.length !== 3) {
	                        return;
	                    }
	                    return hsla2rgba(params);
	                default:
	                    return;
	            }
	        }
	
	        return;
	    }
	
	    /**
	     * @param {Array.<number>} hsla
	     * @return {Array.<number>} rgba
	     */
	    function hsla2rgba(hsla) {
	        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
	        // NOTE(deanm): According to the CSS spec s/l should only be
	        // percentages, but we don't bother and let float or percentage.
	        var s = parseCssFloat(hsla[1]);
	        var l = parseCssFloat(hsla[2]);
	        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	        var m1 = l * 2 - m2;
	
	        var rgba = [
	            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
	            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
	        ];
	
	        if (hsla.length === 4) {
	            rgba[3] = hsla[3];
	        }
	
	        return rgba;
	    }
	
	    /**
	     * @param {Array.<number>} rgba
	     * @return {Array.<number>} hsla
	     */
	    function rgba2hsla(rgba) {
	        if (!rgba) {
	            return;
	        }
	
	        // RGB from 0 to 255
	        var R = rgba[0] / 255;
	        var G = rgba[1] / 255;
	        var B = rgba[2] / 255;
	
	        var vMin = Math.min(R, G, B); // Min. value of RGB
	        var vMax = Math.max(R, G, B); // Max. value of RGB
	        var delta = vMax - vMin; // Delta RGB value
	
	        var L = (vMax + vMin) / 2;
	        var H;
	        var S;
	        // HSL results from 0 to 1
	        if (delta === 0) {
	            H = 0;
	            S = 0;
	        }
	        else {
	            if (L < 0.5) {
	                S = delta / (vMax + vMin);
	            }
	            else {
	                S = delta / (2 - vMax - vMin);
	            }
	
	            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	
	            if (R === vMax) {
	                H = deltaB - deltaG;
	            }
	            else if (G === vMax) {
	                H = (1 / 3) + deltaR - deltaB;
	            }
	            else if (B === vMax) {
	                H = (2 / 3) + deltaG - deltaR;
	            }
	
	            if (H < 0) {
	                H += 1;
	            }
	
	            if (H > 1) {
	                H -= 1;
	            }
	        }
	
	        var hsla = [H * 360, S, L];
	
	        if (rgba[3] != null) {
	            hsla.push(rgba[3]);
	        }
	
	        return hsla;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number} level
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function lift(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            for (var i = 0; i < 3; i++) {
	                if (level < 0) {
	                    colorArr[i] = colorArr[i] * (1 - level) | 0;
	                }
	                else {
	                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	                }
	            }
	            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @return {string}
	     * @memberOf module:zrender/util/color
	     */
	    function toHex(color, level) {
	        var colorArr = parse(color);
	        if (colorArr) {
	            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	        }
	    }
	
	    /**
	     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<Array.<number>>} colors List of rgba color array
	     * @param {Array.<number>} [out] Mapped gba color array
	     * @return {Array.<number>}
	     */
	    function fastMapToColor(normalizedValue, colors, out) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	        out = out || [0, 0, 0, 0];
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = colors[leftIndex];
	        var rightColor = colors[rightIndex];
	        var dv = value - leftIndex;
	        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
	        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
	        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
	        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
	        return out;
	    }
	    /**
	     * @param {number} normalizedValue A float between 0 and 1.
	     * @param {Array.<string>} colors Color list.
	     * @param {boolean=} fullOutput Default false.
	     * @return {(string|Object)} Result color. If fullOutput,
	     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
	     * @memberOf module:zrender/util/color
	     */
	    function mapToColor(normalizedValue, colors, fullOutput) {
	        if (!(colors && colors.length)
	            || !(normalizedValue >= 0 && normalizedValue <= 1)
	        ) {
	            return;
	        }
	
	        var value = normalizedValue * (colors.length - 1);
	        var leftIndex = Math.floor(value);
	        var rightIndex = Math.ceil(value);
	        var leftColor = parse(colors[leftIndex]);
	        var rightColor = parse(colors[rightIndex]);
	        var dv = value - leftIndex;
	
	        var color = stringify(
	            [
	                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
	                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
	                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
	                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
	            ],
	            'rgba'
	        );
	
	        return fullOutput
	            ? {
	                color: color,
	                leftIndex: leftIndex,
	                rightIndex: rightIndex,
	                value: value
	            }
	            : color;
	    }
	
	    /**
	     * @param {Array<number>} interval  Array length === 2,
	     *                                  each item is normalized value ([0, 1]).
	     * @param {Array.<string>} colors Color list.
	     * @return {Array.<Object>} colors corresponding to the interval,
	     *                          each item is {color: 'xxx', offset: ...}
	     *                          where offset is between 0 and 1.
	     * @memberOf module:zrender/util/color
	     */
	    function mapIntervalToColor(interval, colors) {
	        if (interval.length !== 2 || interval[1] < interval[0]) {
	            return;
	        }
	
	        var info0 = mapToColor(interval[0], colors, true);
	        var info1 = mapToColor(interval[1], colors, true);
	
	        var result = [{color: info0.color, offset: 0}];
	
	        var during = info1.value - info0.value;
	        var start = Math.max(info0.value, info0.rightIndex);
	        var end = Math.min(info1.value, info1.leftIndex);
	
	        for (var i = start; during > 0 && i <= end; i++) {
	            result.push({
	                color: colors[i],
	                offset: (i - info0.value) / during
	            });
	        }
	        result.push({color: info1.color, offset: 1});
	
	        return result;
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} h 0 ~ 360, ignore when null.
	     * @param {number=} s 0 ~ 1, ignore when null.
	     * @param {number=} l 0 ~ 1, ignore when null.
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyHSL(color, h, s, l) {
	        color = parse(color);
	
	        if (color) {
	            color = rgba2hsla(color);
	            h != null && (color[0] = clampCssAngle(h));
	            s != null && (color[1] = parseCssFloat(s));
	            l != null && (color[2] = parseCssFloat(l));
	
	            return stringify(hsla2rgba(color), 'rgba');
	        }
	    }
	
	    /**
	     * @param {string} color
	     * @param {number=} alpha 0 ~ 1
	     * @return {string} Color string in rgba format.
	     * @memberOf module:zrender/util/color
	     */
	    function modifyAlpha(color, alpha) {
	        color = parse(color);
	
	        if (color && alpha != null) {
	            color[3] = clampCssFloat(alpha);
	            return stringify(color, 'rgba');
	        }
	    }
	
	    /**
	     * @param {Array.<string>} colors Color list.
	     * @param {string} type 'rgba', 'hsva', ...
	     * @return {string} Result color.
	     */
	    function stringify(arrColor, type) {
	        if (type === 'rgb' || type === 'hsv' || type === 'hsl') {
	            arrColor = arrColor.slice(0, 3);
	        }
	        return type + '(' + arrColor.join(',') + ')';
	    }
	
	    module.exports = {
	        parse: parse,
	        lift: lift,
	        toHex: toHex,
	        fastMapToColor: fastMapToColor,
	        mapToColor: mapToColor,
	        mapIntervalToColor: mapIntervalToColor,
	        modifyHSL: modifyHSL,
	        modifyAlpha: modifyAlpha,
	        stringify: stringify
	    };
	
	


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	
	        var config = __webpack_require__(25);
	
	        /**
	         * @exports zrender/tool/log
	         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	         */
	        module.exports = function() {
	            if (config.debugMode === 0) {
	                return;
	            }
	            else if (config.debugMode == 1) {
	                for (var k in arguments) {
	                    throw new Error(arguments[k]);
	                }
	            }
	            else if (config.debugMode > 1) {
	                for (var k in arguments) {
	                    console.log(arguments[k]);
	                }
	            }
	        };
	
	        /* for debug
	        return function(mes) {
	            document.getElementById('wrong-message').innerHTML =
	                mes + ' ' + (new Date() - 0)
	                + '<br/>' 
	                + document.getElementById('wrong-message').innerHTML;
	        };
	        */
	    


/***/ },
/* 25 */
/***/ function(module, exports) {

	
	    var dpr = 1;
	    // If in browser environment
	    if (typeof window !== 'undefined') {
	        dpr = Math.max(window.devicePixelRatio || 1, 1);
	    }
	    /**
	     * config默认配置项
	     * @exports zrender/config
	     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	     */
	    var config = {
	        /**
	         * debug日志选项：catchBrushException为true下有效
	         * 0 : 不生成debug数据，发布用
	         * 1 : 异常抛出，调试用
	         * 2 : 控制台输出，调试用
	         */
	        debugMode: 0,
	
	        // retina 屏幕优化
	        devicePixelRatio: dpr
	    };
	    module.exports = config;
	
	


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * @module echarts/core/BoundingRect
	 */
	
	
	    var vec2 = __webpack_require__(18);
	    var matrix = __webpack_require__(17);
	
	    var v2ApplyTransform = vec2.applyTransform;
	    var mathMin = Math.min;
	    var mathAbs = Math.abs;
	    var mathMax = Math.max;
	    /**
	     * @alias module:echarts/core/BoundingRect
	     */
	    function BoundingRect(x, y, width, height) {
	        /**
	         * @type {number}
	         */
	        this.x = x;
	        /**
	         * @type {number}
	         */
	        this.y = y;
	        /**
	         * @type {number}
	         */
	        this.width = width;
	        /**
	         * @type {number}
	         */
	        this.height = height;
	    }
	
	    BoundingRect.prototype = {
	
	        constructor: BoundingRect,
	
	        /**
	         * @param {module:echarts/core/BoundingRect} other
	         */
	        union: function (other) {
	            var x = mathMin(other.x, this.x);
	            var y = mathMin(other.y, this.y);
	
	            this.width = mathMax(
	                    other.x + other.width,
	                    this.x + this.width
	                ) - x;
	            this.height = mathMax(
	                    other.y + other.height,
	                    this.y + this.height
	                ) - y;
	            this.x = x;
	            this.y = y;
	        },
	
	        /**
	         * @param {Array.<number>} m
	         * @methods
	         */
	        applyTransform: (function () {
	            var min = [];
	            var max = [];
	            return function (m) {
	                // In case usage like this
	                // el.getBoundingRect().applyTransform(el.transform)
	                // And element has no transform
	                if (!m) {
	                    return;
	                }
	                min[0] = this.x;
	                min[1] = this.y;
	                max[0] = this.x + this.width;
	                max[1] = this.y + this.height;
	
	                v2ApplyTransform(min, min, m);
	                v2ApplyTransform(max, max, m);
	
	                this.x = mathMin(min[0], max[0]);
	                this.y = mathMin(min[1], max[1]);
	                this.width = mathAbs(max[0] - min[0]);
	                this.height = mathAbs(max[1] - min[1]);
	            };
	        })(),
	
	        /**
	         * Calculate matrix of transforming from self to target rect
	         * @param  {module:zrender/core/BoundingRect} b
	         * @return {Array.<number>}
	         */
	        calculateTransform: function (b) {
	            var a = this;
	            var sx = b.width / a.width;
	            var sy = b.height / a.height;
	
	            var m = matrix.create();
	
	            // 矩阵右乘
	            matrix.translate(m, m, [-a.x, -a.y]);
	            matrix.scale(m, m, [sx, sy]);
	            matrix.translate(m, m, [b.x, b.y]);
	
	            return m;
	        },
	
	        /**
	         * @param {(module:echarts/core/BoundingRect|Object)} b
	         * @return {boolean}
	         */
	        intersect: function (b) {
	            var a = this;
	            var ax0 = a.x;
	            var ax1 = a.x + a.width;
	            var ay0 = a.y;
	            var ay1 = a.y + a.height;
	
	            var bx0 = b.x;
	            var bx1 = b.x + b.width;
	            var by0 = b.y;
	            var by1 = b.y + b.height;
	
	            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        },
	
	        contain: function (x, y) {
	            var rect = this;
	            return x >= rect.x
	                && x <= (rect.x + rect.width)
	                && y >= rect.y
	                && y <= (rect.y + rect.height);
	        },
	
	        /**
	         * @return {module:echarts/core/BoundingRect}
	         */
	        clone: function () {
	            return new BoundingRect(this.x, this.y, this.width, this.height);
	        },
	
	        /**
	         * Copy from another rect
	         */
	        copy: function (other) {
	            this.x = other.x;
	            this.y = other.y;
	            this.width = other.width;
	            this.height = other.height;
	        }
	    };
	
	    module.exports = BoundingRect;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 动画主类, 调度和管理所有动画控制器
	 *
	 * @module zrender/animation/Animation
	 * @author pissang(https://github.com/pissang)
	 */
	// TODO Additive animation
	// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
	// https://developer.apple.com/videos/wwdc2014/#236
	
	
	    var util = __webpack_require__(9);
	    var Dispatcher = __webpack_require__(7).Dispatcher;
	
	    var requestAnimationFrame = (typeof window !== 'undefined' &&
	                                    (window.requestAnimationFrame
	                                    || window.msRequestAnimationFrame
	                                    || window.mozRequestAnimationFrame
	                                    || window.webkitRequestAnimationFrame))
	                                || function (func) {
	                                    setTimeout(func, 16);
	                                };
	
	    var Animator = __webpack_require__(20);
	    /**
	     * @typedef {Object} IZRenderStage
	     * @property {Function} update
	     */
	
	    /**
	     * @alias module:zrender/animation/Animation
	     * @constructor
	     * @param {Object} [options]
	     * @param {Function} [options.onframe]
	     * @param {IZRenderStage} [options.stage]
	     * @example
	     *     var animation = new Animation();
	     *     var obj = {
	     *         x: 100,
	     *         y: 100
	     *     };
	     *     animation.animate(node.position)
	     *         .when(1000, {
	     *             x: 500,
	     *             y: 500
	     *         })
	     *         .when(2000, {
	     *             x: 100,
	     *             y: 100
	     *         })
	     *         .start('spline');
	     */
	    var Animation = function (options) {
	
	        options = options || {};
	
	        this.stage = options.stage || {};
	
	        this.onframe = options.onframe || function() {};
	
	        // private properties
	        this._clips = [];
	
	        this._running = false;
	
	        this._time = 0;
	
	        Dispatcher.call(this);
	    };
	
	    Animation.prototype = {
	
	        constructor: Animation,
	        /**
	         * 添加 clip
	         * @param {module:zrender/animation/Clip} clip
	         */
	        addClip: function (clip) {
	            this._clips.push(clip);
	        },
	        /**
	         * 添加 animator
	         * @param {module:zrender/animation/Animator} animator
	         */
	        addAnimator: function (animator) {
	            animator.animation = this;
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.addClip(clips[i]);
	            }
	        },
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Clip} clip
	         */
	        removeClip: function(clip) {
	            var idx = util.indexOf(this._clips, clip);
	            if (idx >= 0) {
	                this._clips.splice(idx, 1);
	            }
	        },
	
	        /**
	         * 删除动画片段
	         * @param {module:zrender/animation/Animator} animator
	         */
	        removeAnimator: function (animator) {
	            var clips = animator.getClips();
	            for (var i = 0; i < clips.length; i++) {
	                this.removeClip(clips[i]);
	            }
	            animator.animation = null;
	        },
	
	        _update: function() {
	
	            var time = new Date().getTime();
	            var delta = time - this._time;
	            var clips = this._clips;
	            var len = clips.length;
	
	            var deferredEvents = [];
	            var deferredClips = [];
	            for (var i = 0; i < len; i++) {
	                var clip = clips[i];
	                var e = clip.step(time);
	                // Throw out the events need to be called after
	                // stage.update, like destroy
	                if (e) {
	                    deferredEvents.push(e);
	                    deferredClips.push(clip);
	                }
	            }
	
	            // Remove the finished clip
	            for (var i = 0; i < len;) {
	                if (clips[i]._needsRemove) {
	                    clips[i] = clips[len - 1];
	                    clips.pop();
	                    len--;
	                }
	                else {
	                    i++;
	                }
	            }
	
	            len = deferredEvents.length;
	            for (var i = 0; i < len; i++) {
	                deferredClips[i].fire(deferredEvents[i]);
	            }
	
	            this._time = time;
	
	            this.onframe(delta);
	
	            this.trigger('frame', delta);
	
	            if (this.stage.update) {
	                this.stage.update();
	            }
	        },
	        /**
	         * 开始运行动画
	         */
	        start: function () {
	            var self = this;
	
	            this._running = true;
	
	            function step() {
	                if (self._running) {
	
	                    requestAnimationFrame(step);
	
	                    self._update();
	                }
	            }
	
	            this._time = new Date().getTime();
	            requestAnimationFrame(step);
	        },
	        /**
	         * 停止运行动画
	         */
	        stop: function () {
	            this._running = false;
	        },
	        /**
	         * 清除所有动画片段
	         */
	        clear: function () {
	            this._clips = [];
	        },
	        /**
	         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
	         * @param  {Object} target
	         * @param  {Object} options
	         * @param  {boolean} [options.loop=false] 是否循环播放动画
	         * @param  {Function} [options.getter=null]
	         *         如果指定getter函数，会通过getter函数取属性值
	         * @param  {Function} [options.setter=null]
	         *         如果指定setter函数，会通过setter函数设置属性值
	         * @return {module:zrender/animation/Animation~Animator}
	         */
	        animate: function (target, options) {
	            options = options || {};
	            var animator = new Animator(
	                target,
	                options.loop,
	                options.getter,
	                options.setter
	            );
	
	            return animator;
	        }
	    };
	
	    util.mixin(Animation, Dispatcher);
	
	    module.exports = Animation;
	


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Default canvas painter
	 * @module zrender/Painter
	 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 *         pissang (https://www.github.com/pissang)
	 */
	 
	
	    var config = __webpack_require__(25);
	    var util = __webpack_require__(9);
	    var log = __webpack_require__(24);
	    var BoundingRect = __webpack_require__(26);
	
	    var Layer = __webpack_require__(29);
	
	    function parseInt10(val) {
	        return parseInt(val, 10);
	    }
	
	    function isLayerValid(layer) {
	        if (!layer) {
	            return false;
	        }
	
	        if (layer.isBuildin) {
	            return true;
	        }
	
	        if (typeof(layer.resize) !== 'function'
	            || typeof(layer.refresh) !== 'function'
	        ) {
	            return false;
	        }
	
	        return true;
	    }
	
	    function preProcessLayer(layer) {
	        layer.__unusedCount++;
	    }
	
	    function postProcessLayer(layer) {
	        layer.__dirty = false;
	        if (layer.__unusedCount == 1) {
	            layer.clear();
	        }
	    }
	
	    var tmpRect = new BoundingRect(0, 0, 0, 0);
	    var viewRect = new BoundingRect(0, 0, 0, 0);
	    function isDisplayableCulled(el, width, height) {
	        tmpRect.copy(el.getBoundingRect());
	        if (el.transform) {
	            tmpRect.applyTransform(el.transform);
	        }
	        viewRect.width = width;
	        viewRect.height = height;
	        return !tmpRect.intersect(viewRect);
	    }
	
	    function isClipPathChanged(clipPaths, prevClipPaths) {
	        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	            return true;
	        }
	        for (var i = 0; i < clipPaths.length; i++) {
	            if (clipPaths[i] !== prevClipPaths[i]) {
	                return true;
	            }
	        }
	    }
	
	    function doClip(clipPaths, ctx) {
	        for (var i = 0; i < clipPaths.length; i++) {
	            var clipPath = clipPaths[i];
	            var m;
	            if (clipPath.transform) {
	                m = clipPath.transform;
	                ctx.transform(
	                    m[0], m[1],
	                    m[2], m[3],
	                    m[4], m[5]
	                );
	            }
	            var path = clipPath.path;
	            path.beginPath(ctx);
	            clipPath.buildPath(path, clipPath.shape);
	            ctx.clip();
	            // Transform back
	            if (clipPath.transform) {
	                m = clipPath.invTransform;
	                ctx.transform(
	                    m[0], m[1],
	                    m[2], m[3],
	                    m[4], m[5]
	                );
	            }
	        }
	    }
	
	    /**
	     * @alias module:zrender/Painter
	     * @constructor
	     * @param {HTMLElement} root 绘图容器
	     * @param {module:zrender/Storage} storage
	     * @param {Ojbect} opts
	     */
	    var Painter = function (root, storage, opts) {
	        var singleCanvas = !root.nodeName // In node ?
	            || root.nodeName.toUpperCase() === 'CANVAS';
	
	        opts = opts || {};
	
	        /**
	         * @type {number}
	         */
	        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
	        /**
	         * @type {boolean}
	         * @private
	         */
	        this._singleCanvas = singleCanvas;
	        /**
	         * 绘图容器
	         * @type {HTMLElement}
	         */
	        this.root = root;
	
	        var rootStyle = root.style;
	
	        // In node environment using node-canvas
	        if (rootStyle) {
	            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
	            rootStyle['-webkit-user-select'] = 'none';
	            rootStyle['user-select'] = 'none';
	            rootStyle['-webkit-touch-callout'] = 'none';
	
	            root.innerHTML = '';
	        }
	
	        /**
	         * @type {module:zrender/Storage}
	         */
	        this.storage = storage;
	
	        if (!singleCanvas) {
	            var width = this._getWidth();
	            var height = this._getHeight();
	            this._width = width;
	            this._height = height;
	
	            var domRoot = document.createElement('div');
	            this._domRoot = domRoot;
	            var domRootStyle = domRoot.style;
	
	            // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domRootStyle.position = 'relative';
	            domRootStyle.overflow = 'hidden';
	            domRootStyle.width = this._width + 'px';
	            domRootStyle.height = this._height + 'px';
	            root.appendChild(domRoot);
	
	            /**
	             * @type {Object.<key, module:zrender/Layer>}
	             * @private
	             */
	            this._layers = {};
	            /**
	             * @type {Array.<number>}
	             * @private
	             */
	            this._zlevelList = [];
	        }
	        else {
	            // Use canvas width and height directly
	            var width = root.width;
	            var height = root.height;
	            this._width = width;
	            this._height = height;
	
	            // Create layer if only one given canvas
	            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
	            var mainLayer = new Layer(root, this, 1);
	            mainLayer.initContext();
	            // FIXME Use canvas width and height
	            // mainLayer.resize(width, height);
	            this._layers = {
	                0: mainLayer
	            };
	            this._zlevelList = [0];
	        }
	
	        this._layerConfig = {};
	
	        this.pathToImage = this._createPathToImage();
	    };
	
	    Painter.prototype = {
	
	        constructor: Painter,
	
	        /**
	         * If painter use a single canvas
	         * @return {boolean}
	         */
	        isSingleCanvas: function () {
	            return this._singleCanvas;
	        },
	        /**
	         * @return {HTMLDivElement}
	         */
	        getViewportRoot: function () {
	            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
	        },
	
	        /**
	         * 刷新
	         * @param {boolean} [paintAll=false] 强制绘制所有displayable
	         */
	        refresh: function (paintAll) {
	            var list = this.storage.getDisplayList(true);
	            var zlevelList = this._zlevelList;
	
	            this._paintList(list, paintAll);
	
	            // Paint custum layers
	            for (var i = 0; i < zlevelList.length; i++) {
	                var z = zlevelList[i];
	                var layer = this._layers[z];
	                if (!layer.isBuildin && layer.refresh) {
	                    layer.refresh();
	                }
	            }
	
	            return this;
	        },
	
	        _paintList: function (list, paintAll) {
	
	            if (paintAll == null) {
	                paintAll = false;
	            }
	
	            this._updateLayerStatus(list);
	
	            var currentLayer;
	            var currentZLevel;
	            var ctx;
	
	            var viewWidth = this._width;
	            var viewHeight = this._height;
	
	            this.eachBuildinLayer(preProcessLayer);
	
	            // var invTransform = [];
	            var prevElClipPaths = null;
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var elZLevel = this._singleCanvas ? 0 : el.zlevel;
	                // Change draw layer
	                if (currentZLevel !== elZLevel) {
	                    // Only 0 zlevel if only has one canvas
	                    currentZLevel = elZLevel;
	                    currentLayer = this.getLayer(currentZLevel);
	
	                    if (!currentLayer.isBuildin) {
	                        log(
	                            'ZLevel ' + currentZLevel
	                            + ' has been used by unkown layer ' + currentLayer.id
	                        );
	                    }
	
	                    ctx = currentLayer.ctx;
	
	                    // Reset the count
	                    currentLayer.__unusedCount = 0;
	
	                    if (currentLayer.__dirty || paintAll) {
	                        currentLayer.clear();
	                    }
	                }
	
	                if (
	                    (currentLayer.__dirty || paintAll)
	                    // Ignore invisible element
	                    && !el.invisible
	                    // Ignore transparent element
	                    && el.style.opacity !== 0
	                    // Ignore scale 0 element, in some environment like node-canvas
	                    // Draw a scale 0 element can cause all following draw wrong
	                    && el.scale[0] && el.scale[1]
	                    // Ignore culled element
	                    && !(el.culling && isDisplayableCulled(el, viewWidth, viewHeight))
	                ) {
	                    var clipPaths = el.__clipPaths;
	
	                    // Optimize when clipping on group with several elements
	                    if (isClipPathChanged(clipPaths, prevElClipPaths)) {
	                        // If has previous clipping state, restore from it
	                        if (prevElClipPaths) {
	                            ctx.restore();
	                        }
	                        // New clipping state
	                        if (clipPaths) {
	                            ctx.save();
	                            doClip(clipPaths, ctx);
	                        }
	                        prevElClipPaths = clipPaths;
	                    }
	                    // TODO Use events ?
	                    el.beforeBrush && el.beforeBrush(ctx);
	                    el.brush(ctx, false);
	                    el.afterBrush && el.afterBrush(ctx);
	                }
	
	                el.__dirty = false;
	            }
	
	            // If still has clipping state
	            if (prevElClipPaths) {
	                ctx.restore();
	            }
	
	            this.eachBuildinLayer(postProcessLayer);
	        },
	
	        /**
	         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
	         * @param {number} zlevel
	         * @return {module:zrender/Layer}
	         */
	        getLayer: function (zlevel) {
	            if (this._singleCanvas) {
	                return this._layers[0];
	            }
	
	            var layer = this._layers[zlevel];
	            if (!layer) {
	                // Create a new layer
	                layer = new Layer('zr_' + zlevel, this, this.dpr);
	                layer.isBuildin = true;
	
	                if (this._layerConfig[zlevel]) {
	                    util.merge(layer, this._layerConfig[zlevel], true);
	                }
	
	                this.insertLayer(zlevel, layer);
	
	                // Context is created after dom inserted to document
	                // Or excanvas will get 0px clientWidth and clientHeight
	                layer.initContext();
	            }
	
	            return layer;
	        },
	
	        insertLayer: function (zlevel, layer) {
	
	            var layersMap = this._layers;
	            var zlevelList = this._zlevelList;
	            var len = zlevelList.length;
	            var prevLayer = null;
	            var i = -1;
	            var domRoot = this._domRoot;
	
	            if (layersMap[zlevel]) {
	                log('ZLevel ' + zlevel + ' has been used already');
	                return;
	            }
	            // Check if is a valid layer
	            if (!isLayerValid(layer)) {
	                log('Layer of zlevel ' + zlevel + ' is not valid');
	                return;
	            }
	
	            if (len > 0 && zlevel > zlevelList[0]) {
	                for (i = 0; i < len - 1; i++) {
	                    if (
	                        zlevelList[i] < zlevel
	                        && zlevelList[i + 1] > zlevel
	                    ) {
	                        break;
	                    }
	                }
	                prevLayer = layersMap[zlevelList[i]];
	            }
	            zlevelList.splice(i + 1, 0, zlevel);
	
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(
	                        layer.dom,
	                        prevDom.nextSibling
	                    );
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	
	            layersMap[zlevel] = layer;
	        },
	
	        // Iterate each layer
	        eachLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                cb.call(context, this._layers[z], z);
	            }
	        },
	
	        // Iterate each buildin layer
	        eachBuildinLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        // Iterate each other layer except buildin layer
	        eachOtherLayer: function (cb, context) {
	            var zlevelList = this._zlevelList;
	            var layer;
	            var z;
	            var i;
	            for (i = 0; i < zlevelList.length; i++) {
	                z = zlevelList[i];
	                layer = this._layers[z];
	                if (! layer.isBuildin) {
	                    cb.call(context, layer, z);
	                }
	            }
	        },
	
	        /**
	         * 获取所有已创建的层
	         * @param {Array.<module:zrender/Layer>} [prevLayer]
	         */
	        getLayers: function () {
	            return this._layers;
	        },
	
	        _updateLayerStatus: function (list) {
	
	            var layers = this._layers;
	
	            var elCounts = {};
	
	            this.eachBuildinLayer(function (layer, z) {
	                elCounts[z] = layer.elCount;
	                layer.elCount = 0;
	            });
	
	            for (var i = 0, l = list.length; i < l; i++) {
	                var el = list[i];
	                var zlevel = this._singleCanvas ? 0 : el.zlevel;
	                var layer = layers[zlevel];
	                if (layer) {
	                    layer.elCount++;
	                    // 已经被标记为需要刷新
	                    if (layer.__dirty) {
	                        continue;
	                    }
	                    layer.__dirty = el.__dirty;
	                }
	            }
	
	            // 层中的元素数量有发生变化
	            this.eachBuildinLayer(function (layer, z) {
	                if (elCounts[z] !== layer.elCount) {
	                    layer.__dirty = true;
	                }
	            });
	        },
	
	        /**
	         * 清除hover层外所有内容
	         */
	        clear: function () {
	            this.eachBuildinLayer(this._clearLayer);
	            return this;
	        },
	
	        _clearLayer: function (layer) {
	            layer.clear();
	        },
	
	        /**
	         * 修改指定zlevel的绘制参数
	         *
	         * @param {string} zlevel
	         * @param {Object} config 配置对象
	         * @param {string} [config.clearColor=0] 每次清空画布的颜色
	         * @param {string} [config.motionBlur=false] 是否开启动态模糊
	         * @param {number} [config.lastFrameAlpha=0.7]
	         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         */
	        configLayer: function (zlevel, config) {
	            if (config) {
	                var layerConfig = this._layerConfig;
	                if (!layerConfig[zlevel]) {
	                    layerConfig[zlevel] = config;
	                }
	                else {
	                    util.merge(layerConfig[zlevel], config, true);
	                }
	
	                var layer = this._layers[zlevel];
	
	                if (layer) {
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        },
	
	        /**
	         * 删除指定层
	         * @param {number} zlevel 层所在的zlevel
	         */
	        delLayer: function (zlevel) {
	            var layers = this._layers;
	            var zlevelList = this._zlevelList;
	            var layer = layers[zlevel];
	            if (!layer) {
	                return;
	            }
	            layer.dom.parentNode.removeChild(layer.dom);
	            delete layers[zlevel];
	
	            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	        },
	
	        /**
	         * 区域大小变化后重绘
	         */
	        resize: function (width, height) {
	            var domRoot = this._domRoot;
	            // FIXME Why ?
	            domRoot.style.display = 'none';
	
	            width = width || this._getWidth();
	            height = height || this._getHeight();
	
	            domRoot.style.display = '';
	
	            // 优化没有实际改变的resize
	            if (this._width != width || height != this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	
	                for (var id in this._layers) {
	                    this._layers[id].resize(width, height);
	                }
	
	                this.refresh(true);
	            }
	
	            this._width = width;
	            this._height = height;
	
	            return this;
	        },
	
	        /**
	         * 清除单独的一个层
	         * @param {number} zlevel
	         */
	        clearLayer: function (zlevel) {
	            var layer = this._layers[zlevel];
	            if (layer) {
	                layer.clear();
	            }
	        },
	
	        /**
	         * 释放
	         */
	        dispose: function () {
	            this.root.innerHTML = '';
	
	            this.root =
	            this.storage =
	
	            this._domRoot =
	            this._layers = null;
	        },
	
	        /**
	         * Get canvas which has all thing rendered
	         * @param {Object} opts
	         * @param {string} [opts.backgroundColor]
	         */
	        getRenderedCanvas: function (opts) {
	            opts = opts || {};
	            if (this._singleCanvas) {
	                return this._layers[0].dom;
	            }
	
	            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
	            imageLayer.initContext();
	
	            var ctx = imageLayer.ctx;
	            imageLayer.clearColor = opts.backgroundColor;
	            imageLayer.clear();
	
	            var displayList = this.storage.getDisplayList(true);
	
	            for (var i = 0; i < displayList.length; i++) {
	                var el = displayList[i];
	                if (!el.invisible) {
	                    el.beforeBrush && el.beforeBrush(ctx);
	                    // TODO Check image cross origin
	                    el.brush(ctx, false);
	                    el.afterBrush && el.afterBrush(ctx);
	                }
	            }
	
	            return imageLayer.dom;
	        },
	        /**
	         * 获取绘图区域宽度
	         */
	        getWidth: function () {
	            return this._width;
	        },
	
	        /**
	         * 获取绘图区域高度
	         */
	        getHeight: function () {
	            return this._height;
	        },
	
	        _getWidth: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            // FIXME Better way to get the width and height when element has not been append to the document
	            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))
	                    - (parseInt10(stl.paddingLeft) || 0)
	                    - (parseInt10(stl.paddingRight) || 0)) | 0;
	        },
	
	        _getHeight: function () {
	            var root = this.root;
	            var stl = document.defaultView.getComputedStyle(root);
	
	            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))
	                    - (parseInt10(stl.paddingTop) || 0)
	                    - (parseInt10(stl.paddingBottom) || 0)) | 0;
	        },
	
	        _pathToImage: function (id, path, width, height, dpr) {
	            var canvas = document.createElement('canvas');
	            var ctx = canvas.getContext('2d');
	
	            canvas.width = width * dpr;
	            canvas.height = height * dpr;
	
	            ctx.clearRect(0, 0, width * dpr, height * dpr);
	
	            var pathTransform = {
	                position: path.position,
	                rotation: path.rotation,
	                scale: path.scale
	            };
	            path.position = [0, 0, 0];
	            path.rotation = 0;
	            path.scale = [1, 1];
	            if (path) {
	                path.brush(ctx);
	            }
	
	            var ImageShape = __webpack_require__(30);
	            var imgShape = new ImageShape({
	                id: id,
	                style: {
	                    x: 0,
	                    y: 0,
	                    image: canvas
	                }
	            });
	
	            if (pathTransform.position != null) {
	                imgShape.position = path.position = pathTransform.position;
	            }
	
	            if (pathTransform.rotation != null) {
	                imgShape.rotation = path.rotation = pathTransform.rotation;
	            }
	
	            if (pathTransform.scale != null) {
	                imgShape.scale = path.scale = pathTransform.scale;
	            }
	
	            return imgShape;
	        },
	
	        _createPathToImage: function () {
	            var me = this;
	
	            return function (id, e, width, height) {
	                return me._pathToImage(
	                    id, e, width, height, me.dpr
	                );
	            };
	        }
	    };
	
	    module.exports = Painter;
	


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/Layer
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var util = __webpack_require__(9);
	    var config = __webpack_require__(25);
	
	    function returnFalse() {
	        return false;
	    }
	
	    /**
	     * 创建dom
	     *
	     * @inner
	     * @param {string} id dom id 待用
	     * @param {string} type dom type，such as canvas, div etc.
	     * @param {Painter} painter painter instance
	     * @param {number} number
	     */
	    function createDom(id, type, painter, dpr) {
	        var newDom = document.createElement(type);
	        var width = painter.getWidth();
	        var height = painter.getHeight();
	
	        var newDomStyle = newDom.style;
	        // 没append呢，请原谅我这样写，清晰~
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = 0;
	        newDomStyle.top = 0;
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.width = width * dpr;
	        newDom.height = height * dpr;
	
	        // id不作为索引用，避免可能造成的重名，定义为私有属性
	        newDom.setAttribute('data-zr-dom-id', id);
	        return newDom;
	    }
	
	    /**
	     * @alias module:zrender/Layer
	     * @constructor
	     * @extends module:zrender/mixin/Transformable
	     * @param {string} id
	     * @param {module:zrender/Painter} painter
	     * @param {number} [dpr]
	     */
	    var Layer = function(id, painter, dpr) {
	        var dom;
	        dpr = dpr || config.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, 'canvas', painter, dpr);
	        }
	        // Not using isDom because in node it will return false
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        this.id = id;
	        this.dom = dom;
	
	        var domStyle = dom.style;
	        if (domStyle) { // Not in node
	            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
	            domStyle['-webkit-user-select'] = 'none';
	            domStyle['user-select'] = 'none';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
	        }
	
	        this.domBack = null;
	        this.ctxBack = null;
	
	        this.painter = painter;
	
	        this.config = null;
	
	        // Configs
	        /**
	         * 每次清空画布的颜色
	         * @type {string}
	         * @default 0
	         */
	        this.clearColor = 0;
	        /**
	         * 是否开启动态模糊
	         * @type {boolean}
	         * @default false
	         */
	        this.motionBlur = false;
	        /**
	         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
	         * @type {number}
	         * @default 0.7
	         */
	        this.lastFrameAlpha = 0.7;
	
	        /**
	         * Layer dpr
	         * @type {number}
	         */
	        this.dpr = dpr;
	    };
	
	    Layer.prototype = {
	
	        constructor: Layer,
	
	        elCount: 0,
	
	        __dirty: true,
	
	        initContext: function () {
	            this.ctx = this.dom.getContext('2d');
	
	            var dpr = this.dpr;
	            if (dpr != 1) {
	                this.ctx.scale(dpr, dpr);
	            }
	        },
	
	        createBackBuffer: function () {
	            var dpr = this.dpr;
	
	            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
	            this.ctxBack = this.domBack.getContext('2d');
	
	            if (dpr != 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        },
	
	        /**
	         * @param  {number} width
	         * @param  {number} height
	         */
	        resize: function (width, height) {
	            var dpr = this.dpr;
	
	            var dom = this.dom;
	            var domStyle = dom.style;
	            var domBack = this.domBack;
	
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	
	            dom.width = width * dpr;
	            dom.height = height * dpr;
	
	            if (dpr != 1) {
	                this.ctx.scale(dpr, dpr);
	            }
	
	            if (domBack) {
	                domBack.width = width * dpr;
	                domBack.height = height * dpr;
	
	                if (dpr != 1) {
	                    this.ctxBack.scale(dpr, dpr);
	                }
	            }
	        },
	
	        /**
	         * 清空该层画布
	         * @param {boolean} clearAll Clear all with out motion blur
	         */
	        clear: function (clearAll) {
	            var dom = this.dom;
	            var ctx = this.ctx;
	            var width = dom.width;
	            var height = dom.height;
	
	            var haveClearColor = this.clearColor;
	            var haveMotionBLur = this.motionBlur && !clearAll;
	            var lastFrameAlpha = this.lastFrameAlpha;
	
	            var dpr = this.dpr;
	
	            if (haveMotionBLur) {
	                if (!this.domBack) {
	                    this.createBackBuffer();
	                }
	
	                this.ctxBack.globalCompositeOperation = 'copy';
	                this.ctxBack.drawImage(
	                    dom, 0, 0,
	                    width / dpr,
	                    height / dpr
	                );
	            }
	
	            ctx.clearRect(0, 0, width / dpr, height / dpr);
	            if (haveClearColor) {
	                ctx.save();
	                ctx.fillStyle = this.clearColor;
	                ctx.fillRect(0, 0, width / dpr, height / dpr);
	                ctx.restore();
	            }
	
	            if (haveMotionBLur) {
	                var domBack = this.domBack;
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);
	                ctx.restore();
	            }
	        }
	    };
	
	    module.exports = Layer;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Image element
	 * @module zrender/graphic/Image
	 */
	
	
	
	    var Displayable = __webpack_require__(31);
	    var BoundingRect = __webpack_require__(26);
	    var zrUtil = __webpack_require__(9);
	    var roundRectHelper = __webpack_require__(35);
	
	    var LRU = __webpack_require__(36);
	    var globalImageCache = new LRU(50);
	    /**
	     * @alias zrender/graphic/Image
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var ZImage = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    ZImage.prototype = {
	
	        constructor: ZImage,
	
	        type: 'image',
	
	        brush: function (ctx) {
	            var style = this.style;
	            var src = style.image;
	            var image;
	            // style.image is a url string
	            if (typeof src === 'string') {
	                image = this._image;
	            }
	            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
	            else {
	                image = src;
	            }
	            // FIXME Case create many images with src
	            if (!image && src) {
	                // Try get from global image cache
	                var cachedImgObj = globalImageCache.get(src);
	                if (!cachedImgObj) {
	                    // Create a new image
	                    image = new Image();
	                    image.onload = function () {
	                        image.onload = null;
	                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
	                            cachedImgObj.pending[i].dirty();
	                        }
	                    };
	                    cachedImgObj = {
	                        image: image,
	                        pending: [this]
	                    };
	                    image.src = src;
	                    globalImageCache.put(src, cachedImgObj);
	                    this._image = image;
	                    return;
	                }
	                else {
	                    image = cachedImgObj.image;
	                    this._image = image;
	                    // Image is not complete finish, add to pending list
	                    if (!image.width || !image.height) {
	                        cachedImgObj.pending.push(this);
	                        return;
	                    }
	                }
	            }
	
	            if (image) {
	                // 图片已经加载完成
	                // if (image.nodeName.toUpperCase() == 'IMG') {
	                //     if (!image.complete) {
	                //         return;
	                //     }
	                // }
	                // Else is canvas
	
	                var width = style.width || image.width;
	                var height = style.height || image.height;
	                var x = style.x || 0;
	                var y = style.y || 0;
	                // 图片加载失败
	                if (!image.width || !image.height) {
	                    return;
	                }
	
	                ctx.save();
	
	                style.bind(ctx);
	
	                // 设置transform
	                this.setTransform(ctx);
	
	                if (style.r) {
	                    // Border radius clipping
	                    // FIXME
	                    ctx.beginPath();
	                    roundRectHelper.buildPath(ctx, style);
	                    ctx.clip();
	                }
	
	                if (style.sWidth && style.sHeight) {
	                    var sx = style.sx || 0;
	                    var sy = style.sy || 0;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, style.sWidth, style.sHeight,
	                        x, y, width, height
	                    );
	                }
	                else if (style.sx && style.sy) {
	                    var sx = style.sx;
	                    var sy = style.sy;
	                    var sWidth = width - sx;
	                    var sHeight = height - sy;
	                    ctx.drawImage(
	                        image,
	                        sx, sy, sWidth, sHeight,
	                        x, y, width, height
	                    );
	                }
	                else {
	                    ctx.drawImage(image, x, y, width, height);
	                }
	
	                // 如果没设置宽和高的话自动根据图片宽高设置
	                if (style.width == null) {
	                    style.width = width;
	                }
	                if (style.height == null) {
	                    style.height = height;
	                }
	
	                // Draw rect text
	                if (style.text != null) {
	                    this.drawRectText(ctx, this.getBoundingRect());
	                }
	
	                ctx.restore();
	            }
	        },
	
	        getBoundingRect: function () {
	            var style = this.style;
	            if (! this._rect) {
	                this._rect = new BoundingRect(
	                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
	                );
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(ZImage, Displayable);
	
	    module.exports = ZImage;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 可绘制的图形基类
	 * Base class of all displayable graphic objects
	 * @module zrender/graphic/Displayable
	 */
	
	
	
	    var zrUtil = __webpack_require__(9);
	
	    var Style = __webpack_require__(32);
	
	    var Element = __webpack_require__(15);
	    var RectText = __webpack_require__(33);
	    // var Stateful = require('./mixin/Stateful');
	
	    /**
	     * @alias module:zrender/graphic/Displayable
	     * @extends module:zrender/Element
	     * @extends module:zrender/graphic/mixin/RectText
	     */
	    function Displayable(opts) {
	
	        opts = opts || {};
	
	        Element.call(this, opts);
	
	        // Extend properties
	        for (var name in opts) {
	            if (
	                opts.hasOwnProperty(name) &&
	                name !== 'style'
	            ) {
	                this[name] = opts[name];
	            }
	        }
	
	        /**
	         * @type {module:zrender/graphic/Style}
	         */
	        this.style = new Style(opts.style);
	
	        this._rect = null;
	        // Shapes for cascade clipping.
	        this.__clipPaths = [];
	
	        // FIXME Stateful must be mixined after style is setted
	        // Stateful.call(this, opts);
	    }
	
	    Displayable.prototype = {
	
	        constructor: Displayable,
	
	        type: 'displayable',
	
	        /**
	         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
	         * Dirty flag. From which painter will determine if this displayable object needs brush
	         * @name module:zrender/graphic/Displayable#__dirty
	         * @type {boolean}
	         */
	        __dirty: true,
	
	        /**
	         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
	         * If ignore drawing of the displayable object. Mouse event will still be triggered
	         * @name module:/zrender/graphic/Displayable#invisible
	         * @type {boolean}
	         * @default false
	         */
	        invisible: false,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z: 0,
	
	        /**
	         * @name module:/zrender/graphic/Displayable#z
	         * @type {number}
	         * @default 0
	         */
	        z2: 0,
	
	        /**
	         * z层level，决定绘画在哪层canvas中
	         * @name module:/zrender/graphic/Displayable#zlevel
	         * @type {number}
	         * @default 0
	         */
	        zlevel: 0,
	
	        /**
	         * 是否可拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        draggable: false,
	
	        /**
	         * 是否正在拖拽
	         * @name module:/zrender/graphic/Displayable#draggable
	         * @type {boolean}
	         * @default false
	         */
	        dragging: false,
	
	        /**
	         * 是否相应鼠标事件
	         * @name module:/zrender/graphic/Displayable#silent
	         * @type {boolean}
	         * @default false
	         */
	        silent: false,
	
	        /**
	         * If enable culling
	         * @type {boolean}
	         * @default false
	         */
	        culling: false,
	
	        /**
	         * Mouse cursor when hovered
	         * @name module:/zrender/graphic/Displayable#cursor
	         * @type {string}
	         */
	        cursor: 'pointer',
	
	        /**
	         * If hover area is bounding rect
	         * @name module:/zrender/graphic/Displayable#rectHover
	         * @type {string}
	         */
	        rectHover: false,
	
	        beforeBrush: function (ctx) {},
	
	        afterBrush: function (ctx) {},
	
	        /**
	         * 图形绘制方法
	         * @param {Canvas2DRenderingContext} ctx
	         */
	        // Interface
	        brush: function (ctx) {},
	
	        /**
	         * 获取最小包围盒
	         * @return {module:zrender/core/BoundingRect}
	         */
	        // Interface
	        getBoundingRect: function () {},
	
	        /**
	         * 判断坐标 x, y 是否在图形上
	         * If displayable element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        contain: function (x, y) {
	            return this.rectContain(x, y);
	        },
	
	        /**
	         * @param  {Function} cb
	         * @param  {}   context
	         */
	        traverse: function (cb, context) {
	            cb.call(context, this);
	        },
	
	        /**
	         * 判断坐标 x, y 是否在图形的包围盒上
	         * If bounding rect of element contain coord x, y
	         * @param  {number} x
	         * @param  {number} y
	         * @return {boolean}
	         */
	        rectContain: function (x, y) {
	            var coord = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            return rect.contain(coord[0], coord[1]);
	        },
	
	        /**
	         * 标记图形元素为脏，并且在下一帧重绘
	         * Mark displayable element dirty and refresh next frame
	         */
	        dirty: function () {
	            this.__dirty = true;
	
	            this._rect = null;
	
	            this.__zr && this.__zr.refresh();
	        },
	
	        /**
	         * 图形是否会触发事件
	         * If displayable object binded any event
	         * @return {boolean}
	         */
	        // TODO, 通过 bind 绑定的事件
	        // isSilent: function () {
	        //     return !(
	        //         this.hoverable || this.draggable
	        //         || this.onmousemove || this.onmouseover || this.onmouseout
	        //         || this.onmousedown || this.onmouseup || this.onclick
	        //         || this.ondragenter || this.ondragover || this.ondragleave
	        //         || this.ondrop
	        //     );
	        // },
	        /**
	         * Alias for animate('style')
	         * @param {boolean} loop
	         */
	        animateStyle: function (loop) {
	            return this.animate('style', loop);
	        },
	
	        attrKV: function (key, value) {
	            if (key !== 'style') {
	                Element.prototype.attrKV.call(this, key, value);
	            }
	            else {
	                this.style.set(value);
	            }
	        },
	
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setStyle: function (key, value) {
	            this.style.set(key, value);
	            this.dirty();
	            return this;
	        }
	    };
	
	    zrUtil.inherits(Displayable, Element);
	
	    zrUtil.mixin(Displayable, RectText);
	    // zrUtil.mixin(Displayable, Stateful);
	
	    module.exports = Displayable;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * @module zrender/graphic/Style
	 */
	
	
	
	    var STYLE_LIST_COMMON = [
	        'lineCap', 'lineJoin', 'miterLimit',
	        'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'shadowColor'
	    ];
	
	    var Style = function (opts) {
	        this.extendFrom(opts);
	    };
	
	    Style.prototype = {
	
	        constructor: Style,
	
	        /**
	         * @type {string}
	         */
	        fill: '#000000',
	
	        /**
	         * @type {string}
	         */
	        stroke: null,
	
	        /**
	         * @type {number}
	         */
	        opacity: 1,
	
	        /**
	         * @type {Array.<number>}
	         */
	        lineDash: null,
	
	        /**
	         * @type {number}
	         */
	        lineDashOffset: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        shadowOffsetY: 0,
	
	        /**
	         * @type {number}
	         */
	        lineWidth: 1,
	
	        /**
	         * If stroke ignore scale
	         * @type {Boolean}
	         */
	        strokeNoScale: false,
	
	        // Bounding rect text configuration
	        // Not affected by element transform
	        /**
	         * @type {string}
	         */
	        text: null,
	
	        /**
	         * @type {string}
	         */
	        textFill: '#000',
	
	        /**
	         * @type {string}
	         */
	        textStroke: null,
	
	        /**
	         * 'inside', 'left', 'right', 'top', 'bottom'
	         * [x, y]
	         * @type {string|Array.<number>}
	         * @default 'inside'
	         */
	        textPosition: 'inside',
	
	        /**
	         * @type {string}
	         */
	        textBaseline: null,
	
	        /**
	         * @type {string}
	         */
	        textAlign: null,
	
	        /**
	         * @type {string}
	         */
	        textVerticalAlign: null,
	
	        /**
	         * @type {number}
	         */
	        textDistance: 5,
	
	        /**
	         * @type {number}
	         */
	        textShadowBlur: 0,
	
	        /**
	         * @type {number}
	         */
	        textShadowOffsetX: 0,
	
	        /**
	         * @type {number}
	         */
	        textShadowOffsetY: 0,
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         */
	        bind: function (ctx, el) {
	            var fill = this.fill;
	            var stroke = this.stroke;
	            for (var i = 0; i < STYLE_LIST_COMMON.length; i++) {
	                var styleName = STYLE_LIST_COMMON[i];
	
	                if (this[styleName] != null) {
	                    ctx[styleName] = this[styleName];
	                }
	            }
	            if (stroke != null) {
	                var lineWidth = this.lineWidth;
	                ctx.lineWidth = lineWidth / (
	                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
	                );
	            }
	            if (fill != null) {
	                 // Use canvas gradient if has
	                ctx.fillStyle = fill.canvasGradient ? fill.canvasGradient : fill;
	            }
	            if (stroke != null) {
	                 // Use canvas gradient if has
	                ctx.strokeStyle = stroke.canvasGradient ? stroke.canvasGradient : stroke;
	            }
	            this.opacity != null && (ctx.globalAlpha = this.opacity);
	        },
	
	        /**
	         * Extend from other style
	         * @param {zrender/graphic/Style} otherStyle
	         * @param {boolean} overwrite
	         */
	        extendFrom: function (otherStyle, overwrite) {
	            if (otherStyle) {
	                var target = this;
	                for (var name in otherStyle) {
	                    if (otherStyle.hasOwnProperty(name)
	                        && (overwrite || ! target.hasOwnProperty(name))
	                    ) {
	                        target[name] = otherStyle[name];
	                    }
	                }
	            }
	        },
	
	        /**
	         * Batch setting style with a given object
	         * @param {Object|string} obj
	         * @param {*} [obj]
	         */
	        set: function (obj, value) {
	            if (typeof obj === 'string') {
	                this[obj] = value;
	            }
	            else {
	                this.extendFrom(obj, true);
	            }
	        },
	
	        /**
	         * Clone
	         * @return {zrender/graphic/Style} [description]
	         */
	        clone: function () {
	            var newStyle = new this.constructor();
	            newStyle.extendFrom(this, true);
	            return newStyle;
	        }
	    };
	
	    var styleProto = Style.prototype;
	    var name;
	    var i;
	    for (i = 0; i < STYLE_LIST_COMMON.length; i++) {
	        name = STYLE_LIST_COMMON[i];
	        if (!(name in styleProto)) {
	            styleProto[name] = null;
	        }
	    }
	
	    module.exports = Style;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Mixin for drawing text in a element bounding rect
	 * @module zrender/mixin/RectText
	 */
	
	
	
	    var textContain = __webpack_require__(34);
	    var BoundingRect = __webpack_require__(26);
	
	    var tmpRect = new BoundingRect();
	
	    var RectText = function () {};
	
	    function parsePercent(value, maxValue) {
	        if (typeof value === 'string') {
	            if (value.lastIndexOf('%') >= 0) {
	                return parseFloat(value) / 100 * maxValue;
	            }
	            return parseFloat(value);
	        }
	        return value;
	    }
	
	    function setTransform(ctx, m) {
	        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
	    }
	
	    RectText.prototype = {
	
	        constructor: RectText,
	
	        /**
	         * Draw text in a rect with specified position.
	         * @param  {CanvasRenderingContext} ctx
	         * @param  {Object} rect Displayable rect
	         * @return {Object} textRect Alternative precalculated text bounding rect
	         */
	        drawRectText: function (ctx, rect, textRect) {
	            var style = this.style;
	            var text = style.text;
	            // Convert to string
	            text != null && (text += '');
	            if (!text) {
	                return;
	            }
	            var x;
	            var y;
	            var textPosition = style.textPosition;
	            var distance = style.textDistance;
	            var align = style.textAlign;
	            var font = style.textFont || style.font;
	            var baseline = style.textBaseline;
	            var verticalAlign = style.textVerticalAlign;
	
	            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
	
	            // Transform rect to view space
	            var transform = this.transform;
	            var invTransform = this.invTransform;
	            if (transform) {
	                tmpRect.copy(rect);
	                tmpRect.applyTransform(transform);
	                rect = tmpRect;
	                // Transform back
	                setTransform(ctx, invTransform);
	            }
	
	            // Text position represented by coord
	            if (textPosition instanceof Array) {
	                // Percent
	                x = rect.x + parsePercent(textPosition[0], rect.width);
	                y = rect.y + parsePercent(textPosition[1], rect.height);
	                align = align || 'left';
	                baseline = baseline || 'top';
	            }
	            else {
	                var res = textContain.adjustTextPositionOnRect(
	                    textPosition, rect, textRect, distance
	                );
	                x = res.x;
	                y = res.y;
	                // Default align and baseline when has textPosition
	                align = align || res.textAlign;
	                baseline = baseline || res.textBaseline;
	            }
	
	            ctx.textAlign = align;
	            if (verticalAlign) {
	                switch (verticalAlign) {
	                    case 'middle':
	                        y -= textRect.height / 2;
	                        break;
	                    case 'bottom':
	                        y -= textRect.height;
	                        break;
	                    // 'top'
	                }
	                // Ignore baseline
	                ctx.textBaseline = 'top';
	            }
	            else {
	                ctx.textBaseline = baseline;
	            }
	
	            var textFill = style.textFill;
	            var textStroke = style.textStroke;
	            textFill && (ctx.fillStyle = textFill);
	            textStroke && (ctx.strokeStyle = textStroke);
	            ctx.font = font;
	
	            // Text shadow
	            ctx.shadowColor = style.textShadowColor;
	            ctx.shadowBlur = style.textShadowBlur;
	            ctx.shadowOffsetX = style.textShadowOffsetX;
	            ctx.shadowOffsetY = style.textShadowOffsetY;
	
	            var textLines = text.split('\n');
	            for (var i = 0; i < textLines.length; i++) {
	                textFill && ctx.fillText(textLines[i], x, y);
	                textStroke && ctx.strokeText(textLines[i], x, y);
	                y += textRect.lineHeight;
	            }
	
	            // Transform again
	            transform && setTransform(ctx, transform);
	        }
	    };
	
	    module.exports = RectText;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var textWidthCache = {};
	    var textWidthCacheCounter = 0;
	    var TEXT_CACHE_MAX = 5000;
	
	    var util = __webpack_require__(9);
	    var BoundingRect = __webpack_require__(26);
	
	    function getTextWidth(text, textFont) {
	        var key = text + ':' + textFont;
	        if (textWidthCache[key]) {
	            return textWidthCache[key];
	        }
	
	        var textLines = (text + '').split('\n');
	        var width = 0;
	
	        for (var i = 0, l = textLines.length; i < l; i++) {
	            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
	            width =  Math.max(textContain.measureText(textLines[i], textFont).width, width);
	        }
	
	        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
	            textWidthCacheCounter = 0;
	            textWidthCache = {};
	        }
	        textWidthCacheCounter++;
	        textWidthCache[key] = width;
	
	        return width;
	    }
	
	    function getTextRect(text, textFont, textAlign, textBaseline) {
	        var textLineLen = ((text || '') + '').split('\n').length;
	
	        var width = getTextWidth(text, textFont);
	        // FIXME 高度计算比较粗暴
	        var lineHeight = getTextWidth('国', textFont);
	        var height = textLineLen * lineHeight;
	
	        var rect = new BoundingRect(0, 0, width, height);
	        // Text has a special line height property
	        rect.lineHeight = lineHeight;
	
	        switch (textBaseline) {
	            case 'bottom':
	            case 'alphabetic':
	                rect.y -= lineHeight;
	                break;
	            case 'middle':
	                rect.y -= lineHeight / 2;
	                break;
	            // case 'hanging':
	            // case 'top':
	        }
	
	        // FIXME Right to left language
	        switch (textAlign) {
	            case 'end':
	            case 'right':
	                rect.x -= rect.width;
	                break;
	            case 'center':
	                rect.x -= rect.width / 2;
	                break;
	            // case 'start':
	            // case 'left':
	        }
	
	        return rect;
	    }
	
	    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
	
	        var x = rect.x;
	        var y = rect.y;
	
	        var height = rect.height;
	        var width = rect.width;
	
	        var textHeight = textRect.height;
	
	        var halfHeight = height / 2 - textHeight / 2;
	
	        var textAlign = 'left';
	
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance + textHeight;
	                textAlign = 'center';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textAlign = 'left';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - textHeight - distance;
	                textAlign = 'center';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                textAlign = 'left';
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - textHeight - distance;
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - textHeight - distance;
	                textAlign = 'right';
	                break;
	        }
	
	        return {
	            x: x,
	            y: y,
	            textAlign: textAlign,
	            textBaseline: 'top'
	        };
	    }
	
	    /**
	     * Show ellipsis if overflow.
	     *
	     * @param  {string} text
	     * @param  {string} textFont
	     * @param  {string} containerWidth
	     * @param  {Object} [options]
	     * @param  {number} [options.ellipsis='...']
	     * @param  {number} [options.maxIterations=3]
	     * @param  {number} [options.minCharacters=3]
	     * @return {string}
	     */
	    function textEllipsis(text, textFont, containerWidth, options) {
	        if (!containerWidth) {
	            return '';
	        }
	
	        options = util.defaults({
	            ellipsis: '...',
	            minCharacters: 3,
	            maxIterations: 3,
	            cnCharWidth: getTextWidth('国', textFont),
	            // FIXME
	            // 未考虑非等宽字体
	            ascCharWidth: getTextWidth('a', textFont)
	        }, options, true);
	
	        containerWidth -= getTextWidth(options.ellipsis);
	
	        var textLines = (text + '').split('\n');
	
	        for (var i = 0, len = textLines.length; i < len; i++) {
	            textLines[i] = textLineTruncate(
	                textLines[i], textFont, containerWidth, options
	            );
	        }
	
	        return textLines.join('\n');
	    }
	
	    function textLineTruncate(text, textFont, containerWidth, options) {
	        // FIXME
	        // 粗糙得写的，尚未考虑性能和各种语言、字体的效果。
	        for (var i = 0;; i++) {
	            var lineWidth = getTextWidth(text, textFont);
	
	            if (lineWidth < containerWidth || i >= options.maxIterations) {
	                text += options.ellipsis;
	                break;
	            }
	
	            var subLength = i === 0
	                ? estimateLength(text, containerWidth, options)
	                : Math.floor(text.length * containerWidth / lineWidth);
	
	            if (subLength < options.minCharacters) {
	                text = '';
	                break;
	            }
	
	            text = text.substr(0, subLength);
	        }
	
	        return text;
	    }
	
	    function estimateLength(text, containerWidth, options) {
	        var width = 0;
	        var i = 0;
	        for (var len = text.length; i < len && width < containerWidth; i++) {
	            var charCode = text.charCodeAt(i);
	            width += (0 <= charCode && charCode <= 127)
	                ? options.ascCharWidth : options.cnCharWidth;
	        }
	        return i;
	    }
	
	    var textContain = {
	
	        getWidth: getTextWidth,
	
	        getBoundingRect: getTextRect,
	
	        adjustTextPositionOnRect: adjustTextPositionOnRect,
	
	        ellipsis: textEllipsis,
	
	        measureText: function (text, textFont) {
	            var ctx = util.getContext();
	            ctx.font = textFont;
	            return ctx.measureText(text);
	        }
	    };
	
	    module.exports = textContain;


/***/ },
/* 35 */
/***/ function(module, exports) {

	
	
	    module.exports = {
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            var r = shape.r;
	            var r1;
	            var r2;
	            var r3;
	            var r4;
	
	            // Convert width and height to positive for better borderRadius
	            if (width < 0) {
	                x = x + width;
	                width = -width;
	            }
	            if (height < 0) {
	                y = y + height;
	                height = -height;
	            }
	
	            if (typeof r === 'number') {
	                r1 = r2 = r3 = r4 = r;
	            }
	            else if (r instanceof Array) {
	                if (r.length === 1) {
	                    r1 = r2 = r3 = r4 = r[0];
	                }
	                else if (r.length === 2) {
	                    r1 = r3 = r[0];
	                    r2 = r4 = r[1];
	                }
	                else if (r.length === 3) {
	                    r1 = r[0];
	                    r2 = r4 = r[1];
	                    r3 = r[2];
	                }
	                else {
	                    r1 = r[0];
	                    r2 = r[1];
	                    r3 = r[2];
	                    r4 = r[3];
	                }
	            }
	            else {
	                r1 = r2 = r3 = r4 = 0;
	            }
	
	            var total;
	            if (r1 + r2 > width) {
	                total = r1 + r2;
	                r1 *= width / total;
	                r2 *= width / total;
	            }
	            if (r3 + r4 > width) {
	                total = r3 + r4;
	                r3 *= width / total;
	                r4 *= width / total;
	            }
	            if (r2 + r3 > height) {
	                total = r2 + r3;
	                r2 *= height / total;
	                r3 *= height / total;
	            }
	            if (r1 + r4 > height) {
	                total = r1 + r4;
	                r1 *= height / total;
	                r4 *= height / total;
	            }
	            ctx.moveTo(x + r1, y);
	            ctx.lineTo(x + width - r2, y);
	            r2 !== 0 && ctx.quadraticCurveTo(
	                x + width, y, x + width, y + r2
	            );
	            ctx.lineTo(x + width, y + height - r3);
	            r3 !== 0 && ctx.quadraticCurveTo(
	                x + width, y + height, x + width - r3, y + height
	            );
	            ctx.lineTo(x + r4, y + height);
	            r4 !== 0 && ctx.quadraticCurveTo(
	                x, y + height, x, y + height - r4
	            );
	            ctx.lineTo(x, y + r1);
	            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
	        }
	    };


/***/ },
/* 36 */
/***/ function(module, exports) {

	// Simple LRU cache use doubly linked list
	// @module zrender/core/LRU
	
	
	    /**
	     * Simple double linked list. Compared with array, it has O(1) remove operation.
	     * @constructor
	     */
	    var LinkedList = function() {
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.head = null;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.tail = null;
	
	        this._len = 0;
	    };
	
	    var linkedListProto = LinkedList.prototype;
	    /**
	     * Insert a new value at the tail
	     * @param  {} val
	     * @return {module:zrender/core/LRU~Entry}
	     */
	    linkedListProto.insert = function(val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	
	    /**
	     * Insert an entry at the tail
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.insertEntry = function(entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	
	    /**
	     * Remove entry.
	     * @param  {module:zrender/core/LRU~Entry} entry
	     */
	    linkedListProto.remove = function(entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            // Is head
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            // Is tail
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	
	    /**
	     * @return {number}
	     */
	    linkedListProto.len = function() {
	        return this._len;
	    };
	
	    /**
	     * @constructor
	     * @param {} val
	     */
	    var Entry = function(val) {
	        /**
	         * @type {}
	         */
	        this.value = val;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.next;
	
	        /**
	         * @type {module:zrender/core/LRU~Entry}
	         */
	        this.prev;
	    };
	
	    /**
	     * LRU Cache
	     * @constructor
	     * @alias module:zrender/core/LRU
	     */
	    var LRU = function(maxSize) {
	
	        this._list = new LinkedList();
	
	        this._map = {};
	
	        this._maxSize = maxSize || 10;
	    };
	
	    var LRUProto = LRU.prototype;
	
	    /**
	     * @param  {string} key
	     * @param  {} value
	     */
	    LRUProto.put = function(key, value) {
	        var list = this._list;
	        var map = this._map;
	        if (map[key] == null) {
	            var len = list.len();
	            if (len >= this._maxSize && len > 0) {
	                // Remove the least recently used
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	            }
	
	            var entry = list.insert(value);
	            entry.key = key;
	            map[key] = entry;
	        }
	    };
	
	    /**
	     * @param  {string} key
	     * @return {}
	     */
	    LRUProto.get = function(key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            // Put the latest used entry in the tail
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	
	            return entry.value;
	        }
	    };
	
	    /**
	     * Clear the cache
	     */
	    LRUProto.clear = function() {
	        this._list.clear();
	        this._map = {};
	    };
	
	    module.exports = LRU;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BO节点
	 * 1.BO是一个矩形
	 * 2.BO有名字
	 * 3.BO有事件决策[]，双击事件决策弹出详情
	 * 4.BO有外键属性[]
	 * 5.BO有子BO
	 * 6.当前BO特殊颜色显示
	 * 7.双击BO弹出BO属性以及属性事件决策页面
	 * @module fish-topo-bo/node/BoNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(38);
	    var BoName = __webpack_require__(39);
	    var EventDecision = __webpack_require__(69);
	    var Line = __webpack_require__(70);
	    var BoAttr = __webpack_require__(71);
	    var graphic = __webpack_require__(40);
	
	
	    /**
	     *
	     * @param {{
	     *          id: String BO主键,
	     *          name: String BO名字,
	     *          boEventArr: [] BO事件决策数组,
	     *          boAttrArr: [] BO属性数组
	     *          }} boData, bo数据对象
	     * @param {{
	     *          startPos: {x: number, y: number} 起始位置,
	     *          displayAttrDataType: boolean 是否显示属性数据类型,
	     *          displayAttrEvent: boolean 是否显示属性事件决策,
	     *          boClickable: boolean BO是否支持点击事件, 可空 默认false
	     *          boPopupOpts: Object BO弹出页面参数，url,width,height等
	     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false
	     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等
	     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false
	     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等
	     *          isCurrent: boolean 是否为当前BO
	     *          }} opts
	     * @constructor
	     */
	    function BO(boData, opts) {
	
	        /**
	         * BO数据
	         * @type {Object}
	         * @private
	         */
	        this._data = boData;
	
	        /**
	         * 初始坐标，用于最后画BO矩形
	         * @type {{x: number, y: number}}
	         * @private
	         */
	        this._oriStartPos = opts.startPos;
	
	        /**
	         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算
	         * @type {{x: number, y: number}}
	         * @private
	         */
	        this._nextStartPos = {
	            x: opts.startPos.x,
	            y: opts.startPos.y
	        };
	
	        /**
	         * 是否显示属性数据类型
	         * @type {boolean}
	         * @private
	         */
	        this._displayAttrDataType = opts.displayAttrDataType || false;
	
	        /**
	         * 是否显示属性事件决策
	         * @type {boolean}
	         * @private
	         */
	        this._displayAttrEvent = opts.displayAttrEvent || false;
	
	        //TODO
	        if (this._displayAttrEvent) {
	            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;
	        } else if (this._displayAttrDataType) {
	            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;
	        }
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._boClickable = opts.boClickable || false;
	        this._boPopupOpts = opts.boPopupOpts;
	        this._boEventClickable = opts.boEventClickable || false;
	        this._boEventPopupOpts = opts.boEventPopupOpts;
	        this._attrEventClickable = opts.attrEventClickable || false;
	        this._attrEventPopupOpts = opts.attrEventPopupOpts;
	
	        /**
	         * 是否是当前BO，当前BO特殊颜色显示
	         * @type {boolean}
	         * @private
	         */
	        this._isCurrent = opts.isCurrent || false;
	
	
	        /**
	         * BO矩形高度，根据实际内容计算
	         * @type {number}
	         * @private
	         */
	        this._boShapeHeight = 0;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	        this._group.setCurrent = function (style) {
	            //Group最后一个是BO矩形
	            var _boShape = this.childAt(this.childCount() - 1);
	
	            if (style) {
	                fish.extend(_boShape.style, style);
	            } else {
	                //默认效果
	                _boShape.style.fill = '#66CC99';
	            }
	
	        };
	
	        this._render();
	    }
	
	
	    var boProto = BO.prototype;
	
	    /**
	     * 获取BO整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    boProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 获取数据
	     * @returns {Object}
	     */
	    boProto.getData = function () {
	        return this._data;
	    };
	
	    boProto.getLayout = function () {
	        return this._data.layout;
	    };
	
	
	
	    /**
	     * 设置当前BO特殊演示显示
	     */
	    boProto.setCurrent = function () {
	        //BO矩形是最后一个图形
	        this.childAt(this.childCount - 1).style.fill = '#66CC99'
	    };
	
	    /**
	     * 生成BO整体图形
	     * @private
	     */
	    boProto._render = function () {
	        //BO名字
	        this._createBoName();
	
	        //BO事件决策
	        this._createEventDecision();
	
	        //BO属性
	        this._createBoAttr();
	
	        //BO矩形
	        this._createBoShape();
	
	        //TODO
	        Const.BO_NODE_WIDTH = 180;
	    };
	
	
	    /**
	     * 生成BO名字文本
	     * @private
	     */
	    boProto._createBoName = function () {
	        var _boNameShape = BoName(this._data.name, this._nextStartPos);
	
	        if (this._boClickable) {
	            _boNameShape.clickable = this._boClickable;
	            _boNameShape._data = this._data;
	            _boNameShape._boPopupOpts = this._boPopupOpts;
	            _boNameShape.onclick = this._click;
	        }
	
	        this._group.add(_boNameShape);
	        this._calNextShapeStartPos(_boNameShape);
	    };
	
	    /**
	     * 生成BO事件决策
	     * @private
	     */
	    boProto._createEventDecision = function () {
	
	        //如果没有BO事件决策，则返回
	        if (!this._data.boEventArr) {
	            return;
	        }
	
	        var _boEventArr = this._data.boEventArr,
	            _boEventLen = _boEventArr.length,
	            _eventShape,
	            _eventOpts = {
	                startPos: this._nextStartPos,
	                clickable: this._boEventClickable,
	                popupOpts: this._boEventPopupOpts
	            };
	
	        for (var i = 0; i < _boEventLen; i++) {
	            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);
	            this._group.add(_eventShape.getShape());
	            this._calNextShapeStartPos(_eventShape.getShape());
	        }
	
	    };
	
	    /**
	     * 生成BO属性
	     * @private
	     */
	    boProto._createBoAttr = function () {
	        //如果没有BO属性，则返回
	        if (!this._data.boAttrArr) {
	            return;
	        }
	
	        var _boAttrArr = this._data.boAttrArr,
	            _boAttrLen = _boAttrArr.length,
	            _boAttrShape, _lineShape,
	            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};
	
	        for (var i = 0; i < _boAttrLen; i++) {
	            if (i == 0) {
	                _lineShape = Line.BoLine(this._nextStartPos); //实线
	            }
	            else {
	                _lineShape = Line.AttrLine(this._nextStartPos);//虚线
	            }
	
	            this._group.add(_lineShape);
	
	            this._calNextShapeStartPos(_lineShape);
	
	            _boAttrShape = new BoAttr(_boAttrArr[i],
	                {
	                    startPos: this._nextStartPos,
	                    displayDataType: this._displayAttrDataType,
	                    displayEventDecision: this._displayAttrEvent,
	                    eventClickable: this._attrEventClickable,
	                    eventPopupOpts: this._attrEventPopupOpts
	                }
	            );
	            this._group.add(_boAttrShape.getShape());
	            this._calNextShapeStartPos(_boAttrShape.getShape())
	        }
	
	        if (this._displayAttrEvent) {
	            _lineShape = Line.AttrEventLine(_attrEventStartPos,
	                this._nextStartPos.y - _attrEventStartPos.y
	            );
	            this._group.add(_lineShape);
	        }
	    };
	
	
	    /**
	     * 计算下一个图形的开始位置，以及BO矩形的高度
	     * @param curShape 当前图形
	     * @private
	     */
	    boProto._calNextShapeStartPos = function (curShape) {
	        //下一图形起始位置
	        this._nextStartPos.y += curShape.getBoundingRect().height;
	
	        //BO矩形高度增加
	        this._boShapeHeight += curShape.getBoundingRect().height;
	    };
	
	
	    /**
	     * 生成BO矩形
	     * @private
	     */
	    boProto._createBoShape = function () {
	        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?
	                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,
	            shape = new graphic.Rect({
	                position: [this._oriStartPos.x, this._oriStartPos.y],
	
	                shape: {
	                    r: 5,
	                    width: Const.BO_NODE_WIDTH,
	                    height: height
	                },
	
	                style: {
	                    brushType: 'both',
	                    fill: this._isCurrent ? '#66CC99' : 'white',
	                    stroke: '#000000',
	                    lineWidth: 1,
	                    lineCape: 'round'
	                },
	
	                zlevel: -1
	            });
	
	        if (this._boClickable) {
	            shape._data = this._data;
	            shape._boPopupOpts = this._boPopupOpts;
	
	            shape.clickable = this._boClickable;
	            shape.onclick = this._click;
	        }
	
	        this._group.add(shape);
	    };
	
	    /**
	     * 点击事件
	     * @private
	     */
	    boProto._click = function () {
	        var options = fish.extend(
	            {
	                viewOption: {
	                    DATA: this._data
	                },
	                width: 800,
	                height: 500
	            }, this._boPopupOpts);
	
	        fish.popupView(options);
	    };
	
	    module.exports = BO;
	


/***/ },
/* 38 */
/***/ function(module, exports) {

	/**
	 * Created by majianan on 16/5/19.
	 */
	
	    module.exports = {
	        BO_NODE_WIDTH: 180,    //BO矩形宽度
	        BO_NODE_DEFAULT_HEIGHT: 60,	//BO矩形默认高度，即只有BO名字的情况
	        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般
	        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量
	
	        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,
	        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离
	        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离
	
	        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度
	        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度
	        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式
	
	        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式
	        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离
	        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离
	        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离
	        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离
	        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度
	
	        LINE_DASH: 10,  //虚线
	        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度
	        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度
	        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半
	        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量
	        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量
	    };
	


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BO名字
	 * @module fish-topo-bo/node/BoName
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(38);
	    var graphic = __webpack_require__(40);
	
	    /**
	     *
	     * @param {String} text, BO名字
	     * @param {{x: number, y: number}} startPos, 起始位置
	     * @returns {zrender/graphic/Text}
	     * @constructor
	     */
	    function BoName(text, startPos) {
	        var x = startPos.x,
	            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10
	
	            shape = new graphic.Text({
	                style: {
	                    text: text,
	                    textFont: Const.BO_NAME_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top'
	                },
	
	                position: [x, y]
	            });
	
	        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2
	        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;
	
	        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom
	        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;
	
	        return shape;
	    }
	
	    module.exports = BoName;
	


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(9);
	
	    var pathTool = __webpack_require__(41);
	    var round = Math.round;
	    var Path = __webpack_require__(42);
	    var colorTool = __webpack_require__(23);
	    var matrix = __webpack_require__(17);
	    var vector = __webpack_require__(18);
	    var Gradient = __webpack_require__(10);
	
	    var graphic = {};
	    graphic.Util = zrUtil;
	    graphic.Group = __webpack_require__(14);
	
	    graphic.Image = __webpack_require__(30);
	
	    graphic.Text = __webpack_require__(54);
	
	    graphic.textContain = __webpack_require__(34);
	
	    graphic.Circle = __webpack_require__(55);
	
	    graphic.Sector = __webpack_require__(56);
	
	    graphic.Ring = __webpack_require__(57);
	
	    graphic.Polygon = __webpack_require__(58);
	
	    graphic.Polyline = __webpack_require__(62);
	
	    graphic.Rect = __webpack_require__(63);
	
	    graphic.Line = __webpack_require__(64);
	
	    graphic.BezierCurve = __webpack_require__(65);
	
	    graphic.Arc = __webpack_require__(66);
	
	    graphic.LinearGradient = __webpack_require__(67);
	
	    graphic.RadialGradient = __webpack_require__(68);
	
	    graphic.BoundingRect = __webpack_require__(26);
	
	    /**
	     * Extend shape with parameters
	     */
	    graphic.extendShape = function (opts) {
	        return Path.extend(opts);
	    };
	
	    /**
	     * Extend path
	     */
	    graphic.extendPath = function (pathData, opts) {
	        return pathTool.extendFromString(pathData, opts);
	    };
	
	    /**
	     * Create a path element from path data string
	     * @param {string} pathData
	     * @param {Object} opts
	     * @param {module:zrender/core/BoundingRect} rect
	     * @param {string} [layout=cover] 'center' or 'cover'
	     */
	    graphic.makePath = function (pathData, opts, rect, layout) {
	        var path = pathTool.createFromString(pathData, opts);
	        var boundingRect = path.getBoundingRect();
	        if (rect) {
	            var aspect = boundingRect.width / boundingRect.height;
	
	            if (layout === 'center') {
	                // Set rect to center, keep width / height ratio.
	                var width = rect.height * aspect;
	                var height;
	                if (width <= rect.width) {
	                    height = rect.height;
	                }
	                else {
	                    width = rect.width;
	                    height = width / aspect;
	                }
	                var cx = rect.x + rect.width / 2;
	                var cy = rect.y + rect.height / 2;
	
	                rect.x = cx - width / 2;
	                rect.y = cy - height / 2;
	                rect.width = width;
	                rect.height = height;
	            }
	
	            this.resizePath(path, rect);
	        }
	        return path;
	    };
	
	    graphic.mergePath = pathTool.mergePath,
	
	    /**
	     * Resize a path to fit the rect
	     * @param {module:zrender/graphic/Path} path
	     * @param {Object} rect
	     */
	    graphic.resizePath = function (path, rect) {
	        if (!path.applyTransform) {
	            return;
	        }
	
	        var pathRect = path.getBoundingRect();
	
	        var m = pathRect.calculateTransform(rect);
	
	        path.applyTransform(m);
	    };
	
	    /**
	     * Sub pixel optimize line for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x1]
	     * @param {number} [param.shape.y1]
	     * @param {number} [param.shape.x2]
	     * @param {number} [param.shape.y2]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeLine = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	
	        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
	            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
	        }
	        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
	            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
	        }
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize rect for canvas
	     *
	     * @param {Object} param
	     * @param {Object} [param.shape]
	     * @param {number} [param.shape.x]
	     * @param {number} [param.shape.y]
	     * @param {number} [param.shape.width]
	     * @param {number} [param.shape.height]
	     * @param {Object} [param.style]
	     * @param {number} [param.style.lineWidth]
	     * @return {Object} Modified param
	     */
	    graphic.subPixelOptimizeRect = function (param) {
	        var subPixelOptimize = graphic.subPixelOptimize;
	        var shape = param.shape;
	        var lineWidth = param.style.lineWidth;
	        var originX = shape.x;
	        var originY = shape.y;
	        var originWidth = shape.width;
	        var originHeight = shape.height;
	        shape.x = subPixelOptimize(shape.x, lineWidth, true);
	        shape.y = subPixelOptimize(shape.y, lineWidth, true);
	        shape.width = Math.max(
	            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
	            originWidth === 0 ? 0 : 1
	        );
	        shape.height = Math.max(
	            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
	            originHeight === 0 ? 0 : 1
	        );
	        return param;
	    };
	
	    /**
	     * Sub pixel optimize for canvas
	     *
	     * @param {number} position Coordinate, such as x, y
	     * @param {number} lineWidth Should be nonnegative integer.
	     * @param {boolean=} positiveOrNegative Default false (negative).
	     * @return {number} Optimized position.
	     */
	    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
	        // Assure that (position + lineWidth / 2) is near integer edge,
	        // otherwise line will be fuzzy in canvas.
	        var doubledPosition = round(position * 2);
	        return (doubledPosition + round(lineWidth)) % 2 === 0
	            ? doubledPosition / 2
	            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	    };
	
	    /**
	     * @private
	     */
	    function doSingleEnterHover(el) {
	        if (el.__isHover) {
	            return;
	        }
	        if (el.__hoverStlDirty) {
	            var stroke = el.style.stroke;
	            var fill = el.style.fill;
	
	            // Create hoverStyle on mouseover
	            var hoverStyle = el.__hoverStl;
	            var lift = colorTool.lift;
	            hoverStyle.fill = hoverStyle.fill
	                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));
	            hoverStyle.stroke = hoverStyle.stroke
	                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));
	
	            var normalStyle = {};
	            for (var name in hoverStyle) {
	                if (hoverStyle.hasOwnProperty(name)) {
	                    normalStyle[name] = el.style[name];
	                }
	            }
	
	            el.__normalStl = normalStyle;
	
	            el.__hoverStlDirty = false;
	        }
	        el.setStyle(el.__hoverStl);
	        el.z2 += 1;
	
	        el.__isHover = true;
	    }
	
	    /**
	     * @inner
	     */
	    function doSingleLeaveHover(el) {
	        if (!el.__isHover) {
	            return;
	        }
	
	        var normalStl = el.__normalStl;
	        normalStl && el.setStyle(normalStl);
	        el.z2 -= 1;
	
	        el.__isHover = false;
	    }
	
	    /**
	     * @inner
	     */
	    function doEnterHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleEnterHover(child);
	                }
	            })
	            : doSingleEnterHover(el);
	    }
	    graphic.doEnterHover = doEnterHover;
	    function doLeaveHover(el) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    doSingleLeaveHover(child);
	                }
	            })
	            : doSingleLeaveHover(el);
	    }
	    graphic.doLeaveHover = doLeaveHover;
	    /**
	     * @inner
	     */
	    function setElementHoverStl(el, hoverStl) {
	        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
	        // Often used when item group has a label element and it's hoverStyle is different
	        el.__hoverStl = el.hoverStyle || hoverStl || {};
	        el.__hoverStlDirty = true;
	    }
	    graphic.setElementHoverStl = setElementHoverStl;
	    /**
	     * @inner
	     */
	    function onElementMouseOver() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function onElementMouseOut() {
	        // Only if element is not in emphasis status
	        !this.__isEmphasis && doLeaveHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function enterEmphasis() {
	        this.__isEmphasis = true;
	        doEnterHover(this);
	    }
	
	    /**
	     * @inner
	     */
	    function leaveEmphasis() {
	        this.__isEmphasis = false;
	        doLeaveHover(this);
	    }
	
	    /**
	     * Set hover style of element
	     * @param {module:zrender/Element} el
	     * @param {Object} [hoverStyle]
	     */
	    graphic.setHoverStyle = function (el, hoverStyle) {
	        el.type === 'group'
	            ? el.traverse(function (child) {
	                if (child.type !== 'group') {
	                    setElementHoverStl(child, hoverStyle);
	                }
	            })
	            : setElementHoverStl(el, hoverStyle);
	        // Remove previous bound handlers
	        el.on('mouseover', onElementMouseOver)
	          .on('mouseout', onElementMouseOut);
	
	        // Emphasis, normal can be triggered manually
	        el.on('emphasis', enterEmphasis)
	          .on('normal', leaveEmphasis);
	    };
	
	    /**
	     * Set text option in the style
	     * @param {Object} textStyle
	     * @param {module:echarts/model/Model} labelModel
	     * @param {string} color
	     */
	    graphic.setText = function (textStyle, labelModel, color) {
	        var labelPosition = labelModel.getShallow('position') || 'inside';
	        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
	        var textStyleModel = labelModel.getModel('textStyle');
	        zrUtil.extend(textStyle, {
	            textDistance: labelModel.getShallow('distance') || 5,
	            textFont: textStyleModel.getFont(),
	            textPosition: labelPosition,
	            textFill: textStyleModel.getTextColor() || labelColor
	        });
	    };
	
	    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
	        var postfix = isUpdate ? 'Update' : '';
	        var duration = animatableModel
	            && animatableModel.getShallow('animationDuration' + postfix);
	        var animationEasing = animatableModel
	            && animatableModel.getShallow('animationEasing' + postfix);
	
	        animatableModel && animatableModel.getShallow('animation')
	            ? el.animateTo(props, duration, animationEasing, cb)
	            : (el.attr(props), cb && cb());
	    }
	    /**
	     * Update graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
	
	    /**
	     * Init graphic element properties with or without animation according to the configuration in series
	     * @param {module:zrender/Element} el
	     * @param {Object} props
	     * @param {module:echarts/model/Model} [animatableModel]
	     * @param {Function} cb
	     */
	    graphic.initProps = zrUtil.curry(animateOrSetProps, false);
	
	    /**
	     * Get transform matrix of target (param target),
	     * in coordinate of its ancestor (param ancestor)
	     *
	     * @param {module:zrender/mixin/Transformable} target
	     * @param {module:zrender/mixin/Transformable} ancestor
	     */
	    graphic.getTransform = function (target, ancestor) {
	        var mat = matrix.identity([]);
	
	        while (target && target !== ancestor) {
	            matrix.mul(mat, target.getLocalTransform(), mat);
	            target = target.parent;
	        }
	
	        return mat;
	    };
	
	    /**
	     * Apply transform to an vertex.
	     * @param {Array.<number>} vertex [x, y]
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {Array.<number>} [x, y]
	     */
	    graphic.applyTransform = function (vertex, transform, invert) {
	        if (invert) {
	            transform = matrix.invert([], transform);
	        }
	        return vector.applyTransform([], vertex, transform);
	    };
	
	    /**
	     * @param {string} direction 'left' 'right' 'top' 'bottom'
	     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
	     * @param {boolean=} invert Whether use invert matrix.
	     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
	     */
	    graphic.transformDirection = function (direction, transform, invert) {
	
	        // Pick a base, ensure that transform result will not be (0, 0).
	        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[0]);
	        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
	            ? 1 : Math.abs(2 * transform[4] / transform[2]);
	
	        var vertex = [
	            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
	            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
	        ];
	
	        vertex = graphic.applyTransform(vertex, transform, invert);
	
	        return Math.abs(vertex[0]) > Math.abs(vertex[1])
	            ? (vertex[0] > 0 ? 'right' : 'left')
	            : (vertex[1] > 0 ? 'bottom' : 'top');
	    };
	
	    module.exports = graphic;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var Path = __webpack_require__(42);
	    var PathProxy = __webpack_require__(43);
	    var transformPath = __webpack_require__(53);
	    var matrix = __webpack_require__(17);
	
	    // command chars
	    var cc = [
	        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
	        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
	    ];
	
	    var mathSqrt = Math.sqrt;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	    var PI = Math.PI;
	
	    var vMag = function(v) {
	        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	    };
	    var vRatio = function(u, v) {
	        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	    };
	    var vAngle = function(u, v) {
	        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	                * Math.acos(vRatio(u, v));
	    };
	
	    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	        var psi = psiDeg * (PI / 180.0);
	        var xp = mathCos(psi) * (x1 - x2) / 2.0
	                 + mathSin(psi) * (y1 - y2) / 2.0;
	        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	                 + mathCos(psi) * (y1 - y2) / 2.0;
	
	        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	
	        if (lambda > 1) {
	            rx *= mathSqrt(lambda);
	            ry *= mathSqrt(lambda);
	        }
	
	        var f = (fa === fs ? -1 : 1)
	            * mathSqrt((((rx * rx) * (ry * ry))
	                    - ((rx * rx) * (yp * yp))
	                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	                    + (ry * ry) * (xp * xp))
	                ) || 0;
	
	        var cxp = f * rx * yp / ry;
	        var cyp = f * -ry * xp / rx;
	
	        var cx = (x1 + x2) / 2.0
	                 + mathCos(psi) * cxp
	                 - mathSin(psi) * cyp;
	        var cy = (y1 + y2) / 2.0
	                + mathSin(psi) * cxp
	                + mathCos(psi) * cyp;
	
	        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
	        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
	        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
	        var dTheta = vAngle(u, v);
	
	        if (vRatio(u, v) <= -1) {
	            dTheta = PI;
	        }
	        if (vRatio(u, v) >= 1) {
	            dTheta = 0;
	        }
	        if (fs === 0 && dTheta > 0) {
	            dTheta = dTheta - 2 * PI;
	        }
	        if (fs === 1 && dTheta < 0) {
	            dTheta = dTheta + 2 * PI;
	        }
	
	        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	    }
	
	    function createPathProxyFromString(data) {
	        if (!data) {
	            return [];
	        }
	
	        // command string
	        var cs = data.replace(/-/g, ' -')
	            .replace(/  /g, ' ')
	            .replace(/ /g, ',')
	            .replace(/,,/g, ',');
	
	        var n;
	        // create pipes so that we can split the data
	        for (n = 0; n < cc.length; n++) {
	            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
	        }
	
	        // create array
	        var arr = cs.split('|');
	        // init context point
	        var cpx = 0;
	        var cpy = 0;
	
	        var path = new PathProxy();
	        var CMD = PathProxy.CMD;
	
	        var prevCmd;
	        for (n = 1; n < arr.length; n++) {
	            var str = arr[n];
	            var c = str.charAt(0);
	            var off = 0;
	            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
	            var cmd;
	
	            if (p.length > 0 && p[0] === '') {
	                p.shift();
	            }
	
	            for (var i = 0; i < p.length; i++) {
	                p[i] = parseFloat(p[i]);
	            }
	            while (off < p.length && !isNaN(p[off])) {
	                if (isNaN(p[0])) {
	                    break;
	                }
	                var ctlPtx;
	                var ctlPty;
	
	                var rx;
	                var ry;
	                var psi;
	                var fa;
	                var fs;
	
	                var x1 = cpx;
	                var y1 = cpy;
	
	                // convert l, H, h, V, and v to L
	                switch (c) {
	                    case 'l':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'L':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'm':
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'l';
	                        break;
	                    case 'M':
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.M;
	                        path.addData(cmd, cpx, cpy);
	                        c = 'L';
	                        break;
	                    case 'h':
	                        cpx += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'H':
	                        cpx = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'v':
	                        cpy += p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'V':
	                        cpy = p[off++];
	                        cmd = CMD.L;
	                        path.addData(cmd, cpx, cpy);
	                        break;
	                    case 'C':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
	                        );
	                        cpx = p[off - 2];
	                        cpy = p[off - 1];
	                        break;
	                    case 'c':
	                        cmd = CMD.C;
	                        path.addData(
	                            cmd,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy,
	                            p[off++] + cpx, p[off++] + cpy
	                        );
	                        cpx += p[off - 2];
	                        cpy += p[off - 1];
	                        break;
	                    case 'S':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 's':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.C) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cmd = CMD.C;
	                        x1 = cpx + p[off++];
	                        y1 = cpy + p[off++];
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                        break;
	                    case 'Q':
	                        x1 = p[off++];
	                        y1 = p[off++];
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'q':
	                        x1 = p[off++] + cpx;
	                        y1 = p[off++] + cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, x1, y1, cpx, cpy);
	                        break;
	                    case 'T':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 't':
	                        ctlPtx = cpx;
	                        ctlPty = cpy;
	                        var len = path.len();
	                        var pathData = path.data;
	                        if (prevCmd === CMD.Q) {
	                            ctlPtx += cpx - pathData[len - 4];
	                            ctlPty += cpy - pathData[len - 3];
	                        }
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.Q;
	                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                        break;
	                    case 'A':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx = p[off++];
	                        cpy = p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                    case 'a':
	                        rx = p[off++];
	                        ry = p[off++];
	                        psi = p[off++];
	                        fa = p[off++];
	                        fs = p[off++];
	
	                        x1 = cpx, y1 = cpy;
	                        cpx += p[off++];
	                        cpy += p[off++];
	                        cmd = CMD.A;
	                        processArc(
	                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
	                        );
	                        break;
	                }
	            }
	
	            if (c === 'z' || c === 'Z') {
	                cmd = CMD.Z;
	                path.addData(cmd);
	            }
	
	            prevCmd = cmd;
	        }
	
	        path.toStatic();
	
	        return path;
	    }
	
	    // TODO Optimize double memory cost problem
	    function createPathOptions(str, opts) {
	        var pathProxy = createPathProxyFromString(str);
	        var transform;
	        opts = opts || {};
	        opts.buildPath = function (path) {
	            path.setData(pathProxy.data);
	            transform && transformPath(path, transform);
	            // Svg and vml renderer don't have context
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx);
	            }
	        };
	
	        opts.applyTransform = function (m) {
	            if (!transform) {
	                transform = matrix.create();
	            }
	            matrix.mul(transform, m, transform);
	        };
	
	        return opts;
	    }
	
	    module.exports = {
	        /**
	         * Create a Path object from path string data
	         * http://www.w3.org/TR/SVG/paths.html#PathData
	         * @param  {Object} opts Other options
	         */
	        createFromString: function (str, opts) {
	            return new Path(createPathOptions(str, opts));
	        },
	
	        /**
	         * Create a Path class from path string data
	         * @param  {string} str
	         * @param  {Object} opts Other options
	         */
	        extendFromString: function (str, opts) {
	            return Path.extend(createPathOptions(str, opts));
	        },
	
	        /**
	         * Merge multiple paths
	         */
	        // TODO Apply transform
	        // TODO stroke dash
	        // TODO Optimize double memory cost problem
	        mergePath: function (pathEls, opts) {
	            var pathList = [];
	            var len = pathEls.length;
	            var pathEl;
	            var i;
	            for (i = 0; i < len; i++) {
	                pathEl = pathEls[i];
	                if (pathEl.__dirty) {
	                    pathEl.buildPath(pathEl.path, pathEl.shape);
	                }
	                pathList.push(pathEl.path);
	            }
	
	            var pathBundle = new Path(opts);
	            pathBundle.buildPath = function (path) {
	                path.appendPath(pathList);
	                // Svg and vml renderer don't have context
	                var ctx = path.getContext();
	                if (ctx) {
	                    path.rebuildPath(ctx);
	                }
	            };
	
	            return pathBundle;
	        }
	    };


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Path element
	 * @module zrender/graphic/Path
	 */
	
	
	
	    var Displayable = __webpack_require__(31);
	    var zrUtil = __webpack_require__(9);
	    var PathProxy = __webpack_require__(43);
	    var pathContain = __webpack_require__(46);
	
	    var Gradient = __webpack_require__(10);
	
	    function pathHasFill(style) {
	        var fill = style.fill;
	        return fill != null && fill !== 'none';
	    }
	
	    function pathHasStroke(style) {
	        var stroke = style.stroke;
	        return stroke != null && stroke !== 'none' && style.lineWidth > 0;
	    }
	
	    var abs = Math.abs;
	
	    /**
	     * @alias module:zrender/graphic/Path
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    function Path(opts) {
	        Displayable.call(this, opts);
	
	        /**
	         * @type {module:zrender/core/PathProxy}
	         * @readOnly
	         */
	        this.path = new PathProxy();
	    }
	
	    Path.prototype = {
	
	        constructor: Path,
	
	        type: 'path',
	
	        __dirtyPath: true,
	
	        strokeContainThreshold: 5,
	
	        brush: function (ctx) {
	            ctx.save();
	
	            var style = this.style;
	            var path = this.path;
	            var hasStroke = pathHasStroke(style);
	            var hasFill = pathHasFill(style);
	
	            if (this.__dirtyPath) {
	                // Update gradient because bounding rect may changed
	                if (hasFill && (style.fill instanceof Gradient)) {
	                    style.fill.updateCanvasGradient(this, ctx);
	                }
	                if (hasStroke && (style.stroke instanceof Gradient)) {
	                    style.stroke.updateCanvasGradient(this, ctx);
	                }
	            }
	
	            style.bind(ctx, this);
	            this.setTransform(ctx);
	
	            var lineDash = style.lineDash;
	            var lineDashOffset = style.lineDashOffset;
	
	            var ctxLineDash = !!ctx.setLineDash;
	
	            // Proxy context
	            // Rebuild path in following 2 cases
	            // 1. Path is dirty
	            // 2. Path needs javascript implemented lineDash stroking.
	            //    In this case, lineDash information will not be saved in PathProxy
	            if (this.__dirtyPath || (
	                lineDash && !ctxLineDash && hasStroke
	            )) {
	                path = this.path.beginPath(ctx);
	
	                // Setting line dash before build path
	                if (lineDash && !ctxLineDash) {
	                    path.setLineDash(lineDash);
	                    path.setLineDashOffset(lineDashOffset);
	                }
	
	                this.buildPath(path, this.shape);
	
	                // Clear path dirty flag
	                this.__dirtyPath = false;
	            }
	            else {
	                // Replay path building
	                ctx.beginPath();
	                this.path.rebuildPath(ctx);
	            }
	
	            hasFill && path.fill(ctx);
	
	            if (lineDash && ctxLineDash) {
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	            }
	
	            hasStroke && path.stroke(ctx);
	
	            // Draw rect text
	            if (style.text != null) {
	                // var rect = this.getBoundingRect();
	                this.drawRectText(ctx, this.getBoundingRect());
	            }
	
	            ctx.restore();
	        },
	
	        buildPath: function (ctx, shapeCfg) {},
	
	        getBoundingRect: function () {
	            var rect = this._rect;
	            var style = this.style;
	            if (!rect) {
	                var path = this.path;
	                if (this.__dirtyPath) {
	                    path.beginPath();
	                    this.buildPath(path, this.shape);
	                }
	                rect = path.getBoundingRect();
	            }
	            /**
	             * Needs update rect with stroke lineWidth when
	             * 1. Element changes scale or lineWidth
	             * 2. First create rect
	             */
	            if (pathHasStroke(style) && (this.__dirty || !this._rect)) {
	                var rectWithStroke = this._rectWithStroke
	                    || (this._rectWithStroke = rect.clone());
	                rectWithStroke.copy(rect);
	                // FIXME Must after updateTransform
	                var w = style.lineWidth;
	                // PENDING, Min line width is needed when line is horizontal or vertical
	                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	
	                // Only add extra hover lineWidth when there are no fill
	                if (!pathHasFill(style)) {
	                    w = Math.max(w, this.strokeContainThreshold);
	                }
	                // Consider line width
	                // Line scale can't be 0;
	                if (lineScale > 1e-10) {
	                    rectWithStroke.width += w / lineScale;
	                    rectWithStroke.height += w / lineScale;
	                    rectWithStroke.x -= w / lineScale / 2;
	                    rectWithStroke.y -= w / lineScale / 2;
	                }
	                return rectWithStroke;
	            }
	            this._rect = rect;
	            return rect;
	        },
	
	        contain: function (x, y) {
	            var localPos = this.transformCoordToLocal(x, y);
	            var rect = this.getBoundingRect();
	            var style = this.style;
	            x = localPos[0];
	            y = localPos[1];
	
	            if (rect.contain(x, y)) {
	                var pathData = this.path.data;
	                if (pathHasStroke(style)) {
	                    var lineWidth = style.lineWidth;
	                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                    // Line scale can't be 0;
	                    if (lineScale > 1e-10) {
	                        // Only add extra hover lineWidth when there are no fill
	                        if (!pathHasFill(style)) {
	                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                        }
	                        if (pathContain.containStroke(
	                            pathData, lineWidth / lineScale, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                }
	                if (pathHasFill(style)) {
	                    return pathContain.contain(pathData, x, y);
	                }
	            }
	            return false;
	        },
	
	        /**
	         * @param  {boolean} dirtyPath
	         */
	        dirty: function (dirtyPath) {
	            if (arguments.length ===0) {
	                dirtyPath = true;
	            }
	            // Only mark dirty, not mark clean
	            if (dirtyPath) {
	                this.__dirtyPath = dirtyPath;
	                this._rect = null;
	            }
	
	            this.__dirty = true;
	
	            this.__zr && this.__zr.refresh();
	
	            // Used as a clipping path
	            if (this.__clipTarget) {
	                this.__clipTarget.dirty();
	            }
	        },
	
	        /**
	         * Alias for animate('shape')
	         * @param {boolean} loop
	         */
	        animateShape: function (loop) {
	            return this.animate('shape', loop);
	        },
	
	        // Overwrite attrKV
	        attrKV: function (key, value) {
	            // FIXME
	            if (key === 'shape') {
	                this.setShape(value);
	            }
	            else {
	                Displayable.prototype.attrKV.call(this, key, value);
	            }
	        },
	        /**
	         * @param {Object|string} key
	         * @param {*} value
	         */
	        setShape: function (key, value) {
	            var shape = this.shape;
	            // Path from string may not have shape
	            if (shape) {
	                if (zrUtil.isObject(key)) {
	                    for (var name in key) {
	                        shape[name] = key[name];
	                    }
	                }
	                else {
	                    shape[key] = value;
	                }
	                this.dirty(true);
	            }
	            return this;
	        },
	
	        getLineScale: function () {
	            var m = this.transform;
	            // Get the line scale.
	            // Determinant of `m` means how much the area is enlarged by the
	            // transformation. So its square root can be used as a scale factor
	            // for width.
	            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	                : 1;
	        }
	    };
	
	    /**
	     * 扩展一个 Path element, 比如星形，圆等。
	     * Extend a path element
	     * @param {Object} props
	     * @param {string} props.type Path type
	     * @param {Function} props.init Initialize
	     * @param {Function} props.buildPath Overwrite buildPath method
	     * @param {Object} [props.style] Extended default style config
	     * @param {Object} [props.shape] Extended default shape config
	     */
	    Path.extend = function (defaults) {
	        var Sub = function (opts) {
	            Path.call(this, opts);
	
	            if (defaults.style) {
	                // Extend default style
	                this.style.extendFrom(defaults.style, false);
	            }
	
	            // Extend default shape
	            var defaultShape = defaults.shape;
	            if (defaultShape) {
	                this.shape = this.shape || {};
	                var thisShape = this.shape;
	                for (var name in defaultShape) {
	                    if (
	                        ! thisShape.hasOwnProperty(name)
	                        && defaultShape.hasOwnProperty(name)
	                    ) {
	                        thisShape[name] = defaultShape[name];
	                    }
	                }
	            }
	
	            defaults.init && defaults.init.call(this, opts);
	        };
	
	        zrUtil.inherits(Sub, Path);
	
	        // FIXME 不能 extend position, rotation 等引用对象
	        for (var name in defaults) {
	            // Extending prototype values and methods
	            if (name !== 'style' && name !== 'shape') {
	                Sub.prototype[name] = defaults[name];
	            }
	        }
	
	        return Sub;
	    };
	
	    zrUtil.inherits(Path, Displayable);
	
	    module.exports = Path;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
	 * 可以用于 isInsidePath 判断以及获取boundingRect
	 *
	 * @module zrender/core/PathProxy
	 * @author Yi Shen (http://www.github.com/pissang)
	 */
	
	 // TODO getTotalLength, getPointAtLength
	
	
	    var curve = __webpack_require__(44);
	    var vec2 = __webpack_require__(18);
	    var bbox = __webpack_require__(45);
	    var BoundingRect = __webpack_require__(26);
	
	    var CMD = {
	        M: 1,
	        L: 2,
	        C: 3,
	        Q: 4,
	        A: 5,
	        Z: 6,
	        // Rect
	        R: 7
	    };
	
	    var min = [];
	    var max = [];
	    var min2 = [];
	    var max2 = [];
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathCos = Math.cos;
	    var mathSin = Math.sin;
	    var mathSqrt = Math.sqrt;
	
	    var hasTypedArray = typeof Float32Array != 'undefined';
	
	    /**
	     * @alias module:zrender/core/PathProxy
	     * @constructor
	     */
	    var PathProxy = function () {
	
	        /**
	         * Path data. Stored as flat array
	         * @type {Array.<Object>}
	         */
	        this.data = [];
	
	        this._len = 0;
	
	        this._ctx = null;
	
	        this._xi = 0;
	        this._yi = 0;
	
	        this._x0 = 0;
	        this._y0 = 0;
	    };
	
	    /**
	     * 快速计算Path包围盒（并不是最小包围盒）
	     * @return {Object}
	     */
	    PathProxy.prototype = {
	
	        constructor: PathProxy,
	
	        _lineDash: null,
	
	        _dashOffset: 0,
	
	        _dashIdx: 0,
	
	        _dashSum: 0,
	
	        getContext: function () {
	            return this._ctx;
	        },
	
	        /**
	         * @param  {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        beginPath: function (ctx) {
	            this._ctx = ctx;
	
	            ctx && ctx.beginPath();
	
	            // Reset
	            this._len = 0;
	
	            if (this._lineDash) {
	                this._lineDash = null;
	
	                this._dashOffset = 0;
	            }
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        moveTo: function (x, y) {
	            this.addData(CMD.M, x, y);
	            this._ctx && this._ctx.moveTo(x, y);
	
	            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
	            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
	            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
	            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
	            this._x0 = x;
	            this._y0 = y;
	
	            this._xi = x;
	            this._yi = y;
	
	            return this;
	        },
	
	        /**
	         * @param  {number} x
	         * @param  {number} y
	         * @return {module:zrender/core/PathProxy}
	         */
	        lineTo: function (x, y) {
	            this.addData(CMD.L, x, y);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedLineTo(x, y)
	                    : this._ctx.lineTo(x, y);
	            }
	            this._xi = x;
	            this._yi = y;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @param  {number} x3
	         * @param  {number} y3
	         * @return {module:zrender/core/PathProxy}
	         */
	        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
	            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	            }
	            this._xi = x3;
	            this._yi = y3;
	            return this;
	        },
	
	        /**
	         * @param  {number} x1
	         * @param  {number} y1
	         * @param  {number} x2
	         * @param  {number} y2
	         * @return {module:zrender/core/PathProxy}
	         */
	        quadraticCurveTo: function (x1, y1, x2, y2) {
	            this.addData(CMD.Q, x1, y1, x2, y2);
	            if (this._ctx) {
	                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	            }
	            this._xi = x2;
	            this._yi = y2;
	            return this;
	        },
	
	        /**
	         * @param  {number} cx
	         * @param  {number} cy
	         * @param  {number} r
	         * @param  {number} startAngle
	         * @param  {number} endAngle
	         * @param  {boolean} anticlockwise
	         * @return {module:zrender/core/PathProxy}
	         */
	        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	            this.addData(
	                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
	            );
	            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	
	            this._xi = mathCos(endAngle) * r + cx;
	            this._xi = mathSin(endAngle) * r + cx;
	            return this;
	        },
	
	        // TODO
	        arcTo: function (x1, y1, x2, y2, radius) {
	            if (this._ctx) {
	                this._ctx.arcTo(x1, y1, x2, y2, radius);
	            }
	            return this;
	        },
	
	        // TODO
	        rect: function (x, y, w, h) {
	            this._ctx && this._ctx.rect(x, y, w, h);
	            this.addData(CMD.R, x, y, w, h);
	            return this;
	        },
	
	        /**
	         * @return {module:zrender/core/PathProxy}
	         */
	        closePath: function () {
	            this.addData(CMD.Z);
	
	            var ctx = this._ctx;
	            var x0 = this._x0;
	            var y0 = this._y0;
	            if (ctx) {
	                this._needsDash() && this._dashedLineTo(x0, y0);
	                ctx.closePath();
	            }
	
	            this._xi = x0;
	            this._yi = y0;
	            return this;
	        },
	
	        /**
	         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
	         * stroke 同样
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        fill: function (ctx) {
	            ctx && ctx.fill();
	            this.toStatic();
	        },
	
	        /**
	         * @param {CanvasRenderingContext2D} ctx
	         * @return {module:zrender/core/PathProxy}
	         */
	        stroke: function (ctx) {
	            ctx && ctx.stroke();
	            this.toStatic();
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDash: function (lineDash) {
	            if (lineDash instanceof Array) {
	                this._lineDash = lineDash;
	
	                this._dashIdx = 0;
	
	                var lineDashSum = 0;
	                for (var i = 0; i < lineDash.length; i++) {
	                    lineDashSum += lineDash[i];
	                }
	                this._dashSum = lineDashSum;
	            }
	            return this;
	        },
	
	        /**
	         * 必须在其它绘制命令前调用
	         * Must be invoked before all other path drawing methods
	         * @return {module:zrender/core/PathProxy}
	         */
	        setLineDashOffset: function (offset) {
	            this._dashOffset = offset;
	            return this;
	        },
	
	        /**
	         *
	         * @return {boolean}
	         */
	        len: function () {
	            return this._len;
	        },
	
	        /**
	         * 直接设置 Path 数据
	         */
	        setData: function (data) {
	
	            var len = data.length;
	
	            if (! (this.data && this.data.length == len) && hasTypedArray) {
	                this.data = new Float32Array(len);
	            }
	
	            for (var i = 0; i < len; i++) {
	                this.data[i] = data[i];
	            }
	
	            this._len = len;
	        },
	
	        /**
	         * 添加子路径
	         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
	         */
	        appendPath: function (path) {
	            if (!(path instanceof Array)) {
	                path = [path];
	            }
	            var len = path.length;
	            var appendSize = 0;
	            var offset = this._len;
	            for (var i = 0; i < len; i++) {
	                appendSize += path[i].len();
	            }
	            if (hasTypedArray && (this.data instanceof Float32Array)) {
	                this.data = new Float32Array(offset + appendSize);
	            }
	            for (var i = 0; i < len; i++) {
	                var appendPathData = path[i].data;
	                for (var k = 0; k < appendPathData.length; k++) {
	                    this.data[offset++] = appendPathData[k];
	                }
	            }
	            this._len = offset;
	        },
	
	        /**
	         * 填充 Path 数据。
	         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
	         */
	        addData: function (cmd) {
	            var data = this.data;
	            if (this._len + arguments.length > data.length) {
	                // 因为之前的数组已经转换成静态的 Float32Array
	                // 所以不够用时需要扩展一个新的动态数组
	                this._expandData();
	                data = this.data;
	            }
	            for (var i = 0; i < arguments.length; i++) {
	                data[this._len++] = arguments[i];
	            }
	
	            this._prevCmd = cmd;
	        },
	
	        _expandData: function () {
	            // Only if data is Float32Array
	            if (!(this.data instanceof Array)) {
	                var newData = [];
	                for (var i = 0; i < this._len; i++) {
	                    newData[i] = this.data[i];
	                }
	                this.data = newData;
	            }
	        },
	
	        /**
	         * If needs js implemented dashed line
	         * @return {boolean}
	         * @private
	         */
	        _needsDash: function () {
	            return this._lineDash;
	        },
	
	        _dashedLineTo: function (x1, y1) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            var dist = mathSqrt(dx * dx + dy * dy);
	            var x = x0;
	            var y = y0;
	            var dash;
	            var nDash = lineDash.length;
	            var idx;
	            dx /= dist;
	            dy /= dist;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            x -= offset * dx;
	            y -= offset * dy;
	
	            while ((dx >= 0 && x <= x1) || (dx < 0 && x > x1)) {
	                idx = this._dashIdx;
	                dash = lineDash[idx];
	                x += dx * dash;
	                y += dy * dash;
	                this._dashIdx = (idx + 1) % nDash;
	                // Skip positive offset
	                if ((dx > 0 && x < x0) || (dx < 0 && x > x0)) {
	                    continue;
	                }
	                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
	                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
	                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
	                );
	            }
	            // Offset for next lineTo
	            dx = x - x1;
	            dy = y - y1;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        // Not accurate dashed line to
	        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
	            var dashSum = this._dashSum;
	            var offset = this._dashOffset;
	            var lineDash = this._lineDash;
	            var ctx = this._ctx;
	
	            var x0 = this._xi;
	            var y0 = this._yi;
	            var t;
	            var dx;
	            var dy;
	            var cubicAt = curve.cubicAt;
	            var bezierLen = 0;
	            var idx = this._dashIdx;
	            var nDash = lineDash.length;
	
	            var x;
	            var y;
	
	            var tmpLen = 0;
	
	            if (offset < 0) {
	                // Convert to positive offset
	                offset = dashSum + offset;
	            }
	            offset %= dashSum;
	            // Bezier approx length
	            for (t = 0; t < 1; t += 0.1) {
	                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
	                    - cubicAt(x0, x1, x2, x3, t);
	                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
	                    - cubicAt(y0, y1, y2, y3, t);
	                bezierLen += mathSqrt(dx * dx + dy * dy);
	            }
	
	            // Find idx after add offset
	            for (; idx < nDash; idx++) {
	                tmpLen += lineDash[idx];
	                if (tmpLen > offset) {
	                    break;
	                }
	            }
	            t = (tmpLen - offset) / bezierLen;
	
	            while (t <= 1) {
	
	                x = cubicAt(x0, x1, x2, x3, t);
	                y = cubicAt(y0, y1, y2, y3, t);
	
	                // Use line to approximate dashed bezier
	                // Bad result if dash is long
	                idx % 2 ? ctx.moveTo(x, y)
	                    : ctx.lineTo(x, y);
	
	                t += lineDash[idx] / bezierLen;
	
	                idx = (idx + 1) % nDash;
	            }
	
	            // Finish the last segment and calculate the new offset
	            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	            dx = x3 - x;
	            dy = y3 - y;
	            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	        },
	
	        _dashedQuadraticTo: function (x1, y1, x2, y2) {
	            // Convert quadratic to cubic using degree elevation
	            var x3 = x2;
	            var y3 = y2;
	            x2 = (x2 + 2 * x1) / 3;
	            y2 = (y2 + 2 * y1) / 3;
	            x1 = (this._xi + 2 * x1) / 3;
	            y1 = (this._yi + 2 * y1) / 3;
	
	            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	        },
	
	        /**
	         * 转成静态的 Float32Array 减少堆内存占用
	         * Convert dynamic array to static Float32Array
	         */
	        toStatic: function () {
	            var data = this.data;
	            if (data instanceof Array) {
	                data.length = this._len;
	                if (hasTypedArray) {
	                    this.data = new Float32Array(data);
	                }
	            }
	        },
	
	        /**
	         * @return {module:zrender/core/BoundingRect}
	         */
	        getBoundingRect: function () {
	            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	
	            var data = this.data;
	            var xi = 0;
	            var yi = 0;
	            var x0 = 0;
	            var y0 = 0;
	
	            for (var i = 0; i < data.length;) {
	                var cmd = data[i++];
	
	                if (i == 1) {
	                    // 如果第一个命令是 L, C, Q
	                    // 则 previous point 同绘制命令的第一个 point
	                    //
	                    // 第一个命令为 Arc 的情况下会在后面特殊处理
	                    xi = data[i];
	                    yi = data[i + 1];
	
	                    x0 = xi;
	                    y0 = yi;
	                }
	
	                switch (cmd) {
	                    case CMD.M:
	                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                        // 在 closePath 的时候使用
	                        x0 = data[i++];
	                        y0 = data[i++];
	                        xi = x0;
	                        yi = y0;
	                        min2[0] = x0;
	                        min2[1] = y0;
	                        max2[0] = x0;
	                        max2[1] = y0;
	                        break;
	                    case CMD.L:
	                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.C:
	                        bbox.fromCubic(
	                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.Q:
	                        bbox.fromQuadratic(
	                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
	                            min2, max2
	                        );
	                        xi = data[i++];
	                        yi = data[i++];
	                        break;
	                    case CMD.A:
	                        // TODO Arc 判断的开销比较大
	                        var cx = data[i++];
	                        var cy = data[i++];
	                        var rx = data[i++];
	                        var ry = data[i++];
	                        var startAngle = data[i++];
	                        var endAngle = data[i++] + startAngle;
	                        // TODO Arc 旋转
	                        var psi = data[i++];
	                        var anticlockwise = 1 - data[i++];
	
	                        if (i == 1) {
	                            // 直接使用 arc 命令
	                            // 第一个命令起点还未定义
	                            x0 = mathCos(startAngle) * rx + cx;
	                            y0 = mathSin(startAngle) * ry + cy;
	                        }
	
	                        bbox.fromArc(
	                            cx, cy, rx, ry, startAngle, endAngle,
	                            anticlockwise, min2, max2
	                        );
	
	                        xi = mathCos(endAngle) * rx + cx;
	                        yi = mathSin(endAngle) * ry + cy;
	                        break;
	                    case CMD.R:
	                        x0 = xi = data[i++];
	                        y0 = yi = data[i++];
	                        var width = data[i++];
	                        var height = data[i++];
	                        // Use fromLine
	                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                        break;
	                    case CMD.Z:
	                        xi = x0;
	                        yi = y0;
	                        break;
	                }
	
	                // Union
	                vec2.min(min, min, min2);
	                vec2.max(max, max, max2);
	            }
	
	            // No data
	            if (i === 0) {
	                min[0] = min[1] = max[0] = max[1] = 0;
	            }
	
	            return new BoundingRect(
	                min[0], min[1], max[0] - min[0], max[1] - min[1]
	            );
	        },
	
	        /**
	         * Rebuild path from current data
	         * Rebuild path will not consider javascript implemented line dash.
	         * @param {CanvasRenderingContext} ctx
	         */
	        rebuildPath: function (ctx) {
	            var d = this.data;
	            for (var i = 0; i < this._len;) {
	                var cmd = d[i++];
	                switch (cmd) {
	                    case CMD.M:
	                        ctx.moveTo(d[i++], d[i++]);
	                        break;
	                    case CMD.L:
	                        ctx.lineTo(d[i++], d[i++]);
	                        break;
	                    case CMD.C:
	                        ctx.bezierCurveTo(
	                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
	                        );
	                        break;
	                    case CMD.Q:
	                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.A:
	                        var cx = d[i++];
	                        var cy = d[i++];
	                        var rx = d[i++];
	                        var ry = d[i++];
	                        var theta = d[i++];
	                        var dTheta = d[i++];
	                        var psi = d[i++];
	                        var fs = d[i++];
	                        var r = (rx > ry) ? rx : ry;
	                        var scaleX = (rx > ry) ? 1 : rx / ry;
	                        var scaleY = (rx > ry) ? ry / rx : 1;
	                        var isEllipse = Math.abs(rx - ry) > 1e-3;
	                        if (isEllipse) {
	                            ctx.translate(cx, cy);
	                            ctx.rotate(psi);
	                            ctx.scale(scaleX, scaleY);
	                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
	                            ctx.scale(1 / scaleX, 1 / scaleY);
	                            ctx.rotate(-psi);
	                            ctx.translate(-cx, -cy);
	                        }
	                        else {
	                            ctx.arc(cx, cy, r, theta, theta + dTheta, 1 - fs);
	                        }
	                        break;
	                    case CMD.R:
	                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
	                        break;
	                    case CMD.Z:
	                        ctx.closePath();
	                }
	            }
	        }
	    };
	
	    PathProxy.CMD = CMD;
	
	    module.exports = PathProxy;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 曲线辅助模块
	 * @module zrender/core/curve
	 * @author pissang(https://www.github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(18);
	    var v2Create = vec2.create;
	    var v2DistSquare = vec2.distSquare;
	    var mathPow = Math.pow;
	    var mathSqrt = Math.sqrt;
	
	    var EPSILON = 1e-4;
	
	    var THREE_SQRT = mathSqrt(3);
	    var ONE_THIRD = 1 / 3;
	
	    // 临时变量
	    var _v0 = v2Create();
	    var _v1 = v2Create();
	    var _v2 = v2Create();
	    // var _v3 = vec2.create();
	
	    function isAroundZero(val) {
	        return val > -EPSILON && val < EPSILON;
	    }
	    function isNotAroundZero(val) {
	        return val > EPSILON || val < -EPSILON;
	    }
	    /**
	     * 计算三次贝塞尔值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return onet * onet * (onet * p0 + 3 * t * p1)
	             + t * t * (t * p3 + 3 * onet * p2);
	    }
	
	    /**
	     * 计算三次贝塞尔导数值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @return {number}
	     */
	    function cubicDerivativeAt(p0, p1, p2, p3, t) {
	        var onet = 1 - t;
	        return 3 * (
	            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	            + (p3 - p2) * t * t
	        );
	    }
	
	    /**
	     * 计算三次贝塞尔方程根，使用盛金公式
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} val
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function cubicRootAt(p0, p1, p2, p3, val, roots) {
	        // Evaluate roots of cubic functions
	        var a = p3 + 3 * (p1 - p2) - p0;
	        var b = 3 * (p2 - p1 * 2 + p0);
	        var c = 3 * (p1  - p0);
	        var d = p0 - val;
	
	        var A = b * b - 3 * a * c;
	        var B = b * c - 9 * a * d;
	        var C = c * c - 3 * b * d;
	
	        var n = 0;
	
	        if (isAroundZero(A) && isAroundZero(B)) {
	            if (isAroundZero(b)) {
	                roots[0] = 0;
	            }
	            else {
	                var t1 = -c / b;  //t1, t2, t3, b is not zero
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = B * B - 4 * A * C;
	
	            if (isAroundZero(disc)) {
	                var K = B / A;
	                var t1 = -b / a + K;  // t1, a is not zero
	                var t2 = -K / 2;  // t2, t3
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	                if (Y1 < 0) {
	                    Y1 = -mathPow(-Y1, ONE_THIRD);
	                }
	                else {
	                    Y1 = mathPow(Y1, ONE_THIRD);
	                }
	                if (Y2 < 0) {
	                    Y2 = -mathPow(-Y2, ONE_THIRD);
	                }
	                else {
	                    Y2 = mathPow(Y2, ONE_THIRD);
	                }
	                var t1 = (-b - (Y1 + Y2)) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else {
	                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	                var theta = Math.acos(T) / 3;
	                var ASqrt = mathSqrt(A);
	                var tmp = Math.cos(theta);
	
	                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	                if (t3 >= 0 && t3 <= 1) {
	                    roots[n++] = t3;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算三次贝塞尔方程极限值的位置
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {Array.<number>} extrema
	     * @return {number} 有效数目
	     */
	    function cubicExtrema(p0, p1, p2, p3, extrema) {
	        var b = 6 * p2 - 12 * p1 + 6 * p0;
	        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	        var c = 3 * p1 - 3 * p0;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <=1) {
	                    extrema[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                extrema[0] = -b / (2 * a);
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    extrema[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    extrema[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 细分三次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} p3
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function cubicSubdivide(p0, p1, p2, p3, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p23 = (p3 - p2) * t + p2;
	
	        var p012 = (p12 - p01) * t + p01;
	        var p123 = (p23 - p12) * t + p12;
	
	        var p0123 = (p123 - p012) * t + p012;
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	        out[3] = p0123;
	        // Seg1
	        out[4] = p0123;
	        out[5] = p123;
	        out[6] = p23;
	        out[7] = p3;
	    }
	
	    /**
	     * 投射点到三次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} [out] 投射点
	     * @return {number}
	     */
	    function cubicProjectPoint(
	        x0, y0, x1, y1, x2, y2, x3, y3,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	        var prev;
	        var next;
	        var d1;
	        var d2;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	            d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON) {
	                break;
	            }
	            prev = t - interval;
	            next = t + interval;
	            // t - interval
	            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	
	            d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = cubicAt(x0, x1, x2, x3, next);
	                _v2[1] = cubicAt(y0, y1, y2, y3, next);
	                d2 = v2DistSquare(_v2, _v0);
	
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = cubicAt(x0, x1, x2, x3, t);
	            out[1] = cubicAt(y0, y1, y2, y3, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    /**
	     * 计算二次方贝塞尔值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticAt(p0, p1, p2, t) {
	        var onet = 1 - t;
	        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	    }
	
	    /**
	     * 计算二次方贝塞尔导数值
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @return {number}
	     */
	    function quadraticDerivativeAt(p0, p1, p2, t) {
	        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	    }
	
	    /**
	     * 计算二次方贝塞尔方程根
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} roots
	     * @return {number} 有效根数目
	     */
	    function quadraticRootAt(p0, p1, p2, val, roots) {
	        var a = p0 - 2 * p1 + p2;
	        var b = 2 * (p1 - p0);
	        var c = p0 - val;
	
	        var n = 0;
	        if (isAroundZero(a)) {
	            if (isNotAroundZero(b)) {
	                var t1 = -c / b;
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	        }
	        else {
	            var disc = b * b - 4 * a * c;
	            if (isAroundZero(disc)) {
	                var t1 = -b / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	            }
	            else if (disc > 0) {
	                var discSqrt = mathSqrt(disc);
	                var t1 = (-b + discSqrt) / (2 * a);
	                var t2 = (-b - discSqrt) / (2 * a);
	                if (t1 >= 0 && t1 <= 1) {
	                    roots[n++] = t1;
	                }
	                if (t2 >= 0 && t2 <= 1) {
	                    roots[n++] = t2;
	                }
	            }
	        }
	        return n;
	    }
	
	    /**
	     * 计算二次贝塞尔方程极限值
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @return {number}
	     */
	    function quadraticExtremum(p0, p1, p2) {
	        var divider = p0 + p2 - 2 * p1;
	        if (divider === 0) {
	            // p1 is center of p0 and p2
	            return 0.5;
	        }
	        else {
	            return (p0 - p1) / divider;
	        }
	    }
	
	    /**
	     * 细分二次贝塞尔曲线
	     * @memberOf module:zrender/core/curve
	     * @param  {number} p0
	     * @param  {number} p1
	     * @param  {number} p2
	     * @param  {number} t
	     * @param  {Array.<number>} out
	     */
	    function quadraticSubdivide(p0, p1, p2, t, out) {
	        var p01 = (p1 - p0) * t + p0;
	        var p12 = (p2 - p1) * t + p1;
	        var p012 = (p12 - p01) * t + p01;
	
	        // Seg0
	        out[0] = p0;
	        out[1] = p01;
	        out[2] = p012;
	
	        // Seg1
	        out[3] = p012;
	        out[4] = p12;
	        out[5] = p2;
	    }
	
	    /**
	     * 投射点到二次贝塞尔曲线上，返回投射距离。
	     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x
	     * @param {number} y
	     * @param {Array.<number>} out 投射点
	     * @return {number}
	     */
	    function quadraticProjectPoint(
	        x0, y0, x1, y1, x2, y2,
	        x, y, out
	    ) {
	        // http://pomax.github.io/bezierinfo/#projections
	        var t;
	        var interval = 0.005;
	        var d = Infinity;
	
	        _v0[0] = x;
	        _v0[1] = y;
	
	        // 先粗略估计一下可能的最小距离的 t 值
	        // PENDING
	        for (var _t = 0; _t < 1; _t += 0.05) {
	            _v1[0] = quadraticAt(x0, x1, x2, _t);
	            _v1[1] = quadraticAt(y0, y1, y2, _t);
	            var d1 = v2DistSquare(_v0, _v1);
	            if (d1 < d) {
	                t = _t;
	                d = d1;
	            }
	        }
	        d = Infinity;
	
	        // At most 32 iteration
	        for (var i = 0; i < 32; i++) {
	            if (interval < EPSILON) {
	                break;
	            }
	            var prev = t - interval;
	            var next = t + interval;
	            // t - interval
	            _v1[0] = quadraticAt(x0, x1, x2, prev);
	            _v1[1] = quadraticAt(y0, y1, y2, prev);
	
	            var d1 = v2DistSquare(_v1, _v0);
	
	            if (prev >= 0 && d1 < d) {
	                t = prev;
	                d = d1;
	            }
	            else {
	                // t + interval
	                _v2[0] = quadraticAt(x0, x1, x2, next);
	                _v2[1] = quadraticAt(y0, y1, y2, next);
	                var d2 = v2DistSquare(_v2, _v0);
	                if (next <= 1 && d2 < d) {
	                    t = next;
	                    d = d2;
	                }
	                else {
	                    interval *= 0.5;
	                }
	            }
	        }
	        // t
	        if (out) {
	            out[0] = quadraticAt(x0, x1, x2, t);
	            out[1] = quadraticAt(y0, y1, y2, t);
	        }
	        // console.log(interval, i);
	        return mathSqrt(d);
	    }
	
	    module.exports = {
	
	        cubicAt: cubicAt,
	
	        cubicDerivativeAt: cubicDerivativeAt,
	
	        cubicRootAt: cubicRootAt,
	
	        cubicExtrema: cubicExtrema,
	
	        cubicSubdivide: cubicSubdivide,
	
	        cubicProjectPoint: cubicProjectPoint,
	
	        quadraticAt: quadraticAt,
	
	        quadraticDerivativeAt: quadraticDerivativeAt,
	
	        quadraticRootAt: quadraticRootAt,
	
	        quadraticExtremum: quadraticExtremum,
	
	        quadraticSubdivide: quadraticSubdivide,
	
	        quadraticProjectPoint: quadraticProjectPoint
	    };


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author Yi Shen(https://github.com/pissang)
	 */
	
	
	    var vec2 = __webpack_require__(18);
	    var curve = __webpack_require__(44);
	
	    var bbox = {};
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var mathSin = Math.sin;
	    var mathCos = Math.cos;
	
	    var start = vec2.create();
	    var end = vec2.create();
	    var extremity = vec2.create();
	
	    var PI2 = Math.PI * 2;
	    /**
	     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
	     * @module zrender/core/bbox
	     * @param {Array<Object>} points 顶点数组
	     * @param {number} min
	     * @param {number} max
	     */
	    bbox.fromPoints = function(points, min, max) {
	        if (points.length === 0) {
	            return;
	        }
	        var p = points[0];
	        var left = p[0];
	        var right = p[0];
	        var top = p[1];
	        var bottom = p[1];
	        var i;
	
	        for (i = 1; i < points.length; i++) {
	            p = points[i];
	            left = mathMin(left, p[0]);
	            right = mathMax(right, p[0]);
	            top = mathMin(top, p[1]);
	            bottom = mathMax(bottom, p[1]);
	        }
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
	        min[0] = mathMin(x0, x1);
	        min[1] = mathMin(y0, y1);
	        max[0] = mathMax(x0, x1);
	        max[1] = mathMax(y0, y1);
	    };
	
	    /**
	     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {number} x3
	     * @param {number} y3
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromCubic = function(
	        x0, y0, x1, y1, x2, y2, x3, y3, min, max
	    ) {
	        var xDim = [];
	        var yDim = [];
	        var cubicExtrema = curve.cubicExtrema;
	        var cubicAt = curve.cubicAt;
	        var left, right, top, bottom;
	        var i;
	        var n = cubicExtrema(x0, x1, x2, x3, xDim);
	
	        for (i = 0; i < n; i++) {
	            xDim[i] = cubicAt(x0, x1, x2, x3, xDim[i]);
	        }
	        n = cubicExtrema(y0, y1, y2, y3, yDim);
	        for (i = 0; i < n; i++) {
	            yDim[i] = cubicAt(y0, y1, y2, y3, yDim[i]);
	        }
	
	        xDim.push(x0, x3);
	        yDim.push(y0, y3);
	
	        left = mathMin.apply(null, xDim);
	        right = mathMax.apply(null, xDim);
	        top = mathMin.apply(null, yDim);
	        bottom = mathMax.apply(null, yDim);
	
	        min[0] = left;
	        min[1] = top;
	        max[0] = right;
	        max[1] = bottom;
	    };
	
	    /**
	     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x0
	     * @param {number} y0
	     * @param {number} x1
	     * @param {number} y1
	     * @param {number} x2
	     * @param {number} y2
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
	        var quadraticExtremum = curve.quadraticExtremum;
	        var quadraticAt = curve.quadraticAt;
	        // Find extremities, where derivative in x dim or y dim is zero
	        var tx =
	            mathMax(
	                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
	            );
	        var ty =
	            mathMax(
	                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
	            );
	
	        var x = quadraticAt(x0, x1, x2, tx);
	        var y = quadraticAt(y0, y1, y2, ty);
	
	        min[0] = mathMin(x0, x2, x);
	        min[1] = mathMin(y0, y2, y);
	        max[0] = mathMax(x0, x2, x);
	        max[1] = mathMax(y0, y2, y);
	    };
	
	    /**
	     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
	     * @method
	     * @memberOf module:zrender/core/bbox
	     * @param {number} x
	     * @param {number} y
	     * @param {number} rx
	     * @param {number} ry
	     * @param {number} startAngle
	     * @param {number} endAngle
	     * @param {number} anticlockwise
	     * @param {Array.<number>} min
	     * @param {Array.<number>} max
	     */
	    bbox.fromArc = function (
	        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
	    ) {
	        var vec2Min = vec2.min;
	        var vec2Max = vec2.max;
	
	        var diff = Math.abs(startAngle - endAngle);
	
	
	        if (diff % PI2 < 1e-4 && diff > 1e-4) {
	            // Is a circle
	            min[0] = x - rx;
	            min[1] = y - ry;
	            max[0] = x + rx;
	            max[1] = y + ry;
	            return;
	        }
	
	        start[0] = mathCos(startAngle) * rx + x;
	        start[1] = mathSin(startAngle) * ry + y;
	
	        end[0] = mathCos(endAngle) * rx + x;
	        end[1] = mathSin(endAngle) * ry + y;
	
	        vec2Min(min, start, end);
	        vec2Max(max, start, end);
	
	        // Thresh to [0, Math.PI * 2]
	        startAngle = startAngle % (PI2);
	        if (startAngle < 0) {
	            startAngle = startAngle + PI2;
	        }
	        endAngle = endAngle % (PI2);
	        if (endAngle < 0) {
	            endAngle = endAngle + PI2;
	        }
	
	        if (startAngle > endAngle && !anticlockwise) {
	            endAngle += PI2;
	        }
	        else if (startAngle < endAngle && anticlockwise) {
	            startAngle += PI2;
	        }
	        if (anticlockwise) {
	            var tmp = endAngle;
	            endAngle = startAngle;
	            startAngle = tmp;
	        }
	
	        // var number = 0;
	        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
	        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	            if (angle > startAngle) {
	                extremity[0] = mathCos(angle) * rx + x;
	                extremity[1] = mathSin(angle) * ry + y;
	
	                vec2Min(min, extremity, min);
	                vec2Max(max, extremity, max);
	            }
	        }
	    };
	
	    module.exports = bbox;
	


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var CMD = __webpack_require__(43).CMD;
	    var line = __webpack_require__(47);
	    var cubic = __webpack_require__(48);
	    var quadratic = __webpack_require__(49);
	    var arc = __webpack_require__(50);
	    var normalizeRadian = __webpack_require__(51).normalizeRadian;
	    var curve = __webpack_require__(44);
	
	    var windingLine = __webpack_require__(52);
	
	    var containStroke = line.containStroke;
	
	    var PI2 = Math.PI * 2;
	
	    var EPSILON = 1e-4;
	
	    function isAroundEqual(a, b) {
	        return Math.abs(a - b) < EPSILON;
	    }
	
	    // 临时数组
	    var roots = [-1, -1, -1];
	    var extrema = [-1, -1];
	
	    function swapExtrema() {
	        var tmp = extrema[0];
	        extrema[0] = extrema[1];
	        extrema[1] = tmp;
	    }
	
	    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2 && y > y3)
	            || (y < y0 && y < y1 && y < y2 && y < y3)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var w = 0;
	            var nExtrema = -1;
	            var y0_, y1_;
	            for (var i = 0; i < nRoots; i++) {
	                var t = roots[i];
	                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	                if (x_ < x) { // Quick reject
	                    continue;
	                }
	                if (nExtrema < 0) {
	                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                    if (extrema[1] < extrema[0] && nExtrema > 1) {
	                        swapExtrema();
	                    }
	                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                    if (nExtrema > 1) {
	                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                    }
	                }
	                if (nExtrema == 2) {
	                    // 分成三段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? 1 : -1;
	                    }
	                    else if (t < extrema[1]) {
	                        w += y1_ < y0_ ? 1 : -1;
	                    }
	                    else {
	                        w += y3 < y1_ ? 1 : -1;
	                    }
	                }
	                else {
	                    // 分成两段单调函数
	                    if (t < extrema[0]) {
	                        w += y0_ < y0 ? 1 : -1;
	                    }
	                    else {
	                        w += y3 < y0_ ? 1 : -1;
	                    }
	                }
	            }
	            return w;
	        }
	    }
	
	    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	        // Quick reject
	        if (
	            (y > y0 && y > y1 && y > y2)
	            || (y < y0 && y < y1 && y < y2)
	        ) {
	            return 0;
	        }
	        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	        if (nRoots === 0) {
	            return 0;
	        }
	        else {
	            var t = curve.quadraticExtremum(y0, y1, y2);
	            if (t >=0 && t <= 1) {
	                var w = 0;
	                var y_ = curve.quadraticAt(y0, y1, y2, t);
	                for (var i = 0; i < nRoots; i++) {
	                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                    if (x_ > x) {
	                        continue;
	                    }
	                    if (roots[i] < t) {
	                        w += y_ < y0 ? 1 : -1;
	                    }
	                    else {
	                        w += y2 < y_ ? 1 : -1;
	                    }
	                }
	                return w;
	            }
	            else {
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	                if (x_ > x) {
	                    return 0;
	                }
	                return y2 < y0 ? 1 : -1;
	            }
	        }
	    }
	
	    // TODO
	    // Arc 旋转
	    function windingArc(
	        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
	    ) {
	        y -= cy;
	        if (y > r || y < -r) {
	            return 0;
	        }
	        var tmp = Math.sqrt(r * r - y * y);
	        roots[0] = -tmp;
	        roots[1] = tmp;
	
	        var diff = Math.abs(startAngle - endAngle);
	        if (diff < 1e-4) {
	            return 0;
	        }
	        if (diff % PI2 < 1e-4) {
	            // Is a circle
	            startAngle = 0;
	            endAngle = PI2;
	            var dir = anticlockwise ? 1 : -1;
	            if (x >= roots[0] + cx && x <= roots[1] + cx) {
	                return dir;
	            } else {
	                return 0;
	            }
	        }
	
	        if (anticlockwise) {
	            var tmp = startAngle;
	            startAngle = normalizeRadian(endAngle);
	            endAngle = normalizeRadian(tmp);
	        }
	        else {
	            startAngle = normalizeRadian(startAngle);
	            endAngle = normalizeRadian(endAngle);
	        }
	        if (startAngle > endAngle) {
	            endAngle += PI2;
	        }
	
	        var w = 0;
	        for (var i = 0; i < 2; i++) {
	            var x_ = roots[i];
	            if (x_ + cx > x) {
	                var angle = Math.atan2(y, x_);
	                var dir = anticlockwise ? 1 : -1;
	                if (angle < 0) {
	                    angle = PI2 + angle;
	                }
	                if (
	                    (angle >= startAngle && angle <= endAngle)
	                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
	                ) {
	                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                        dir = -dir;
	                    }
	                    w += dir;
	                }
	            }
	        }
	        return w;
	    }
	
	    function containPath(data, lineWidth, isStroke, x, y) {
	        var w = 0;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	
	        for (var i = 0; i < data.length;) {
	            var cmd = data[i++];
	            // Begin a new subpath
	            if (cmd === CMD.M && i > 1) {
	                // Close previous subpath
	                if (!isStroke) {
	                    w += windingLine(xi, yi, x0, y0, x, y);
	                }
	                // 如果被任何一个 subpath 包含
	                if (w !== 0) {
	                    return true;
	                }
	            }
	
	            if (i == 1) {
	                // 如果第一个命令是 L, C, Q
	                // 则 previous point 同绘制命令的第一个 point
	                //
	                // 第一个命令为 Arc 的情况下会在后面特殊处理
	                xi = data[i];
	                yi = data[i + 1];
	
	                x0 = xi;
	                y0 = yi;
	            }
	
	            switch (cmd) {
	                case CMD.M:
	                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
	                    // 在 closePath 的时候使用
	                    x0 = data[i++];
	                    y0 = data[i++];
	                    xi = x0;
	                    yi = y0;
	                    break;
	                case CMD.L:
	                    if (isStroke) {
	                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
	                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    if (isStroke) {
	                        if (cubic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingCubic(
	                            xi, yi,
	                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    if (isStroke) {
	                        if (quadratic.containStroke(xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingQuadratic(
	                            xi, yi,
	                            data[i++], data[i++], data[i], data[i + 1],
	                            x, y
	                        ) || 0;
	                    }
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    // TODO Arc 判断的开销比较大
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var theta = data[i++];
	                    var dTheta = data[i++];
	                    // TODO Arc 旋转
	                    var psi = data[i++];
	                    var anticlockwise = 1 - data[i++];
	                    var x1 = Math.cos(theta) * rx + cx;
	                    var y1 = Math.sin(theta) * ry + cy;
	                    // 不是直接使用 arc 命令
	                    if (i > 1) {
	                        w += windingLine(xi, yi, x1, y1, x, y);
	                    }
	                    else {
	                        // 第一个命令起点还未定义
	                        x0 = x1;
	                        y0 = y1;
	                    }
	                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
	                    var _x = (x - cx) * ry / rx + cx;
	                    if (isStroke) {
	                        if (arc.containStroke(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            lineWidth, _x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        w += windingArc(
	                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
	                            _x, y
	                        );
	                    }
	                    xi = Math.cos(theta + dTheta) * rx + cx;
	                    yi = Math.sin(theta + dTheta) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    var x1 = x0 + width;
	                    var y1 = y0 + height;
	                    if (isStroke) {
	                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                          || containStroke(x0, y1, x1, y1, lineWidth, x, y)
	                        ) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // FIXME Clockwise ?
	                        w += windingLine(x1, y0, x1, y1, x, y);
	                        w += windingLine(x0, y1, x0, y0, x, y);
	                    }
	                    break;
	                case CMD.Z:
	                    if (isStroke) {
	                        if (containStroke(
	                            xi, yi, x0, y0, lineWidth, x, y
	                        )) {
	                            return true;
	                        }
	                    }
	                    else {
	                        // Close a subpath
	                        w += windingLine(xi, yi, x0, y0, x, y);
	                        // 如果被任何一个 subpath 包含
	                        if (w !== 0) {
	                            return true;
	                        }
	                    }
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	        }
	        if (!isStroke && !isAroundEqual(yi, y0)) {
	            w += windingLine(xi, yi, x0, y0, x, y) || 0;
	        }
	        return w !== 0;
	    }
	
	    module.exports = {
	        contain: function (pathData, x, y) {
	            return containPath(pathData, 0, false, x, y);
	        },
	
	        containStroke: function (pathData, lineWidth, x, y) {
	            return containPath(pathData, lineWidth, true, x, y);
	        }
	    };


/***/ },
/* 47 */
/***/ function(module, exports) {

	
	    module.exports = {
	        /**
	         * 线段包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            var _a = 0;
	            var _b = x0;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l)
	                || (y < y0 - _l && y < y1 - _l)
	                || (x > x0 + _l && x > x1 + _l)
	                || (x < x0 - _l && x < x1 - _l)
	            ) {
	                return false;
	            }
	
	            if (x0 !== x1) {
	                _a = (y0 - y1) / (x0 - x1);
	                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
	            }
	            else {
	                return Math.abs(x - x0) <= _l / 2;
	            }
	            var tmp = _a * x - y + _b;
	            var _s = tmp * tmp / (_a * _a + 1);
	            return _s <= _l / 2 * _l / 2;
	        }
	    };


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(44);
	
	    module.exports = {
	        /**
	         * 三次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  x3
	         * @param  {number}  y3
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.cubicProjectPoint(
	                x0, y0, x1, y1, x2, y2, x3, y3,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var curve = __webpack_require__(44);
	
	    module.exports = {
	        /**
	         * 二次贝塞尔曲线描边包含判断
	         * @param  {number}  x0
	         * @param  {number}  y0
	         * @param  {number}  x1
	         * @param  {number}  y1
	         * @param  {number}  x2
	         * @param  {number}  y2
	         * @param  {number}  lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {boolean}
	         */
	        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	            // Quick reject
	            if (
	                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
	                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
	            ) {
	                return false;
	            }
	            var d = curve.quadraticProjectPoint(
	                x0, y0, x1, y1, x2, y2,
	                x, y, null
	            );
	            return d <= _l / 2;
	        }
	    };


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var normalizeRadian = __webpack_require__(51).normalizeRadian;
	    var PI2 = Math.PI * 2;
	
	    module.exports = {
	        /**
	         * 圆弧描边包含判断
	         * @param  {number}  cx
	         * @param  {number}  cy
	         * @param  {number}  r
	         * @param  {number}  startAngle
	         * @param  {number}  endAngle
	         * @param  {boolean}  anticlockwise
	         * @param  {number} lineWidth
	         * @param  {number}  x
	         * @param  {number}  y
	         * @return {Boolean}
	         */
	        containStroke: function (
	            cx, cy, r, startAngle, endAngle, anticlockwise,
	            lineWidth, x, y
	        ) {
	
	            if (lineWidth === 0) {
	                return false;
	            }
	            var _l = lineWidth;
	
	            x -= cx;
	            y -= cy;
	            var d = Math.sqrt(x * x + y * y);
	
	            if ((d - _l > r) || (d + _l < r)) {
	                return false;
	            }
	            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	                // Is a circle
	                return true;
	            }
	            if (anticlockwise) {
	                var tmp = startAngle;
	                startAngle = normalizeRadian(endAngle);
	                endAngle = normalizeRadian(tmp);
	            } else {
	                startAngle = normalizeRadian(startAngle);
	                endAngle = normalizeRadian(endAngle);
	            }
	            if (startAngle > endAngle) {
	                endAngle += PI2;
	            }
	
	            var angle = Math.atan2(y, x);
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return (angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	        }
	    };


/***/ },
/* 51 */
/***/ function(module, exports) {

	
	
	    var PI2 = Math.PI * 2;
	    module.exports = {
	        normalizeRadian: function(angle) {
	            angle %= PI2;
	            if (angle < 0) {
	                angle += PI2;
	            }
	            return angle;
	        }
	    };


/***/ },
/* 52 */
/***/ function(module, exports) {

	
	    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
	        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	            return 0;
	        }
	        if (y1 === y0) {
	            return 0;
	        }
	        var dir = y1 < y0 ? 1 : -1;
	        var t = (y - y0) / (y1 - y0);
	        var x_ = t * (x1 - x0) + x0;
	
	        return x_ > x ? dir : 0;
	    };


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var CMD = __webpack_require__(43).CMD;
	    var vec2 = __webpack_require__(18);
	    var v2ApplyTransform = vec2.applyTransform;
	
	    var points = [[], [], []];
	    var mathSqrt = Math.sqrt;
	    var mathAtan2 = Math.atan2;
	    function transformPath(path, m) {
	        var data = path.data;
	        var cmd;
	        var nPoint;
	        var i;
	        var j;
	        var k;
	        var p;
	
	        var M = CMD.M;
	        var C = CMD.C;
	        var L = CMD.L;
	        var R = CMD.R;
	        var A = CMD.A;
	        var Q = CMD.Q;
	
	        for (i = 0, j = 0; i < data.length;) {
	            cmd = data[i++];
	            j = i;
	            nPoint = 0;
	
	            switch (cmd) {
	                case M:
	                    nPoint = 1;
	                    break;
	                case L:
	                    nPoint = 1;
	                    break;
	                case C:
	                    nPoint = 3;
	                    break;
	                case Q:
	                    nPoint = 2;
	                    break;
	                case A:
	                    var x = m[4];
	                    var y = m[5];
	                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                    // cx
	                    data[i++] += x;
	                    // cy
	                    data[i++] += y;
	                    // Scale rx and ry
	                    // FIXME Assume psi is 0 here
	                    data[i++] *= sx;
	                    data[i++] *= sy;
	
	                    // Start angle
	                    data[i++] += angle;
	                    // end angle
	                    data[i++] += angle;
	                    // FIXME psi
	                    i += 2;
	                    j = i;
	                    break;
	                case R:
	                    // x0, y0
	                    p[0] = data[i++];
	                    p[1] = data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	                    // x1, y1
	                    p[0] += data[i++];
	                    p[1] += data[i++];
	                    v2ApplyTransform(p, p, m);
	                    data[j++] = p[0];
	                    data[j++] = p[1];
	            }
	
	            for (k = 0; k < nPoint; k++) {
	                var p = points[k];
	                p[0] = data[i++];
	                p[1] = data[i++];
	
	                v2ApplyTransform(p, p, m);
	                // Write back
	                data[j++] = p[0];
	                data[j++] = p[1];
	            }
	        }
	    }
	
	    module.exports = transformPath;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Text element
	 * @module zrender/graphic/Text
	 *
	 * TODO Wrapping
	 */
	
	
	
	    var Displayable = __webpack_require__(31);
	    var zrUtil = __webpack_require__(9);
	    var textContain = __webpack_require__(34);
	
	    /**
	     * @alias zrender/graphic/Text
	     * @extends module:zrender/graphic/Displayable
	     * @constructor
	     * @param {Object} opts
	     */
	    var Text = function (opts) {
	        Displayable.call(this, opts);
	    };
	
	    Text.prototype = {
	
	        constructor: Text,
	
	        type: 'text',
	
	        brush: function (ctx) {
	            var style = this.style;
	            var x = style.x || 0;
	            var y = style.y || 0;
	            // Convert to string
	            var text = style.text;
	            var textFill = style.fill;
	            var textStroke = style.stroke;
	
	            // Convert to string
	            text != null && (text += '');
	
	            if (text) {
	                ctx.save();
	
	                this.style.bind(ctx);
	                this.setTransform(ctx);
	
	                textFill && (ctx.fillStyle = textFill);
	                textStroke && (ctx.strokeStyle = textStroke);
	
	                ctx.font = style.textFont || style.font;
	                ctx.textAlign = style.textAlign;
	
	                if (style.textVerticalAlign) {
	                    var rect = textContain.getBoundingRect(
	                        text, ctx.font, style.textAlign, 'top'
	                    );
	                    // Ignore textBaseline
	                    ctx.textBaseline = 'top';
	                    switch (style.textVerticalAlign) {
	                        case 'middle':
	                            y -= rect.height / 2;
	                            break;
	                        case 'bottom':
	                            y -= rect.height;
	                            break;
	                        // 'top'
	                    }
	                }
	                else {
	                    ctx.textBaseline = style.textBaseline;
	                }
	                var lineHeight = textContain.measureText('国', ctx.font).width;
	
	                var textLines = text.split('\n');
	                for (var i = 0; i < textLines.length; i++) {
	                    textFill && ctx.fillText(textLines[i], x, y);
	                    textStroke && ctx.strokeText(textLines[i], x, y);
	                    y += lineHeight;
	                }
	
	                ctx.restore();
	            }
	        },
	
	        getBoundingRect: function () {
	            if (!this._rect) {
	                var style = this.style;
	                var rect = textContain.getBoundingRect(
	                    style.text + '', style.textFont || style.font, style.textAlign, style.textBaseline
	                );
	                rect.x += style.x || 0;
	                rect.y += style.y || 0;
	                this._rect = rect;
	            }
	            return this._rect;
	        }
	    };
	
	    zrUtil.inherits(Text, Displayable);
	
	    module.exports = Text;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 圆形
	 * @module zrender/shape/Circle
	 */
	
	
	
	    module.exports = __webpack_require__(42).extend({
	        
	        type: 'circle',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0
	        },
	
	        buildPath : function (ctx, shape) {
	            // Better stroking in ShapeBundle
	            ctx.moveTo(shape.cx + shape.r, shape.cy);
	            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
	            return;
	        }
	    });
	


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 扇形
	 * @module zrender/graphic/shape/Sector
	 */
	
	// FIXME clockwise seems wrong
	
	
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'sector',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r0: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r0 = Math.max(shape.r0 || 0, 0);
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
	
	            ctx.lineTo(unitX * r + x, unitY * r + y);
	
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	
	            ctx.lineTo(
	                Math.cos(endAngle) * r0 + x,
	                Math.sin(endAngle) * r0 + y
	            );
	
	            if (r0 !== 0) {
	                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	            }
	
	            ctx.closePath();
	        }
	    });
	


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆环
	 * @module zrender/graphic/shape/Ring
	 */
	
	
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'ring',
	
	        shape: {
	            cx: 0,
	            cy: 0,
	            r: 0,
	            r0: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.cx;
	            var y = shape.cy;
	            var PI2 = Math.PI * 2;
	            ctx.moveTo(x + shape.r, y);
	            ctx.arc(x, y, shape.r, 0, PI2, false);
	            ctx.moveTo(x + shape.r0, y);
	            ctx.arc(x, y, shape.r0, 0, PI2, true);
	        }
	    });
	


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 多边形
	 * @module zrender/shape/Polygon
	 */
	
	
	    var polyHelper = __webpack_require__(59);
	
	    module.exports = __webpack_require__(42).extend({
	        
	        type: 'polygon',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, true);
	        }
	    });


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	
	
	    var smoothSpline = __webpack_require__(60);
	    var smoothBezier = __webpack_require__(61);
	
	    module.exports = {
	        buildPath: function (ctx, shape, closePath) {
	            var points = shape.points;
	            var smooth = shape.smooth;
	            if (points && points.length >= 2) {
	                if (smooth && smooth !== 'spline') {
	                    var controlPoints = smoothBezier(
	                        points, smooth, closePath, shape.smoothConstraint
	                    );
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    var len = points.length;
	                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                        var cp1 = controlPoints[i * 2];
	                        var cp2 = controlPoints[i * 2 + 1];
	                        var p = points[(i + 1) % len];
	                        ctx.bezierCurveTo(
	                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
	                        );
	                    }
	                }
	                else {
	                    if (smooth === 'spline') {
	                        points = smoothSpline(points, closePath);
	                    }
	
	                    ctx.moveTo(points[0][0], points[0][1]);
	                    for (var i = 1, l = points.length; i < l; i++) {
	                        ctx.lineTo(points[i][0], points[i][1]);
	                    }
	                }
	
	                closePath && ctx.closePath();
	            }
	        }
	    };


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Catmull-Rom spline 插值折线
	 * @module zrender/shape/util/smoothSpline
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	    var vec2 = __webpack_require__(18);
	
	    /**
	     * @inner
	     */
	    function interpolate(p0, p1, p2, p3, t, t2, t3) {
	        var v0 = (p2 - p0) * 0.5;
	        var v1 = (p3 - p1) * 0.5;
	        return (2 * (p1 - p2) + v0 + v1) * t3
	                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	                + v0 * t + p1;
	    }
	
	    /**
	     * @alias module:zrender/shape/util/smoothSpline
	     * @param {Array} points 线段顶点数组
	     * @param {boolean} isLoop
	     * @return {Array}
	     */
	    module.exports = function (points, isLoop) {
	        var len = points.length;
	        var ret = [];
	
	        var distance = 0;
	        for (var i = 1; i < len; i++) {
	            distance += vec2.distance(points[i - 1], points[i]);
	        }
	
	        var segs = distance / 2;
	        segs = segs < len ? len : segs;
	        for (var i = 0; i < segs; i++) {
	            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	            var idx = Math.floor(pos);
	
	            var w = pos - idx;
	
	            var p0;
	            var p1 = points[idx % len];
	            var p2;
	            var p3;
	            if (!isLoop) {
	                p0 = points[idx === 0 ? idx : idx - 1];
	                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	            }
	            else {
	                p0 = points[(idx - 1 + len) % len];
	                p2 = points[(idx + 1) % len];
	                p3 = points[(idx + 2) % len];
	            }
	
	            var w2 = w * w;
	            var w3 = w * w2;
	
	            ret.push([
	                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	            ]);
	        }
	        return ret;
	    };
	


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 贝塞尔平滑曲线
	 * @module zrender/shape/util/smoothBezier
	 * @author pissang (https://www.github.com/pissang)
	 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
	 *         errorrik (errorrik@gmail.com)
	 */
	
	
	    var vec2 = __webpack_require__(18);
	    var v2Min = vec2.min;
	    var v2Max = vec2.max;
	    var v2Scale = vec2.scale;
	    var v2Distance = vec2.distance;
	    var v2Add = vec2.add;
	
	    /**
	     * 贝塞尔平滑曲线
	     * @alias module:zrender/shape/util/smoothBezier
	     * @param {Array} points 线段顶点数组
	     * @param {number} smooth 平滑等级, 0-1
	     * @param {boolean} isLoop
	     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
	     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
	     *                           整个折线的包围盒做一个并集用来约束控制点。
	     * @param {Array} 计算出来的控制点数组
	     */
	    module.exports = function (points, smooth, isLoop, constraint) {
	        var cps = [];
	
	        var v = [];
	        var v1 = [];
	        var v2 = [];
	        var prevPoint;
	        var nextPoint;
	
	        var min, max;
	        if (constraint) {
	            min = [Infinity, Infinity];
	            max = [-Infinity, -Infinity];
	            for (var i = 0, len = points.length; i < len; i++) {
	                v2Min(min, min, points[i]);
	                v2Max(max, max, points[i]);
	            }
	            // 与指定的包围盒做并集
	            v2Min(min, min, constraint[0]);
	            v2Max(max, max, constraint[1]);
	        }
	
	        for (var i = 0, len = points.length; i < len; i++) {
	            var point = points[i];
	
	            if (isLoop) {
	                prevPoint = points[i ? i - 1 : len - 1];
	                nextPoint = points[(i + 1) % len];
	            }
	            else {
	                if (i === 0 || i === len - 1) {
	                    cps.push(vec2.clone(points[i]));
	                    continue;
	                }
	                else {
	                    prevPoint = points[i - 1];
	                    nextPoint = points[i + 1];
	                }
	            }
	
	            vec2.sub(v, nextPoint, prevPoint);
	
	            // use degree to scale the handle length
	            v2Scale(v, v, smooth);
	
	            var d0 = v2Distance(point, prevPoint);
	            var d1 = v2Distance(point, nextPoint);
	            var sum = d0 + d1;
	            if (sum !== 0) {
	                d0 /= sum;
	                d1 /= sum;
	            }
	
	            v2Scale(v1, v, -d0);
	            v2Scale(v2, v, d1);
	            var cp0 = v2Add([], point, v1);
	            var cp1 = v2Add([], point, v2);
	            if (constraint) {
	                v2Max(cp0, cp0, min);
	                v2Min(cp0, cp0, max);
	                v2Max(cp1, cp1, min);
	                v2Min(cp1, cp1, max);
	            }
	            cps.push(cp0);
	            cps.push(cp1);
	        }
	
	        if (isLoop) {
	            cps.push(cps.shift());
	        }
	
	        return cps;
	    };
	


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module zrender/graphic/shape/Polyline
	 */
	
	
	    var polyHelper = __webpack_require__(59);
	
	    module.exports = __webpack_require__(42).extend({
	        
	        type: 'polyline',
	
	        shape: {
	            points: null,
	
	            smooth: false,
	
	            smoothConstraint: null
	        },
	
	        style: {
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            polyHelper.buildPath(ctx, shape, false);
	        }
	    });


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 矩形
	 * @module zrender/graphic/shape/Rect
	 */
	
	
	    var roundRectHelper = __webpack_require__(35);
	
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'rect',
	
	        shape: {
	            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
	            // r缩写为1         相当于 [1, 1, 1, 1]
	            // r缩写为[1]       相当于 [1, 1, 1, 1]
	            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
	            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
	            r: 0,
	
	            x: 0,
	            y: 0,
	            width: 0,
	            height: 0
	        },
	
	        buildPath: function (ctx, shape) {
	            var x = shape.x;
	            var y = shape.y;
	            var width = shape.width;
	            var height = shape.height;
	            if (!shape.r) {
	                ctx.rect(x, y, width, height);
	            }
	            else {
	                roundRectHelper.buildPath(ctx, shape);
	            }
	            ctx.closePath();
	            return;
	        }
	    });
	


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 直线
	 * @module zrender/graphic/shape/Line
	 */
	
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'line',
	
	        shape: {
	            // Start point
	            x1: 0,
	            y1: 0,
	            // End point
	            x2: 0,
	            y2: 0,
	
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var percent = shape.percent;
	
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (percent < 1) {
	                x2 = x1 * (1 - percent) + x2 * percent;
	                y2 = y1 * (1 - percent) + y2 * percent;
	            }
	            ctx.lineTo(x2, y2);
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            return [
	                shape.x1 * (1 - p) + shape.x2 * p,
	                shape.y1 * (1 - p) + shape.y2 * p
	            ];
	        }
	    });
	


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	/**
	 * 贝塞尔曲线
	 * @module zrender/shape/BezierCurve
	 */
	
	
	    var curveTool = __webpack_require__(44);
	    var quadraticSubdivide = curveTool.quadraticSubdivide;
	    var cubicSubdivide = curveTool.cubicSubdivide;
	    var quadraticAt = curveTool.quadraticAt;
	    var cubicAt = curveTool.cubicAt;
	
	    var out = [];
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'bezier-curve',
	
	        shape: {
	            x1: 0,
	            y1: 0,
	            x2: 0,
	            y2: 0,
	            cpx1: 0,
	            cpy1: 0,
	            // cpx2: 0,
	            // cpy2: 0
	
	            // Curve show percent, for animating
	            percent: 1
	        },
	
	        style: {
	            stroke: '#000',
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	            var x1 = shape.x1;
	            var y1 = shape.y1;
	            var x2 = shape.x2;
	            var y2 = shape.y2;
	            var cpx1 = shape.cpx1;
	            var cpy1 = shape.cpy1;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            var percent = shape.percent;
	            if (percent === 0) {
	                return;
	            }
	
	            ctx.moveTo(x1, y1);
	
	            if (cpx2 == null || cpy2 == null) {
	                if (percent < 1) {
	                    quadraticSubdivide(
	                        x1, cpx1, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    x2 = out[2];
	                    quadraticSubdivide(
	                        y1, cpy1, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    y2 = out[2];
	                }
	
	                ctx.quadraticCurveTo(
	                    cpx1, cpy1,
	                    x2, y2
	                );
	            }
	            else {
	                if (percent < 1) {
	                    cubicSubdivide(
	                        x1, cpx1, cpx2, x2, percent, out
	                    );
	                    cpx1 = out[1];
	                    cpx2 = out[2];
	                    x2 = out[3];
	                    cubicSubdivide(
	                        y1, cpy1, cpy2, y2, percent, out
	                    );
	                    cpy1 = out[1];
	                    cpy2 = out[2];
	                    y2 = out[3];
	                }
	                ctx.bezierCurveTo(
	                    cpx1, cpy1,
	                    cpx2, cpy2,
	                    x2, y2
	                );
	            }
	        },
	
	        /**
	         * Get point at percent
	         * @param  {number} percent
	         * @return {Array.<number>}
	         */
	        pointAt: function (p) {
	            var shape = this.shape;
	            var cpx2 = shape.cpx2;
	            var cpy2 = shape.cpy2;
	            if (cpx2 === null || cpy2 === null) {
	                return [
	                    quadraticAt(shape.x1, shape.cpx1, shape.x2, p),
	                    quadraticAt(shape.y1, shape.cpy1, shape.y2, p)
	                ];
	            }
	            else {
	                return [
	                    cubicAt(shape.x1, shape.cpx1, shape.cpx1, shape.x2, p),
	                    cubicAt(shape.y1, shape.cpy1, shape.cpy1, shape.y2, p)
	                ];
	            }
	        }
	    });
	


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 圆弧
	 * @module zrender/graphic/shape/Arc
	 */
	 
	
	    module.exports = __webpack_require__(42).extend({
	
	        type: 'arc',
	
	        shape: {
	
	            cx: 0,
	
	            cy: 0,
	
	            r: 0,
	
	            startAngle: 0,
	
	            endAngle: Math.PI * 2,
	
	            clockwise: true
	        },
	
	        style: {
	
	            stroke: '#000',
	
	            fill: null
	        },
	
	        buildPath: function (ctx, shape) {
	
	            var x = shape.cx;
	            var y = shape.cy;
	            var r = Math.max(shape.r, 0);
	            var startAngle = shape.startAngle;
	            var endAngle = shape.endAngle;
	            var clockwise = shape.clockwise;
	
	            var unitX = Math.cos(startAngle);
	            var unitY = Math.sin(startAngle);
	
	            ctx.moveTo(unitX * r + x, unitY * r + y);
	            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	        }
	    });


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(9);
	
	    var Gradient = __webpack_require__(10);
	
	    /**
	     * x, y, x2, y2 are all percent from 0 to 1
	     * @param {number} [x=0]
	     * @param {number} [y=0]
	     * @param {number} [x2=1]
	     * @param {number} [y2=0]
	     * @param {Array.<Object>} colorStops
	     */
	    var LinearGradient = function (x, y, x2, y2, colorStops) {
	        this.x = x == null ? 0 : x;
	
	        this.y = y == null ? 0 : y;
	
	        this.x2 = x2 == null ? 1 : x2;
	
	        this.y2 = y2 == null ? 0 : y2;
	
	        Gradient.call(this, colorStops);
	    };
	
	    LinearGradient.prototype = {
	
	        constructor: LinearGradient,
	
	        type: 'linear',
	
	        updateCanvasGradient: function (shape, ctx) {
	            var rect = shape.getBoundingRect();
	            // var size =
	            var x = this.x * rect.width + rect.x;
	            var x2 = this.x2 * rect.width + rect.x;
	            var y = this.y * rect.height + rect.y;
	            var y2 = this.y2 * rect.height + rect.y;
	
	            var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	
	            var colorStops = this.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	
	            this.canvasGradient = canvasGradient;
	        }
	
	    };
	
	    zrUtil.inherits(LinearGradient, Gradient);
	
	    module.exports = LinearGradient;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	
	    var zrUtil = __webpack_require__(9);
	
	    var Gradient = __webpack_require__(10);
	
	    /**
	     * x, y, r are all percent from 0 to 1
	     * @param {number} [x=0.5]
	     * @param {number} [y=0.5]
	     * @param {number} [r=0.5]
	     * @param {Array.<Object>} [colorStops]
	     */
	    var RadialGradient = function (x, y, r, colorStops) {
	        this.x = x == null ? 0.5 : x;
	
	        this.y = y == null ? 0.5 : y;
	
	        this.r = r == null ? 0.5 : r;
	
	        Gradient.call(this, colorStops);
	    };
	
	    RadialGradient.prototype = {
	
	        constructor: RadialGradient,
	
	        type: 'radial',
	
	        updateCanvasGradient: function (shape, ctx) {
	            var rect = shape.getBoundingRect();
	
	            var width = rect.width;
	            var height = rect.height;
	            var min = Math.min(width, height);
	            // var max = Math.max(width, height);
	
	            var x = this.x * width + rect.x;
	            var y = this.y * height + rect.y;
	            var r = this.r * min;
	
	            var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	
	            var colorStops = this.colorStops;
	            for (var i = 0; i < colorStops.length; i++) {
	                canvasGradient.addColorStop(
	                    colorStops[i].offset, colorStops[i].color
	                );
	            }
	
	            this.canvasGradient = canvasGradient;
	        }
	    };
	
	    zrUtil.inherits(RadialGradient, Gradient);
	
	    module.exports = RadialGradient;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 事件决策多边形
	 * @module fish-topo-bo/node/EventDecisionNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(38);
	    var graphic = __webpack_require__(40);
	
	    function EventDecisionNode(data, opts) {
	        /**
	         * BO属性数据
	         * @type {Object}
	         * @private
	         */
	        this._data = data;
	
	        /**
	         * 起始位置坐标
	         * @type {startPos}
	         * @private
	         */
	        this._startPos = opts.startPos;
	
	        this._type = opts.type || 'boEvent';
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._clickable = opts.clickable || false;
	        this._popupOpts = opts.popupOpts;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	
	        //生成BO属性图形
	        this._render();
	    }
	
	    var eventProto = EventDecisionNode.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    eventProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 生成事件决策图形
	     * @private
	     */
	    eventProto._render = function () {
	        //多边形
	        this._createEventShape();
	        //文字
	        this._createEVentName();
	    };
	
	    /**
	     * 事件决策多边形
	     * @private
	     */
	    eventProto._createEventShape = function () {
	
	        //多边形高度
	        var height = Const.BO_EVENT_HEIGHT,
	            x = this._startPos.x + 1,
	            y = this._startPos.y,
	            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,
	
	            shape = new graphic.Polygon({
	                name: this._data.id,
	                shape: {
	                    points: [
	                        [x, y],
	                        [x + width - 10, y],
	                        [x + width, y + height / 2],
	                        [x + width - 10, y + height],
	                        [x, y + height]]
	                },
	
	                style: {
	                    fill: '#FFCCCC',
	                    stroke: '#000000',
	                    lineWidth: 0.75
	                }
	
	            });
	
	        if (this._clickable) {
	            shape.clickable = this._clickable;
	            shape._data = this._data;
	            shape._popupOpts = this._popupOpts;
	            shape.onclick = this._click;
	        }
	
	
	        this._group.add(shape);
	    };
	
	    /**
	     * 点击事件
	     * @private
	     */
	    eventProto._click = function () {
	        var options = fish.extend(
	            {
	                viewOption: {
	                    DATA: this._data
	                },
	                width: 800,
	                height: 500
	            }, this._popupOpts);
	
	        fish.popupView(options);
	    };
	
	    /**
	     * 事件决策名称
	     * @private
	     */
	    eventProto._createEVentName = function () {
	        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),
	            y = this._startPos.y,
	
	            eventNameShape = new graphic.Text({
	                style: {
	                    text: this._data.name,
	                    textFont: Const.BO_EVENT_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top'
	                },
	
	                position: [x, y]
	            });
	
	        if (this._clickable) {
	            eventNameShape.clickable = this._clickable;
	            eventNameShape._data = this._data;
	            eventNameShape._popupOpts = this._popupOpts;
	            eventNameShape.onclick = this._click;
	        }
	
	        this._group.add(eventNameShape);
	    };
	
	    module.exports = EventDecisionNode;
	


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BO矩形内部的横线，分为实线和虚线两种
	 * @module fish-topo-bo/node/LineNode
	 * Created by majianan on 16/5/19.
	 */
	
	
	    var Const = __webpack_require__(38);
	    var graphic = __webpack_require__(40);
	    var util = __webpack_require__(9);
	    /**
	     * BO名字下面的实现
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function BoLine(startPos) {
	
	        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};
	
	        return _line(startPos, endPos);
	    }
	
	    /**
	     * BO属性之间的虚线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function AttrLine(startPos) {
	
	        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},
	            style = {lineDash: [Const.LINE_DASH]};
	
	        return _line(startPos, endPos, style);
	    }
	
	    /**
	     * BO属性与BO事件决策之间的垂直虚线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @param {int} attrHeight, 高度
	     * @returns {zrender/graphic/shape/Line}
	     * @constructor
	     */
	    function AttrEventLine(startPos, attrHeight) {
	        var endPos = {x: startPos.x, y: startPos.y + attrHeight},
	            style = {lineDash: [Const.LINE_DASH]};
	
	        return _line(startPos, endPos, style);
	    }
	
	    /**
	     * 画线
	     * @param {{x: *, y: *}} startPos, 开始坐标
	     * @param {{x: *, y: *}} endPos, 结束坐标
	     * @param {Object} style, 样式,可空
	     * @returns {zrender/graphic/shape/Line}
	     * @private
	     */
	    function _line(startPos, endPos, style) {
	
	        var _style = {
	            strokeColor: '#000000',
	            lineWidth: 0.5,
	            percent: 1
	        };
	
	        util.extend(_style, style);
	
	        var shape = new graphic.Line({
	            shape: {
	                // Start point
	                x1: startPos.x,
	                y1: startPos.y,
	
	                // End point
	                x2: endPos.x,
	                y2: endPos.y,
	
	                percent: 1
	            },
	
	            style: _style
	        });
	
	        return shape;
	    }
	
	
	    module.exports = {
	        BoLine: BoLine,
	        AttrLine: AttrLine,
	        AttrEventLine: AttrEventLine
	    };


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * BO属性
	 * 1.BO属性名字
	 * 2.BO属性数据类型
	 * 3.BO属性事件决策
	 * @module fish-topo-bo/node/BoAttrNode
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(38);
	    var EventDecision = __webpack_require__(69);
	    var graphic = __webpack_require__(40);
	
	    /**
	     *
	     * @param {{
	     *          id: String bo属性标识,
	     *          code: String bo属性编码
	     *          keyValue: boolean 是否为主键,
	     *          dataType: String 属性数据类型,
	     *          boAttrEventArr:[] 属性事件决策数组
	     *          }} boAttrData BO属性数据对象,
	     * @param {{
	     *          startPos: {x: number, y: number}起始位置,
	     *          displayDataType: boolean 是否显示数据类型,
	     *          displayEventDecision: boolean 是否显示事件决策,
	     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,
	     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,
	     *          }} opts
	     * @constructor
	     */
	    function BoAttr(boAttrData, opts) {
	        /**
	         * BO属性数据
	         * @type {Object}
	         * @private
	         */
	        this._data = boAttrData;
	
	        /**
	         * 是否为主键
	         * @type {boolean}
	         * @private
	         */
	        this._keyValue = boAttrData.keyValue || false;
	
	        /**
	         * 起始位置坐标
	         * @type {startPos}
	         * @private
	         */
	        this._startPos = opts.startPos;
	
	        /**
	         * 是否显示数据类型
	         * @type {boolean}
	         * @private
	         */
	        this._displayDataType = opts.displayDataType || false;
	
	        /**
	         * 是否显示事件决策
	         * @type {boolean}
	         * @private
	         */
	        this._displayEventDecision = opts.displayEventDecision || false;
	
	        /**
	         * 是否支持点击
	         * @type {boolean}
	         * @private
	         */
	        this._eventClickable = opts.eventClickable || false;
	        this._eventPopupOpts = opts.eventPopupOpts;
	
	        /**
	         * Group容器
	         * @type zrender/graphic/Group
	         * @private
	         */
	        this._group = new graphic.Group();
	        this._group.name = this._data.id;
	
	        //生成BO属性图形
	        this._render();
	    }
	
	    var boAttrProto = BoAttr.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {zrender/graphic/Group}
	     */
	    boAttrProto.getShape = function () {
	        return this._group;
	    };
	
	
	    /**
	     * 生成BO属性图形
	     * @private
	     */
	    boAttrProto._render = function () {
	        //属性名字
	        this._createText();
	
	        //属性数据类型
	        this._createDataType();
	
	        //属性事件决策
	        this._createEventDecision();
	    };
	
	    /**
	     * 属性名字
	     * @private
	     */
	    boAttrProto._createText = function () {
	
	        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,
	            y = this._startPos.y,
	
	            attrNameShape = new graphic.Text({
	                style: {
	                    text: this._data.name,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: 'left',  //靠左开始，便于计算位置
	                    textBaseline: 'top',
	                    //lineWidth: 1,
	                    fill: this._keyValue ? 'red' : 'black'
	                },
	
	                position: [x, y]
	            });
	
	        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom
	        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;
	        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算
	        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;
	
	        //重新设置B起始水平坐标 = 减去偏移量
	        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;
	        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];
	
	        this._group.add(attrNameShape);
	    };
	
	    /**
	     * 属性数据类型
	     * @private
	     */
	    boAttrProto._createDataType = function () {
	        if (!this._displayDataType) {
	            return;
	        }
	
	        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,
	            y = this._startPos.y,
	            textAlign = 'right';
	
	        //如果还要显示事件决策，则宽度重新计算
	        if (this._displayEventDecision) {
	            textAlign = 'left';
	            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;
	        }
	
	        var _dataTypeShape = new graphic.Text({
	            style: {
	                text: this._data.dataType || '',
	                textFont: Const.BO_ATTR_FONT,
	                textAlign: textAlign,  //靠左开始，便于计算位置
	                textBaseline: 'top',
	                lineWidth: 1
	            },
	
	            position: [x, y]
	        });
	
	        this._group.add(_dataTypeShape);
	    };
	
	    /**
	     * 属性事件决策
	     * @private
	     */
	    boAttrProto._createEventDecision = function () {
	        if (!this._displayEventDecision) {
	            return;
	        }
	
	        var _boAttrEventArr = this._data.boAttrEventArr || [],
	            _boAttrEventLen = _boAttrEventArr.length,
	            padding = (_boAttrEventLen > 1) ? 10 : 0,
	            _startPos = {
	                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,
	                y: this._startPos.y
	            };
	
	        //从右向左画，
	        for (var i = _boAttrEventLen - 1; i >= 0; i--) {
	            this._group.add(new EventDecision(_boAttrEventArr[i], {
	                startPos: _startPos,
	                type: 'boAttrEvent',
	                clickable: this._eventClickable,
	                popupOpts: this._eventPopupOpts
	            }).getShape());
	            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};
	        }
	        /*_startPos = {
	         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,
	         y: this._startPos.y};
	
	         for (var i = 0; i < _boAttrEventLen; i++) {
	         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));
	         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};
	         }*/
	
	
	    };
	
	    module.exports = BoAttr;
	


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * 用来创建关联关系
	 * 关联关系包括折线、箭头、关系文字说明
	 * @module fish-topo-bo/node/Relation
	 * Created by majianan on 16/5/19.
	 */
	
	    var Const = __webpack_require__(38);
	    var graphic = __webpack_require__(40);
	
	    /**
	     *
	     * @param sourceShape, 开始图形
	     * @param targetShape, 目标图形
	     * @param {String} sourceText, 关系开始文字说明,可空
	     * @param {String} targetText, 关系结束文字说明,可空
	     * @constructor
	     */
	    function Relation(sourceShape, targetShape, sourceText, targetText) {
	        this._sourceText = sourceText;
	        this._targetText = targetText;
	
	        this._group = new graphic.Group();
	
	        //左侧开始位置
	        this._lStartPos = {
	            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,
	            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2
	        };
	
	        //左侧结束位置
	        this._lEndPos = {
	            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,
	            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2
	        };
	
	        //右侧开始位置
	        this._rStartPos = {
	            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,
	            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2
	        };
	
	        //右侧结束位置
	        this._rEndPos = {
	            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,
	            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2
	        };
	
	        //判断画线方向
	        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;
	
	        //生成图形
	        this._render();
	    }
	
	    var relationProto = Relation.prototype;
	
	    /**
	     * 获取关系整体图形
	     * @returns {*}
	     */
	    relationProto.getShape = function () {
	        return this._group;
	    };
	
	    /**
	     * 生成关系整体图形
	     * @private
	     */
	    relationProto._render = function () {
	        //画线
	        this._createLine();
	
	        //箭头
	        this._createArrow();
	
	        //关系说明文字
	        this._createText();
	    };
	
	    /**
	     * 生成关系折线
	     * @private
	     */
	    relationProto._createLine = function () {
	        var _linePoints = [];
	
	        if (this._leftDirection) {
	            //第一点
	            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);
	            //第二点
	            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);
	            //第三点
	            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);
	            //第四点
	            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);
	        }
	        else {
	            //第一点
	            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);
	            //第二点
	            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);
	            //第三点
	            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);
	            //第四点
	            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);
	        }
	
	        var _lineShape = new graphic.Polyline({
	            shape: {
	                points: _linePoints
	            },
	
	            style: {
	                //fill: 'blue',
	                stroke: 'blue'
	            }
	        });
	
	        this._group.add(_lineShape);
	    };
	
	    /**
	     * 生成箭头图形
	     * @private
	     */
	    relationProto._createArrow = function () {
	        var _arrowPoints = [];
	
	        if (this._leftDirection) {
	            //右侧第一点
	            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);
	            //下面第二点
	            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);
	            //上面第三点
	            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);
	        }
	        else {
	            //左侧第一点
	            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);
	            //下面第二点
	            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);
	            //上面第三点
	            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);
	        }
	
	        var _arrowShape = new graphic.Polyline({
	            shape: {
	                points: _arrowPoints
	            },
	
	            style: {
	                fill: 'blue',
	                stroke: 'blue'
	            }
	        });
	
	        this._group.add(_arrowShape);
	    };
	
	    /**
	     * 生成文字说明
	     * @private
	     */
	    relationProto._createText = function () {
	        var _sourceTextPos,
	            _targetTextPos,
	            _textAlign;
	
	        if (this._leftDirection) {
	            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _textAlign = 'right';
	        }
	        else {
	            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];
	            _textAlign = 'left';
	        }
	
	        //开始文字
	        if (this._sourceText) {
	            var _srcTextShape = new graphic.Text({
	                position: _sourceTextPos,
	
	                style: {
	                    text: this._sourceText,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: _textAlign,
	                    textBaseline: 'buttom',
	                    lineWidth: 1
	                }
	            });
	            this._group.add(_srcTextShape);
	        }
	
	        //结束文字
	        if (this._targetText) {
	            var _targetTextShape = new graphic.Text({
	                position: _targetTextPos,
	
	                style: {
	                    text: this._targetText,
	                    textFont: Const.BO_ATTR_FONT,
	                    textAlign: _textAlign,
	                    textBaseline: 'buttom',
	                    lineWidth: 1
	                }
	            });
	            this._group.add(_targetTextShape);
	        }
	
	    };
	
	    module.exports = Relation;


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA5MTZlMzdlMzdjZWQyOTgxODhkMyIsIndlYnBhY2s6Ly8vLi9pbmRleC5iby5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9GaXNoVG9wb0JvLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvenJlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZ3VpZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZW52LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvSGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9taXhpbi9EcmFnZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9TdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvdmVjdG9yLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9DbGlwLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvcmUvQm91bmRpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9MYXllci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL0Rpc3BsYXlhYmxlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9yb3VuZFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0JvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9tb2RlbHMvQ29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9Cb05hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb3JlL2N1cnZlLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29yZS9iYm94LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvY29udGFpbi9hcmMuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1NlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3BvbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhTcGxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1BvbHlsaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvQXJjLmpzIiwid2VicGFjazovLy8uL34venJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9FdmVudERlY2lzaW9uTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL0xpbmVOb2RlLmpzIiwid2VicGFjazovLy8uL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvQm9BdHRyTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL1JlbGF0aW9uLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJB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QixvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLHFCQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixTQUFTO0FBQzVCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzlWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkIsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxJQUFJO0FBQ2pELDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBLCtDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxRQUFRO0FBQ3BCLGFBQVksU0FBUztBQUNyQixhQUFZLGVBQWU7QUFDM0IsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFROztBQUVSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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LDBEQUF5RCxPQUFPO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtB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NEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW1CLDRCQUE0QjtBQUMvQyxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0Msb0JBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsNEJBQTRCO0FBQy9DLG9CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQixvQkFBbUIsT0FBTztBQUMxQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUIsb0JBQW1CLE9BQU87QUFDMUIscUJBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQixvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLFFBQVE7QUFDM0Isb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixRQUFRO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0EsaUNBQWdDLE1BQU07QUFDdEMscUNBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGVBQWUsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxxQ0FBcUMsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCLG9CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QixpQkFBZ0IsTUFBTTtBQUN0QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixNQUFNO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFNBQVM7QUFDcEMsZ0NBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLFNBQVM7QUFDeEIsZ0JBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFvQixnQkFBZ0I7QUFDcEMsOEJBQTZCO0FBQzdCLHFCQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBbUMsOEJBQThCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsU0FBUztBQUM3QixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbGxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9BQU87QUFDekIsb0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLG1CQUFrQixPQUFPO0FBQ3pCLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxtQkFBa0IsT0FBTztBQUN6QixvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsbUJBQWtCLE9B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QUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0IsU0FBUztBQUM3QjtBQUNBLHFCQUFvQixTQUFTO0FBQzdCO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDLGlDQUFpQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQSx1Q0FBc0M7O0FBRXRDLHNDQUFxQzs7QUFFckM7QUFDQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0Esd0NBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixTQUFTO0FBQzdCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxvQkFBbUIsY0FBYztBQUNqQyxvQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDMVBBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBLG9CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsOEJBQThCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QyxvQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxvQkFBbUIsY0FBYztBQUNqQyxvQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EscUJBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CLHVCQUF1QjtBQUMzQyxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsNEJBQTRCO0FBQzNDLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxPQUFPO0FBQ3RCLGlCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixpQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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RUE7QUFDQTtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQsK0NBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0Esb0JBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxvQkFBbUIsY0FBYztBQUNqQyxvQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsU0FBUztBQUN4QixnQkFBZSxTQUFTO0FBQ3hCLGdCQUFlLE9BQU87QUFDdEIsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3RVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLHlCQUF5QjtBQUM3QyxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CLE9BQU87QUFDM0IscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsUUFBUTtBQUM1QixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxvQkFBbUIseUJBQXlCO0FBQzVDLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLFNBQVM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLG9CQUFtQixvRUFBb0U7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsU0FBUztBQUNwQztBQUNBLGdDQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsaUJBQWlCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsZUFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUN4ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQixPQUFPO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLGVBQWU7QUFDL0IsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2QixpQkFBZ0IsT0FBTztBQUN2Qixp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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ25ZQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3ZDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3RDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3BDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixRQUFRO0FBQzVCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQixPQUFPO0FBQzNCLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDeEJMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDM0RMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQzFCTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7Ozs7O0FDckJMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQixnQkFBZSxRQUFRO0FBQ3ZCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsT0FBTztBQUN0QixnQkFBZSxRQUFRO0FBQ3ZCLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEMsU0FBUztBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7Ozs7OztBQzVCTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7Ozs7OztBQ3hDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQSxxQkFBb0IsT0FBTztBQUMzQixxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7Ozs7Ozs7O0FDekRMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBLDRCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYiwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXdCLHFCQUFxQjtBQUM3QztBQUNBLHVCQUFzQjtBQUN0QixXQUFVOzs7QUFHVjs7QUFFQTs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCLGdCQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiJmaXNoVG9wb0JvLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZmlzaFRvcG9Cb1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJmaXNoVG9wb0JvXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uXG4gKiovIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA5MTZlMzdlMzdjZWQyOTgxODhkM1xuICoqLyIsIi8qKlxyXG4gKiBFeHBvcnQgZmlzaFRvcG8gYXMgQ29tbW9uSlMgbW9kdWxlXHJcbiAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Zpc2gtdG9wby1iby9saWIvRmlzaFRvcG9Cby5qcycpO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2luZGV4LmJvLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICpcclxuICovXHJcblxyXG4gICAgdmFyIHpyID0gcmVxdWlyZSgnenJlbmRlci9saWIvenJlbmRlcicpO1xyXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL3V0aWwnKTtcclxuICAgIHZhciBCb05vZGUgPSByZXF1aXJlKCcuL25vZGUvQm9Ob2RlJyk7XHJcbiAgICB2YXIgUmVsYXRpb24gPSByZXF1aXJlKCcuL25vZGUvUmVsYXRpb24nKTtcclxuICAgIHZhciBDb25zdCA9IHJlcXVpcmUoJy4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciBldmVudFRvb2wgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL2V2ZW50Jyk7XHJcblxyXG4gICAgZnVuY3Rpb24gRmlzaFRvcG9Cbyhkb20sIG9wdHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDnvKnmlL5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubm93Wm9vbSA9IDE7XHJcbiAgICAgICAgdGhpcy5jYW5TY2FsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOWIneWni+WMlnpyZW5kZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl96ciA9IHpyLmluaXQoZG9tLCB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyOiBvcHRzLnJlbmRlcmVyIHx8ICdjYW52YXMnLFxyXG4gICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiBvcHRzLmRldmljZVBpeGVsUmF0aW9cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZmlzaFRvcG9Qcm90byA9IEZpc2hUb3BvQm8ucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5Yid5aeL5YyWXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLmdyb3VwRHJhZyh0aGlzLmdyb3VwKTtcclxuICAgICAgICB0aGlzLl96ci5hZGQodGhpcy5ncm91cCk7XHJcbiAgICAgICAgdGhpcy56clNjYWxlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6LCD5pW05bC65a+4ICDlnKjnqpflj6PlpKflsI/lj5HnlJ/mlLnlj5jml7bpnIDopoHmiYvlt6XosIPnlKhcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fenIucmVzaXplKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75YqgQk9cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib0RhdGEsIGJv5pWw5o2uXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgIHN0YXJ0UG9zOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IOi1t+Wni+S9jee9rixcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlBdHRyRGF0YVR5cGU6IGJvb2xlYW4g5piv5ZCm5pi+56S65bGe5oCn5pWw5o2u57G75Z6LLFxyXG4gICAgICogICAgICAgICAgZGlzcGxheUF0dHJFdmVudDogYm9vbGVhbiDmmK/lkKbmmL7npLrlsZ7mgKfkuovku7blhrPnrZYsXHJcbiAgICAgKiAgICAgICAgICBib0NsaWNrYWJsZTogYm9vbGVhbiBCT+aYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBib1BvcHVwVXJsOiBTdHJpbmcg54K55Ye7Qk/lvLnlh7rpobXpnaLlnLDlnYBcclxuICAgICAqICAgICAgICAgIGJvRXZlbnRDbGlja2FibGU6IGJvb2xlYW4gQk/kuovku7blhrPnrZbmmK/lkKbmlK/mjIHngrnlh7vkuovku7YsIOWPr+epuiDpu5jorqRmYWxzZVxyXG4gICAgICogICAgICAgICAgYm9FdmVudFBvcHVwVXJsOiBTdHJpbmcg54K55Ye7Qk/kuovku7blhrPnrZblvLnlh7rpobXpnaLlnLDlnYBcclxuICAgICAqICAgICAgICAgIGF0dHJFdmVudENsaWNrYWJsZTogYm9vbGVhbiBCT+WxnuaAp+S6i+S7tuWGs+etluaYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBhdHRyRXZlbnRQb3B1cFVybDogU3RyaW5nIOeCueWHu0JP5bGe5oCn5LqL5Lu25Yaz562W5by55Ye66aG16Z2i5Zyw5Z2AXHJcbiAgICAgKiAgICAgICAgICBpc0N1cnJlbnQ6IGJvb2xlYW4g5piv5ZCm5Li65b2T5YmNQk9cclxuICAgICAqICAgICAgICAgIH19IG9wdHNcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmFkZEJvID0gZnVuY3Rpb24gKGJvRGF0YSwgb3B0cykge1xyXG4gICAgICAgIC8v6K6+572uQk/niLblrZDlhbPns7vvvIzkvr/kuo7lkI7nu63mlbTkvZPnp7vliqhcclxuICAgICAgICB0aGlzLl9zZXRQYXJlbnQoYm9EYXRhKTtcclxuXHJcbiAgICAgICAgLy9sYXlvdXQgQk/nmoTluIPlsYDkv6Hmga/vvIx4LHnlt6bkuIrop5Lotbflp4vlnZDmoIcsIGxldmVsOuWxgue6p1xyXG4gICAgICAgIGJvRGF0YS5sYXlvdXQgPSB7XHJcbiAgICAgICAgICAgIHg6IG9wdHMuc3RhcnRQb3MueCxcclxuICAgICAgICAgICAgeTogb3B0cy5zdGFydFBvcy55LFxyXG4gICAgICAgICAgICBsZXZlbDogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v6K6h566XQk/nmoRY5Z2Q5qCHXHJcbiAgICAgICAgdGhpcy5fYmZzKGJvRGF0YSk7XHJcblxyXG4gICAgICAgIC8v5oyJ54Wn6LW35aeL5Z2Q5qCH5pW05L2T5bem56e7XHJcbiAgICAgICAgdGhpcy5fbW92ZVJpZ2h0QnlQYXJlbnQoYm9EYXRhLCBvcHRzLnN0YXJ0UG9zLnggLSBib0RhdGEubGF5b3V0LngpO1xyXG5cclxuICAgICAgICAvL+eUu0JPXHJcbiAgICAgICAgdmFyIGJvTm9kZSA9IG5ldyBCb05vZGUoYm9EYXRhLCBvcHRzKTtcclxuICAgICAgICB0aGlzLmdyb3VwLmFkZChib05vZGUuZ2V0U2hhcGUoKSk7XHJcblxyXG4gICAgICAgIC8v5Yib5bu65a2QQk9cclxuICAgICAgICB0aGlzLmFkZENoaWxkQm8oYm9Ob2RlLCBvcHRzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGJvTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva5CT+eahOeItuWtkOWFs+ezu1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJvRGF0YSBCT+aVsOaNrlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fc2V0UGFyZW50ID0gZnVuY3Rpb24gKGJvRGF0YSkge1xyXG4gICAgICAgIGlmIChib0RhdGEuY2hpbGQpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkQ250ID0gYm9EYXRhLmNoaWxkLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNoaWxkQm9BcnIgPSBib0RhdGEuY2hpbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRCb0FycltpXS5wYXJlbnQgPSBib0RhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRCb0FycltpICsgMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEJvQXJyW2ldLm5leHQgPSBjaGlsZEJvQXJyW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8v6K6+572u5pyA5ZCO5a2Q6IqC54K555qEbmV4dD3kuIvkuIDkuKrniLboioLngrnnmoTnrKzkuIDkuKrlrZDoioLngrlcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvRGF0YS5uZXh0ICYmIGJvRGF0YS5uZXh0LmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRCb0FycltpXS5uZXh0ID0gYm9EYXRhLm5leHQuY2hpbGRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQYXJlbnQoY2hpbGRCb0FycltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJyZWFkdGgtRmlyc3QtU2VhcmNoIOiuoeeul1jlnZDmoIdcclxuICAgICAqIOeUseS6jkJP5a695bqm5a6a5q2777yM5Y+v5Lul5Zyo55S75Zu+5LmL5YmN6K6h566X5q+P5LiqQk/nmoTotbflp4tY5Z2Q5qCHXHJcbiAgICAgKiDmr4/kuKpCT+eahOmrmOW6puagueaNruaYvuekuuWGheWuueS4jeWbuuWumu+8jOWboOatpOmcgOimgeagueaNruWunumZheeahOeItkJP6auY5bqm5omN6IO96K6h566X5pys6Lqr55qE6LW35aeLWeWdkOagh1xyXG4gICAgICogQHBhcmFtIGJvRGF0YVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5fYmZzID0gZnVuY3Rpb24gKGJvRGF0YSkge1xyXG4gICAgICAgIC8v55So5LqO5L+d5a2Y5q+P5LiqbGV2ZWznmoTmnIDlpKflnZDmoIflgLxcclxuICAgICAgICB0aGlzLl9sZXZlbE1heFBvcyA9IHt9O1xyXG5cclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdOyAgIC8v5a2Y5pS+Qk/mlbDmja5cclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKGJvRGF0YSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdCT1snICsgdG1wLm5hbWUgKyAnXSB7eDogJyArIHRtcC5sYXlvdXQueCArICcsIGxldmVsOiAnICsgdG1wLmxheW91dC5sZXZlbCArICd9ICcpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcgICAgKioqQmVmb3JlIHRoaXMuX2xldmVsTWF4UG9zWycgKyB0bXAubGF5b3V0LmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIC8v6K+lbGV2ZWznrKzkuIDkuKroioLngrlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sZXZlbE1heFBvc1t0bXAubGF5b3V0LmxldmVsXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0gPSB7eDogdG1wLmxheW91dC54fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL+W9k+WJjeWwseaYr+acgOWPs+S+p+eahOiKgueCuVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9sZXZlbE1heFBvc1t0bXAubGF5b3V0LmxldmVsXS54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCA8PSB0bXAubGF5b3V0LngpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdID0ge3g6IHRtcC5sYXlvdXQueH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvZPliY3oioLngrnkuI7kuYvliY3nmoToioLngrnmnInkuqTlj4nvvIzliJnpnIDopoHov57lkIzniLboioLngrnmlbTkvZPlkJHlj7Pnp7vliqhcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlUmlnaHRCeUNoaWxkKHRtcCwgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0ueCAtIHRtcC5sYXlvdXQueCArIENvbnN0LkJPX05PREVfV0lEVEggKyBDb25zdC5CT19OT0RFX09GRlNFVF9YKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmxheW91dC5sZXZlbF0gPSB7eDogdG1wLmxheW91dC54fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnICAgICoqKkFmdGVyIHRoaXMuX2xldmVsTWF4UG9zWycgKyB0bXAubGF5b3V0LmxldmVsICsgJ109JyArIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5sYXlvdXQubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIC8v5a2Y5Zyo5a2Q6IqC54K577yM6K6h566X5a2Q6IqC54K55Z2Q5qCH77yM5ZCM5pe25re75Yqg5Yiw6Zif5YiX5Lit77yM5Lul5L6/5ZCO57ut6K6h566X6LCD5pW0eOWdkOagh1xyXG4gICAgICAgICAgICBpZiAodG1wLmNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRDbnQgPSB0bXAuY2hpbGQubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDbnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0bXAuY2hpbGRbaV0ubGF5b3V0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0bXAubGF5b3V0LnggLSAoQ29uc3QuQk9fTk9ERV9XSURUSCArIENvbnN0LkJPX05PREVfT0ZGU0VUX1gpICogKChjaGlsZENudCAtIDEpIC8gMiAtIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogdG1wLmxheW91dC5sZXZlbCArIDFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHRtcC5jaGlsZFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5a2Q6IqC54K55Y+z56e75pe277yM5ZCM5pe25LiL5LiA5Liq5a2Q6IqC54K577yM5Lul5Y+K54i26IqC54K56YO95ZCM5pe256e75YqoXHJcbiAgICAgKiBAcGFyYW0gYm9EYXRhXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX21vdmVSaWdodEJ5Q2hpbGQgPSBmdW5jdGlvbiAoYm9EYXRhLCB3aWR0aCkge1xyXG4gICAgICAgIGlmIChib0RhdGEpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICghYm9EYXRhLmxheW91dC5tb3ZlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChib0RhdGEubGF5b3V0LmxldmVsID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBib0RhdGEubGF5b3V0LnggKz0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBib0RhdGEubGF5b3V0LnggKz0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYm9EYXRhLmxheW91dC5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/lvZPliY3oioLngrnnmoTkuIvkuIDoioLngrnmlbTkvZPlj7Pnp7tcclxuICAgICAgICAgICAgdGhpcy5fbW92ZVJpZ2h0QnlQcmV2aW91cyhib0RhdGEubmV4dCwgd2lkdGgpO1xyXG4gICAgICAgICAgICAvL+W9k+WJjeiKgueCueeahOeItuiKgueCueaVtOS9k+WPs+enu1xyXG4gICAgICAgICAgICB0aGlzLl9tb3ZlUmlnaHRCeUNoaWxkKGJvRGF0YS5wYXJlbnQsIHdpZHRoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWJjeS4gOS4quiKgueCueWPs+enu+eahOaXtuWAme+8jOaJgOacieWQjumdoueahOiKgueCueaVtOS9k+WPs+enu1xyXG4gICAgICogQHBhcmFtIGJvRGF0YVxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLl9tb3ZlUmlnaHRCeVByZXZpb3VzID0gZnVuY3Rpb24gKGJvRGF0YSwgd2lkdGgpIHtcclxuICAgICAgICBpZiAoYm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGJvRGF0YS5sYXlvdXQueCArPSB3aWR0aDtcclxuICAgICAgICAgICAgYm9EYXRhLmxheW91dC5tb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8v5b2T5YmN6IqC54K555qE5omA5pyJ5ZCO57ut6IqC54K55pW05L2T5Y+z56e7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdmVSaWdodEJ5UHJldmlvdXMoYm9EYXRhLm5leHQsIHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog54i26IqC54K55Y+z56e75pe277yM5omA5pyJ5a2Q6IqC54K55pW05L2T5Y+z56e7XHJcbiAgICAgKiBAcGFyYW0gYm9EYXRhXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uX21vdmVSaWdodEJ5UGFyZW50ID0gZnVuY3Rpb24gKGJvRGF0YSwgd2lkdGgpIHtcclxuICAgICAgICBpZiAoYm9EYXRhKSB7XHJcbiAgICAgICAgICAgIGJvRGF0YS5sYXlvdXQueCArPSB3aWR0aDtcclxuICAgICAgICAgICAgaWYgKGJvRGF0YS5jaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib0RhdGEuY2hpbGQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb3ZlUmlnaHRCeVBhcmVudChib0RhdGEuY2hpbGRbaV0sIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmt7vliqDlrZBCT1xyXG4gICAgICogQHBhcmFtIHtCb05vZGV9IHBhcmVudEJvTm9kZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZpc2hUb3BvUHJvdG8uYWRkQ2hpbGRCbyA9IGZ1bmN0aW9uIChwYXJlbnRCb05vZGUsIG9wdHMpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTsgLy/pnIDopoHmoLnmja5CT+iKgueCueeahOWunumZhemrmOW6puiuoeeul+iHquW3seeCueeahOi1t+Wni1nlnZDmoIfvvIzlm6DmraTlrZjmlL7nmoTmmK9Cb05vZGXlm77lvaJcclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhcmVudEJvTm9kZSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpLFxyXG4gICAgICAgICAgICAgICAgYm9Ob2RlSGVpZ2h0ID0gdG1wLmdldFNoYXBlKCkuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdQYXJlbnQgQk9bJyArIHRtcC5nZXREYXRhKCkubmFtZSArICddIHt5OiAnICsgdG1wLmdldExheW91dCgpLnkgKyAnLCBsZXZlbDogJyArIHRtcC5nZXRMYXlvdXQoKS5sZXZlbCArICcsIGJvTm9kZUhlaWdodDonICsgYm9Ob2RlSGVpZ2h0ICsgJ30gJyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJyAgICAqKipCZWZvcmUgdGhpcy5fbGV2ZWxNYXhQb3NbJyArIHRtcC5nZXRMYXlvdXQoKS5sZXZlbCArICddPScgKyB0aGlzLl9sZXZlbE1heFBvc1t0bXAuZ2V0TGF5b3V0KCkubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIC8v5aaC5p6c5piv6K+lTGV2ZWznrKzkuIDkuKroioLngrnvvIzmiJbogIXlvZPkvY7kuo7ljp/mnaXnmoToioLngrlcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9sZXZlbE1heFBvc1t0bXAuZ2V0TGF5b3V0KCkubGV2ZWxdLnkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsTWF4UG9zW3RtcC5nZXRMYXlvdXQoKS5sZXZlbF0ueSA8IHRtcC5nZXRMYXlvdXQoKS55ICsgYm9Ob2RlSGVpZ2h0ICsgQ29uc3QuQk9fTk9ERV9PRkZTRVRfWSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmdldExheW91dCgpLmxldmVsXS55ID0gdG1wLmdldExheW91dCgpLnkgKyBib05vZGVIZWlnaHQgKyBDb25zdC5CT19OT0RFX09GRlNFVF9ZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCcgICAgKioqQWZ0ZXIgdGhpcy5fbGV2ZWxNYXhQb3NbJyArIHRtcC5nZXRMYXlvdXQoKS5sZXZlbCArICddPScgKyB0aGlzLl9sZXZlbE1heFBvc1t0bXAuZ2V0TGF5b3V0KCkubGV2ZWxdKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0bXAuZ2V0RGF0YSgpLmNoaWxkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQm9BcnIgPSB0bXAuZ2V0RGF0YSgpLmNoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ250ID0gY2hpbGRCb0Fyci5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9Ob2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uTm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL+ivpWxldmVs5omA5pyJ5a2Q6IqC54K555qE6LW35aeLWeWdkOagh+mDveebuOWQjFxyXG4gICAgICAgICAgICAgICAgb3B0cy5zdGFydFBvcy55ID0gdGhpcy5fbGV2ZWxNYXhQb3NbdG1wLmdldExheW91dCgpLmxldmVsXS55O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5zdGFydFBvcy54ID0gY2hpbGRCb0FycltpXS5sYXlvdXQueDtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZEJvQXJyW2ldLmxheW91dC55ID0gb3B0cy5zdGFydFBvcy55O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvTm9kZSA9IG5ldyBCb05vZGUoY2hpbGRCb0FycltpXSwgb3B0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnQ2hpbGQgQk9bJyArIGJvTm9kZS5nZXREYXRhKCkubmFtZSArICddIHt5OiAnICsgb3B0cy5zdGFydFBvcy55ICsgJywgbGV2ZWw6ICcgKyBib05vZGUuZ2V0TGF5b3V0KCkubGV2ZWwgKyAnfSAnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cC5hZGQoYm9Ob2RlLmdldFNoYXBlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goYm9Ob2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9CT+WFs+ezu1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEJvQXJyW2ldLnJlbGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVsYXRpb25MZW4gPSBjaGlsZEJvQXJyW2ldLnJlbGF0aW9uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfcmVsYXRpb25MZW47IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUlkID0gY2hpbGRCb0FycltpXS5yZWxhdGlvbltqXS5zb3VyY2VJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IGNoaWxkQm9BcnJbaV0ucmVsYXRpb25bal0udGFyZ2V0SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVGV4dCA9IGNoaWxkQm9BcnJbaV0ucmVsYXRpb25bal0uc291cmNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUZXh0ID0gY2hpbGRCb0FycltpXS5yZWxhdGlvbltqXS50YXJnZXRUZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uTm9kZSA9IG5ldyBSZWxhdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib05vZGUuZ2V0U2hhcGUoKS5jaGlsZE9mTmFtZShzb3VyY2VJZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLmdldFNoYXBlKCkuY2hpbGRPZk5hbWUodGFyZ2V0SWQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuYWRkKHJlbGF0aW9uTm9kZS5nZXRTaGFwZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6K6+572u5b2T5YmNQk/kuLrnibnmrormoLflvI9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBib0lkLCBCT+agh+ivhlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlLCBCT+eJueauiuagt+W8jyzlj6/nqbpcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by5zZXRDdXJyZW50Qm8gPSBmdW5jdGlvbiAoYm9JZCwgc3R5bGUpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5ncm91cC5jaGlsZENvdW50KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ncm91cC5jaGlsZEF0KGkpLm5hbWUgPT0gYm9JZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cC5jaGlsZEF0KGkpLnNldEN1cnJlbnQoc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOa4heepulxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3pyLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcbiAgICAgICAgdGhpcy5fenIuYWRkKHRoaXMuZ3JvdXApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOe8qeaUvuWKn+iDvVxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Qcm90by56clNjYWxlID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJuYXJyb3dpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHpvb21EZWx0YSA9IDEgLyAxLjE7XHJcbiAgICAgICAgICAgICAgICB6b29tKHpvb21EZWx0YSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJlbmxhcmdlXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGEgPSAxLjE7XHJcbiAgICAgICAgICAgICAgICB6b29tKHpvb21EZWx0YSwgdGhpcy5fenIuZ2V0V2lkdGgoKSAvIDIsIHRoaXMuX3pyLmdldEhlaWdodCgpIC8gMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbignbW91c2V3aGVlbCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciB6b29tRGVsdGEgPSBlLndoZWVsRGVsdGEgPiAwID8gMS4xIDogMSAvIDEuMTtcclxuICAgICAgICAgICAgICAgIHpvb20oem9vbURlbHRhLCBlLm9mZnNldFgsIGUub2Zmc2V0WSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICA7XHJcbiAgICAgICAgZnVuY3Rpb24gem9vbSh6b29tRGVsdGEsIHpvb21YLCB6b29tWSkge1xyXG4gICAgICAgICAgICBpZiAodGhhdC5jYW5TY2FsZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGF0Lmdyb3VwO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGFyZ2V0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGFyZ2V0LnNjYWxlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1pvb20gPSB0aGF0Ll96b29tID0gdGhhdC5fem9vbSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgbmV3Wm9vbSAqPSB6b29tRGVsdGE7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9vbVNjYWxlID0gbmV3Wm9vbSAvIHRoYXQuX3pvb207XHJcbiAgICAgICAgICAgICAgICAvLyBpZihuZXdab29tPjIuNnx8bmV3Wm9vbTwwLjM4KXtcclxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAvLyB9O1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fem9vbSA9IG5ld1pvb207XHJcblxyXG4gICAgICAgICAgICAgICAgdGhhdC5ub3dab29tID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgdGhlIG1vdXNlIGNlbnRlciB3aGVuIHNjYWxpbmdcclxuICAgICAgICAgICAgICAgIHBvc1swXSAtPSAoem9vbVggLSBwb3NbMF0pICogKHpvb21TY2FsZSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcG9zWzFdIC09ICh6b29tWSAtIHBvc1sxXSkgKiAoem9vbVNjYWxlIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVswXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgICAgICAgICBzY2FsZVsxXSAqPSB6b29tU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuYXR0cihcInBvc2l0aW9uXCIsIFtwb3NbMF0sIHBvc1sxXV0pO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmF0dHIoXCJzY2FsZVwiLCBbc2NhbGVbMF0sIHNjYWxlWzFdXSk7XHJcbiAgICAgICAgICAgICAgICAvL3RoYXQubWluaW1hcC51cGRhdGVTZWxlY3Rpb25Qb3NpdGlvbihwb3Msem9vbVNjYWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmi5bmi71Hcm91cFxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmdyb3VwRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgdGhhdC5fenIub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgZ3JvdXBEcmFnRnVuY3Rpb24oZSk7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiBncm91cERyYWdGdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBlLmV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBlLmV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgICAgIHZhciBtb3ZlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZURyYWcoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5vd0dyb3VwUG9zaXRpb24gPSB0aGF0Lmdyb3VwLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblggPSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblkgPSB0aGF0Lmdyb3VwLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgYWxhcm1Qb3NpdGlvblgsIGFsYXJtUG9zaXRpb25ZO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbW92ZURyYWcoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhhdC5ncm91cC5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAqIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGF0Lmdyb3VwLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAqIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciBneCA9IHRoYXQuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkueCAqIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciBneSA9IHRoYXQuZ3JvdXAuZ2V0Qm91bmRpbmdSZWN0KCkueSAqIHRoYXQubm93Wm9vbTtcclxuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBbMTAgLSAod2lkdGggKyBneCksIDEwIC0gKGhlaWdodCArIGd5KV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gWyh0aGF0Ll96ci5nZXRXaWR0aCgpIC0gZ3gpIC0gMTAsICh0aGF0Ll96ci5nZXRIZWlnaHQoKSAtIGd5KSAtIDEwXTtcclxuICAgICAgICAgICAgICAgIHZhciBzWCA9IChlLmV2ZW50LmNsaWVudFggLSBzdGFydFgpICogKHRoYXQubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc1kgPSAoZS5ldmVudC5jbGllbnRZIC0gc3RhcnRZKSAqICh0aGF0Lm5vd1pvb20pO1xyXG4gICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblswXSA9IGdyb3VwUG9zaXRpb25YICsgKHNYKTtcclxuICAgICAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMV0gPSBncm91cFBvc2l0aW9uWSArIChzWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93R3JvdXBQb3NpdGlvblswXSA+IG1heFswXSB8fCBub3dHcm91cFBvc2l0aW9uWzFdID4gbWF4WzFdIHx8IG5vd0dyb3VwUG9zaXRpb25bMF0gPCBtaW5bMF0gfHwgbm93R3JvdXBQb3NpdGlvblsxXSA8IG1pblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5ncm91cC5hdHRyKFwicG9zaXRpb25cIiwgbm93R3JvdXBQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB2YXIgdXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlbmREcmFnKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlbmREcmFnKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2Vtb3ZlJywgbW92ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoYXQuX3pyLm9mZignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbignbW91c2V1cCcsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGF0Ll96ci5vbihcImdsb2JhbG91dFwiLCB1cEZ1bmN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5ouW5ou9XHJcbiAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb1Byb3RvLmRyYWcgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBub2RlLm9uKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzZHJhZ2dhYmxlID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JvdXBEcmFnRnVuY3Rpb24oZSk7XHJcbiAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiBncm91cERyYWdGdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFggPSBlLmV2ZW50LmNsaWVudFg7XHJcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSBlLmV2ZW50LmNsaWVudFk7XHJcbiAgICAgICAgICAgIHZhciBtb3ZlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgbW92ZURyYWcoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5vd0dyb3VwUG9zaXRpb24gPSBub2RlLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblggPSBub2RlLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBQb3NpdGlvblkgPSBub2RlLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB2YXIgYWxhcm1Qb3NpdGlvblgsIGFsYXJtUG9zaXRpb25ZO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5hbGFybSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld0FsYXJtUG9zaXRpb24gPSBub2RlLmFsYXJtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgYWxhcm1Qb3NpdGlvblggPSBub2RlLmFsYXJtLnBvc2l0aW9uWzBdO1xyXG4gICAgICAgICAgICAgICAgYWxhcm1Qb3NpdGlvblkgPSBub2RlLmFsYXJtLnBvc2l0aW9uWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgZnVuY3Rpb24gbW92ZURyYWcoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNYID0gKGUuZXZlbnQuY2xpZW50WCAtIHN0YXJ0WCkgLyAodGhhdC5ub3dab29tKTtcclxuICAgICAgICAgICAgICAgIHZhciBzWSA9IChlLmV2ZW50LmNsaWVudFkgLSBzdGFydFkpIC8gKHRoYXQubm93Wm9vbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQgJiYgbm9kZS5wYXJlbnQgaW5zdGFuY2VvZiBHcm91cE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL+aUvuWFpW5vZGXnjrDmnInmlbDlgLzvvIznlKjkuo7ph43nu5hncm91cFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlTWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUuc2hhcGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbm9kZS5zaGFwZS5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBub2RlLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlWFk6IFtub2RlLnNoYXBlLngsIG5vZGUuc2hhcGUueV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVQb3NpdGlvbjogW2dyb3VwUG9zaXRpb25YLCBncm91cFBvc2l0aW9uWV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYOiBzWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW92ZVk6IHNZXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBOb2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBOb2RlLnJlRHJhdyhub2RlTWVzc2FnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vd0dyb3VwUG9zaXRpb25bMF0gPSBncm91cFBvc2l0aW9uWCArIChzWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm93R3JvdXBQb3NpdGlvblsxXSA9IGdyb3VwUG9zaXRpb25ZICsgKHNZKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoXCJwb3NpdGlvblwiLCBub3dHcm91cFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5hbGFybSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3QWxhcm1Qb3NpdGlvbiA9IFtub3dHcm91cFBvc2l0aW9uWzBdICsgbm9kZS5nZXRCb3VuZGluZ1JlY3QoKS53aWR0aCAtIChub2RlLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoIC0gNiksIG5vd0dyb3VwUG9zaXRpb25bMV0gLSBub2RlLmFsYXJtLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCAtIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFsYXJtLmF0dHIoXCJwb3NpdGlvblwiLCBuZXdBbGFybVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIucmVmcmVzaExpbmVCeU5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB2YXIgdXBGdW5jdGlvbiA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBlbmREcmFnKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5ouW5ou957uT5p2fXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVuZERyYWcoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZW1vdmUnLCBtb3ZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhhdC5fenIub2ZmKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGF0Ll96ci5vZmYoXCJnbG9iYWxvdXRcIiwgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgICAgICAvL+W4g+WxgOmHjeaWsOiuoeeul1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5sYXlvdXROb2RlKFwidHJlZVwiLCB7XCJub2RlXCI6IG5vZGV9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmZvcmNlTGF5b3V0T3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhhdC5mb3JjZUxheW91dE9wdGlvbi5hbGxOb2RlcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoXy5pbmRleE9mKG5vZGVzLCBub2RlKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmxheW91dE5vZGUoXCJmb3JjZVwiLCB0aGlzLmZvcmNlTGF5b3V0T3B0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKCdtb3VzZXVwJywgdXBGdW5jdGlvbik7XHJcbiAgICAgICAgICAgIHRoYXQuX3pyLm9uKFwiZ2xvYmFsb3V0XCIsIHVwRnVuY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIC0tLS0tLS0tLeWvueWkluaatOmcsmZpc2hUb3BvQm8tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHZhciBpZEJhc2UgPSBuZXcgRGF0ZSgpIC0gMDtcclxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgIHZhciBET01fQVRUUklCVVRFX0tFWSA9ICdfZmlzaFRvcG9Cb19pbnN0YW5jZV8nO1xyXG4gICAgdmFyIGZpc2hUb3BvQm8gPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB2ZXJzaW9uOiAnMS4wLjAnLFxyXG4gICAgICAgIGRlcGVuZGVuY2llczoge1xyXG4gICAgICAgICAgICB6cmVuZGVyOiAnMy4wLjQnXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Cby5pbml0ID0gZnVuY3Rpb24gKGRvbSwgb3B0cykge1xyXG4gICAgICAgIGlmICghZG9tKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5pdGlhbGl6ZSBmYWlsZWQ6IGludmFsaWQgZG9tLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZVxyXG4gICAgICAgIHV0aWwuZGVmYXVsdHMob3B0cyxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJicG1uXCIsXHJcbiAgICAgICAgICAgICAgICBzaG93R3JpZExpbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBkZXZpY2VQaXhlbFJhdGlvOiAxLFxyXG4gICAgICAgICAgICAgICAgZ3JpZExpbmVTcGFjaW5nOjEwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB2YXIgZmlzaFRvcG9CbyA9IG5ldyBGaXNoVG9wb0JvKGRvbSwgb3B0cyk7XHJcbiAgICAgICAgZmlzaFRvcG9Cby5pbml0KCk7XHJcblxyXG4gICAgICAgIGZpc2hUb3BvQm8uaWQgPSAnZnRfJyArIGlkQmFzZSsrO1xyXG4gICAgICAgIGluc3RhbmNlc1tmaXNoVG9wb0JvLmlkXSA9IGZpc2hUb3BvQm87XHJcblxyXG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUgJiYgZG9tLnNldEF0dHJpYnV0ZShET01fQVRUUklCVVRFX0tFWSwgZmlzaFRvcG9Cby5pZCk7XHJcblxyXG4gICAgICAgIHJldHVybiBmaXNoVG9wb0JvO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gIHtIVE1MRG9tRWxlbWVudH0gZG9tXHJcbiAgICAgKiBAcmV0dXJuIHtmaXNoVG9wb31cclxuICAgICAqL1xyXG4gICAgZmlzaFRvcG9Cby5nZXRJbnN0YW5jZUJ5RG9tID0gZnVuY3Rpb24gKGRvbSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBkb20uZ2V0QXR0cmlidXRlKERPTV9BVFRSSUJVVEVfS0VZKTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2VzW2tleV07XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZSBhIGZpc2hUb3BvIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gIHttb2R1bGU6ZmlzaFRvcG98SFRNTERvbUVsZW1lbnR8c3RyaW5nfSBmaXNoVG9wb1xyXG4gICAgICovXHJcbiAgICBmaXNoVG9wb0JvLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY2hhcnQpIHtcclxuICAgICAgICB2YXIgdG9wbztcclxuICAgICAgICBpZiAoenJVdGlsLmlzRG9tKGNoYXJ0KSkge1xyXG4gICAgICAgICAgICB0b3BvID0gZmlzaFRvcG9Cby5nZXRJbnN0YW5jZUJ5RG9tKGNoYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoYXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0b3BvID0gaW5zdGFuY2VzW2NoYXJ0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCh0b3BvIGluc3RhbmNlb2YgZmlzaFRvcG9CbykgJiYgIXRvcG8uaXNEaXNwb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRvcG8uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmaXNoVG9wb0JvO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYm8vbGliL0Zpc2hUb3BvQm8uanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIFpSZW5kZXIsIGEgaGlnaCBwZXJmb3JtYW5jZSAyZCBkcmF3aW5nIGxpYnJhcnkuXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuICovXG4vLyBHbG9iYWwgZGVmaW5lc1xuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBlbnYgPSByZXF1aXJlKCcuL2NvcmUvZW52Jyk7XG5cbiAgICB2YXIgSGFuZGxlciA9IHJlcXVpcmUoJy4vSGFuZGxlcicpO1xuICAgIHZhciBTdG9yYWdlID0gcmVxdWlyZSgnLi9TdG9yYWdlJyk7XG4gICAgdmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uL0FuaW1hdGlvbicpO1xuXG4gICAgdmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xuXG4gICAgdmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgICAgICAgY2FudmFzOiByZXF1aXJlKCcuL1BhaW50ZXInKVxuICAgIH07XG5cbiAgICB2YXIgaW5zdGFuY2VzID0ge307ICAgIC8vIFpSZW5kZXLlrp7kvottYXDntKLlvJVcblxuICAgIHZhciB6cmVuZGVyID0ge307XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB6cmVuZGVyLnZlcnNpb24gPSAnMy4wLjQnO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMucmVuZGVyZXI9J2NhbnZhcyddICdjYW52YXMnIG9yICdzdmcnXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAgICAgKi9cbiAgICB6cmVuZGVyLmluaXQgPSBmdW5jdGlvbihkb20sIG9wdHMpIHtcbiAgICAgICAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICAgICAgICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gICAgICAgIHJldHVybiB6cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAqL1xuICAgIHpyZW5kZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICh6cikge1xuICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgIHpyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNba2V5XS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6cmVuZGVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiDojrflj5Z6cmVuZGVy5a6e5L6LXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFpSZW5kZXLlr7nosaHntKLlvJVcbiAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgICAqL1xuICAgIHpyZW5kZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlc1tpZF07XG4gICAgfTtcblxuICAgIHpyZW5kZXIucmVnaXN0ZXJQYWludGVyID0gZnVuY3Rpb24gKG5hbWUsIEN0b3IpIHtcbiAgICAgICAgcGFpbnRlckN0b3JzW25hbWVdID0gQ3RvcjtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZGVsSW5zdGFuY2UoaWQpIHtcbiAgICAgICAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvWlJlbmRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7SFRNTERvbUVsZW1lbnR9IGRvbVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy5kZXZpY2VQaXhlbFJhdGlvXVxuICAgICAqL1xuICAgIHZhciBaUmVuZGVyID0gZnVuY3Rpb24oaWQsIGRvbSwgb3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTERvbUVsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRvbSA9IGRvbTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdG9yYWdlID0gbmV3IFN0b3JhZ2UoKTtcblxuICAgICAgICB2YXIgcmVuZGVyZXJUeXBlID0gb3B0cy5yZW5kZXJlcjtcbiAgICAgICAgaWYgKHVzZVZNTCkge1xuICAgICAgICAgICAgaWYgKCFwYWludGVyQ3RvcnMudm1sKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byByZXF1aXJlIFxcJ3pyZW5kZXIvdm1sL3ZtbFxcJyB0byBzdXBwb3J0IElFOCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXJUeXBlID0gJ3ZtbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJlbmRlcmVyVHlwZSB8fCAhcGFpbnRlckN0b3JzW3JlbmRlcmVyVHlwZV0pIHtcbiAgICAgICAgICAgIHJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWludGVyID0gbmV3IHBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKGRvbSwgc3RvcmFnZSwgb3B0cyk7XG5cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgICAgICAgaWYgKCFlbnYubm9kZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyID0gbmV3IEhhbmRsZXIocGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKSwgc3RvcmFnZSwgcGFpbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oe1xuICAgICAgICAgICAgc3RhZ2U6IHtcbiAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX25lZWRzUmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoO1xuXG4gICAgICAgIC8vIOS/ruaUuSBzdG9yYWdlLmRlbEZyb21NYXAsIOavj+asoeWIoOmZpOWFg+e0oOS5i+WJjeWIoOmZpOWKqOeUu1xuICAgICAgICAvLyBGSVhNRSDmnInngrl1Z2x5XG4gICAgICAgIHZhciBvbGREZWxGcm9tTWFwID0gc3RvcmFnZS5kZWxGcm9tTWFwO1xuICAgICAgICB2YXIgb2xkQWRkVG9NYXAgPSBzdG9yYWdlLmFkZFRvTWFwO1xuXG4gICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcCA9IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzdG9yYWdlLmdldChlbElkKTtcblxuICAgICAgICAgICAgb2xkRGVsRnJvbU1hcC5jYWxsKHN0b3JhZ2UsIGVsSWQpO1xuXG4gICAgICAgICAgICBlbCAmJiBlbC5yZW1vdmVTZWxmRnJvbVpyKHNlbGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN0b3JhZ2UuYWRkVG9NYXAgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIG9sZEFkZFRvTWFwLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgICAgICAgICBlbC5hZGRTZWxmVG9acihzZWxmKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgWlJlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5blrp7kvovllK/kuIDmoIfor4ZcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlhYPntKBcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfG1vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5YWD57SgXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xtb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KGVsKTtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItumFjee9rumhuVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gekxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAqL1xuICAgICAgICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpMZXZlbCwgY29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIoekxldmVsLCBjb25maWcpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6KeG5Zu+5pu05pawXG4gICAgICAgICAqL1xuICAgICAgICByZWZyZXNoSW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIG5lZWRzUmVmcmVzaCBhaGVhZCB0byBhdm9pZCBzb21ldGhpbmcgd3JvbmcgaGFwcGVucyBpbiByZWZyZXNoXG4gICAgICAgICAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXZvaWQgdHJpZ2dlciB6ci5yZWZyZXNoIGluIEVsZW1lbnQjYmVmb3JlVXBkYXRlIGhvb2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOagh+iusOinhuWbvuWcqOa1j+iniOWZqOS4i+S4gOW4p+mcgOimgee7mOWItlxuICAgICAgICAgKi9cbiAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDosIPmlbTop4blm77lpKflsI9cbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50ZXIucmVzaXplKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIgJiYgdGhpcy5oYW5kbGVyLnJlc2l6ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLmiYDmnInliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bop4blm77lrr3luqZcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W6KeG5Zu+6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRIZWlnaHQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5YOP5a+85Ye6XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ10g6IOM5pmv6ImyXG4gICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30g5Zu+54mH55qEQmFzZTY0IHVybFxuICAgICAgICAgKi9cbiAgICAgICAgdG9EYXRhVVJMOiBmdW5jdGlvbih0eXBlLCBiYWNrZ3JvdW5kQ29sb3IsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhaW50ZXIudG9EYXRhVVJMKHR5cGUsIGJhY2tncm91bmRDb2xvciwgYXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWwhuW4uOinhHNoYXBl6L2s5oiQaW1hZ2Ugc2hhcGVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHBhdGhUb0ltYWdlOiBmdW5jdGlvbihlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBndWlkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWludGVyLnBhdGhUb0ltYWdlKGlkLCBlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u6buY6K6k55qEY3Vyc29yIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJzb3JTdHlsZSDkvovlpoIgY3Jvc3NoYWlyXG4gICAgICAgICAqL1xuICAgICAgICBzZXREZWZhdWx0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnNldERlZmF1bHRDdXJzb3JTdHlsZShjdXJzb3JTdHlsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6i+S7tue7keWumlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudEhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0g5ZON5bqU5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciAmJiB0aGlzLmhhbmRsZXIub24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bop6Pnu5HlrprvvIzlj4LmlbDkuLrnqbrliJnop6Pnu5HmiYDmnInoh6rlrprkuYnkuovku7ZcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7BcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIOWTjeW6lOWHveaVsFxuICAgICAgICAgKi9cbiAgICAgICAgb2ZmOiBmdW5jdGlvbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyICYmIHRoaXMuaGFuZGxlci5vZmYoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bop6blj5FcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSDkuovku7blkI3np7DvvIxyZXNpemXvvIxob3Zlcu+8jGRyYWfvvIxldGNcbiAgICAgICAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IGV2ZW50IGRvbeS6i+S7tuWvueixoVxuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciAmJiB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaTlvZPliY1aUmVuZGVy5LiL5omA5pyJ57G75Zu+55qE5pWw5o2u5ZKM5pi+56S677yMY2xlYXLlkI5NVkPlkozlt7Lnu5Hlrprkuovku7blnYfov5jlrZjlnKjlnKjvvIxaUmVuZGVy5Y+v55SoXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbFJvb3QoKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnRlci5jbGVhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDph4rmlL7lvZPliY1aUuWunuS+i++8iOWIoOmZpOWMheaLrGRvbe+8jOaVsOaNruOAgeaYvuekuuWSjOS6i+S7tue7keWumu+8ie+8jGRpc3Bvc2XlkI5aUuS4jeWPr+eUqFxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciAmJiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuICAgICAgICAgICAgdGhpcy5wYWludGVyID1cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRlbEluc3RhbmNlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0genJlbmRlcjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvenJlbmRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICogenJlbmRlcjog55Sf5oiQ5ZSv5LiAaWRcbiAqXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgICAgIHZhciBpZFN0YXJ0ID0gMHgwOTA3O1xuXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICd6cl8nICsgKGlkU3RhcnQrKyk7XG4gICAgICAgIH07XG4gICAgXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2d1aWQuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xuXG4gICAgdmFyIGVudiA9IHt9O1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBJbiBub2RlXG4gICAgICAgIGVudiA9IHtcbiAgICAgICAgICAgIGJyb3dzZXI6IHt9LFxuICAgICAgICAgICAgb3M6IHt9LFxuICAgICAgICAgICAgbm9kZTogdHJ1ZSxcbiAgICAgICAgICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudiA9IGRldGVjdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVudjtcblxuICAgIC8vIFplcHRvLmpzXG4gICAgLy8gKGMpIDIwMTAtMjAxMyBUaG9tYXMgRnVjaHNcbiAgICAvLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuICAgIGZ1bmN0aW9uIGRldGVjdCh1YSkge1xuICAgICAgICB2YXIgb3MgPSB7fTtcbiAgICAgICAgdmFyIGJyb3dzZXIgPSB7fTtcbiAgICAgICAgdmFyIHdlYmtpdCA9IHVhLm1hdGNoKC9XZWJba0tdaXRbXFwvXXswLDF9KFtcXGQuXSspLyk7XG4gICAgICAgIHZhciBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pO1xuICAgICAgICB2YXIgaXBhZCA9IHVhLm1hdGNoKC8oaVBhZCkuKk9TXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIHZhciBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKTtcbiAgICAgICAgdmFyIGlwaG9uZSA9ICFpcGFkICYmIHVhLm1hdGNoKC8oaVBob25lXFxzT1MpXFxzKFtcXGRfXSspLyk7XG4gICAgICAgIHZhciB3ZWJvcyA9IHVhLm1hdGNoKC8od2ViT1N8aHB3T1MpW1xcc1xcL10oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyk7XG4gICAgICAgIHZhciBraW5kbGUgPSB1YS5tYXRjaCgvS2luZGxlXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIHZhciBzaWxrID0gdWEubWF0Y2goL1NpbGtcXC8oW1xcZC5fXSspLyk7XG4gICAgICAgIHZhciBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAgICAgICB2YXIgYmIxMCA9IHVhLm1hdGNoKC8oQkIxMCkuKlZlcnNpb25cXC8oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIHJpbXRhYmxldG9zID0gdWEubWF0Y2goLyhSSU1cXHNUYWJsZXRcXHNPUylcXHMoW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyk7XG4gICAgICAgIHZhciBjaHJvbWUgPSB1YS5tYXRjaCgvQ2hyb21lXFwvKFtcXGQuXSspLykgfHwgdWEubWF0Y2goL0NyaU9TXFwvKFtcXGQuXSspLyk7XG4gICAgICAgIHZhciBmaXJlZm94ID0gdWEubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZC5dKykvKTtcbiAgICAgICAgdmFyIHNhZmFyaSA9IHdlYmtpdCAmJiB1YS5tYXRjaCgvTW9iaWxlXFwvLykgJiYgIWNocm9tZTtcbiAgICAgICAgdmFyIHdlYnZpZXcgPSB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pICYmICFjaHJvbWU7XG4gICAgICAgIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLylcbiAgICAgICAgICAgIC8vIElFIDExIFRyaWRlbnQvNy4wOyBydjoxMS4wXG4gICAgICAgICAgICB8fCB1YS5tYXRjaCgvVHJpZGVudFxcLy4rP3J2OigoW1xcZC5dKykpLyk7XG4gICAgICAgIHZhciBlZGdlID0gdWEubWF0Y2goL0VkZ2VcXC8oW1xcZC5dKykvKTsgLy8gSUUgMTIgYW5kIDEyK1xuXG4gICAgICAgIC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gICAgICAgIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gICAgICAgIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAgICAgICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAgICAgICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuXG4gICAgICAgIGlmIChicm93c2VyLndlYmtpdCA9ICEhd2Via2l0KSBicm93c2VyLnZlcnNpb24gPSB3ZWJraXRbMV07XG5cbiAgICAgICAgaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXTtcbiAgICAgICAgaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gICAgICAgIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgICBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsO1xuICAgICAgICBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdO1xuICAgICAgICBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXTtcbiAgICAgICAgaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXTtcbiAgICAgICAgaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXTtcbiAgICAgICAgaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZTtcbiAgICAgICAgaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXTtcbiAgICAgICAgaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV07XG4gICAgICAgIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlO1xuICAgICAgICBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXTtcbiAgICAgICAgaWYgKGZpcmVmb3gpIGJyb3dzZXIuZmlyZWZveCA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV07XG4gICAgICAgIGlmIChpZSkgYnJvd3Nlci5pZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdO1xuICAgICAgICBpZiAoc2FmYXJpICYmICh1YS5tYXRjaCgvU2FmYXJpLykgfHwgISFvcy5pb3MpKSBicm93c2VyLnNhZmFyaSA9IHRydWU7XG4gICAgICAgIGlmICh3ZWJ2aWV3KSBicm93c2VyLndlYnZpZXcgPSB0cnVlO1xuICAgICAgICBpZiAoaWUpIGJyb3dzZXIuaWUgPSB0cnVlLCBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgICAgICAgaWYgKGVkZ2UpIGJyb3dzZXIuZWRnZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGVkZ2VbMV07XG5cbiAgICAgICAgb3MudGFibGV0ID0gISEoaXBhZCB8fCBwbGF5Ym9vayB8fCAoYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pKSB8fFxuICAgICAgICAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL1RhYmxldC8pKSB8fCAoaWUgJiYgIXVhLm1hdGNoKC9QaG9uZS8pICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSk7XG4gICAgICAgIG9zLnBob25lICA9ICEhKCFvcy50YWJsZXQgJiYgIW9zLmlwb2QgJiYgKGFuZHJvaWQgfHwgaXBob25lIHx8IHdlYm9zIHx8IGJsYWNrYmVycnkgfHwgYmIxMCB8fFxuICAgICAgICAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxuICAgICAgICAgICAgKGZpcmVmb3ggJiYgdWEubWF0Y2goL01vYmlsZS8pKSB8fCAoaWUgJiYgdWEubWF0Y2goL1RvdWNoLykpKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICBvczogb3MsXG4gICAgICAgICAgICBub2RlOiBmYWxzZSxcbiAgICAgICAgICAgIC8vIOWOn+eUn2NhbnZhc+aUr+aMge+8jOaUueaegeerr+eCueS6hlxuICAgICAgICAgICAgLy8gY2FudmFzU3VwcG9ydGVkIDogIShicm93c2VyLmllICYmIHBhcnNlRmxvYXQoYnJvd3Nlci52ZXJzaW9uKSA8IDkpXG4gICAgICAgICAgICBjYW52YXNTdXBwb3J0ZWQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0ID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgLy8gQHNlZSA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80ODE3MDI5L3doYXRzLXRoZS1iZXN0LXdheS10by1kZXRlY3QtYS10b3VjaC1zY3JlZW4tZGV2aWNlLXVzaW5nLWphdmFzY3JpcHQ+XG4gICAgICAgICAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBJRTEwLzExIGRvZXMgbm90IHN1cHBvcnQgdG91Y2ggZXZlbnQsIGFuZCBNUyBFZGdlIHN1cHBvcnRzIHRoZW0gYnV0IG5vdCBieVxuICAgICAgICAgICAgLy8gZGVmYXVsdCwgc28gd2UgZG9udCBjaGVjayBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgZm9yIHRoZW0gaGVyZS5cbiAgICAgICAgICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAgICAgICAgIC8vIDxodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1wb2ludGVyJTIwZXZlbnQ+LlxuICAgICAgICAgICAgcG9pbnRlckV2ZW50c1N1cHBvcnRlZDogJ29ucG9pbnRlcmRvd24nIGluIHdpbmRvd1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggc3VwcG9ydHMgcG9pbnRlciBidXQgbm90IGJ5IGRlZmF1bHQsXG4gICAgICAgICAgICAgICAgLy8gb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlciBldmVudHMgY3VycmVudGx5LlxuICAgICAgICAgICAgICAgICYmIChicm93c2VyLmVkZ2UgfHwgKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci52ZXJzaW9uID49IDEwKSlcbiAgICAgICAgfTtcbiAgICB9XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Vudi5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogSGFuZGxlcuaOp+WItuaooeWdl1xuICogQG1vZHVsZSB6cmVuZGVyL0hhbmRsZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChzaGVueWkuOTE0QGdtYWlsLmNvbSlcbiAqL1xuXG5cbiAgICB2YXIgZW52ID0gcmVxdWlyZSgnLi9jb3JlL2VudicpO1xuICAgIHZhciBldmVudFRvb2wgPSByZXF1aXJlKCcuL2NvcmUvZXZlbnQnKTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG4gICAgdmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vRHJhZ2dhYmxlJyk7XG4gICAgdmFyIEdlc3R1cmVNZ3IgPSByZXF1aXJlKCcuL2NvcmUvR2VzdHVyZU1ncicpO1xuXG4gICAgdmFyIEV2ZW50ZnVsID0gcmVxdWlyZSgnLi9taXhpbi9FdmVudGZ1bCcpO1xuXG4gICAgdmFyIG1vdXNlSGFuZGxlck5hbWVzID0gW1xuICAgICAgICAnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V3aGVlbCcsICdtb3VzZW91dCdcbiAgICBdO1xuICAgICF1c2VQb2ludGVyRXZlbnQoKSAmJiBtb3VzZUhhbmRsZXJOYW1lcy5wdXNoKFxuICAgICAgICAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJ1xuICAgICk7XG5cbiAgICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZSdcbiAgICBdO1xuXG4gICAgdmFyIHBvaW50ZXJIYW5kbGVyTmFtZXMgPSBbXG4gICAgICAgICdwb2ludGVyZG93bicsICdwb2ludGVydXAnLCAncG9pbnRlcm1vdmUnXG4gICAgXTtcblxuICAgIHZhciBUT1VDSF9DTElDS19ERUxBWSA9IDMwMDtcblxuICAgIC8vIHRvdWNo5oyH5bCW6ZSZ6KeJ55qE5bCd6K+V5YGP56e76YeP6YWN572uXG4gICAgLy8gdmFyIE1PQklMRV9UT1VDSF9PRkZTRVRTID0gW1xuICAgIC8vICAgICB7IHg6IDEwIH0sXG4gICAgLy8gICAgIHsgeDogLTIwIH0sXG4gICAgLy8gICAgIHsgeDogMTAsIHk6IDEwIH0sXG4gICAgLy8gICAgIHsgeTogLTIwIH1cbiAgICAvLyBdO1xuXG4gICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBldmVudFRvb2wuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV2ZW50VG9vbC5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIHZhciBub3JtYWxpemVFdmVudCA9IGV2ZW50VG9vbC5ub3JtYWxpemVFdmVudDtcblxuICAgIGZ1bmN0aW9uIG1ha2VFdmVudFBhY2tldChldmVUeXBlLCB0YXJnZXQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBldmVUeXBlLFxuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICBjYW5jZWxCdWJibGU6IGZhbHNlLFxuICAgICAgICAgICAgb2Zmc2V0WDogZXZlbnQuenJYLFxuICAgICAgICAgICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgICAgICAgICAgZ2VzdHVyZUV2ZW50OiBldmVudC5nZXN0dXJlRXZlbnQsXG4gICAgICAgICAgICBwaW5jaFg6IGV2ZW50LnBpbmNoWCxcbiAgICAgICAgICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgICAgICAgICAgcGluY2hTY2FsZTogZXZlbnQucGluY2hTY2FsZSxcbiAgICAgICAgICAgIHdoZWVsRGVsdGE6IGV2ZW50LnpyRGVsdGFcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZG9tSGFuZGxlcnMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXJcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLnJvb3QsIGV2ZW50KTtcblxuICAgICAgICAgICAgdmFyIHggPSBldmVudC56clg7XG4gICAgICAgICAgICB2YXIgeSA9IGV2ZW50LnpyWTtcblxuICAgICAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmZpbmRIb3Zlcih4LCB5LCBudWxsKTtcbiAgICAgICAgICAgIHZhciBsYXN0SG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQ7XG5cbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcmVkO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3Quc3R5bGUuY3Vyc29yID0gaG92ZXJlZCA/IGhvdmVyZWQuY3Vyc29yIDogdGhpcy5fZGVmYXVsdEN1cnNvclN0eWxlO1xuICAgICAgICAgICAgLy8gTW91c2Ugb3V0IG9uIHByZXZpb3VzIGhvdmVyZWQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGxhc3RIb3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkICYmIGxhc3RIb3ZlcmVkLl9fenIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb3h5KGxhc3RIb3ZlcmVkLCAnbW91c2VvdXQnLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm94eShob3ZlcmVkLCAnbW91c2Vtb3ZlJywgZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBvdmVyIG9uIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChob3ZlcmVkICYmIGhvdmVyZWQgIT09IGxhc3RIb3ZlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm94eShob3ZlcmVkLCAnbW91c2VvdmVyJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3VzZSBvdXQgaGFuZGxlclxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5yb290LCBldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnQudG9FbGVtZW50IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAhPSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b+955Wl5YyF5ZCr5Zyocm9vdOS4reeahGRvbeW8lei1t+eahG1vdXNlT3V0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSB0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb3h5KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdnbG9iYWxvdXQnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVG91Y2jlvIDlp4vlk43lupTlh73mlbBcbiAgICAgICAgICogQGlubmVyXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyDnp7vliqjnq6/lj6/og73pnIDopoFkZWZhdWx06KGM5Li677yM5L6L5aaC6Z2Z5oCB5Zu+6KGo5pe244CCXG4gICAgICAgICAgICAvLyBldmVudFRvb2wuc3RvcChldmVudCk7Ly8g6Zi75q2i5rWP6KeI5Zmo6buY6K6k5LqL5Lu277yM6YeN6KaBXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMucm9vdCwgZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ3N0YXJ0Jyk7XG5cbiAgICAgICAgICAgIC8vIOW5s+adv+ihpeWFheS4gOasoWZpbmRIb3ZlclxuICAgICAgICAgICAgLy8gdGhpcy5fbW9iaWxlRmluZEZpeGVkKGV2ZW50KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgbW91c2Vtb3ZlIGFuZCBtb3VzZWRvd25cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOenu+WKqOWTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBldmVudFRvb2wuc3RvcChldmVudCk7Ly8g6Zi75q2i5rWP6KeI5Zmo6buY6K6k5LqL5Lu277yM6YeN6KaBXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMucm9vdCwgZXZlbnQpO1xuXG4gICAgICAgICAgICBwcm9jZXNzR2VzdHVyZSh0aGlzLCBldmVudCwgJ2NoYW5nZScpO1xuXG4gICAgICAgICAgICAvLyBNb3VzZSBtb3ZlIHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LCBiZWNhdXNlIG1vdXNlIG1vdmUgYW5kIHBpbmNoIG1heVxuICAgICAgICAgICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAgICAgZG9tSGFuZGxlcnMubW91c2Vtb3ZlLmNhbGwodGhpcywgZXZlbnQpO1xuXG4gICAgICAgICAgICBzZXRUb3VjaFRpbWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb3VjaOe7k+adn+WTjeW6lOWHveaVsFxuICAgICAgICAgKiBAaW5uZXJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGV2ZW50VG9vbC5zdG9wKGV2ZW50KTsvLyDpmLvmraLmtY/op4jlmajpu5jorqTkuovku7bvvIzph43opoFcbiAgICAgICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5yb290LCBldmVudCk7XG5cbiAgICAgICAgICAgIHByb2Nlc3NHZXN0dXJlKHRoaXMsIGV2ZW50LCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGRvbUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAgICAgICAgIC8vIGNsaWNrIGV2ZW50IHNob3VsZCBhbHdheXMgYmUgdHJpZ2dlcmVkIG5vIG1hdHRlciB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBnZXN0cnVlIGV2ZW50LiBTeXN0ZW0gY2xpY2sgY2FuIG5vdCBiZSBwcmV2ZW50ZWQuXG4gICAgICAgICAgICBpZiAoK25ldyBEYXRlKCkgLSB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPCBUT1VDSF9DTElDS19ERUxBWSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX21vYmlsZUZpbmRGaXhlZChldmVudCk7XG4gICAgICAgICAgICAgICAgZG9tSGFuZGxlcnMuY2xpY2suY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldFRvdWNoVGltZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ29tbW9uIGhhbmRsZXJzXG4gICAgdXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnbW91c2V3aGVlbCcsICdkYmxjbGljayddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLnJvb3QsIGV2ZW50KTtcbiAgICAgICAgICAgIC8vIEZpbmQgaG92ZXIgYWdhaW4gdG8gYXZvaWQgY2xpY2sgZXZlbnQgaXMgZGlzcGF0Y2hlZCBtYW51YWxseS4gT3IgY2xpY2sgaXMgdHJpZ2dlcmVkIHdpdGhvdXQgbW91c2VvdmVyXG4gICAgICAgICAgICB2YXIgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKGV2ZW50LnpyWCwgZXZlbnQuenJZLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJveHkoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gUG9pbnRlciBldmVudCBoYW5kbGVyc1xuICAgIC8vIHV0aWwuZWFjaChbJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCddLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vICAgICBkb21IYW5kbGVyc1tuYW1lXSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vICAgICAgICAgdmFyIG1vdXNlTmFtZSA9IG5hbWUucmVwbGFjZSgncG9pbnRlcicsICdtb3VzZScpO1xuICAgIC8vICAgICAgICAgZG9tSGFuZGxlcnNbbW91c2VOYW1lXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAvLyAgICAgfTtcbiAgICAvLyB9KTtcblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NHZXN0dXJlKHpySGFuZGxlciwgZXZlbnQsIHN0YWdlKSB7XG4gICAgICAgIHZhciBnZXN0dXJlTWdyID0genJIYW5kbGVyLl9nZXN0dXJlTWdyO1xuXG4gICAgICAgIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcblxuICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSBnZXN0dXJlTWdyLnJlY29nbml6ZShcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgenJIYW5kbGVyLmZpbmRIb3ZlcihldmVudC56clgsIGV2ZW50LnpyWSwgbnVsbClcbiAgICAgICAgKTtcblxuICAgICAgICBzdGFnZSA9PT0gJ2VuZCcgJiYgZ2VzdHVyZU1nci5jbGVhcigpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgLy8gZXZlbnRUb29sLnN0b3AoZXZlbnQpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXN0dXJlSW5mby50eXBlO1xuICAgICAgICAgICAgZXZlbnQuZ2VzdHVyZUV2ZW50ID0gdHlwZTtcblxuICAgICAgICAgICAgenJIYW5kbGVyLl9kaXNwYXRjaFByb3h5KGdlc3R1cmVJbmZvLnRhcmdldCwgdHlwZSwgZ2VzdHVyZUluZm8uZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5Li65o6n5Yi257G75a6e5L6L5Yid5aeL5YyWZG9tIOS6i+S7tuWkhOeQhuWHveaVsFxuICAgICAqXG4gICAgICogQGlubmVyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9IYW5kbGVyfSBpbnN0YW5jZSDmjqfliLbnsbvlrp7kvotcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0RG9tSGFuZGxlcihpbnN0YW5jZSkge1xuICAgICAgICB2YXIgaGFuZGxlck5hbWVzID0gdG91Y2hIYW5kbGVyTmFtZXMuY29uY2F0KHBvaW50ZXJIYW5kbGVyTmFtZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBoYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSB1dGlsLmJpbmQoZG9tSGFuZGxlcnNbbmFtZV0sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW91c2VIYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbW91c2VIYW5kbGVyTmFtZXNbaV07XG4gICAgICAgICAgICBpbnN0YW5jZS5faGFuZGxlcnNbbmFtZV0gPSBtYWtlTW91c2VIYW5kbGVyKGRvbUhhbmRsZXJzW25hbWVdLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYWtlTW91c2VIYW5kbGVyKGZuLCBpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuX3RvdWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IE1haW4gSFRNTCBlbGVtZW50IGZvciBwYWludGluZy5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXIgUGFpbnRlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICB2YXIgSGFuZGxlciA9IGZ1bmN0aW9uKHJvb3QsIHN0b3JhZ2UsIHBhaW50ZXIpIHtcbiAgICAgICAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnBhaW50ZXIgPSBwYWludGVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvdmVyZWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtEYXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFg7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0WTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2RlZmF1bHRDdXJzb3JTdHlsZSA9ICdkZWZhdWx0JztcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvR2VzdHVyZU1ncn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dlc3R1cmVNZ3IgPSBuZXcgR2VzdHVyZU1ncigpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdG91Y2hpbmcgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdWNoVGltZXI7XG5cbiAgICAgICAgaW5pdERvbUhhbmRsZXIodGhpcyk7XG5cbiAgICAgICAgaWYgKHVzZVBvaW50ZXJFdmVudCgpKSB7XG4gICAgICAgICAgICBtb3VudEhhbmRsZXJzKHBvaW50ZXJIYW5kbGVyTmFtZXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVzZVRvdWNoRXZlbnQoKSkge1xuICAgICAgICAgICAgbW91bnRIYW5kbGVycyh0b3VjaEhhbmRsZXJOYW1lcywgdGhpcyk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZXIgb2YgJ21vdXNlb3V0JyBldmVudCBpcyBuZWVkZWQgaW4gdG91Y2ggbW9kZSwgd2hpY2ggd2lsbCBiZSBtb3VudGVkIGJlbG93LlxuICAgICAgICAgICAgLy8gYWRkRXZlbnRMaXN0ZW5lcihyb290LCAnbW91c2VvdXQnLCB0aGlzLl9tb3VzZW91dEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uc2lkZXJpbmcgc29tZSBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIGV2ZW50IChsaWtlIE1TIFN1cmZhY2VcbiAgICAgICAgLy8gYW5kIGxlbm92byBYMjQwLCBAc2VlICMyMzUwKSwgd2UgbWFrZSBtb3VzZSBldmVudCBiZSBhbHdheXMgbGlzdGVuZWQsIG90aGVyd2lzZVxuICAgICAgICAvLyBtb3VzZSBldmVudCBjYW4gbm90IGJlIGhhbmRsZSBpbiB0aG9zZSBkZXZpY2VzLlxuICAgICAgICBtb3VudEhhbmRsZXJzKG1vdXNlSGFuZGxlck5hbWVzLCB0aGlzKTtcblxuICAgICAgICBEcmFnZ2FibGUuY2FsbCh0aGlzKTtcblxuICAgICAgICBmdW5jdGlvbiBtb3VudEhhbmRsZXJzKGhhbmRsZXJOYW1lcywgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHV0aWwuZWFjaChoYW5kbGVyTmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihyb290LCBldmVudE5hbWVGaXgobmFtZSksIGluc3RhbmNlLl9oYW5kbGVyc1tuYW1lXSk7XG4gICAgICAgICAgICB9LCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSGFuZGxlci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2l6ZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hvdmVyZWQgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwYXRjaCBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICAgICAgICovXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50QXJncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3Bvc2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290O1xuXG4gICAgICAgICAgICB2YXIgaGFuZGxlck5hbWVzID0gbW91c2VIYW5kbGVyTmFtZXMuY29uY2F0KHRvdWNoSGFuZGxlck5hbWVzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGhhbmRsZXJOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHJvb3QsIGV2ZW50TmFtZUZpeChuYW1lKSwgdGhpcy5faGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJvb3QgPVxuICAgICAgICAgICAgdGhpcy5zdG9yYWdlID1cbiAgICAgICAgICAgIHRoaXMucGFpbnRlciA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3Vyc29yU3R5bGUg5L6L5aaCIGNyb3NzaGFpclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGVmYXVsdEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRDdXJzb3JTdHlsZSA9IGN1cnNvclN0eWxlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuovku7bliIblj5Hku6PnkIZcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldEVsIOebruagh+WbvuW9ouWFg+e0oFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAgICAgICAqL1xuICAgICAgICBfZGlzcGF0Y2hQcm94eTogZnVuY3Rpb24gKHRhcmdldEVsLCBldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICAgICAgICAgIHZhciBldmVudFBhY2tldCA9IG1ha2VFdmVudFBhY2tldChldmVudE5hbWUsIHRhcmdldEVsLCBldmVudCk7XG5cbiAgICAgICAgICAgIHZhciBlbCA9IHRhcmdldEVsO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICBlbFtldmVudEhhbmRsZXJdXG4gICAgICAgICAgICAgICAgICAgICYmIChldmVudFBhY2tldC5jYW5jZWxCdWJibGUgPSBlbFtldmVudEhhbmRsZXJdLmNhbGwoZWwsIGV2ZW50UGFja2V0KSk7XG5cbiAgICAgICAgICAgICAgICBlbC50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuXG4gICAgICAgICAgICAgICAgZWwgPSBlbC5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRQYWNrZXQuY2FuY2VsQnViYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFldmVudFBhY2tldC5jYW5jZWxCdWJibGUpIHtcbiAgICAgICAgICAgICAgICAvLyDlhpLms6HliLDpobbnuqcgenJlbmRlciDlr7nosaFcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8g5YiG5Y+R5LqL5Lu25Yiw55So5oi36Ieq5a6a5LmJ5bGCXG4gICAgICAgICAgICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG4gICAgICAgICAgICAgICAgdGhpcy5wYWludGVyICYmIHRoaXMucGFpbnRlci5lYWNoT3RoZXJMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZihsYXllcltldmVudEhhbmRsZXJdKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcltldmVudEhhbmRsZXJdLmNhbGwobGF5ZXIsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50UGFja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGV9IGV4Y2x1ZGVcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKi9cbiAgICAgICAgZmluZEhvdmVyOiBmdW5jdGlvbih4LCB5LCBleGNsdWRlKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0W2ldLnNpbGVudFxuICAgICAgICAgICAgICAgICAmJiBsaXN0W2ldICE9PSBleGNsdWRlXG4gICAgICAgICAgICAgICAgIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgICAgICAgICAgICAmJiAhbGlzdFtpXS5pZ25vcmVcbiAgICAgICAgICAgICAgICAgJiYgaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNIb3ZlcihkaXNwbGF5YWJsZSwgeCwgeSkge1xuICAgICAgICBpZiAoZGlzcGxheWFibGVbZGlzcGxheWFibGUucmVjdEhvdmVyID8gJ3JlY3RDb250YWluJyA6ICdjb250YWluJ10oeCwgeSkpIHtcbiAgICAgICAgICAgIHZhciBwID0gZGlzcGxheWFibGUucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocC5jbGlwUGF0aCAmJiAhcC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSAge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwcGVkIGJ5IHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gYmVpbmcgZGlzcGF0Y2hlZCBhZnRlciBUb3VjaCBFdmVudHMgYWN0aW9uXG4gICAgICogQHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlbHRha29zaC9oYW5kanMvYmxvYi9tYXN0ZXIvc3JjL2hhbmQuYmFzZS5qcz5cbiAgICAgKiAxLiBNb2JpbGUgYnJvd3NlcnMgZGlzcGF0Y2ggbW91c2UgZXZlbnRzIDMwMG1zIGFmdGVyIHRvdWNoZW5kLlxuICAgICAqIDIuIENocm9tZSBmb3IgQW5kcm9pZCBkaXNwYXRjaCBtb3VzZWRvd24gZm9yIGxvbmctdG91Y2ggYWJvdXQgNjUwbXNcbiAgICAgKiBSZXN1bHQ6IEJsb2NraW5nIE1vdXNlIEV2ZW50cyBmb3IgNzAwbXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0VG91Y2hUaW1lcihpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS5fdG91Y2hpbmcgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoaW5zdGFuY2UuX3RvdWNoVGltZXIpO1xuICAgICAgICBpbnN0YW5jZS5fdG91Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuX3RvdWNoaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIDcwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWx0aG91Z2h0IE1TIFN1cmZhY2Ugc3VwcG9ydCBzY3JlZW4gdG91Y2gsIElFMTAvMTEgZG8gbm90IHN1cHBvcnRcbiAgICAgKiB0b3VjaCBldmVudCBhbmQgTVMgRWRnZSBzdXBwb3J0ZWQgdGhlbSBidXQgbm90IGJ5IGRlZmF1bHQgKGJ1dCBjaHJvbWVcbiAgICAgKiBhbmQgZmlyZWZveCBkbykuIFRodXMgd2UgdXNlIFBvaW50ZXIgZXZlbnQgb24gTVMgYnJvd3NlcnMgdG8gaGFuZGxlIHRvdWNoLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVzZVBvaW50ZXJFdmVudCgpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBwb2ludGVybW92ZSBldmVudCBkb250IHRyaWdnZXIgd2hlbiB1c2luZyBmaW5nZXIuXG4gICAgICAgIC8vIFdlIG1heSBmaWdnZXIgaXQgb3V0IGxhdHRlci5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyByZXR1cm4gZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIEluIG5vLXRvdWNoIGRldmljZSB3ZSBkb250IHVzZSBwb2ludGVyIGV2bmV0cyBidXQganVzdFxuICAgICAgICAgICAgLy8gdXNlIG1vdXNlIGV2ZW50IGZvciBhdm9pZGluZyBwcm9ibGVtcy5cbiAgICAgICAgICAgIC8vICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXNlVG91Y2hFdmVudCgpIHtcbiAgICAgICAgcmV0dXJuIGVudi50b3VjaEV2ZW50c1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBldmVudE5hbWVGaXgobmFtZSkge1xuICAgICAgICByZXR1cm4gKG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94KSA/ICdET01Nb3VzZVNjcm9sbCcgOiBuYW1lO1xuICAgIH1cblxuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRXZlbnRmdWwpO1xuICAgIHV0aWwubWl4aW4oSGFuZGxlciwgRHJhZ2dhYmxlKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL0hhbmRsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOS6i+S7tui+heWKqeexu1xuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvZXZlbnRcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICovXG5cblxuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4uL21peGluL0V2ZW50ZnVsJyk7XG5cbiAgICB2YXIgaXNEb21MZXZlbDIgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpICYmICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXI7XG5cbiAgICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdFxuICAgICAgICByZXR1cm4gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7IGxlZnQ6IDAsIHRvcDogMH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOWmguaenOWtmOWcqOesrOS4ieaWueW1jOWFpeeahOS4gOS6m2RvbeinpuWPkeeahOS6i+S7tu+8jOaIlnRvdWNo5LqL5Lu277yM6ZyA6KaB6L2s5o2i5LiA5LiL5LqL5Lu25Z2Q5qCHXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUpIHtcblxuICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGUudHlwZTtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSBldmVudFR5cGUgJiYgZXZlbnRUeXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMDtcblxuICAgICAgICBpZiAoIWlzVG91Y2gpIHtcbiAgICAgICAgICAgIHZhciBib3ggPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuICAgICAgICAgICAgZS56clggPSBlLmNsaWVudFggLSBib3gubGVmdDtcbiAgICAgICAgICAgIGUuenJZID0gZS5jbGllbnRZIC0gYm94LnRvcDtcbiAgICAgICAgICAgIGUuenJEZWx0YSA9IChlLndoZWVsRGVsdGEpID8gZS53aGVlbERlbHRhIC8gMTIwIDogLShlLmRldGFpbCB8fCAwKSAvIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT0gJ3RvdWNoZW5kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZS50YXJnZXRUb3VjaGVzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgaWYgKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJCb3VuZGluZyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCk7XG4gICAgICAgICAgICAgICAgLy8gdG91Y2jkuovku7blnZDmoIfmmK/lhajlsY/nmoR+XG4gICAgICAgICAgICAgICAgZS56clggPSB0b3VjaC5jbGllbnRYIC0gckJvdW5kaW5nLmxlZnQ7XG4gICAgICAgICAgICAgICAgZS56clkgPSB0b3VjaC5jbGllbnRZIC0gckJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGlzRG9tTGV2ZWwyKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgbmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDlgZzmraLlhpLms6HlkozpmLvmraLpu5jorqTooYzkuLpcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9ldmVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIDogZXZlbnTlr7nosaFcbiAgICAgKi9cbiAgICB2YXIgc3RvcCA9IGlzRG9tTGV2ZWwyXG4gICAgICAgID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50OiBub3JtYWxpemVFdmVudCxcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lcixcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lcixcblxuICAgICAgICBzdG9wOiBzdG9wLFxuICAgICAgICAvLyDlgZrlkJHkuIrlhbzlrrlcbiAgICAgICAgRGlzcGF0Y2hlcjogRXZlbnRmdWxcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDkuovku7bmianlsZVcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9FdmVudGZ1bFxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgYXJyeVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaW5kZXhPZiA9IHpyVXRpbC5pbmRleE9mO1xuXG4gICAgLyoqXG4gICAgICog5LqL5Lu25YiG5Y+R5ZmoXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIEV2ZW50ZnVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgICB9O1xuXG4gICAgRXZlbnRmdWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBFdmVudGZ1bCxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Y2V5qyh6Kem5Y+R57uR5a6a77yMdHJpZ2dlcuWQjumUgOavgVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5ZON5bqU5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBvbmU6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIgfHwgIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2hbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleE9mKF9oW2V2ZW50XSwgZXZlbnQpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2hbZXZlbnRdLnB1c2goe1xuICAgICAgICAgICAgICAgIGg6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe7keWumuS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQg5LqL5Lu25ZCNXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIg5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICAgICAgICovXG4gICAgICAgIG9uOiBmdW5jdGlvbiAoZXZlbnQsIGhhbmRsZXIsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIV9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIF9oW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaFtldmVudF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgaDogaGFuZGxlcixcbiAgICAgICAgICAgICAgICBvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN0eDogY29udGV4dCB8fCB0aGlzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaYr+WQpue7keWumuS6huS6i+S7tlxuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaXNTaWxlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuICAgICAgICAgICAgcmV0dXJuIF9oW2V2ZW50XSAmJiBfaFtldmVudF0ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDop6Pnu5Hkuovku7ZcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IOS6i+S7tuWQjVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0g5LqL5Lu25aSE55CG5Ye95pWwXG4gICAgICAgICAqL1xuICAgICAgICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzO1xuXG4gICAgICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fJGhhbmRsZXJzID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9oW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaFtldmVudF1baV1bJ2gnXSAhPSBoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5wdXNoKF9oW2V2ZW50XVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2hbZXZlbnRdID0gbmV3TGlzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2hbZXZlbnRdICYmIF9oW2V2ZW50XS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9oW2V2ZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5LqL5Lu25YiG5Y+RXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl8kaGFuZGxlcnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMykge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJyeVNsaWNlLmNhbGwoYXJncywgMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKF9oW2ldWydjdHgnXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShfaFtpXVsnY3R4J10sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDluKbmnIljb250ZXh055qE5LqL5Lu25YiG5Y+RLCDmnIDlkI7kuIDkuKrlj4LmlbDmmK/kuovku7blm57osIPnmoRjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIOS6i+S7tuexu+Wei1xuICAgICAgICAgKi9cbiAgICAgICAgdHJpZ2dlcldpdGhDb250ZXh0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuXyRoYW5kbGVyc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxLCBhcmdzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYXJnTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgbW9yZSB0aGFuIDIgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hbaV1bJ2gnXS5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9oW2ldWydvbmUnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVuLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIOWvueixoeWPr+S7pemAmui/hyBvbnh4eHgg57uR5a6a5LqL5Lu2XG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uY2xpY2tcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdXRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNlbW92ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2V3aGVlbFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vkb3duXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnc3RhcnRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbmRcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdlbnRlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2xlYXZlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnb3ZlclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJvcFxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50ZnVsO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9taXhpbi9FdmVudGZ1bC5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICovXG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuLi9ncmFwaGljL0dyYWRpZW50Jyk7XG4gICAgLy8g55So5LqO5aSE55CGbWVyZ2Xml7bml6Dms5XpgY3ljoZEYXRl562J5a+56LGh55qE6Zeu6aKYXG4gICAgdmFyIEJVSUxUSU5fT0JKRUNUID0ge1xuICAgICAgICAnW29iamVjdCBGdW5jdGlvbl0nOiAxLFxuICAgICAgICAnW29iamVjdCBSZWdFeHBdJzogMSxcbiAgICAgICAgJ1tvYmplY3QgRGF0ZV0nOiAxLFxuICAgICAgICAnW29iamVjdCBFcnJvcl0nOiAxLFxuICAgICAgICAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nOiAxXG4gICAgfTtcblxuICAgIHZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgICB2YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbiAgICB2YXIgbmF0aXZlRmlsdGVyID0gYXJyYXlQcm90by5maWx0ZXI7XG4gICAgdmFyIG5hdGl2ZVNsaWNlID0gYXJyYXlQcm90by5zbGljZTtcbiAgICB2YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG4gICAgdmFyIG5hdGl2ZVJlZHVjZSA9IGFycmF5UHJvdG8ucmVkdWNlO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHsqfSDmi7fotJ3lkI7nmoTmlrDlr7nosaFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT0gJ29iamVjdCcgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICAgICAgICAgICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBjbG9uZShzb3VyY2VbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICFpc0J1aWxkSW5PYmplY3Qoc291cmNlKVxuICAgICAgICAgICAgICAgIC8vIOaYr+WQpuS4uiBkb20g5a+56LGhXG4gICAgICAgICAgICAgICAgJiYgIWlzRG9tKHNvdXJjZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBlc2NhcHNlIHRoYXQgc291cmNlIGlzIHN0cmluZ1xuICAgICAgICAvLyBhbmQgZW50ZXIgZm9yIC4uLiBpbiAuLi5cbiAgICAgICAgaWYgKCFpc09iamVjdChzb3VyY2UpIHx8ICFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVByb3AgPSBzb3VyY2Vba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiBpc09iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheShzb3VyY2VQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNBcnJheSh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNEb20oc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzRG9tKHRhcmdldFByb3ApXG4gICAgICAgICAgICAgICAgICAgICYmICFpc0J1aWxkSW5PYmplY3Qoc291cmNlUHJvcClcbiAgICAgICAgICAgICAgICAgICAgJiYgIWlzQnVpbGRJbk9iamVjdCh0YXJnZXRQcm9wKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0QW5kU291cmNlcyBUaGUgZmlyc3QgaXRlbSBpcyB0YXJnZXQsIGFuZCB0aGUgcmVzdHMgYXJlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gICAgICogQHJldHVybiB7Kn0gdGFyZ2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VBbGwodGFyZ2V0QW5kU291cmNlcywgb3ZlcndyaXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXRBbmRTb3VyY2VzWzBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gbWVyZ2UocmVzdWx0LCB0YXJnZXRBbmRTb3VyY2VzW2ldLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVufSBbb3ZlcmxheT1mYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgICAgICAgICAgICAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIH1cbiAgICAvLyBGSVhNRVxuICAgIHZhciBfY3R4O1xuICAgIGZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gICAgICAgIGlmICghX2N0eCkge1xuICAgICAgICAgICAgLy8gVXNlIHV0aWwuY3JlYXRlQ2FudmFzIGluc3RlYWQgb2YgY3JlYXRlQ2FudmFzXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgICAgICAgICBfY3R4ID0gdXRpbC5jcmVhdGVDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfY3R4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOafpeivouaVsOe7hOS4reWFg+e0oOeahGluZGV4XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkuaW5kZXhPZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmnoTpgKDnsbvnu6fmib/lhbPns7tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNsYXp6IOa6kOexu1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VDbGF6eiDln7rnsbtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gICAgICAgIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgZnVuY3Rpb24gRigpIHt9XG4gICAgICAgIEYucHJvdG90eXBlID0gYmFzZUNsYXp6LnByb3RvdHlwZTtcbiAgICAgICAgY2xhenoucHJvdG90eXBlID0gbmV3IEYoKTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNsYXp6UHJvdG90eXBlKSB7XG4gICAgICAgICAgICBjbGF6ei5wcm90b3R5cGVbcHJvcF0gPSBjbGF6elByb3RvdHlwZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICBjbGF6ei5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjbGF6ejtcbiAgICAgICAgY2xhenouc3VwZXJDbGFzcyA9IGJhc2VDbGF6ejtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IHNvcmNlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgICAgICAgdGFyZ2V0ID0gJ3Byb3RvdHlwZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LnByb3RvdHlwZSA6IHRhcmdldDtcbiAgICAgICAgc291cmNlID0gJ3Byb3RvdHlwZScgaW4gc291cmNlID8gc291cmNlLnByb3RvdHlwZSA6IHNvdXJjZTtcblxuICAgICAgICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UoZGF0YSkge1xuICAgICAgICBpZiAoISBkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBkYXRhLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmiJblr7nosaHpgY3ljoZcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmlbDnu4TmmKDlsIRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLm1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3Rvb2wvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKG9iaiwgY2IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVkdWNlICYmIG9iai5yZWR1Y2UgPT09IG5hdGl2ZVJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog5pWw57uE6L+H5rukXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3Rvb2wvdXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gICAgICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIob2JqLCBjYiwgY29udGV4dCkge1xuICAgICAgICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5maWx0ZXIgJiYgb2JqLmZpbHRlciA9PT0gbmF0aXZlRmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaVsOe7hOmhueafpeaJvlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci90b29sL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3Rvb2wvdXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiaW5kKGZ1bmMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgICAqIEBwYXJhbSB7Li4ufVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3Rvb2wvdXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgLy8gQXZvaWQgYSBWOCBKSVQgYnVnIGluIENocm9tZSAxOS0yMC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMjkxIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAoISF2YWx1ZSAmJiB0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdG9vbC91dGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCdWlsZEluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhIUJVSUxUSU5fT0JKRUNUW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXVxuICAgICAgICAgICAgfHwgKHZhbHVlIGluc3RhbmNlb2YgR3JhZGllbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci90b29sL3V0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0RvbSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUubm9kZVR5cGUgPT09IDFcbiAgICAgICAgICAgICAgICYmIHR5cGVvZih2YWx1ZS5ub2RlTmFtZSkgPT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdmFsdWUxIGlzIG5vdCBudWxsLCB0aGVuIHJldHVybiB2YWx1ZTEsIG90aGVyd2lzZSBqdWRnZXQgcmVzdCBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtICB7Ki4uLn0gdmFsdWVzXG4gICAgICogQHJldHVybiB7Kn0gRmluYWwgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci90b29sL3V0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24uY2FsbC5hcHBseShuYXRpdmVTbGljZSwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbmRpdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHV0aWwgPSB7XG4gICAgICAgIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgICAgICAgbWl4aW46IG1peGluLFxuICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgbWVyZ2VBbGw6IG1lcmdlQWxsLFxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBnZXRDb250ZXh0OiBnZXRDb250ZXh0LFxuICAgICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgaW5kZXhPZjogaW5kZXhPZixcbiAgICAgICAgc2xpY2U6IHNsaWNlLFxuICAgICAgICBmaW5kOiBmaW5kLFxuICAgICAgICBpc0FycmF5TGlrZTogaXNBcnJheUxpa2UsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgIGJpbmQ6IGJpbmQsXG4gICAgICAgIGN1cnJ5OiBjdXJyeSxcbiAgICAgICAgaXNBcnJheTogaXNBcnJheSxcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gICAgICAgIGlzQnVpbGRJbk9iamVjdDogaXNCdWlsZEluT2JqZWN0LFxuICAgICAgICBpc0RvbTogaXNEb20sXG4gICAgICAgIHJldHJpZXZlOiByZXRyaWV2ZSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uICgpIHt9XG4gICAgfTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV0aWw7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICAgICAqL1xuICAgIHZhciBHcmFkaWVudCA9IGZ1bmN0aW9uIChjb2xvclN0b3BzKSB7XG5cbiAgICAgICAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbiAgICB9O1xuXG4gICAgR3JhZGllbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcblxuICAgICAgICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yU3RvcHMucHVzaCh7XG5cbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcblxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcmFkaWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gVE9ETyBEcmFnZ2FibGUgZm9yIGdyb3VwXG4vLyBGSVhNRSBEcmFnZ2FibGUgb24gZWxlbWVudCB3aGljaCBoYXMgcGFyZW50IHJvdGF0aW9uIG9yIHNjYWxlXG5cbiAgICBmdW5jdGlvbiBEcmFnZ2FibGUoKSB7XG5cbiAgICAgICAgdGhpcy5vbignbW91c2Vkb3duJywgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZywgdGhpcyk7XG4gICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG5cbiAgICAgICAgLy8gdGhpcy5feCA9IDA7XG4gICAgICAgIC8vIHRoaXMuX3kgPSAwO1xuICAgIH1cblxuICAgIERyYWdnYWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcblxuICAgICAgICBfZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQgJiYgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldDtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm94eShkcmFnZ2luZ1RhcmdldCwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcblxuICAgICAgICAgICAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gZS5vZmZzZXRZO1xuXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtIHRoaXMuX3g7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtIHRoaXMuX3k7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmlmdChkeCwgZHksIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJveHkoZHJhZ2dpbmdUYXJnZXQsICdkcmFnJywgZS5ldmVudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcFRhcmdldCA9IHRoaXMuZmluZEhvdmVyKHgsIHksIGRyYWdnaW5nVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdERyb3BUYXJnZXQgPSB0aGlzLl9kcm9wVGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Ryb3BUYXJnZXQgPSBkcm9wVGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hQcm94eShsYXN0RHJvcFRhcmdldCwgJ2RyYWdsZWF2ZScsIGUuZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wVGFyZ2V0ICYmIGRyb3BUYXJnZXQgIT09IGxhc3REcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb3h5KGRyb3BUYXJnZXQsICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfZHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnZ2luZ1RhcmdldCA9IHRoaXMuX2RyYWdnaW5nVGFyZ2V0O1xuXG4gICAgICAgICAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1RhcmdldC5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb3h5KGRyYWdnaW5nVGFyZ2V0LCAnZHJhZ2VuZCcsIGUuZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJveHkodGhpcy5fZHJvcFRhcmdldCwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmdUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERyYWdnYWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xuXG5cbiAgICB2YXIgR2VzdHVyZU1nciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhY2sgPSBbXTtcbiAgICB9O1xuXG4gICAgR2VzdHVyZU1nci5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEdlc3R1cmVNZ3IsXG5cbiAgICAgICAgcmVjb2duaXplOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5fZG9UcmFjayhldmVudCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemUoZXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvVHJhY2s6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0KSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG5cbiAgICAgICAgICAgIGlmICghdG91Y2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRyYWNrSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgICAgICAgIHRvdWNoZXM6IFtdLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSB0b3VjaGVzW2ldO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS5wb2ludHMucHVzaChbdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WV0pO1xuICAgICAgICAgICAgICAgIHRyYWNrSXRlbS50b3VjaGVzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3JlY29nbml6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcmVjb2duaXplcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb2duaXplcnMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUluZm8gPSByZWNvZ25pemVyc1tldmVudE5hbWVdKHRoaXMuX3RyYWNrLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlc3R1cmVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRpc3QocG9pbnRQYWlyKSB7XG4gICAgICAgIHZhciBkeCA9IHBvaW50UGFpclsxXVswXSAtIHBvaW50UGFpclswXVswXTtcbiAgICAgICAgdmFyIGR5ID0gcG9pbnRQYWlyWzFdWzFdIC0gcG9pbnRQYWlyWzBdWzFdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNlbnRlcihwb2ludFBhaXIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMF0gKyBwb2ludFBhaXJbMV1bMF0pIC8gMixcbiAgICAgICAgICAgIChwb2ludFBhaXJbMF1bMV0gKyBwb2ludFBhaXJbMV1bMV0pIC8gMlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHZhciByZWNvZ25pemVycyA9IHtcblxuICAgICAgICBwaW5jaDogZnVuY3Rpb24gKHRyYWNrLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoIXRyYWNrTGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGluY2hFbmQgPSAodHJhY2tbdHJhY2tMZW4gLSAxXSB8fCB7fSkucG9pbnRzO1xuICAgICAgICAgICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgICAgICAgICAgaWYgKHBpbmNoUHJlXG4gICAgICAgICAgICAgICAgJiYgcGluY2hQcmUubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICYmIHBpbmNoRW5kXG4gICAgICAgICAgICAgICAgJiYgcGluY2hFbmQubGVuZ3RoID4gMVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBpbmNoU2NhbGUgPSBkaXN0KHBpbmNoRW5kKSAvIGRpc3QocGluY2hQcmUpO1xuICAgICAgICAgICAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuXG4gICAgICAgICAgICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWCA9IHBpbmNoQ2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIGV2ZW50LnBpbmNoWSA9IHBpbmNoQ2VudGVyWzFdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3BpbmNoJyxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0cmFja1swXS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHBpbmNoIGN1cnJlbnRseS5cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHZXN0dXJlTWdyO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0dlc3R1cmVNZ3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBTdG9yYWdl5YaF5a655LuT5bqT5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvU3RvcmFnZVxuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vZ2l0aHViLmNvbS9waXNzYW5nLylcbiAqL1xuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JvdXAgPSByZXF1aXJlKCcuL2NvbnRhaW5lci9Hcm91cCcpO1xuXG4gICAgZnVuY3Rpb24gc2hhcGVDb21wYXJlRnVuYyhhLCBiKSB7XG4gICAgICAgIGlmIChhLnpsZXZlbCA9PT0gYi56bGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgICAgICAgICAgIGlmIChhLnoyID09PSBiLnoyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuejIgLSBiLnoyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEueiAtIGIuejtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56bGV2ZWwgLSBiLnpsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5YaF5a655LuT5bqTIChNKVxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIOaJgOacieW4uOinhOW9oueKtu+8jGlk57Si5byV55qEbWFwXG4gICAgICAgIHRoaXMuX2VsZW1lbnRzID0ge307XG5cbiAgICAgICAgdGhpcy5fcm9vdHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9kaXNwbGF5TGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB9O1xuXG4gICAgU3RvcmFnZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFN0b3JhZ2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOi/lOWbnuaJgOacieWbvuW9oueahOe7mOWItumYn+WIl1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cGRhdGU9ZmFsc2VdIOaYr+WQpuWcqOi/lOWbnuWJjeabtOaWsOivpeaVsOe7hFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSWdub3JlPWZhbHNlXSDmmK/lkKbljIXlkKsgaWdub3JlIOeahOaVsOe7hCwg5ZyoIHVwZGF0ZSDkuLogdHJ1ZSDnmoTml7blgJnmnInmlYhcbiAgICAgICAgICpcbiAgICAgICAgICog6K+m6KeBe0BsaW5rIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUucHJvdG90eXBlLnVwZGF0ZURpc3BsYXlMaXN0fVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXNwbGF5TGlzdDogZnVuY3Rpb24gKHVwZGF0ZSwgaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgaW5jbHVkZUlnbm9yZSA9IGluY2x1ZGVJZ25vcmUgfHwgZmFsc2U7XG4gICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5TGlzdChpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TGlzdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5pu05paw5Zu+5b2i55qE57uY5Yi26Zif5YiX44CCXG4gICAgICAgICAqIOavj+asoee7mOWItuWJjemDveS8muiwg+eUqO+8jOivpeaWueazleS8muWFiOa3seW6puS8mOWFiOmBjeWOhuaVtOS4quagke+8jOabtOaWsOaJgOaciUdyb3Vw5ZKMU2hhcGXnmoTlj5jmjaLlubbkuJTmiormiYDmnInlj6/op4HnmoRTaGFwZeS/neWtmOWIsOaVsOe7hOS4re+8jFxuICAgICAgICAgKiDmnIDlkI7moLnmja7nu5jliLbnmoTkvJjlhYjnuqfvvIh6bGV2ZWwgPiB6ID4g5o+S5YWl6aG65bqP77yJ5o6S5bqP5b6X5Yiw57uY5Yi26Zif5YiXXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJZ25vcmU9ZmFsc2VdIOaYr+WQpuWMheWQqyBpZ25vcmUg55qE5pWw57uEXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVEaXNwbGF5TGlzdDogZnVuY3Rpb24gKGluY2x1ZGVJZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMuX3Jvb3RzO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5fZGlzcGxheUxpc3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm9vdHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShyb290c1tpXSwgbnVsbCwgaW5jbHVkZUlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5sZW5ndGggPSB0aGlzLl9kaXNwbGF5TGlzdExlbjtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheUxpc3RbaV0uX19yZW5kZXJpZHggPSBpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXNwbGF5TGlzdC5zb3J0KHNoYXBlQ29tcGFyZUZ1bmMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcblxuICAgICAgICAgICAgaWYgKGVsLmlnbm9yZSAmJiAhaW5jbHVkZUlnbm9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAgICAgICAgIGVsLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICBlbC5hZnRlclVwZGF0ZSgpO1xuXG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSBlbC5jbGlwUGF0aDtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aCkge1xuICAgICAgICAgICAgICAgIC8vIGNsaXBQYXRoIOeahOWPmOaNouaYr+WfuuS6jiBncm91cCDnmoTlj5jmjaJcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5wYXJlbnQgPSBlbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIOaViOeOh+W9seWTjVxuICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGhzID0gY2xpcFBhdGhzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocy5wdXNoKGNsaXBQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBQYXRocyA9IFtjbGlwUGF0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwudHlwZSA9PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX19kaXJ0eSA9IGVsLl9fZGlydHkgfHwgY2hpbGQuX19kaXJ0eTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVBbmRBZGREaXNwbGF5YWJsZShjaGlsZCwgY2xpcFBhdGhzLCBpbmNsdWRlSWdub3JlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYXJrIGdyb3VwIGNsZWFuIGhlcmVcbiAgICAgICAgICAgICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLl9fY2xpcFBhdGhzID0gY2xpcFBhdGhzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RbdGhpcy5fZGlzcGxheUxpc3RMZW4rK10gPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbZWwuaWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgIGVsLmFkZENoaWxkcmVuVG9TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkZFRvTWFwKGVsKTtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RzLnB1c2goZWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTmjIflrprnmoTlm77lvaIoU2hhcGUp5oiW6ICF57uEKEdyb3VwKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gW2VsSWRdIOWmguaenOS4uuepuua4heepuuaVtOS4qlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRlbFJvb3Q6IGZ1bmN0aW9uIChlbElkKSB7XG4gICAgICAgICAgICBpZiAoZWxJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8g5LiN5oyH5a6aZWxJZOa4heepulxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudHMgPSB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxJZCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbElkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbFJvb3QoZWxJZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihlbElkKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZWxlbWVudHNbZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbCA9IGVsSWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsRnJvbU1hcChlbC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG9NYXA6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWwuZGlydHkoKTtcblxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudHNbZWwuaWRdID0gZWw7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKGVsSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50c1tlbElkXTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWxGcm9tTWFwOiBmdW5jdGlvbiAoZWxJZCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fZWxlbWVudHM7XG4gICAgICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50c1tlbElkXTtcbiAgICAgICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBlbC5fX3N0b3JhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICAgICAgICovXG4gICAgICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRzID1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxpc3QgPVxuICAgICAgICAgICAgdGhpcy5fcm9vdHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gU3RvcmFnZTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvU3RvcmFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEdyb3Vw5piv5LiA5Liq5a655Zmo77yM5Y+v5Lul5o+S5YWl5a2Q6IqC54K577yMR3JvdXDnmoTlj5jmjaLkuZ/kvJrooqvlupTnlKjliLDlrZDoioLngrnkuIpcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0dyb3VwXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBHcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xuICogICAgIHZhciBDaXJjbGUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL0VsZW1lbnQnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0dyb3VwXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gICAgICovXG4gICAgdmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICBFbGVtZW50LmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICAgICAgdGhpcy5fX3N0b3JhZ2UgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX19kaXJ0eSA9IHRydWU7XG4gICAgfTtcblxuICAgIEdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogR3JvdXAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvRWxlbWVudD59XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltpZHhdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmjIflrprlkI3lrZfnmoTlhL/lrZDoioLngrlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZE9mTmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDoioLngrnliLDmnIDlkI5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBjaGlsZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpc1xuICAgICAgICAgICAgICAgICYmIG5leHRTaWJsaW5nICYmIG5leHRTaWJsaW5nLnBhcmVudCA9PT0gdGhpcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IGNoaWxkcmVuLmluZGV4T2YobmV4dFNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9BZGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2RvQWRkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLl9fc3RvcmFnZTtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUb01hcChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHpyICYmIHpyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog56e76Zmk5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICAgICAgICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc3RvcmFnZSkge1xuXG4gICAgICAgICAgICAgICAgc3RvcmFnZS5kZWxGcm9tTWFwKGNoaWxkLmlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UuZGVsRnJvbU1hcChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YGN5Y6G5omA5pyJ5a2Q6IqC54K5XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaENoaWxkOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNiLmNhbGwoY29udGV4dCwgY2hpbGQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3seW6puS8mOWFiOmBjeWOhuaJgOacieWtkOWtmeiKgueCuVxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICAgICAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICAgICAgICovXG4gICAgICAgIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRDaGlsZHJlblRvU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRvTWFwKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmRlbEZyb21NYXAoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgICAgICAgICAgLy8gVE9ETyBUcmFuc2Zvcm1cbiAgICAgICAgICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGluY2x1ZGVDaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5pZ25vcmUgfHwgY2hpbGQuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gY2hpbGQuZ2V0TG9jYWxUcmFuc2Zvcm0odG1wTWF0KTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoR3JvdXAsIEVsZW1lbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIEBtb2R1bGUgenJlbmRlci9FbGVtZW50XG4gKi9cblxuXG4gICAgdmFyIGd1aWQgPSByZXF1aXJlKCcuL2NvcmUvZ3VpZCcpO1xuICAgIHZhciBFdmVudGZ1bCA9IHJlcXVpcmUoJy4vbWl4aW4vRXZlbnRmdWwnKTtcbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoJy4vbWl4aW4vVHJhbnNmb3JtYWJsZScpO1xuICAgIHZhciBBbmltYXRhYmxlID0gcmVxdWlyZSgnLi9taXhpbi9BbmltYXRhYmxlJyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4vY29yZS91dGlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9BbmltYXRhYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICAgICAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bH1cbiAgICAgKi9cbiAgICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG5cbiAgICAgICAgVHJhbnNmb3JtYWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBFdmVudGZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xuICAgICAgICBBbmltYXRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUu+W4g+WFg+e0oElEXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gb3B0cy5pZCB8fCBndWlkKCk7XG4gICAgfTtcblxuICAgIEVsZW1lbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlhYPntKDnsbvlnotcbiAgICAgICAgICogRWxlbWVudCB0eXBlXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0eXBlOiAnZWxlbWVudCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWFg+e0oOWQjeWtl1xuICAgICAgICAgKiBFbGVtZW50IG5hbWVcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIG5hbWU6ICcnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBaUmVuZGVyIOWunuS+i+Wvueixoe+8jOS8muWcqCBlbGVtZW50IOa3u+WKoOWIsCB6cmVuZGVyIOWunuS+i+S4reWQjuiHquWKqOi1i+WAvFxuICAgICAgICAgKiBaUmVuZGVyIGluc3RhbmNlIHdpbGwgYmUgYXNzaWduZWQgd2hlbiBlbGVtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB6cmVuZGVyXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I19fenJcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfX3pyOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlm77lvaLmmK/lkKblv73nlaXvvIzkuLp0cnVl5pe25b+955Wl5Zu+5b2i55qE57uY5Yi25Lul5Y+K5LqL5Lu26Kem5Y+RXG4gICAgICAgICAqIElmIGlnbm9yZSBkcmF3aW5nIGFuZCBldmVudHMgb2YgdGhlIGVsZW1lbnQgb2JqZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9FbGVtZW50I2lnbm9yZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGlnbm9yZTogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOeUqOS6juijgeWJqueahOi3r+W+hChzaGFwZSnvvIzmiYDmnIkgR3JvdXAg5YaF55qE6Lev5b6E5Zyo57uY5Yi25pe26YO95Lya6KKr6L+Z5Liq6Lev5b6E6KOB5YmqXG4gICAgICAgICAqIOivpei3r+W+hOS8mue7p+aJv+iiq+ijgeWHj+WvueixoeeahOWPmOaNolxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofVxuICAgICAgICAgKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jY2xpcHBpbmctcmVnaW9uXG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgY2xpcFBhdGg6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERyaWZ0IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBkeCBkeCBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZHkgZHkgb24gdGhlIGdsb2JhbCBzcGFjZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJpZnQ6IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgICAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICBtID0gdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzRdICs9IGR4O1xuICAgICAgICAgICAgbVs1XSArPSBkeTtcblxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBiZWZvcmUgdXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSG9vayBhZnRlciB1cGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgICAgICAgKi9cbiAgICAgICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJLVjogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicgfHwga2V5ID09PSAnc2NhbGUnIHx8IGtleSA9PT0gJ29yaWdpbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBhcnJheVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WzBdID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFsxXSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHRoZSBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGtleVxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhdHRyOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyS1Yoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cktWKG5hbWUsIGtleVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICAgICAgICovXG4gICAgICAgIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICAgICAgICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICAgICAgICAgIGlmICh6cikge1xuICAgICAgICAgICAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGNsaXAgcGF0aFxuICAgICAgICAgICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXBQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBjbGlwUGF0aDtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fenIgPSB6cjtcbiAgICAgICAgICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMuZGlydHkoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNsaXBQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2xpcFBhdGggPSB0aGlzLmNsaXBQYXRoO1xuICAgICAgICAgICAgaWYgKGNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsaXBQYXRoLl9fenIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcFBhdGgucmVtb3ZlU2VsZkZyb21acihjbGlwUGF0aC5fX3pyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX3pyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjbGlwUGF0aC5fX2NsaXBUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAgICAgICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgICAgICAgKi9cbiAgICAgICAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgICAgICAgICAgdGhpcy5fX3pyID0genI7XG4gICAgICAgICAgICAvLyDmt7vliqDliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5hZGRTZWxmVG9acih6cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICAgICAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICAgICAgICAgIHRoaXMuX196ciA9IG51bGw7XG4gICAgICAgICAgICAvLyDnp7vpmaTliqjnlLtcbiAgICAgICAgICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcbiAgICAgICAgICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24ucmVtb3ZlQW5pbWF0b3IoYW5pbWF0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwUGF0aC5yZW1vdmVTZWxmRnJvbVpyKHpyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwubWl4aW4oRWxlbWVudCwgQW5pbWF0YWJsZSk7XG4gICAgenJVdGlsLm1peGluKEVsZW1lbnQsIFRyYW5zZm9ybWFibGUpO1xuICAgIHpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9FbGVtZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5o+Q5L6b5Y+Y5o2i5omp5bGVXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2NvcmUvbWF0cml4Jyk7XG4gICAgdmFyIHZlY3RvciA9IHJlcXVpcmUoJy4uL2NvcmUvdmVjdG9yJyk7XG4gICAgdmFyIG1JZGVudGl0eSA9IG1hdHJpeC5pZGVudGl0eTtcblxuICAgIHZhciBFUFNJTE9OID0gNWUtNTtcblxuICAgIGZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuICAgICAgICBpZiAoIW9wdHMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog5bmz56e7XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IFswLCAwXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yb3RhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIOaXi+i9rFxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICog57yp5pS+XG4gICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAgICAgKiBAZGVmYXVsdCBbMSwgMV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLm9yaWdpbiB8fCBudWxsO1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtYWJsZVByb3RvID0gVHJhbnNmb3JtYWJsZS5wcm90b3R5cGU7XG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAgICAgKiDlpoLmnpzmnInlnZDmoIflj5jmjaIsIOWImeS7jnBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGXku6Xlj4rniLboioLngrnnmoR0cmFuc2Zvcm3orqHnrpflh7roh6rouqvnmoR0cmFuc2Zvcm3nn6npmLVcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1hYmxlUHJvdG8ubmVlZExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaXNOb3RBcm91bmRaZXJvKHRoaXMucm90YXRpb24pXG4gICAgICAgICAgICB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5wb3NpdGlvblswXSlcbiAgICAgICAgICAgIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMF0gLSAxKVxuICAgICAgICAgICAgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMuc2NhbGVbMV0gLSAxKTtcbiAgICB9O1xuXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgICAgICAgICBtICYmIG1JZGVudGl0eShtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG0gPSBtIHx8IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbUlkZW50aXR5KG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8g5bqU55So54i26IqC54K55Y+Y5o2iXG4gICAgICAgIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4LmNvcHkobSwgcGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbTtcblxuICAgICAgICB0aGlzLmludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtIHx8IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgbWF0cml4LmludmVydCh0aGlzLmludlRyYW5zZm9ybSwgbSk7XG4gICAgfTtcblxuICAgIHRyYW5zZm9ybWFibGVQcm90by5nZXRMb2NhbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIG0gPSBtIHx8IFtdO1xuICAgICAgICBtSWRlbnRpdHkobSk7XG5cbiAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xuXG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICAgIHZhciByb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIFRyYW5zbGF0ZSB0byBvcmlnaW5cbiAgICAgICAgICAgIG1bNF0gLT0gb3JpZ2luWzBdO1xuICAgICAgICAgICAgbVs1XSAtPSBvcmlnaW5bMV07XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LnNjYWxlKG0sIG0sIHNjYWxlKTtcbiAgICAgICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICAgICAgICBtYXRyaXgucm90YXRlKG0sIG0sIHJvdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBUcmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICAgICAgICAgICAgbVs0XSArPSBvcmlnaW5bMF07XG4gICAgICAgICAgICBtWzVdICs9IG9yaWdpblsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1bNF0gKz0gcG9zaXRpb25bMF07XG4gICAgICAgIG1bNV0gKz0gcG9zaXRpb25bMV07XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gICAgICogQHBhcmFtIHtDb250ZXh0MkR9IGN0eFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0bXBUcmFuc2Zvcm0gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIOWIhuino2B0cmFuc2Zvcm1g55+p6Zi15YiwYHBvc2l0aW9uYCwgYHJvdGF0aW9uYCwgYHNjYWxlYFxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by5kZWNvbXBvc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gR2V0IGxvY2FsIHRyYW5zZm9ybSBhbmQgZGVjb21wb3NlIHRoZW0gdG8gcG9zaXRpb24sIHNjYWxlLCByb3RhdGlvblxuICAgICAgICAgICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIHBhcmVudC5pbnZUcmFuc2Zvcm0sIG0pO1xuICAgICAgICAgICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ggPSBtWzBdICogbVswXSArIG1bMV0gKiBtWzFdO1xuICAgICAgICB2YXIgc3kgPSBtWzJdICogbVsyXSArIG1bM10gKiBtWzNdO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN4IC0gMSkpIHtcbiAgICAgICAgICAgIHN4ID0gTWF0aC5zcXJ0KHN4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOb3RBcm91bmRaZXJvKHN5IC0gMSkpIHtcbiAgICAgICAgICAgIHN5ID0gTWF0aC5zcXJ0KHN5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobVswXSA8IDApIHtcbiAgICAgICAgICAgIHN4ID0gLXN4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtWzNdIDwgMCkge1xuICAgICAgICAgICAgc3kgPSAtc3k7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25bMF0gPSBtWzRdO1xuICAgICAgICBwb3NpdGlvblsxXSA9IG1bNV07XG4gICAgICAgIHNjYWxlWzBdID0gc3g7XG4gICAgICAgIHNjYWxlWzFdID0gc3k7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBNYXRoLmF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWPmOaNouWdkOagh+S9jee9ruWIsCBzaGFwZSDnmoTlsYDpg6jlnZDmoIfnqbrpl7RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIHRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm1Db29yZFRvTG9jYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciBpbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybTtcbiAgICAgICAgaWYgKGludlRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgaW52VHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOWPmOaNouWxgOmDqOWdkOagh+S9jee9ruWIsOWFqOWxgOWdkOagh+epuumXtFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAgICovXG4gICAgdHJhbnNmb3JtYWJsZVByb3RvLnRyYW5zZm9ybUNvb3JkVG9HbG9iYWwgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdjIgPSBbeCwgeV07XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdmVjdG9yLmFwcGx5VHJhbnNmb3JtKHYyLCB2MiwgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjI7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtYWJsZTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcbiAgICAvKipcbiAgICAgKiAzeDLnn6npmLXmk43kvZznsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvbWF0cml4XG4gICAgICovXG4gICAgdmFyIG1hdHJpeCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWNleS9jeefqemYtVxuICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGUgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgQXJyYXlDdG9yKDYpO1xuICAgICAgICAgICAgbWF0cml4LmlkZW50aXR5KG91dCk7XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDorr7nva7nn6npmLXkuLrljZXkvY3nn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKi9cbiAgICAgICAgaWRlbnRpdHkgOiBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgICAgIG91dFswXSA9IDE7XG4gICAgICAgICAgICBvdXRbMV0gPSAwO1xuICAgICAgICAgICAgb3V0WzJdID0gMDtcbiAgICAgICAgICAgIG91dFszXSA9IDE7XG4gICAgICAgICAgICBvdXRbNF0gPSAwO1xuICAgICAgICAgICAgb3V0WzVdID0gMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlpI3liLbnn6npmLVcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgY29weTogZnVuY3Rpb24ob3V0LCBtKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBtWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXTtcbiAgICAgICAgICAgIG91dFsyXSA9IG1bMl07XG4gICAgICAgICAgICBvdXRbM10gPSBtWzNdO1xuICAgICAgICAgICAgb3V0WzRdID0gbVs0XTtcbiAgICAgICAgICAgIG91dFs1XSA9IG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog55+p6Zi155u45LmYXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG0xXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsIDogZnVuY3Rpb24gKG91dCwgbTEsIG0yKSB7XG4gICAgICAgICAgICAvLyBDb25zaWRlciBtYXRyaXgubXVsKG0sIG0yLCBtKTtcbiAgICAgICAgICAgIC8vIHdoZXJlIG91dCBpcyB0aGUgc2FtZSBhcyBtMi5cbiAgICAgICAgICAgIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgICAgICAgICAgIHZhciBvdXQwID0gbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV07XG4gICAgICAgICAgICB2YXIgb3V0MSA9IG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdO1xuICAgICAgICAgICAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgICAgICAgICAgIHZhciBvdXQzID0gbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM107XG4gICAgICAgICAgICB2YXIgb3V0NCA9IG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF07XG4gICAgICAgICAgICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgICAgICAgICBvdXRbMF0gPSBvdXQwO1xuICAgICAgICAgICAgb3V0WzFdID0gb3V0MTtcbiAgICAgICAgICAgIG91dFsyXSA9IG91dDI7XG4gICAgICAgICAgICBvdXRbM10gPSBvdXQzO1xuICAgICAgICAgICAgb3V0WzRdID0gb3V0NDtcbiAgICAgICAgICAgIG91dFs1XSA9IG91dDU7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5bmz56e75Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zbGF0ZSA6IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSBhWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICAgICAgICAgIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSArIHZbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5peL6L2s5Y+Y5o2iXG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICAgICAgICAgKi9cbiAgICAgICAgcm90YXRlIDogZnVuY3Rpb24ob3V0LCBhLCByYWQpIHtcbiAgICAgICAgICAgIHZhciBhYSA9IGFbMF07XG4gICAgICAgICAgICB2YXIgYWMgPSBhWzJdO1xuICAgICAgICAgICAgdmFyIGF0eCA9IGFbNF07XG4gICAgICAgICAgICB2YXIgYWIgPSBhWzFdO1xuICAgICAgICAgICAgdmFyIGFkID0gYVszXTtcbiAgICAgICAgICAgIHZhciBhdHkgPSBhWzVdO1xuICAgICAgICAgICAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgICAgICAgICAgIHZhciBjdCA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFhICogY3QgKyBhYiAqIHN0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFhICogc3QgKyBhYiAqIGN0O1xuICAgICAgICAgICAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gICAgICAgICAgICBvdXRbM10gPSAtYWMgKiBzdCArIGN0ICogYWQ7XG4gICAgICAgICAgICBvdXRbNF0gPSBjdCAqIGF0eCArIHN0ICogYXR5O1xuICAgICAgICAgICAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnvKnmlL7lj5jmjaJcbiAgICAgICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgc2NhbGUgOiBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICAgICAgICAgIHZhciB2eCA9IHZbMF07XG4gICAgICAgICAgICB2YXIgdnkgPSB2WzFdO1xuICAgICAgICAgICAgb3V0WzBdID0gYVswXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzFdID0gYVsxXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzNdID0gYVszXSAqIHZ5O1xuICAgICAgICAgICAgb3V0WzRdID0gYVs0XSAqIHZ4O1xuICAgICAgICAgICAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxgumAhuefqemYtVxuICAgICAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gICAgICAgICAqL1xuICAgICAgICBpbnZlcnQgOiBmdW5jdGlvbihvdXQsIGEpIHtcblxuICAgICAgICAgICAgdmFyIGFhID0gYVswXTtcbiAgICAgICAgICAgIHZhciBhYyA9IGFbMl07XG4gICAgICAgICAgICB2YXIgYXR4ID0gYVs0XTtcbiAgICAgICAgICAgIHZhciBhYiA9IGFbMV07XG4gICAgICAgICAgICB2YXIgYWQgPSBhWzNdO1xuICAgICAgICAgICAgdmFyIGF0eSA9IGFbNV07XG5cbiAgICAgICAgICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICAgICAgICAgIGlmICghZGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICAgICAgICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgICAgICAgICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgICAgICAgICAgb3V0WzJdID0gLWFjICogZGV0O1xuICAgICAgICAgICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgICAgICAgICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gbWF0cml4O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL21hdHJpeC5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBBcnJheVxuICAgICAgICA6IEZsb2F0MzJBcnJheTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IFZlY3RvcjJcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiDkuoznu7TlkJHph4/nsbtcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL3Rvb2wvdmVjdG9yXG4gICAgICovXG4gICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIm+W7uuS4gOS4quWQkemHj1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIG91dFswXSA9IHggfHwgMDtcbiAgICAgICAgICAgIG91dFsxXSA9IHkgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWkjeWItuWQkemHj+aVsOaNrlxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgICAgICovXG4gICAgICAgIGNvcHk6IGZ1bmN0aW9uIChvdXQsIHYpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5YWL6ZqG5LiA5Liq5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcbiAgICAgICAgICAgIG91dFswXSA9IHZbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5ZCR6YeP55qE5Lik5Liq6aG5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gICAgICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9IOe7k+aenFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBhO1xuICAgICAgICAgICAgb3V0WzFdID0gYjtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+ebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+e8qeaUvuWQjuebuOWKoFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFcbiAgICAgICAgICovXG4gICAgICAgIHNjYWxlQW5kQWRkOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIsIGEpIHtcbiAgICAgICAgICAgIG91dFswXSA9IHYxWzBdICsgdjJbMF0gKiBhO1xuICAgICAgICAgICAgb3V0WzFdID0gdjFbMV0gKyB2MlsxXSAqIGE7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nm7jlh49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqZcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlbjogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5TcXVhcmUodikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/plb/luqblubPmlrlcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGxlblNxdWFyZTogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2WzBdICogdlswXSArIHZbMV0gKiB2WzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/kuZjms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBtdWw6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gKiB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdICogdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/pmaTms5VcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqL1xuICAgICAgICBkaXY6IGZ1bmN0aW9uIChvdXQsIHYxLCB2Mikge1xuICAgICAgICAgICAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHYxWzFdIC8gdjJbMV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/ngrnkuZhcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIGRvdDogZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICAgICAgcmV0dXJuIHYxWzBdICogdjJbMF0gKyB2MVsxXSAqIHYyWzFdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlkJHph4/nvKnmlL5cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzXG4gICAgICAgICAqL1xuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKG91dCwgdiwgcykge1xuICAgICAgICAgICAgb3V0WzBdID0gdlswXSAqIHM7XG4gICAgICAgICAgICBvdXRbMV0gPSB2WzFdICogcztcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+W9kuS4gOWMllxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKG91dCwgdikge1xuICAgICAgICAgICAgdmFyIGQgPSB2ZWN0b3IubGVuKHYpO1xuICAgICAgICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSAwO1xuICAgICAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRbMF0gPSB2WzBdIC8gZDtcbiAgICAgICAgICAgICAgICBvdXRbMV0gPSB2WzFdIC8gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuoeeul+WQkemHj+mXtOi3neemu1xuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgKHYxWzBdIC0gdjJbMF0pICogKHYxWzBdIC0gdjJbMF0pXG4gICAgICAgICAgICAgICAgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWQkemHj+i3neemu+W5s+aWuVxuICAgICAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZGlzdGFuY2VTcXVhcmU6IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIHJldHVybiAodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSlcbiAgICAgICAgICAgICAgICArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC6LSf5ZCR6YePXG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlOiBmdW5jdGlvbiAob3V0LCB2KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSAtdlswXTtcbiAgICAgICAgICAgIG91dFsxXSA9IC12WzFdO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5o+S5YC85Lik5Liq54K5XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdFxuICAgICAgICAgKi9cbiAgICAgICAgbGVycDogZnVuY3Rpb24gKG91dCwgdjEsIHYyLCB0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSB2MVswXSArIHQgKiAodjJbMF0gLSB2MVswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSB2MVsxXSArIHQgKiAodjJbMV0gLSB2MVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnn6npmLXlt6bkuZjlkJHph49cbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gICAgICAgICAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uIChvdXQsIHYsIG0pIHtcbiAgICAgICAgICAgIHZhciB4ID0gdlswXTtcbiAgICAgICAgICAgIHZhciB5ID0gdlsxXTtcbiAgICAgICAgICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICAgICAgICAgICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5rGC5Lik5Liq5ZCR6YeP5pyA5bCP5YC8XG4gICAgICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2MlxuICAgICAgICAgKi9cbiAgICAgICAgbWluOiBmdW5jdGlvbiAob3V0LCB2MSwgdjIpIHtcbiAgICAgICAgICAgIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gICAgICAgICAgICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaxguS4pOS4quWQkemHj+acgOWkp+WAvFxuICAgICAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBvdXRcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAgICAgICAgICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24gKG91dCwgdjEsIHYyKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICAgICAgICAgICAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmVjdG9yLmxlbmd0aCA9IHZlY3Rvci5sZW47XG4gICAgdmVjdG9yLmxlbmd0aFNxdWFyZSA9IHZlY3Rvci5sZW5TcXVhcmU7XG4gICAgdmVjdG9yLmRpc3QgPSB2ZWN0b3IuZGlzdGFuY2U7XG4gICAgdmVjdG9yLmRpc3RTcXVhcmUgPSB2ZWN0b3IuZGlzdGFuY2VTcXVhcmU7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZlY3RvcjtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS92ZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICovXG5cblxuICAgIHZhciBBbmltYXRvciA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9BbmltYXRvcicpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIGlzU3RyaW5nID0gdXRpbC5pc1N0cmluZztcbiAgICB2YXIgaXNGdW5jdGlvbiA9IHV0aWwuaXNGdW5jdGlvbjtcbiAgICB2YXIgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIHZhciBsb2cgPSByZXF1aXJlKCcuLi9jb3JlL2xvZycpO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBBbmltYXRhYmxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcj59XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRvcnMgPSBbXTtcbiAgICB9O1xuXG4gICAgQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IEFuaW1hdGFibGUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWKqOeUu1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCDpnIDopoHmt7vliqDliqjnlLvnmoTlsZ7mgKfojrflj5bot6/lvoTvvIzlj6/ku6XpgJrov4dhLmIuY+adpeiOt+WPlua3seWxgueahOWxnuaAp1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtsb29wXSDliqjnlLvmmK/lkKblvqrnjq9cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKiBAZXhhbXBsZTpcbiAgICAgICAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAgICAgICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAgICAgICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICAgICAgICogICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW5nU2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgenIgPSB0aGlzLl9fenI7XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb3AgPSBlbDtcbiAgICAgICAgICAgICAgICAvLyBJZiBhbmltYXRpbmcgc2hhcGVcbiAgICAgICAgICAgICAgICBhbmltYXRpbmdTaGFwZSA9IHBhdGhTcGxpdHRlZFswXSA9PT0gJ3NoYXBlJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhTcGxpdHRlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wID0gcHJvcFtwYXRoU3BsaXR0ZWRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IGVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIGxvZyhcbiAgICAgICAgICAgICAgICAgICAgJ1Byb3BlcnR5IFwiJ1xuICAgICAgICAgICAgICAgICAgICArIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgKyAnXCIgaXMgbm90IGV4aXN0ZWQgaW4gZWxlbWVudCAnXG4gICAgICAgICAgICAgICAgICAgICsgZWwuaWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcblxuICAgICAgICAgICAgdmFyIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKHRhcmdldCwgbG9vcCk7XG5cbiAgICAgICAgICAgIGFuaW1hdG9yLmR1cmluZyhmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kb25lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBBbmltYXRvciB3aWxsIG5vdCBiZSByZW1vdmVkIGlmIHVzZSBgQW5pbWF0b3Ijc3RvcGAgdG8gc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBhbmltYXRvcnMuc3BsaWNlKHV0aWwuaW5kZXhPZihhbmltYXRvcnMsIGFuaW1hdG9yKSwgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYW5pbWF0b3JzLnB1c2goYW5pbWF0b3IpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmltYXRlIGFmdGVyIGFkZGVkIHRvIHRoZSB6cmVuZGVyXG4gICAgICAgICAgICBpZiAoenIpIHtcbiAgICAgICAgICAgICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWBnOatouWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcndhcmRUb0xhc3QgSWYgbW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAqL1xuICAgICAgICBzdG9wQW5pbWF0aW9uOiBmdW5jdGlvbiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmltYXRvcnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgZnVuY3Rpb24gKCkgeyAvLyBkb25lIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqICAvLyBBbmltYXRlIHNoYXBlLCBzdHlsZSBhbmQgcG9zaXRpb24gaW4gMTAwbXMsIGRlbGF5ZWQgMTAwbXMsIHdpdGggY3ViaWNPdXQgZWFzaW5nXG4gICAgICAgICAqICBlbC5hbmltYXRlVG8oe1xuICAgICAgICAgKiAgICAgIHNoYXBlOiB7XG4gICAgICAgICAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAgICAgICAgICogICAgICB9LFxuICAgICAgICAgKiAgICAgIHN0eWxlOiB7XG4gICAgICAgICAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICAgICAgICAgKiAgfSwgMTAwLCAxMDAsICdjdWJpY091dCcsIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgICAgICAgKi9cbiAgICAgICAgIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgICAgICAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICAgICAgICAgICAgZWFzaW5nID0gZGVsYXk7XG4gICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYW5pbWF0ZVRvKHRhcmdldCwgdGltZSwgZGVsYXksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZWFzaW5nO1xuICAgICAgICAgICAgICAgIGVhc2luZyA9ICdsaW5lYXInO1xuICAgICAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkZWxheTtcbiAgICAgICAgICAgICAgICBkZWxheSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhbmltYXRlVG8odGFyZ2V0LCBjYWxsYmFjaylcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odGltZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHRpbWU7XG4gICAgICAgICAgICAgICAgdGltZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgICAgICBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSA1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9wIGFsbCBwcmV2aW91cyBhbmltYXRpb25zXG4gICAgICAgICAgICB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVUb1NoYWxsb3coJycsIHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICAgICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgICAgICAgICAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgIGlmICghY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5vIGFuaW1hdG9ycy4gVGhpcyBzaG91bGQgYmUgY2hlY2tlZCBiZWZvcmUgYW5pbWF0b3JzW2ldLnN0YXJ0KCksXG4gICAgICAgICAgICAvLyBiZWNhdXNlICdkb25lJyBtYXkgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkgaWYgbm8gbmVlZCB0byBhbmltYXRlLlxuICAgICAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBhZnRlciBhbGwgYW5pbWF0b3JzIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIEluY2FzZSBhbnkgYW5pbWF0b3IgaXMgZG9uZSBpbW1lZGlhdGVseSB3aGVuIGFsbCBhbmltYXRpb24gcHJvcGVydGllcyBhcmUgbm90IGNoYW5nZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JzW2ldXG4gICAgICAgICAgICAgICAgICAgIC5kb25lKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgIC5zdGFydChlYXNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlPXRoaXNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTBdXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAvLyBBbmltYXRlIHBvc2l0aW9uXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9KVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zXG4gICAgICAgICAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gICAgICAgICAqICAgICAgc2hhcGU6IHtcbiAgICAgICAgICogICAgICAgICAgd2lkdGg6IDUwMFxuICAgICAgICAgKiAgICAgIH0sXG4gICAgICAgICAqICAgICAgc3R5bGU6IHtcbiAgICAgICAgICogICAgICAgICAgZmlsbDogJ3JlZCdcbiAgICAgICAgICogICAgICB9XG4gICAgICAgICAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gICAgICAgICAqICB9LCAxMDAsIDEwMClcbiAgICAgICAgICovXG4gICAgICAgIF9hbmltYXRlVG9TaGFsbG93OiBmdW5jdGlvbiAocGF0aCwgc291cmNlLCB0YXJnZXQsIHRpbWUsIGRlbGF5KSB7XG4gICAgICAgICAgICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFtuYW1lXSkgJiYgIXV0aWwuaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZVRvU2hhbGxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoID8gcGF0aCArICcuJyArIG5hbWUgOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtuYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ciBkaXJlY3RseSBpZiBub3QgaGFzIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FLCBpZiBzb21lIHByb3BlcnR5IG5vdCBuZWVkZWQgZm9yIGVsZW1lbnQgP1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAgLy8gU2hhcGUgb3Igc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbcGF0aF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW3BhdGhdW25hbWVdID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByb3BlcnR5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlKHBhdGgsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KVxuICAgICAgICAgICAgICAgICAgICAuZGVsYXkoZGVsYXkgfHwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0YWJsZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL21peGluL0FuaW1hdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIGVjaGFydHMvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKi9cblxuXG4gICAgdmFyIENsaXAgPSByZXF1aXJlKCcuL0NsaXAnKTtcbiAgICB2YXIgY29sb3IgPSByZXF1aXJlKCcuLi90b29sL2NvbG9yJyk7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgaXNBcnJheUxpa2UgPSB1dGlsLmlzQXJyYXlMaWtlO1xuXG4gICAgdmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0dGVyKHRhcmdldCwga2V5KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gcDBcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICAgICAgICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICogQHBhcmFtICB7QXJyYXl9IG91dFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHBlcmNlbnQsIG91dCwgYXJyRGltKSB7XG4gICAgICAgIHZhciBsZW4gPSBwMC5sZW5ndGg7XG4gICAgICAgIGlmIChhcnJEaW0gPT0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG91dFtpXSA9IGludGVycG9sYXRlTnVtYmVyKHAwW2ldLCBwMVtpXSwgcGVyY2VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGVuMiA9IHAwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV1bal0gPSBpbnRlcnBvbGF0ZU51bWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcGVyY2VudFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gICAgICAgIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gICAgICAgIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIwTGVuID09PSBhcnIxTGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRklYTUUgTm90IHdvcmsgZm9yIFR5cGVkQXJyYXlcbiAgICAgICAgdmFyIGlzUHJldmlvdXNMYXJnZXIgPSBhcnIwTGVuID4gYXJyMUxlbjtcbiAgICAgICAgaWYgKGlzUHJldmlvdXNMYXJnZXIpIHtcbiAgICAgICAgICAgIC8vIEN1dCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIGFycjAubGVuZ3RoID0gYXJyMUxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gYXJyMExlbjsgaSA8IGFycjFMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycjAucHVzaChcbiAgICAgICAgICAgICAgICAgICAgYXJyRGltID09PSAxID8gYXJyMVtpXSA6IGFycmF5U2xpY2UuY2FsbChhcnIxW2ldKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyMFxuICAgICAqIEBwYXJhbSAge0FycmF5fSBhcnIxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlTYW1lKGFycjAsIGFycjEsIGFyckRpbSkge1xuICAgICAgICBpZiAoYXJyMCA9PT0gYXJyMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycjAubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxlbjIgPSBhcnIwWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdG11bGwgUm9tIGludGVycG9sYXRlIGFycmF5XG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAwXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IHAzXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gb3V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mywgb3V0LCBhcnJEaW1cbiAgICApIHtcbiAgICAgICAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyckRpbSA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gY2F0bXVsbFJvbUludGVycG9sYXRlKFxuICAgICAgICAgICAgICAgICAgICBwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXVtqXSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdCwgdDIsIHQzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F0bXVsbCBSb20gaW50ZXJwb2xhdGUgbnVtYmVyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHQzXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhdG11bGxSb21JbnRlcnBvbGF0ZShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzKSB7XG4gICAgICAgIHZhciB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgICAgICAgdmFyIHYxID0gKHAzIC0gcDEpICogMC41O1xuICAgICAgICByZXR1cm4gKDIgKiAocDEgLSBwMikgKyB2MCArIHYxKSAqIHQzXG4gICAgICAgICAgICAgICAgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MlxuICAgICAgICAgICAgICAgICsgdjAgKiB0ICsgcDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXJyYXlTbGljZS5jYWxsKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICAgICAgICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG5cbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JhLmpvaW4oJywnKSArICcpJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmFja0NsaXAgKGFuaW1hdG9yLCBlYXNpbmcsIG9uZVRyYWNrRG9uZSwga2V5ZnJhbWVzLCBwcm9wTmFtZSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgICAgICAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gICAgICAgIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuXG4gICAgICAgIHZhciB0cmFja0xlbiA9IGtleWZyYW1lcy5sZW5ndGg7XG4gICAgICAgIGlmICghdHJhY2tMZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHdWVzcyBkYXRhIHR5cGVcbiAgICAgICAgdmFyIGZpcnN0VmFsID0ga2V5ZnJhbWVzWzBdLnZhbHVlO1xuICAgICAgICB2YXIgaXNWYWx1ZUFycmF5ID0gaXNBcnJheUxpa2UoZmlyc3RWYWwpO1xuICAgICAgICB2YXIgaXNWYWx1ZUNvbG9yID0gZmFsc2U7XG4gICAgICAgIHZhciBpc1ZhbHVlU3RyaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG4gICAgICAgIHZhciBhcnJEaW0gPSAoXG4gICAgICAgICAgICAgICAgaXNWYWx1ZUFycmF5XG4gICAgICAgICAgICAgICAgJiYgaXNBcnJheUxpa2UoZmlyc3RWYWxbMF0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICA/IDIgOiAxO1xuICAgICAgICB2YXIgdHJhY2tNYXhUaW1lO1xuICAgICAgICAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuICAgICAgICBrZXlmcmFtZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS50aW1lIC0gYi50aW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICB0cmFja01heFRpbWUgPSBrZXlmcmFtZXNbdHJhY2tMZW4gLSAxXS50aW1lO1xuICAgICAgICAvLyBQZXJjZW50cyBvZiBlYWNoIGtleWZyYW1lXG4gICAgICAgIHZhciBrZlBlcmNlbnRzID0gW107XG4gICAgICAgIC8vIFZhbHVlIG9mIGVhY2gga2V5ZnJhbWVcbiAgICAgICAgdmFyIGtmVmFsdWVzID0gW107XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gICAgICAgIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7XG4gICAgICAgICAgICAvLyBBc3N1bWUgdmFsdWUgaXMgYSBjb2xvciB3aGVuIGl0IGlzIGEgc3RyaW5nXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlmcmFtZXNbaV0udmFsdWU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHZhbHVlIGlzIGVxdWFsLCBkZWVwIGNoZWNrIGlmIHZhbHVlIGlzIGFycmF5XG4gICAgICAgICAgICBpZiAoISgoaXNWYWx1ZUFycmF5ICYmIGlzQXJyYXlTYW1lKHZhbHVlLCBwcmV2VmFsdWUsIGFyckRpbSkpXG4gICAgICAgICAgICAgICAgfHwgKCFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxWYWx1ZUVxdWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBjb2xvciBhcnJheVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2xvckFycmF5ID0gY29sb3IucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FsbFZhbHVlRXF1YWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSBrZlZhbHVlc1t0cmFja0xlbiAtIDFdO1xuICAgICAgICAgICAgLy8gUG9seWZpbGwgYXJyYXlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaWxsQXJyKGtmVmFsdWVzW2ldLCBsYXN0VmFsdWUsIGFyckRpbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxsQXJyKGdldHRlcihhbmltYXRvci5fdGFyZ2V0LCBwcm9wTmFtZSksIGxhc3RWYWx1ZSwgYXJyRGltKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhY2hlIHRoZSBrZXkgb2YgbGFzdCBmcmFtZSB0byBzcGVlZCB1cCB3aGVuXG4gICAgICAgIC8vIGFuaW1hdGlvbiBwbGF5YmFjayBpcyBzZXF1ZW5jeVxuICAgICAgICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgICAgICAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQ7XG4gICAgICAgIHZhciB3O1xuICAgICAgICB2YXIgcDA7XG4gICAgICAgIHZhciBwMTtcbiAgICAgICAgdmFyIHAyO1xuICAgICAgICB2YXIgcDM7XG5cbiAgICAgICAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgICAgICAgICAgdmFyIHJnYmEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHJhbmdlIGtleWZyYW1lc1xuICAgICAgICAgICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAgICAgICAgIC8vIGZpbmQga2YyIGFuZCBrZjMgYW5kIGRvIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBmcmFtZTtcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgbGFzdEZyYW1lUGVyY2VudCkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgICAgICAgICAgICBzdGFydCA9IE1hdGgubWluKGxhc3RGcmFtZSArIDEsIHRyYWNrTGVuIC0gMSk7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IHN0YXJ0OyBmcmFtZSA+PSAwOyBmcmFtZS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZlBlcmNlbnRzW2ZyYW1lXSA8PSBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lLCB0cmFja0xlbiAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChmcmFtZSA9IGxhc3RGcmFtZTsgZnJhbWUgPCB0cmFja0xlbjsgZnJhbWUrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2ZQZXJjZW50c1tmcmFtZV0gPiBwZXJjZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFtZSA9IE1hdGgubWluKGZyYW1lIC0gMSwgdHJhY2tMZW4gLSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgICAgICAgICAgbGFzdEZyYW1lUGVyY2VudCA9IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IChrZlBlcmNlbnRzW2ZyYW1lICsgMV0gLSBrZlBlcmNlbnRzW2ZyYW1lXSk7XG4gICAgICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gKHBlcmNlbnQgLSBrZlBlcmNlbnRzW2ZyYW1lXSkgLyByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgICAgICAgICAgICBwMSA9IGtmVmFsdWVzW2ZyYW1lXTtcbiAgICAgICAgICAgICAgICBwMCA9IGtmVmFsdWVzW2ZyYW1lID09PSAwID8gZnJhbWUgOiBmcmFtZSAtIDFdO1xuICAgICAgICAgICAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgICAgICAgICAgIHAzID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDMgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICBwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhdG11bGxSb21JbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJnYmEsIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJnYmEyU3RyaW5nKHJnYmEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHdcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0dGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyckRpbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZUFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZ2JhLCAxXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJpbmcgaXMgc3RlcCgwLjUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaW50ZXJwb2xhdGVOdW1iZXIoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbGlwID0gbmV3IENsaXAoe1xuICAgICAgICAgICAgdGFyZ2V0OiBhbmltYXRvci5fdGFyZ2V0LFxuICAgICAgICAgICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgICAgICAgICAgbG9vcDogYW5pbWF0b3IuX2xvb3AsXG4gICAgICAgICAgICBkZWxheTogYW5pbWF0b3IuX2RlbGF5LFxuICAgICAgICAgICAgb25mcmFtZTogb25mcmFtZSxcbiAgICAgICAgICAgIG9uZGVzdHJveTogb25lVHJhY2tEb25lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlYXNpbmcgJiYgZWFzaW5nICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgY2xpcC5lYXNpbmcgPSBlYXNpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xpcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICAgICAqL1xuICAgIHZhciBBbmltYXRvciA9IGZ1bmN0aW9uKHRhcmdldCwgbG9vcCwgZ2V0dGVyLCBzZXR0ZXIpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tzID0ge307XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcblxuICAgICAgICB0aGlzLl9sb29wID0gbG9vcCB8fCBmYWxzZTtcblxuICAgICAgICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgICAgICAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG5cbiAgICAgICAgdGhpcy5fY2xpcENvdW50ID0gMDtcblxuICAgICAgICB0aGlzLl9kZWxheSA9IDA7XG5cbiAgICAgICAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcblxuICAgICAgICB0aGlzLl9vbmZyYW1lTGlzdCA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2NsaXBMaXN0ID0gW107XG4gICAgfTtcblxuICAgIEFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiuvue9ruWKqOeUu+WFs+mUruW4p1xuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRpbWUg5YWz6ZSu5bin5pe26Ze077yM5Y2V5L2N5pivbXNcbiAgICAgICAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wcyDlhbPplK7luKfnmoTlsZ7mgKflgLzvvIxrZXktdmFsdWXooajnpLpcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgd2hlbjogZnVuY3Rpb24odGltZSAvKiBtcyAqLywgcHJvcHMpIHtcbiAgICAgICAgICAgIHZhciB0cmFja3MgPSB0aGlzLl90cmFja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGlmICghdHJhY2tzW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja3NbcHJvcE5hbWVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRpbWUgaXMgMFxuICAgICAgICAgICAgICAgICAgICAvLyAgVGhlbiBwcm9wcyBpcyBnaXZlbiBpbml0aWFsaXplIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gIEluaXRpYWxpemUgdmFsdWUgZnJvbSBjdXJyZW50IHByb3AgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmVWYWx1ZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwcm9wc1twcm9wTmFtZV1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S75q+P5LiA5bin55qE5Zue6LCD5Ye95pWwXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkdXJpbmc6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fb25mcmFtZUxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBDbGVhciBhbGwgdHJhY2tzXG4gICAgICAgICAgICB0aGlzLl90cmFja3MgPSB7fTtcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCBjbGlwc1xuICAgICAgICAgICAgdGhpcy5fY2xpcExpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgICAgICAgICB2YXIgbGVuID0gZG9uZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlvIDlp4vmiafooYzliqjnlLtcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfEZ1bmN0aW9ufSBlYXNpbmdcbiAgICAgICAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChlYXNpbmcpIHtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIHZhciBvbmVUcmFja0RvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjbGlwQ291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kb25lQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgbGFzdENsaXA7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xpcCA9IGNyZWF0ZVRyYWNrQ2xpcChcbiAgICAgICAgICAgICAgICAgICAgdGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICBjbGlwQ291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG4gICAgICAgICAgICBpZiAobGFzdENsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkT25GcmFtZSA9IGxhc3RDbGlwLm9uZnJhbWU7XG4gICAgICAgICAgICAgICAgbGFzdENsaXAub25mcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHBlcmNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkT25GcmFtZSh0YXJnZXQsIHBlcmNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fb25mcmFtZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNsaXBDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLliqjnlLtcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgICAgICAgKi9cbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgIHZhciBjbGlwTGlzdCA9IHRoaXMuX2NsaXBMaXN0O1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjbGlwID0gY2xpcExpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZvcndhcmRUb0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBsYXN0IGZyYW1lIGJlZm9yZSBzdG9wXG4gICAgICAgICAgICAgICAgICAgIGNsaXAub25mcmFtZSh0aGlzLl90YXJnZXQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnJlbW92ZUNsaXAoY2xpcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog6K6+572u5Yqo55S75bu26L+f5byA5aeL55qE5pe26Ze0XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ID0gdGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICog5re75Yqg5Yqo55S757uT5p2f55qE5Zue6LCDXG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAgICAgICAqL1xuICAgICAgICBkb25lOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9uZUxpc3QucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcExpc3Q7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBBbmltYXRvcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWKqOeUu+S4u+aOp+WItuWZqFxuICogQGNvbmZpZyB0YXJnZXQg5Yqo55S75a+56LGh77yM5Y+v5Lul5piv5pWw57uE77yM5aaC5p6c5piv5pWw57uE55qE6K+d5Lya5om56YeP5YiG5Y+Rb25mcmFtZeetieS6i+S7tlxuICogQGNvbmZpZyBsaWZlKDEwMDApIOWKqOeUu+aXtumVv1xuICogQGNvbmZpZyBkZWxheSgwKSDliqjnlLvlu7bov5/ml7bpl7RcbiAqIEBjb25maWcgbG9vcCh0cnVlKVxuICogQGNvbmZpZyBnYXAoMCkg5b6q546v55qE6Ze06ZqU5pe26Ze0XG4gKiBAY29uZmlnIG9uZnJhbWVcbiAqIEBjb25maWcgZWFzaW5nKG9wdGlvbmFsKVxuICogQGNvbmZpZyBvbmRlc3Ryb3kob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9ucmVzdGFydChvcHRpb25hbClcbiAqXG4gKiBUT0RPIHBhdXNlXG4gKi9cblxuXG4gICAgdmFyIGVhc2luZ0Z1bmNzID0gcmVxdWlyZSgnLi9lYXNpbmcnKTtcblxuICAgIGZ1bmN0aW9uIENsaXAob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuXG4gICAgICAgIC8vIOeUn+WRveWRqOacn1xuICAgICAgICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7XG4gICAgICAgIC8vIOW7tuaXtlxuICAgICAgICB0aGlzLl9kZWxheSA9IG9wdGlvbnMuZGVsYXkgfHwgMDtcbiAgICAgICAgLy8g5byA5aeL5pe26Ze0XG4gICAgICAgIC8vIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5fZGVsYXk7Ly8g5Y2V5L2N5q+r56eSXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8g5piv5ZCm5b6q546vXG4gICAgICAgIHRoaXMubG9vcCA9IG9wdGlvbnMubG9vcCA9PSBudWxsID8gZmFsc2UgOiBvcHRpb25zLmxvb3A7XG5cbiAgICAgICAgdGhpcy5nYXAgPSBvcHRpb25zLmdhcCB8fCAwO1xuXG4gICAgICAgIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG5cbiAgICAgICAgdGhpcy5vbmZyYW1lID0gb3B0aW9ucy5vbmZyYW1lO1xuICAgICAgICB0aGlzLm9uZGVzdHJveSA9IG9wdGlvbnMub25kZXN0cm95O1xuICAgICAgICB0aGlzLm9ucmVzdGFydCA9IG9wdGlvbnMub25yZXN0YXJ0O1xuICAgIH1cblxuICAgIENsaXAucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBDbGlwLFxuXG4gICAgICAgIHN0ZXA6IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAgICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHRoaXMuX2RlbGF5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSAodGltZSAtIHRoaXMuX3N0YXJ0VGltZSkgLyB0aGlzLl9saWZlO1xuXG4gICAgICAgICAgICAvLyDov5jmsqHlvIDlp4tcbiAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuXG4gICAgICAgICAgICB2YXIgZWFzaW5nID0gdGhpcy5lYXNpbmc7XG4gICAgICAgICAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT0gJ3N0cmluZycgPyBlYXNpbmdGdW5jc1tlYXNpbmddIDogZWFzaW5nO1xuICAgICAgICAgICAgdmFyIHNjaGVkdWxlID0gdHlwZW9mIGVhc2luZ0Z1bmMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IGVhc2luZ0Z1bmMocGVyY2VudClcbiAgICAgICAgICAgICAgICA6IHBlcmNlbnQ7XG5cbiAgICAgICAgICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7XG5cbiAgICAgICAgICAgIC8vIOe7k+adn1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOmHjeaWsOW8gOWni+WRqOacn1xuICAgICAgICAgICAgICAgICAgICAvLyDmipvlh7rogIzkuI3mmK/nm7TmjqXosIPnlKjkuovku7bnm7TliLAgc3RhZ2UudXBkYXRlIOWQjuWGjee7n+S4gOiwg+eUqOi/meS6m+S6i+S7tlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOWKqOeUu+WujOaIkOWwhui/meS4quaOp+WItuWZqOagh+ivhuS4uuW+heWIoOmZpFxuICAgICAgICAgICAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkZXN0cm95JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHJlbWFpbmRlciA9ICh0aW1lIC0gdGhpcy5fc3RhcnRUaW1lKSAlIHRoaXMuX2xpZmU7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHJlbWFpbmRlciArIHRoaXMuZ2FwO1xuXG4gICAgICAgICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSAnb24nICsgZXZlbnRUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGlwO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQ2xpcC5qc1xuICoqIG1vZHVsZSBpZCA9IDIxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xuXG4gICAgdmFyIGVhc2luZyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogKDIgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGN1YmljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY3ViaWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5Zub5qyh5pa555qE57yT5Yqo77yIdF4077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtICgtLWsgKiBrICogayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgcXVhcnRpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0wLjUgKiAoKGsgLT0gMikgKiBrICogayAqIGsgLSAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHF1aW50aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBxdWludGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogayAqIGsgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDmraPlvKbmm7Lnur/nmoTnvJPliqjvvIhzaW4odCnvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAxIC0gTWF0aC5jb3MoayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oayAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5oyH5pWw5puy57q/55qE57yT5Yqo77yIMl5077yJXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIGsgPT09IDAgPyAwIDogTWF0aC5wb3coMTAyNCwgayAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZXhwb25lbnRpYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gayA9PT0gMSA/IDEgOiAxIC0gTWF0aC5wb3coMiwgLTEwICogayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBleHBvbmVudGlhbEluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIE1hdGgucG93KDEwMjQsIGsgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChrIC0gMSkpICsgMik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGNpcmN1bGFySW46IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAoLS1rICogaykpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChNYXRoLnNxcnQoMSAtIChrIC09IDIpICogaykgKyAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rnsbvkvLzkuo7lvLnnsKflnKjlgZzmraLliY3mnaXlm57mjK/ojaHnmoTliqjnlLtcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGVsYXN0aWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzO1xuICAgICAgICAgICAgdmFyIGEgPSAwLjE7XG4gICAgICAgICAgICB2YXIgcCA9IDAuNDtcbiAgICAgICAgICAgIGlmIChrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhIHx8IGEgPCAxKSB7XG4gICAgICAgICAgICAgICAgYSA9IDE7IHMgPSBwIC8gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLShhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAqL1xuICAgICAgICBlbGFzdGljT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoYSAqIE1hdGgucG93KDIsIC0xMCAqIGspICpcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSArIDEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgZWxhc3RpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHM7XG4gICAgICAgICAgICB2YXIgYSA9IDAuMTtcbiAgICAgICAgICAgIHZhciBwID0gMC40O1xuICAgICAgICAgICAgaWYgKGsgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgICAgICAgICAgICBhID0gMTsgcyA9IHAgLyA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyA9IHAgKiBNYXRoLmFzaW4oMSAvIGEpIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTAuNSAqIChhICogTWF0aC5wb3coMiwgMTAgKiAoayAtPSAxKSlcbiAgICAgICAgICAgICAgICAgICAgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpXG4gICAgICAgICAgICAgICAgICAgICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDlnKjmn5DkuIDliqjnlLvlvIDlp4vmsr/mjIfnpLrnmoTot6/lvoTov5vooYzliqjnlLvlpITnkIbliY3nqI3nqI3mlLblm57or6XliqjnlLvnmoTnp7vliqhcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiBrICogayAqICgocyArIDEpICogayAtIHMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja091dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciBzID0gMS43MDE1ODtcbiAgICAgICAgICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgKi9cbiAgICAgICAgYmFja0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgICAgICAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqIChrICogayAqICgocyArIDEpICogayAtIHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDliJvlu7rlvLnot7PmlYjmnpxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgcmV0dXJuIDEgLSBlYXNpbmcuYm91bmNlT3V0KDEgLSBrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrIDwgKDEgLyAyLjc1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMiAvIDIuNzUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgxLjUgLyAyLjc1KSkgKiBrICsgMC43NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGsgPCAoMi41IC8gMi43NSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gKDIuMjUgLyAyLjc1KSkgKiBrICsgMC45Mzc1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09ICgyLjYyNSAvIDIuNzUpKSAqIGsgKyAwLjk4NDM3NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICovXG4gICAgICAgIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBlYXNpbmc7XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci90b29sL2NvbG9yXG4gKi9cblxuXG4gICAgdmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAgICAgICAndHJhbnNwYXJlbnQnOiBbMCwwLDAsMF0sICdhbGljZWJsdWUnOiBbMjQwLDI0OCwyNTUsMV0sXG4gICAgICAgICdhbnRpcXVld2hpdGUnOiBbMjUwLDIzNSwyMTUsMV0sICdhcXVhJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2FxdWFtYXJpbmUnOiBbMTI3LDI1NSwyMTIsMV0sICdhenVyZSc6IFsyNDAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2JlaWdlJzogWzI0NSwyNDUsMjIwLDFdLCAnYmlzcXVlJzogWzI1NSwyMjgsMTk2LDFdLFxuICAgICAgICAnYmxhY2snOiBbMCwwLDAsMV0sICdibGFuY2hlZGFsbW9uZCc6IFsyNTUsMjM1LDIwNSwxXSxcbiAgICAgICAgJ2JsdWUnOiBbMCwwLDI1NSwxXSwgJ2JsdWV2aW9sZXQnOiBbMTM4LDQzLDIyNiwxXSxcbiAgICAgICAgJ2Jyb3duJzogWzE2NSw0Miw0MiwxXSwgJ2J1cmx5d29vZCc6IFsyMjIsMTg0LDEzNSwxXSxcbiAgICAgICAgJ2NhZGV0Ymx1ZSc6IFs5NSwxNTgsMTYwLDFdLCAnY2hhcnRyZXVzZSc6IFsxMjcsMjU1LDAsMV0sXG4gICAgICAgICdjaG9jb2xhdGUnOiBbMjEwLDEwNSwzMCwxXSwgJ2NvcmFsJzogWzI1NSwxMjcsODAsMV0sXG4gICAgICAgICdjb3JuZmxvd2VyYmx1ZSc6IFsxMDAsMTQ5LDIzNywxXSwgJ2Nvcm5zaWxrJzogWzI1NSwyNDgsMjIwLDFdLFxuICAgICAgICAnY3JpbXNvbic6IFsyMjAsMjAsNjAsMV0sICdjeWFuJzogWzAsMjU1LDI1NSwxXSxcbiAgICAgICAgJ2RhcmtibHVlJzogWzAsMCwxMzksMV0sICdkYXJrY3lhbic6IFswLDEzOSwxMzksMV0sXG4gICAgICAgICdkYXJrZ29sZGVucm9kJzogWzE4NCwxMzQsMTEsMV0sICdkYXJrZ3JheSc6IFsxNjksMTY5LDE2OSwxXSxcbiAgICAgICAgJ2RhcmtncmVlbic6IFswLDEwMCwwLDFdLCAnZGFya2dyZXknOiBbMTY5LDE2OSwxNjksMV0sXG4gICAgICAgICdkYXJra2hha2knOiBbMTg5LDE4MywxMDcsMV0sICdkYXJrbWFnZW50YSc6IFsxMzksMCwxMzksMV0sXG4gICAgICAgICdkYXJrb2xpdmVncmVlbic6IFs4NSwxMDcsNDcsMV0sICdkYXJrb3JhbmdlJzogWzI1NSwxNDAsMCwxXSxcbiAgICAgICAgJ2RhcmtvcmNoaWQnOiBbMTUzLDUwLDIwNCwxXSwgJ2RhcmtyZWQnOiBbMTM5LDAsMCwxXSxcbiAgICAgICAgJ2RhcmtzYWxtb24nOiBbMjMzLDE1MCwxMjIsMV0sICdkYXJrc2VhZ3JlZW4nOiBbMTQzLDE4OCwxNDMsMV0sXG4gICAgICAgICdkYXJrc2xhdGVibHVlJzogWzcyLDYxLDEzOSwxXSwgJ2RhcmtzbGF0ZWdyYXknOiBbNDcsNzksNzksMV0sXG4gICAgICAgICdkYXJrc2xhdGVncmV5JzogWzQ3LDc5LDc5LDFdLCAnZGFya3R1cnF1b2lzZSc6IFswLDIwNiwyMDksMV0sXG4gICAgICAgICdkYXJrdmlvbGV0JzogWzE0OCwwLDIxMSwxXSwgJ2RlZXBwaW5rJzogWzI1NSwyMCwxNDcsMV0sXG4gICAgICAgICdkZWVwc2t5Ymx1ZSc6IFswLDE5MSwyNTUsMV0sICdkaW1ncmF5JzogWzEwNSwxMDUsMTA1LDFdLFxuICAgICAgICAnZGltZ3JleSc6IFsxMDUsMTA1LDEwNSwxXSwgJ2RvZGdlcmJsdWUnOiBbMzAsMTQ0LDI1NSwxXSxcbiAgICAgICAgJ2ZpcmVicmljayc6IFsxNzgsMzQsMzQsMV0sICdmbG9yYWx3aGl0ZSc6IFsyNTUsMjUwLDI0MCwxXSxcbiAgICAgICAgJ2ZvcmVzdGdyZWVuJzogWzM0LDEzOSwzNCwxXSwgJ2Z1Y2hzaWEnOiBbMjU1LDAsMjU1LDFdLFxuICAgICAgICAnZ2FpbnNib3JvJzogWzIyMCwyMjAsMjIwLDFdLCAnZ2hvc3R3aGl0ZSc6IFsyNDgsMjQ4LDI1NSwxXSxcbiAgICAgICAgJ2dvbGQnOiBbMjU1LDIxNSwwLDFdLCAnZ29sZGVucm9kJzogWzIxOCwxNjUsMzIsMV0sXG4gICAgICAgICdncmF5JzogWzEyOCwxMjgsMTI4LDFdLCAnZ3JlZW4nOiBbMCwxMjgsMCwxXSxcbiAgICAgICAgJ2dyZWVueWVsbG93JzogWzE3MywyNTUsNDcsMV0sICdncmV5JzogWzEyOCwxMjgsMTI4LDFdLFxuICAgICAgICAnaG9uZXlkZXcnOiBbMjQwLDI1NSwyNDAsMV0sICdob3RwaW5rJzogWzI1NSwxMDUsMTgwLDFdLFxuICAgICAgICAnaW5kaWFucmVkJzogWzIwNSw5Miw5MiwxXSwgJ2luZGlnbyc6IFs3NSwwLDEzMCwxXSxcbiAgICAgICAgJ2l2b3J5JzogWzI1NSwyNTUsMjQwLDFdLCAna2hha2knOiBbMjQwLDIzMCwxNDAsMV0sXG4gICAgICAgICdsYXZlbmRlcic6IFsyMzAsMjMwLDI1MCwxXSwgJ2xhdmVuZGVyYmx1c2gnOiBbMjU1LDI0MCwyNDUsMV0sXG4gICAgICAgICdsYXduZ3JlZW4nOiBbMTI0LDI1MiwwLDFdLCAnbGVtb25jaGlmZm9uJzogWzI1NSwyNTAsMjA1LDFdLFxuICAgICAgICAnbGlnaHRibHVlJzogWzE3MywyMTYsMjMwLDFdLCAnbGlnaHRjb3JhbCc6IFsyNDAsMTI4LDEyOCwxXSxcbiAgICAgICAgJ2xpZ2h0Y3lhbic6IFsyMjQsMjU1LDI1NSwxXSwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogWzI1MCwyNTAsMjEwLDFdLFxuICAgICAgICAnbGlnaHRncmF5JzogWzIxMSwyMTEsMjExLDFdLCAnbGlnaHRncmVlbic6IFsxNDQsMjM4LDE0NCwxXSxcbiAgICAgICAgJ2xpZ2h0Z3JleSc6IFsyMTEsMjExLDIxMSwxXSwgJ2xpZ2h0cGluayc6IFsyNTUsMTgyLDE5MywxXSxcbiAgICAgICAgJ2xpZ2h0c2FsbW9uJzogWzI1NSwxNjAsMTIyLDFdLCAnbGlnaHRzZWFncmVlbic6IFszMiwxNzgsMTcwLDFdLFxuICAgICAgICAnbGlnaHRza3libHVlJzogWzEzNSwyMDYsMjUwLDFdLCAnbGlnaHRzbGF0ZWdyYXknOiBbMTE5LDEzNiwxNTMsMV0sXG4gICAgICAgICdsaWdodHNsYXRlZ3JleSc6IFsxMTksMTM2LDE1MywxXSwgJ2xpZ2h0c3RlZWxibHVlJzogWzE3NiwxOTYsMjIyLDFdLFxuICAgICAgICAnbGlnaHR5ZWxsb3cnOiBbMjU1LDI1NSwyMjQsMV0sICdsaW1lJzogWzAsMjU1LDAsMV0sXG4gICAgICAgICdsaW1lZ3JlZW4nOiBbNTAsMjA1LDUwLDFdLCAnbGluZW4nOiBbMjUwLDI0MCwyMzAsMV0sXG4gICAgICAgICdtYWdlbnRhJzogWzI1NSwwLDI1NSwxXSwgJ21hcm9vbic6IFsxMjgsMCwwLDFdLFxuICAgICAgICAnbWVkaXVtYXF1YW1hcmluZSc6IFsxMDIsMjA1LDE3MCwxXSwgJ21lZGl1bWJsdWUnOiBbMCwwLDIwNSwxXSxcbiAgICAgICAgJ21lZGl1bW9yY2hpZCc6IFsxODYsODUsMjExLDFdLCAnbWVkaXVtcHVycGxlJzogWzE0NywxMTIsMjE5LDFdLFxuICAgICAgICAnbWVkaXVtc2VhZ3JlZW4nOiBbNjAsMTc5LDExMywxXSwgJ21lZGl1bXNsYXRlYmx1ZSc6IFsxMjMsMTA0LDIzOCwxXSxcbiAgICAgICAgJ21lZGl1bXNwcmluZ2dyZWVuJzogWzAsMjUwLDE1NCwxXSwgJ21lZGl1bXR1cnF1b2lzZSc6IFs3MiwyMDksMjA0LDFdLFxuICAgICAgICAnbWVkaXVtdmlvbGV0cmVkJzogWzE5OSwyMSwxMzMsMV0sICdtaWRuaWdodGJsdWUnOiBbMjUsMjUsMTEyLDFdLFxuICAgICAgICAnbWludGNyZWFtJzogWzI0NSwyNTUsMjUwLDFdLCAnbWlzdHlyb3NlJzogWzI1NSwyMjgsMjI1LDFdLFxuICAgICAgICAnbW9jY2FzaW4nOiBbMjU1LDIyOCwxODEsMV0sICduYXZham93aGl0ZSc6IFsyNTUsMjIyLDE3MywxXSxcbiAgICAgICAgJ25hdnknOiBbMCwwLDEyOCwxXSwgJ29sZGxhY2UnOiBbMjUzLDI0NSwyMzAsMV0sXG4gICAgICAgICdvbGl2ZSc6IFsxMjgsMTI4LDAsMV0sICdvbGl2ZWRyYWInOiBbMTA3LDE0MiwzNSwxXSxcbiAgICAgICAgJ29yYW5nZSc6IFsyNTUsMTY1LDAsMV0sICdvcmFuZ2VyZWQnOiBbMjU1LDY5LDAsMV0sXG4gICAgICAgICdvcmNoaWQnOiBbMjE4LDExMiwyMTQsMV0sICdwYWxlZ29sZGVucm9kJzogWzIzOCwyMzIsMTcwLDFdLFxuICAgICAgICAncGFsZWdyZWVuJzogWzE1MiwyNTEsMTUyLDFdLCAncGFsZXR1cnF1b2lzZSc6IFsxNzUsMjM4LDIzOCwxXSxcbiAgICAgICAgJ3BhbGV2aW9sZXRyZWQnOiBbMjE5LDExMiwxNDcsMV0sICdwYXBheWF3aGlwJzogWzI1NSwyMzksMjEzLDFdLFxuICAgICAgICAncGVhY2hwdWZmJzogWzI1NSwyMTgsMTg1LDFdLCAncGVydSc6IFsyMDUsMTMzLDYzLDFdLFxuICAgICAgICAncGluayc6IFsyNTUsMTkyLDIwMywxXSwgJ3BsdW0nOiBbMjIxLDE2MCwyMjEsMV0sXG4gICAgICAgICdwb3dkZXJibHVlJzogWzE3NiwyMjQsMjMwLDFdLCAncHVycGxlJzogWzEyOCwwLDEyOCwxXSxcbiAgICAgICAgJ3JlZCc6IFsyNTUsMCwwLDFdLCAncm9zeWJyb3duJzogWzE4OCwxNDMsMTQzLDFdLFxuICAgICAgICAncm95YWxibHVlJzogWzY1LDEwNSwyMjUsMV0sICdzYWRkbGVicm93bic6IFsxMzksNjksMTksMV0sXG4gICAgICAgICdzYWxtb24nOiBbMjUwLDEyOCwxMTQsMV0sICdzYW5keWJyb3duJzogWzI0NCwxNjQsOTYsMV0sXG4gICAgICAgICdzZWFncmVlbic6IFs0NiwxMzksODcsMV0sICdzZWFzaGVsbCc6IFsyNTUsMjQ1LDIzOCwxXSxcbiAgICAgICAgJ3NpZW5uYSc6IFsxNjAsODIsNDUsMV0sICdzaWx2ZXInOiBbMTkyLDE5MiwxOTIsMV0sXG4gICAgICAgICdza3libHVlJzogWzEzNSwyMDYsMjM1LDFdLCAnc2xhdGVibHVlJzogWzEwNiw5MCwyMDUsMV0sXG4gICAgICAgICdzbGF0ZWdyYXknOiBbMTEyLDEyOCwxNDQsMV0sICdzbGF0ZWdyZXknOiBbMTEyLDEyOCwxNDQsMV0sXG4gICAgICAgICdzbm93JzogWzI1NSwyNTAsMjUwLDFdLCAnc3ByaW5nZ3JlZW4nOiBbMCwyNTUsMTI3LDFdLFxuICAgICAgICAnc3RlZWxibHVlJzogWzcwLDEzMCwxODAsMV0sICd0YW4nOiBbMjEwLDE4MCwxNDAsMV0sXG4gICAgICAgICd0ZWFsJzogWzAsMTI4LDEyOCwxXSwgJ3RoaXN0bGUnOiBbMjE2LDE5MSwyMTYsMV0sXG4gICAgICAgICd0b21hdG8nOiBbMjU1LDk5LDcxLDFdLCAndHVycXVvaXNlJzogWzY0LDIyNCwyMDgsMV0sXG4gICAgICAgICd2aW9sZXQnOiBbMjM4LDEzMCwyMzgsMV0sICd3aGVhdCc6IFsyNDUsMjIyLDE3OSwxXSxcbiAgICAgICAgJ3doaXRlJzogWzI1NSwyNTUsMjU1LDFdLCAnd2hpdGVzbW9rZSc6IFsyNDUsMjQ1LDI0NSwxXSxcbiAgICAgICAgJ3llbGxvdyc6IFsyNTUsMjU1LDAsMV0sICd5ZWxsb3dncmVlbic6IFsxNTQsMjA1LDUwLDFdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NBbmdsZShpKSB7ICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICAgICAgICBpID0gTWF0aC5yb3VuZChpKTsgIC8vIFNlZW1zIHRvIGJlIHdoYXQgQ2hyb21lIGRvZXMgKHZzIHRydW5jYXRpb24pLlxuICAgICAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDM2MCA/IDM2MCA6IGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xhbXBDc3NGbG9hdChmKSB7ICAvLyBDbGFtcCB0byBmbG9hdCAwLjAgLi4gMS4wLlxuICAgICAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNzc0ludChzdHIpIHsgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhbXBDc3NCeXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzQnl0ZShwYXJzZUludChzdHIsIDEwKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VDc3NGbG9hdChzdHIpIHsgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIGlmIChzdHIubGVuZ3RoICYmIHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIDEpID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSAvIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjc3NIdWVUb1JnYihtMSwgbTIsIGgpIHtcbiAgICAgICAgaWYgKGggPCAwKSB7XG4gICAgICAgICAgICBoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgIGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoICogNiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoICogMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBtMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaCAqIDMgPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMi8zIC0gaCkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsZXJwKGEsIGIsIHApIHtcbiAgICAgICAgcmV0dXJuIGEgKyAoYiAtIGEpICogcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JTdHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlKGNvbG9yU3RyKSB7XG4gICAgICAgIGlmICghY29sb3JTdHIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xvclN0ciBtYXkgYmUgbm90IHN0cmluZ1xuICAgICAgICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuICAgICAgICB2YXIgc3RyID0gY29sb3JTdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG4gICAgICAgIGlmIChzdHIgaW4ga0NTU0NvbG9yVGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBrQ1NTQ29sb3JUYWJsZVtzdHJdLnNsaWNlKCk7ICAvLyBkdXAuXG4gICAgICAgIH1cblxuICAgICAgICAvLyAjYWJjIGFuZCAjYWJjMTIzIHN5bnRheC5cbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7ICAvLyBUT0RPKGRlYW5tKTogU3RyaWN0ZXIgcGFyc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAvLyBDb3ZlcnMgTmFOLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAoKGl2ICYgMHhmMDApID4+IDQpIHwgKChpdiAmIDB4ZjAwKSA+PiA4KSxcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmMCkgfCAoKGl2ICYgMHhmMCkgPj4gNCksXG4gICAgICAgICAgICAgICAgICAgIChpdiAmIDB4ZikgfCAoKGl2ICYgMHhmKSA8PCA0KSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl2ID0gcGFyc2VJbnQoc3RyLnN1YnN0cigxKSwgMTYpOyAgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAgLy8gQ292ZXJzIE5hTi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgKGl2ICYgMHhmZjAwMDApID4+IDE2LFxuICAgICAgICAgICAgICAgICAgICAoaXYgJiAweGZmMDApID4+IDgsXG4gICAgICAgICAgICAgICAgICAgIGl2ICYgMHhmZixcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLCBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG4gICAgICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IDE7ICAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuICAgICAgICAgICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gcGFyc2VDc3NGbG9hdChwYXJhbXMucG9wKCkpOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2guXG4gICAgICAgICAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VDc3NJbnQocGFyYW1zWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlQ3NzSW50KHBhcmFtc1sxXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUNzc0ludChwYXJhbXNbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGFcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoc2xhMnJnYmEocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoc2xhMnJnYmEocGFyYW1zKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaHNsYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gICAgICovXG4gICAgZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEpIHtcbiAgICAgICAgdmFyIGggPSAoKChwYXJzZUZsb2F0KGhzbGFbMF0pICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwOyAgLy8gMCAuLiAxXG4gICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgICAgIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgICAgICAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcblxuICAgICAgICB2YXIgcmdiYSA9IFtcbiAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGggKyAxIC8gMykgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkgKiAyNTUpLFxuICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSlcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoaHNsYS5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJnYmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmdiYTJoc2xhKHJnYmEpIHtcbiAgICAgICAgaWYgKCFyZ2JhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSR0IgZnJvbSAwIHRvIDI1NVxuICAgICAgICB2YXIgUiA9IHJnYmFbMF0gLyAyNTU7XG4gICAgICAgIHZhciBHID0gcmdiYVsxXSAvIDI1NTtcbiAgICAgICAgdmFyIEIgPSByZ2JhWzJdIC8gMjU1O1xuXG4gICAgICAgIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoUiwgRywgQik7IC8vIE1heC4gdmFsdWUgb2YgUkdCXG4gICAgICAgIHZhciBkZWx0YSA9IHZNYXggLSB2TWluOyAvLyBEZWx0YSBSR0IgdmFsdWVcblxuICAgICAgICB2YXIgTCA9ICh2TWF4ICsgdk1pbikgLyAyO1xuICAgICAgICB2YXIgSDtcbiAgICAgICAgdmFyIFM7XG4gICAgICAgIC8vIEhTTCByZXN1bHRzIGZyb20gMCB0byAxXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgICAgICAgSCA9IDA7XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChMIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgUyA9IGRlbHRhIC8gKHZNYXggKyB2TWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFMgPSBkZWx0YSAvICgyIC0gdk1heCAtIHZNaW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGVsdGFSID0gKCgodk1heCAtIFIpIC8gNikgKyAoZGVsdGEgLyAyKSkgLyBkZWx0YTtcbiAgICAgICAgICAgIHZhciBkZWx0YUcgPSAoKCh2TWF4IC0gRykgLyA2KSArIChkZWx0YSAvIDIpKSAvIGRlbHRhO1xuICAgICAgICAgICAgdmFyIGRlbHRhQiA9ICgoKHZNYXggLSBCKSAvIDYpICsgKGRlbHRhIC8gMikpIC8gZGVsdGE7XG5cbiAgICAgICAgICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICAgICAgICAgICAgSCA9IGRlbHRhQiAtIGRlbHRhRztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEcgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDEgLyAzKSArIGRlbHRhUiAtIGRlbHRhQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEIgPT09IHZNYXgpIHtcbiAgICAgICAgICAgICAgICBIID0gKDIgLyAzKSArIGRlbHRhRyAtIGRlbHRhUjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgICAgICAgICAgSCArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoSCA+IDEpIHtcbiAgICAgICAgICAgICAgICBIIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHNsYSA9IFtIICogMzYwLCBTLCBMXTtcblxuICAgICAgICBpZiAocmdiYVszXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaHNsYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yQXJyW2ldID0gY29sb3JBcnJbaV0gKiAoMSAtIGxldmVsKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvckFycltpXSA9ICgoMjU1IC0gY29sb3JBcnJbaV0pICogbGV2ZWwgKyBjb2xvckFycltpXSkgfCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoY29sb3JBcnIsIGNvbG9yQXJyLmxlbmd0aCA9PT0gNCA/ICdyZ2JhJyA6ICdyZ2InKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSGV4KGNvbG9yLCBsZXZlbCkge1xuICAgICAgICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG4gICAgICAgIGlmIChjb2xvckFycikge1xuICAgICAgICAgICAgcmV0dXJuICgoMSA8PCAyNCkgKyAoY29sb3JBcnJbMF0gPDwgMTYpICsgKGNvbG9yQXJyWzFdIDw8IDgpICsgKCtjb2xvckFyclsyXSkpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcCB2YWx1ZSB0byBjb2xvci4gRmFzdGVyIHRoYW4gbWFwVG9Db2xvciBtZXRob2RzIGJlY2F1c2UgY29sb3IgaXMgcmVwcmVzZW50ZWQgYnkgcmdiYSBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkVmFsdWUgQSBmbG9hdCBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0gTWFwcGVkIGdiYSBjb2xvciBhcnJheVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZhc3RNYXBUb0NvbG9yKG5vcm1hbGl6ZWRWYWx1ZSwgY29sb3JzLCBvdXQpIHtcbiAgICAgICAgaWYgKCEoY29sb3JzICYmIGNvbG9ycy5sZW5ndGgpXG4gICAgICAgICAgICB8fCAhKG5vcm1hbGl6ZWRWYWx1ZSA+PSAwICYmIG5vcm1hbGl6ZWRWYWx1ZSA8PSAxKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgPSBvdXQgfHwgWzAsIDAsIDAsIDBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgICAgICAgdmFyIGxlZnRDb2xvciA9IGNvbG9yc1tsZWZ0SW5kZXhdO1xuICAgICAgICB2YXIgcmlnaHRDb2xvciA9IGNvbG9yc1tyaWdodEluZGV4XTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG4gICAgICAgIG91dFswXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKTtcbiAgICAgICAgb3V0WzFdID0gY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzFdLCByaWdodENvbG9yWzFdLCBkdikpO1xuICAgICAgICBvdXRbMl0gPSBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMl0sIHJpZ2h0Q29sb3JbMl0sIGR2KSk7XG4gICAgICAgIG91dFszXSA9IGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRWYWx1ZSBBIGZsb2F0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gICAgICogQHJldHVybiB7KHN0cmluZ3xPYmplY3QpfSBSZXN1bHQgY29sb3IuIElmIGZ1bGxPdXRwdXQsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge2NvbG9yOiAuLi4sIGxlZnRJbmRleDogLi4uLCByaWdodEluZGV4OiAuLi4sIHZhbHVlOiAuLi59LFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVG9Db2xvcihub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICAgICAgICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aClcbiAgICAgICAgICAgIHx8ICEobm9ybWFsaXplZFZhbHVlID49IDAgJiYgbm9ybWFsaXplZFZhbHVlIDw9IDEpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplZFZhbHVlICogKGNvbG9ycy5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIGxlZnRJbmRleCA9IE1hdGguZmxvb3IodmFsdWUpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIHZhciBsZWZ0Q29sb3IgPSBwYXJzZShjb2xvcnNbbGVmdEluZGV4XSk7XG4gICAgICAgIHZhciByaWdodENvbG9yID0gcGFyc2UoY29sb3JzW3JpZ2h0SW5kZXhdKTtcbiAgICAgICAgdmFyIGR2ID0gdmFsdWUgLSBsZWZ0SW5kZXg7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGNsYW1wQ3NzQnl0ZShsZXJwKGxlZnRDb2xvclswXSwgcmlnaHRDb2xvclswXSwgZHYpKSxcbiAgICAgICAgICAgICAgICBjbGFtcENzc0J5dGUobGVycChsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSksXG4gICAgICAgICAgICAgICAgY2xhbXBDc3NCeXRlKGxlcnAobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLFxuICAgICAgICAgICAgICAgIGNsYW1wQ3NzRmxvYXQobGVycChsZWZ0Q29sb3JbM10sIHJpZ2h0Q29sb3JbM10sIGR2KSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAncmdiYSdcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZnVsbE91dHB1dFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaW50ZXJ2YWwgIEFycmF5IGxlbmd0aCA9PT0gMixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGl0ZW0gaXMgbm9ybWFsaXplZCB2YWx1ZSAoWzAsIDFdKS5cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBjb2xvcnMgQ29sb3IgbGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0Pn0gY29sb3JzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGludGVydmFsLFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoIGl0ZW0gaXMge2NvbG9yOiAneHh4Jywgb2Zmc2V0OiAuLi59XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHdoZXJlIG9mZnNldCBpcyBiZXR3ZWVuIDAgYW5kIDEuXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBJbnRlcnZhbFRvQ29sb3IoaW50ZXJ2YWwsIGNvbG9ycykge1xuICAgICAgICBpZiAoaW50ZXJ2YWwubGVuZ3RoICE9PSAyIHx8IGludGVydmFsWzFdIDwgaW50ZXJ2YWxbMF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvMCA9IG1hcFRvQ29sb3IoaW50ZXJ2YWxbMF0sIGNvbG9ycywgdHJ1ZSk7XG4gICAgICAgIHZhciBpbmZvMSA9IG1hcFRvQ29sb3IoaW50ZXJ2YWxbMV0sIGNvbG9ycywgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFt7Y29sb3I6IGluZm8wLmNvbG9yLCBvZmZzZXQ6IDB9XTtcblxuICAgICAgICB2YXIgZHVyaW5nID0gaW5mbzEudmFsdWUgLSBpbmZvMC52YWx1ZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoaW5mbzAudmFsdWUsIGluZm8wLnJpZ2h0SW5kZXgpO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4oaW5mbzEudmFsdWUsIGluZm8xLmxlZnRJbmRleCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBkdXJpbmcgPiAwICYmIGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2ldLFxuICAgICAgICAgICAgICAgIG9mZnNldDogKGkgLSBpbmZvMC52YWx1ZSkgLyBkdXJpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHtjb2xvcjogaW5mbzEuY29sb3IsIG9mZnNldDogMX0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBoIDAgfiAzNjAsIGlnbm9yZSB3aGVuIG51bGwuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBzIDAgfiAxLCBpZ25vcmUgd2hlbiBudWxsLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbG9yIHN0cmluZyBpbiByZ2JhIGZvcm1hdC5cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvdXRpbC9jb2xvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vZGlmeUhTTChjb2xvciwgaCwgcywgbCkge1xuICAgICAgICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGNvbG9yID0gcmdiYTJoc2xhKGNvbG9yKTtcbiAgICAgICAgICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICAgICAgICAgIHMgIT0gbnVsbCAmJiAoY29sb3JbMV0gPSBwYXJzZUNzc0Zsb2F0KHMpKTtcbiAgICAgICAgICAgIGwgIT0gbnVsbCAmJiAoY29sb3JbMl0gPSBwYXJzZUNzc0Zsb2F0KGwpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShoc2xhMnJnYmEoY29sb3IpLCAncmdiYScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSBhbHBoYSAwIH4gMVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5QWxwaGEoY29sb3IsIGFscGhhKSB7XG4gICAgICAgIGNvbG9yID0gcGFyc2UoY29sb3IpO1xuXG4gICAgICAgIGlmIChjb2xvciAmJiBhbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb2xvclszXSA9IGNsYW1wQ3NzRmxvYXQoYWxwaGEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGNvbG9ycyBDb2xvciBsaXN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlICdyZ2JhJywgJ2hzdmEnLCAuLi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpbmdpZnkoYXJyQ29sb3IsIHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyZ2InIHx8IHR5cGUgPT09ICdoc3YnIHx8IHR5cGUgPT09ICdoc2wnKSB7XG4gICAgICAgICAgICBhcnJDb2xvciA9IGFyckNvbG9yLnNsaWNlKDAsIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlICsgJygnICsgYXJyQ29sb3Iuam9pbignLCcpICsgJyknO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgIGxpZnQ6IGxpZnQsXG4gICAgICAgIHRvSGV4OiB0b0hleCxcbiAgICAgICAgZmFzdE1hcFRvQ29sb3I6IGZhc3RNYXBUb0NvbG9yLFxuICAgICAgICBtYXBUb0NvbG9yOiBtYXBUb0NvbG9yLFxuICAgICAgICBtYXBJbnRlcnZhbFRvQ29sb3I6IG1hcEludGVydmFsVG9Db2xvcixcbiAgICAgICAgbW9kaWZ5SFNMOiBtb2RpZnlIU0wsXG4gICAgICAgIG1vZGlmeUFscGhhOiBtb2RpZnlBbHBoYSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlcbiAgICB9O1xuXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanNcbiAqKiBtb2R1bGUgaWQgPSAyM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG4gICAgICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cG9ydHMgenJlbmRlci90b29sL2xvZ1xuICAgICAgICAgKiBAYXV0aG9yIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAgICAgICAgICovXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlYnVnTW9kZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPT0gMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihhcmd1bWVudHNba10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5kZWJ1Z01vZGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBhcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyogZm9yIGRlYnVnXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtZXMpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cm9uZy1tZXNzYWdlJykuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICBtZXMgKyAnICcgKyAobmV3IERhdGUoKSAtIDApXG4gICAgICAgICAgICAgICAgKyAnPGJyLz4nIFxuICAgICAgICAgICAgICAgICsgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyb25nLW1lc3NhZ2UnKS5pbm5lckhUTUw7XG4gICAgICAgIH07XG4gICAgICAgICovXG4gICAgXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2xvZy5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICB2YXIgZHByID0gMTtcbiAgICAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRwciA9IE1hdGgubWF4KHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjb25maWfpu5jorqTphY3nva7poblcbiAgICAgKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICAgICAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICAgICAqL1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZWJ1Z+aXpeW/l+mAiemhue+8mmNhdGNoQnJ1c2hFeGNlcHRpb27kuLp0cnVl5LiL5pyJ5pWIXG4gICAgICAgICAqIDAgOiDkuI3nlJ/miJBkZWJ1Z+aVsOaNru+8jOWPkeW4g+eUqFxuICAgICAgICAgKiAxIDog5byC5bi45oqb5Ye677yM6LCD6K+V55SoXG4gICAgICAgICAqIDIgOiDmjqfliLblj7DovpPlh7rvvIzosIPor5XnlKhcbiAgICAgICAgICovXG4gICAgICAgIGRlYnVnTW9kZTogMCxcblxuICAgICAgICAvLyByZXRpbmEg5bGP5bmV5LyY5YyWXG4gICAgICAgIGRldmljZVBpeGVsUmF0aW86IGRwclxuICAgIH07XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb25maWc7XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29uZmlnLmpzXG4gKiogbW9kdWxlIGlkID0gMjVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogQG1vZHVsZSBlY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG4gICAgdmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSB2ZWMyLmFwcGx5VHJhbnNmb3JtO1xuICAgIHZhciBtYXRoTWluID0gTWF0aC5taW47XG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEJvdW5kaW5nUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBCb3VuZGluZ1JlY3QucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBCb3VuZGluZ1JlY3QsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOmVjaGFydHMvY29yZS9Cb3VuZGluZ1JlY3R9IG90aGVyXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICAgICAgICAgIHZhciB5ID0gbWF0aE1pbihvdGhlci55LCB0aGlzLnkpO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aE1heChcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIueCArIG90aGVyLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoXG4gICAgICAgICAgICAgICAgKSAtIHg7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnkgKyBvdGhlci5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSArIHRoaXMuaGVpZ2h0XG4gICAgICAgICAgICAgICAgKSAtIHk7XG4gICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbVxuICAgICAgICAgKiBAbWV0aG9kc1xuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm06IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gW107XG4gICAgICAgICAgICB2YXIgbWF4ID0gW107XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGVsLmdldEJvdW5kaW5nUmVjdCgpLmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAvLyBBbmQgZWxlbWVudCBoYXMgbm8gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluWzBdID0gdGhpcy54O1xuICAgICAgICAgICAgICAgIG1pblsxXSA9IHRoaXMueTtcbiAgICAgICAgICAgICAgICBtYXhbMF0gPSB0aGlzLnggKyB0aGlzLndpZHRoO1xuICAgICAgICAgICAgICAgIG1heFsxXSA9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtaW4sIG1pbiwgbSk7XG4gICAgICAgICAgICAgICAgdjJBcHBseVRyYW5zZm9ybShtYXgsIG1heCwgbSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnggPSBtYXRoTWluKG1pblswXSwgbWF4WzBdKTtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBtYXRoTWluKG1pblsxXSwgbWF4WzFdKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpZHRoID0gbWF0aEFicyhtYXhbMF0gLSBtaW5bMF0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gbWF0aEFicyhtYXhbMV0gLSBtaW5bMV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAgICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHN4ID0gYi53aWR0aCAvIGEud2lkdGg7XG4gICAgICAgICAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgbSA9IG1hdHJpeC5jcmVhdGUoKTtcblxuICAgICAgICAgICAgLy8g55+p6Zi15Y+z5LmYXG4gICAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKG0sIG0sIFstYS54LCAtYS55XSk7XG4gICAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbYi54LCBiLnldKTtcblxuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgICAgIHZhciBheDAgPSBhLng7XG4gICAgICAgICAgICB2YXIgYXgxID0gYS54ICsgYS53aWR0aDtcbiAgICAgICAgICAgIHZhciBheTAgPSBhLnk7XG4gICAgICAgICAgICB2YXIgYXkxID0gYS55ICsgYS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBieDAgPSBiLng7XG4gICAgICAgICAgICB2YXIgYngxID0gYi54ICsgYi53aWR0aDtcbiAgICAgICAgICAgIHZhciBieTAgPSBiLnk7XG4gICAgICAgICAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIHJldHVybiAhIChheDEgPCBieDAgfHwgYngxIDwgYXgwIHx8IGF5MSA8IGJ5MCB8fCBieTEgPCBheTApO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4geCA+PSByZWN0LnhcbiAgICAgICAgICAgICAgICAmJiB4IDw9IChyZWN0LnggKyByZWN0LndpZHRoKVxuICAgICAgICAgICAgICAgICYmIHkgPj0gcmVjdC55XG4gICAgICAgICAgICAgICAgJiYgeSA8PSAocmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IGZyb20gYW5vdGhlciByZWN0XG4gICAgICAgICAqL1xuICAgICAgICBjb3B5OiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IG90aGVyLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb3VuZGluZ1JlY3Q7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOWKqOeUu+S4u+exuywg6LCD5bqm5ZKM566h55CG5omA5pyJ5Yqo55S75o6n5Yi25ZmoXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG5cbiAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi4vY29yZS9ldmVudCcpLkRpc3BhdGNoZXI7XG5cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuYywgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgdmFyIEFuaW1hdG9yID0gcmVxdWlyZSgnLi9BbmltYXRvcicpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1cGRhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9uXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uZnJhbWVdXG4gICAgICogQHBhcmFtIHtJWlJlbmRlclN0YWdlfSBbb3B0aW9ucy5zdGFnZV1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICB2YXIgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigpO1xuICAgICAqICAgICB2YXIgb2JqID0ge1xuICAgICAqICAgICAgICAgeDogMTAwLFxuICAgICAqICAgICAgICAgeTogMTAwXG4gICAgICogICAgIH07XG4gICAgICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gICAgICogICAgICAgICAud2hlbigxMDAwLCB7XG4gICAgICogICAgICAgICAgICAgeDogNTAwLFxuICAgICAqICAgICAgICAgICAgIHk6IDUwMFxuICAgICAqICAgICAgICAgfSlcbiAgICAgKiAgICAgICAgIC53aGVuKDIwMDAsIHtcbiAgICAgKiAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICogICAgICAgICAgICAgeTogMTAwXG4gICAgICogICAgICAgICB9KVxuICAgICAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAgICAgKi9cbiAgICB2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICAgICAgICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24oKSB7fTtcblxuICAgICAgICAvLyBwcml2YXRlIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5fY2xpcHMgPSBbXTtcblxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdGltZSA9IDA7XG5cbiAgICAgICAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICBBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBBbmltYXRpb24sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqAgY2xpcFxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAgICAgICAqL1xuICAgICAgICBhZGRDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa3u+WKoCBhbmltYXRvclxuICAgICAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICAgICAgICovXG4gICAgICAgIGFkZEFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFuaW1hdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2xpcChjbGlwc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKDpmaTliqjnlLvniYfmrrVcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQ2xpcDogZnVuY3Rpb24oY2xpcCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IHV0aWwuaW5kZXhPZih0aGlzLl9jbGlwcywgY2xpcCk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5Yqo55S754mH5q61XG4gICAgICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfSBhbmltYXRvclxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlQW5pbWF0b3I6IGZ1bmN0aW9uIChhbmltYXRvcikge1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gYW5pbWF0b3IuZ2V0Q2xpcHMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNsaXAoY2xpcHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IHRpbWUgLSB0aGlzLl90aW1lO1xuICAgICAgICAgICAgdmFyIGNsaXBzID0gdGhpcy5fY2xpcHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsaXAgPSBjbGlwc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGNsaXAuc3RlcCh0aW1lKTtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgICAgICAgICAgIC8vIHN0YWdlLnVwZGF0ZSwgbGlrZSBkZXN0cm95XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xpcHNbaV0uX25lZWRzUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzW2ldID0gY2xpcHNbbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNsaXBzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxlbiA9IGRlZmVycmVkRXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZENsaXBzW2ldLmZpcmUoZGVmZXJyZWRFdmVudHNbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgICAgICAgdGhpcy5vbmZyYW1lKGRlbHRhKTtcblxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdmcmFtZScsIGRlbHRhKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhZ2UudXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS51cGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW8gOWni+i/kOihjOWKqOeUu1xuICAgICAgICAgKi9cbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlgZzmraLov5DooYzliqjnlLtcbiAgICAgICAgICovXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOa4hemZpOaJgOacieWKqOeUu+eJh+autVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaXBzID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlr7nkuIDkuKrnm67moIfliJvlu7rkuIDkuKphbmltYXRvcuWvueixoe+8jOWPr+S7peaMh+Wumuebruagh+S4reeahOWxnuaAp+S9v+eUqOWKqOeUu1xuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldFxuICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMubG9vcD1mYWxzZV0g5piv5ZCm5b6q546v5pKt5pS+5Yqo55S7XG4gICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZXR0ZXI9bnVsbF1cbiAgICAgICAgICogICAgICAgICDlpoLmnpzmjIflrppnZXR0ZXLlh73mlbDvvIzkvJrpgJrov4dnZXR0ZXLlh73mlbDlj5blsZ7mgKflgLxcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXVxuICAgICAgICAgKiAgICAgICAgIOWmguaenOaMh+WumnNldHRlcuWHveaVsO+8jOS8mumAmui/h3NldHRlcuWHveaVsOiuvue9ruWxnuaAp+WAvFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoXG4gICAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9vcCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmdldHRlcixcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldHRlclxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdG9yO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHV0aWwubWl4aW4oQW5pbWF0aW9uLCBEaXNwYXRjaGVyKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gQW5pbWF0aW9uO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9hbmltYXRpb24vQW5pbWF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogRGVmYXVsdCBjYW52YXMgcGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL1BhaW50ZXJcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbiBcblxuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgbG9nID0gcmVxdWlyZSgnLi9jb3JlL2xvZycpO1xuICAgIHZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKCcuL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgTGF5ZXIgPSByZXF1aXJlKCcuL0xheWVyJyk7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMYXllclZhbGlkKGxheWVyKSB7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXllci5pc0J1aWxkaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihsYXllci5yZXNpemUpICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICB8fCB0eXBlb2YobGF5ZXIucmVmcmVzaCkgIT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191bnVzZWRDb3VudCsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc3RQcm9jZXNzTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IGZhbHNlO1xuICAgICAgICBpZiAobGF5ZXIuX191bnVzZWRDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRtcFJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuICAgIHZhciB2aWV3UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgZnVuY3Rpb24gaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0bXBSZWN0LmNvcHkoZWwuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgICAgICBpZiAoZWwudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlld1JlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdmlld1JlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gIXRtcFJlY3QuaW50ZXJzZWN0KHZpZXdSZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZDbGlwUGF0aHMpIHtcbiAgICAgICAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgKGNsaXBQYXRocy5sZW5ndGggIT09IHByZXZDbGlwUGF0aHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGlwUGF0aHNbaV0gIT09IHByZXZDbGlwUGF0aHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBQYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICAgICAgdmFyIG07XG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbSA9IGNsaXBQYXRoLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICBtWzBdLCBtWzFdLFxuICAgICAgICAgICAgICAgICAgICBtWzJdLCBtWzNdLFxuICAgICAgICAgICAgICAgICAgICBtWzRdLCBtWzVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXRoID0gY2xpcFBhdGgucGF0aDtcbiAgICAgICAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7XG4gICAgICAgICAgICBjbGlwUGF0aC5idWlsZFBhdGgocGF0aCwgY2xpcFBhdGguc2hhcGUpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYWNrXG4gICAgICAgICAgICBpZiAoY2xpcFBhdGgudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgbSA9IGNsaXBQYXRoLmludlRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICBtWzBdLCBtWzFdLFxuICAgICAgICAgICAgICAgICAgICBtWzJdLCBtWzNdLFxuICAgICAgICAgICAgICAgICAgICBtWzRdLCBtWzVdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9QYWludGVyXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0ge09qYmVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMpIHtcbiAgICAgICAgdmFyIHNpbmdsZUNhbnZhcyA9ICFyb290Lm5vZGVOYW1lIC8vIEluIG5vZGUgP1xuICAgICAgICAgICAgfHwgcm9vdC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJztcblxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHByID0gb3B0cy5kZXZpY2VQaXhlbFJhdGlvIHx8IGNvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zaW5nbGVDYW52YXMgPSBzaW5nbGVDYW52YXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDnu5jlm77lrrnlmahcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcblxuICAgICAgICB2YXIgcm9vdFN0eWxlID0gcm9vdC5zdHlsZTtcblxuICAgICAgICAvLyBJbiBub2RlIGVudmlyb25tZW50IHVzaW5nIG5vZGUtY2FudmFzXG4gICAgICAgIGlmIChyb290U3R5bGUpIHtcbiAgICAgICAgICAgIHJvb3RTdHlsZVsnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgcm9vdFN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICByb290U3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICByb290U3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuXG4gICAgICAgICAgICByb290LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcblxuICAgICAgICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9nZXRIZWlnaHQoKTtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBkb21Sb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID0gZG9tUm9vdDtcbiAgICAgICAgICAgIHZhciBkb21Sb290U3R5bGUgPSBkb21Sb290LnN0eWxlO1xuXG4gICAgICAgICAgICAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8g6YG/5YWN6aG16Z2i6YCJ5Lit55qE5bC05bCsXG4gICAgICAgICAgICBkb21Sb290U3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgZG9tUm9vdFN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBkb21Sb290U3R5bGUud2lkdGggPSB0aGlzLl93aWR0aCArICdweCc7XG4gICAgICAgICAgICBkb21Sb290U3R5bGUuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQoZG9tUm9vdCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge09iamVjdC48a2V5LCBtb2R1bGU6enJlbmRlci9MYXllcj59XG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl9sYXllcnMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5femxldmVsTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG4gICAgICAgICAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJvb3QuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGxheWVyIGlmIG9ubHkgb25lIGdpdmVuIGNhbnZhc1xuICAgICAgICAgICAgLy8gRGV2aWNlIHBpeGVsIHJhdGlvIGlzIGZpeGVkIHRvIDEgYmVjYXVzZSBnaXZlbiBjYW52YXMgaGFzIGl0cyBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgdmFyIG1haW5MYXllciA9IG5ldyBMYXllcihyb290LCB0aGlzLCAxKTtcbiAgICAgICAgICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gRklYTUUgVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgICAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0ge1xuICAgICAgICAgICAgICAgIDA6IG1haW5MYXllclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3psZXZlbExpc3QgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuXG4gICAgICAgIHRoaXMucGF0aFRvSW1hZ2UgPSB0aGlzLl9jcmVhdGVQYXRoVG9JbWFnZSgpO1xuICAgIH07XG5cbiAgICBQYWludGVyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUGFpbnRlcixcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcGFpbnRlciB1c2UgYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBpc1NpbmdsZUNhbnZhczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlQ2FudmFzID8gdGhpcy5fbGF5ZXJzWzBdLmRvbSA6IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWIt+aWsFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYWludEFsbD1mYWxzZV0g5by65Yi257uY5Yi25omA5pyJZGlzcGxheWFibGVcbiAgICAgICAgICovXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uIChwYWludEFsbCkge1xuICAgICAgICAgICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG5cbiAgICAgICAgICAgIHRoaXMuX3BhaW50TGlzdChsaXN0LCBwYWludEFsbCk7XG5cbiAgICAgICAgICAgIC8vIFBhaW50IGN1c3R1bSBsYXllcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllci5pc0J1aWxkaW4gJiYgbGF5ZXIucmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcblxuICAgICAgICAgICAgaWYgKHBhaW50QWxsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYWludEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMYXllclN0YXR1cyhsaXN0KTtcblxuICAgICAgICAgICAgdmFyIGN1cnJlbnRMYXllcjtcbiAgICAgICAgICAgIHZhciBjdXJyZW50WkxldmVsO1xuICAgICAgICAgICAgdmFyIGN0eDtcblxuICAgICAgICAgICAgdmFyIHZpZXdXaWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICAgICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG5cbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcihwcmVQcm9jZXNzTGF5ZXIpO1xuXG4gICAgICAgICAgICAvLyB2YXIgaW52VHJhbnNmb3JtID0gW107XG4gICAgICAgICAgICB2YXIgcHJldkVsQ2xpcFBhdGhzID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgdmFyIGVsWkxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgZHJhdyBsYXllclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50WkxldmVsICE9PSBlbFpMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IDAgemxldmVsIGlmIG9ubHkgaGFzIG9uZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFpMZXZlbCA9IGVsWkxldmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGF5ZXIgPSB0aGlzLmdldExheWVyKGN1cnJlbnRaTGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudExheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdaTGV2ZWwgJyArIGN1cnJlbnRaTGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGN1cnJlbnRMYXllci5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IGN1cnJlbnRMYXllci5jdHg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5fX3VudXNlZENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMYXllci5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudExheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBpbnZpc2libGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAmJiAhZWwuaW52aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICYmIGVsLnN0eWxlLm9wYWNpdHkgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHNjYWxlIDAgZWxlbWVudCwgaW4gc29tZSBlbnZpcm9ubWVudCBsaWtlIG5vZGUtY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIC8vIERyYXcgYSBzY2FsZSAwIGVsZW1lbnQgY2FuIGNhdXNlIGFsbCBmb2xsb3dpbmcgZHJhdyB3cm9uZ1xuICAgICAgICAgICAgICAgICAgICAmJiBlbC5zY2FsZVswXSAmJiBlbC5zY2FsZVsxXVxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgIShlbC5jdWxsaW5nICYmIGlzRGlzcGxheWFibGVDdWxsZWQoZWwsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwUGF0aHMgPSBlbC5fX2NsaXBQYXRocztcblxuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSB3aGVuIGNsaXBwaW5nIG9uIGdyb3VwIHdpdGggc2V2ZXJhbCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDbGlwUGF0aENoYW5nZWQoY2xpcFBhdGhzLCBwcmV2RWxDbGlwUGF0aHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBoYXMgcHJldmlvdXMgY2xpcHBpbmcgc3RhdGUsIHJlc3RvcmUgZnJvbSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXcgY2xpcHBpbmcgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvQ2xpcChjbGlwUGF0aHMsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RWxDbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBVc2UgZXZlbnRzID9cbiAgICAgICAgICAgICAgICAgICAgZWwuYmVmb3JlQnJ1c2ggJiYgZWwuYmVmb3JlQnJ1c2goY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgZWwuYnJ1c2goY3R4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgc3RpbGwgaGFzIGNsaXBwaW5nIHN0YXRlXG4gICAgICAgICAgICBpZiAocHJldkVsQ2xpcFBhdGhzKSB7XG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKHBvc3RQcm9jZXNzTGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5YgemxldmVsIOaJgOWcqOWxgu+8jOWmguaenOS4jeWtmOWcqOWImeS8muWIm+W7uuS4gOS4quaWsOeahOWxglxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL0xheWVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGF5ZXJcbiAgICAgICAgICAgICAgICBsYXllciA9IG5ldyBMYXllcignenJfJyArIHpsZXZlbCwgdGhpcywgdGhpcy5kcHIpO1xuICAgICAgICAgICAgICAgIGxheWVyLmlzQnVpbGRpbiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWxdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydExheWVyKHpsZXZlbCwgbGF5ZXIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGFmdGVyIGRvbSBpbnNlcnRlZCB0byBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIE9yIGV4Y2FudmFzIHdpbGwgZ2V0IDBweCBjbGllbnRXaWR0aCBhbmQgY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgbGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluc2VydExheWVyOiBmdW5jdGlvbiAoemxldmVsLCBsYXllcikge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzTWFwID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxlbiA9IHpsZXZlbExpc3QubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgdmFyIGRvbVJvb3QgPSB0aGlzLl9kb21Sb290O1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJzTWFwW3psZXZlbF0pIHtcbiAgICAgICAgICAgICAgICBsb2coJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpcyBhIHZhbGlkIGxheWVyXG4gICAgICAgICAgICBpZiAoIWlzTGF5ZXJWYWxpZChsYXllcikpIHtcbiAgICAgICAgICAgICAgICBsb2coJ0xheWVyIG9mIHpsZXZlbCAnICsgemxldmVsICsgJyBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHpsZXZlbExpc3RbaV0gPCB6bGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHpsZXZlbExpc3RbaSArIDFdID4gemxldmVsXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldkxheWVyID0gbGF5ZXJzTWFwW3psZXZlbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG4gICAgICAgICAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tUm9vdC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5kb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2RG9tLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIGRvbVJvb3QuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllcnNNYXBbemxldmVsXSA9IGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICAgICAgICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbel0sIHopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hCdWlsZGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gICAgICAgIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgIHZhciB6O1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGxheWVyID0gdGhpcy5fbGF5ZXJzW3pdO1xuICAgICAgICAgICAgICAgIGlmICghIGxheWVyLmlzQnVpbGRpbikge1xuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIGxheWVyLCB6KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPluaJgOacieW3suWIm+W7uueahOWxglxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9MYXllcj59IFtwcmV2TGF5ZXJdXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuXG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuXG4gICAgICAgICAgICB2YXIgZWxDb3VudHMgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5lYWNoQnVpbGRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgICAgICAgICAgIGVsQ291bnRzW3pdID0gbGF5ZXIuZWxDb3VudDtcbiAgICAgICAgICAgICAgICBsYXllci5lbENvdW50ID0gMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICB2YXIgemxldmVsID0gdGhpcy5fc2luZ2xlQ2FudmFzID8gMCA6IGVsLnpsZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuZWxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAvLyDlt7Lnu4/ooqvmoIforrDkuLrpnIDopoHliLfmlrBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxheWVyLl9fZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSBlbC5fX2RpcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8g5bGC5Lit55qE5YWD57Sg5pWw6YeP5pyJ5Y+R55Sf5Y+Y5YyWXG4gICAgICAgICAgICB0aGlzLmVhY2hCdWlsZGluTGF5ZXIoZnVuY3Rpb24gKGxheWVyLCB6KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsQ291bnRzW3pdICE9PSBsYXllci5lbENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXpmaRob3ZlcuWxguWkluaJgOacieWGheWuuVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEJ1aWxkaW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGVhckxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS/ruaUueaMh+WumnpsZXZlbOeahOe7mOWItuWPguaVsFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gemxldmVsXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcg6YWN572u5a+56LGhXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0g5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLm1vdGlvbkJsdXI9ZmFsc2VdIOaYr+WQpuW8gOWQr+WKqOaAgeaooeezilxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5sYXN0RnJhbWVBbHBoYT0wLjddXG4gICAgICAgICAqICAgICAgICAgICAgICAgICDlnKjlvIDlkK/liqjmgIHmqKHns4rnmoTml7blgJnkvb/nlKjvvIzkuI7kuIrkuIDluKfmt7flkIjnmoRhbHBoYeWAvO+8jOWAvOi2iuWkp+Wwvui/uei2iuaYjuaYvlxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwsIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IHRoaXMuX2xheWVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICAgICAgICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwubWVyZ2UobGF5ZXIsIGxheWVyQ29uZmlnW3psZXZlbF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yig6Zmk5oyH5a6a5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWwg5bGC5omA5Zyo55qEemxldmVsXG4gICAgICAgICAqL1xuICAgICAgICBkZWxMYXllcjogZnVuY3Rpb24gKHpsZXZlbCkge1xuICAgICAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICAgICAgICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICAgICAgICAgIHZhciBsYXllciA9IGxheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxheWVyLmRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgICAgICBkZWxldGUgbGF5ZXJzW3psZXZlbF07XG5cbiAgICAgICAgICAgIHpsZXZlbExpc3Quc3BsaWNlKHV0aWwuaW5kZXhPZih6bGV2ZWxMaXN0LCB6bGV2ZWwpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yy65Z+f5aSn5bCP5Y+Y5YyW5ZCO6YeN57uYXG4gICAgICAgICAqL1xuICAgICAgICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7XG4gICAgICAgICAgICAvLyBGSVhNRSBXaHkgP1xuICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHRoaXMuX2dldFdpZHRoKCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5fZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgICAgICAvLyDkvJjljJbmsqHmnInlrp7pmYXmlLnlj5jnmoRyZXNpemVcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCAhPSB3aWR0aCB8fCBoZWlnaHQgIT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZG9tUm9vdC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBkb21Sb290LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5riF6Zmk5Y2V54us55qE5LiA5Liq5bGCXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6bGV2ZWxcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuICAgICAgICAgICAgaWYgKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6YeK5pS+XG4gICAgICAgICAqL1xuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAgICAgICAgIHRoaXMucm9vdCA9XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UgPVxuXG4gICAgICAgICAgICB0aGlzLl9kb21Sb290ID1cbiAgICAgICAgICAgIHRoaXMuX2xheWVycyA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0UmVuZGVyZWRDYW52YXM6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzWzBdLmRvbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltYWdlTGF5ZXIgPSBuZXcgTGF5ZXIoJ2ltYWdlJywgdGhpcywgb3B0cy5waXhlbFJhdGlvIHx8IHRoaXMuZHByKTtcbiAgICAgICAgICAgIGltYWdlTGF5ZXIuaW5pdENvbnRleHQoKTtcblxuICAgICAgICAgICAgdmFyIGN0eCA9IGltYWdlTGF5ZXIuY3R4O1xuICAgICAgICAgICAgaW1hZ2VMYXllci5jbGVhckNvbG9yID0gb3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBpbWFnZUxheWVyLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCh0cnVlKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwbGF5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghZWwuaW52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQ2hlY2sgaW1hZ2UgY3Jvc3Mgb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIGVsLmJydXNoKGN0eCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOiOt+WPlue7mOWbvuWMuuWfn+WuveW6plxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAgICAgICAqL1xuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuXG4gICAgICAgICAgICAvLyBGSVhNRSBCZXR0ZXIgd2F5IHRvIGdldCB0aGUgd2lkdGggYW5kIGhlaWdodCB3aGVuIGVsZW1lbnQgaGFzIG5vdCBiZWVuIGFwcGVuZCB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgIHJldHVybiAoKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpIHx8IHBhcnNlSW50MTAocm9vdC5zdHlsZS53aWR0aCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSB8fCAwKVxuICAgICAgICAgICAgICAgICAgICAtIChwYXJzZUludDEwKHN0bC5wYWRkaW5nUmlnaHQpIHx8IDApKSB8IDA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgc3RsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShyb290KTtcblxuICAgICAgICAgICAgcmV0dXJuICgocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGUuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ1RvcCkgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgLSAocGFyc2VJbnQxMChzdGwucGFkZGluZ0JvdHRvbSkgfHwgMCkpIHwgMDtcbiAgICAgICAgfSxcblxuICAgICAgICBfcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChpZCwgcGF0aCwgd2lkdGgsIGhlaWdodCwgZHByKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIGRwcjtcblxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCAqIGRwciwgaGVpZ2h0ICogZHByKTtcblxuICAgICAgICAgICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBhdGgucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgcm90YXRpb246IHBhdGgucm90YXRpb24sXG4gICAgICAgICAgICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXRoLnBvc2l0aW9uID0gWzAsIDAsIDBdO1xuICAgICAgICAgICAgcGF0aC5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmJydXNoKGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBJbWFnZVNoYXBlID0gcmVxdWlyZSgnLi9ncmFwaGljL0ltYWdlJyk7XG4gICAgICAgICAgICB2YXIgaW1nU2hhcGUgPSBuZXcgSW1hZ2VTaGFwZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBjYW52YXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltZ1NoYXBlLnBvc2l0aW9uID0gcGF0aC5wb3NpdGlvbiA9IHBhdGhUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXRoVHJhbnNmb3JtLnJvdGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGF0aFRyYW5zZm9ybS5zY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW1nU2hhcGUuc2NhbGUgPSBwYXRoLnNjYWxlID0gcGF0aFRyYW5zZm9ybS5zY2FsZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltZ1NoYXBlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVQYXRoVG9JbWFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1lID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZS5fcGF0aFRvSW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGlkLCBlLCB3aWR0aCwgaGVpZ2h0LCBtZS5kcHJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhaW50ZXI7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL1BhaW50ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvTGF5ZXJcbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cblxuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL2NvcmUvdXRpbCcpO1xuICAgIHZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG4gICAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDliJvlu7pkb21cbiAgICAgKlxuICAgICAqIEBpbm5lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZG9tIHR5cGXvvIxzdWNoIGFzIGNhbnZhcywgZGl2IGV0Yy5cbiAgICAgKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb20oaWQsIHR5cGUsIHBhaW50ZXIsIGRwcikge1xuICAgICAgICB2YXIgbmV3RG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICAgICAgdmFyIHdpZHRoID0gcGFpbnRlci5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFpbnRlci5nZXRIZWlnaHQoKTtcblxuICAgICAgICB2YXIgbmV3RG9tU3R5bGUgPSBuZXdEb20uc3R5bGU7XG4gICAgICAgIC8vIOayoWFwcGVuZOWRou+8jOivt+WOn+iwheaIkei/meagt+WGme+8jOa4heaZsH5cbiAgICAgICAgbmV3RG9tU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBuZXdEb21TdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICAgICAgbmV3RG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIG5ld0RvbVN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIG5ld0RvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICBuZXdEb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgIC8vIGlk5LiN5L2c5Li657Si5byV55So77yM6YG/5YWN5Y+v6IO96YCg5oiQ55qE6YeN5ZCN77yM5a6a5LmJ5Li656eB5pyJ5bGe5oCnXG4gICAgICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3RG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1BhaW50ZXJ9IHBhaW50ZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Rwcl1cbiAgICAgKi9cbiAgICB2YXIgTGF5ZXIgPSBmdW5jdGlvbihpZCwgcGFpbnRlciwgZHByKSB7XG4gICAgICAgIHZhciBkb207XG4gICAgICAgIGRwciA9IGRwciB8fCBjb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgJ2NhbnZhcycsIHBhaW50ZXIsIGRwcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGlzRG9tIGJlY2F1c2UgaW4gbm9kZSBpdCB3aWxsIHJldHVybiBmYWxzZVxuICAgICAgICBlbHNlIGlmICh1dGlsLmlzT2JqZWN0KGlkKSkge1xuICAgICAgICAgICAgZG9tID0gaWQ7XG4gICAgICAgICAgICBpZCA9IGRvbS5pZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuXG4gICAgICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICAgICAgaWYgKGRvbVN0eWxlKSB7IC8vIE5vdCBpbiBub2RlXG4gICAgICAgICAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgICAgICAgICBkb21TdHlsZVsndXNlci1zZWxlY3QnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRvdWNoLWNhbGxvdXQnXSA9ICdub25lJztcbiAgICAgICAgICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZG9tQmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuY3R4QmFjayA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcblxuICAgICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG5cbiAgICAgICAgLy8gQ29uZmlnc1xuICAgICAgICAvKipcbiAgICAgICAgICog5q+P5qyh5riF56m655S75biD55qE6aKc6ImyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDAuN1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0RnJhbWVBbHBoYSA9IDAuNztcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGF5ZXIgZHByXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRwciA9IGRwcjtcbiAgICB9O1xuXG4gICAgTGF5ZXIucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBMYXllcixcblxuICAgICAgICBlbENvdW50OiAwLFxuXG4gICAgICAgIF9fZGlydHk6IHRydWUsXG5cbiAgICAgICAgaW5pdENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gdGhpcy5kb20uZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2NhbGUoZHByLCBkcHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJhY2tCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdGhpcy5kb21CYWNrID0gY3JlYXRlRG9tKCdiYWNrLScgKyB0aGlzLmlkLCAnY2FudmFzJywgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgICAgICAgICAgdGhpcy5jdHhCYWNrID0gdGhpcy5kb21CYWNrLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgIGlmIChkcHIgIT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgICAgICAgICAgdmFyIGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuICAgICAgICAgICAgdmFyIGRvbUJhY2sgPSB0aGlzLmRvbUJhY2s7XG5cbiAgICAgICAgICAgIGRvbVN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgICAgZG9tU3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgZG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gICAgICAgICAgICBkb20uaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICBpZiAoZHByICE9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb21CYWNrKSB7XG4gICAgICAgICAgICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgICAgICAgICAgIGRvbUJhY2suaGVpZ2h0ID0gaGVpZ2h0ICogZHByO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRwciAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5zY2FsZShkcHIsIGRwcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmuIXnqbror6XlsYLnlLvluINcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckFsbCBDbGVhciBhbGwgd2l0aCBvdXQgbW90aW9uIGJsdXJcbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyOiBmdW5jdGlvbiAoY2xlYXJBbGwpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGRvbS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuXG4gICAgICAgICAgICB2YXIgaGF2ZUNsZWFyQ29sb3IgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICB2YXIgaGF2ZU1vdGlvbkJMdXIgPSB0aGlzLm1vdGlvbkJsdXIgJiYgIWNsZWFyQWxsO1xuICAgICAgICAgICAgdmFyIGxhc3RGcmFtZUFscGhhID0gdGhpcy5sYXN0RnJhbWVBbHBoYTtcblxuICAgICAgICAgICAgdmFyIGRwciA9IHRoaXMuZHByO1xuXG4gICAgICAgICAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZG9tQmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJhY2tCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eEJhY2suZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4QmFjay5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRvbSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggLyBkcHIsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCAvIGRwclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgICAgICAgICBpZiAoaGF2ZUNsZWFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoIC8gZHByLCBoZWlnaHQgLyBkcHIpO1xuICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgICAgICAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gbGFzdEZyYW1lQWxwaGE7XG4gICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCAvIGRwciwgaGVpZ2h0IC8gZHByKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gTGF5ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9MYXllci5qc1xuICoqIG1vZHVsZSBpZCA9IDI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEltYWdlIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL0ltYWdlXG4gKi9cblxuXG5cbiAgICB2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKCcuL0Rpc3BsYXlhYmxlJyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpO1xuICAgIHZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlci9yb3VuZFJlY3QnKTtcblxuICAgIHZhciBMUlUgPSByZXF1aXJlKCcuLi9jb3JlL0xSVScpO1xuICAgIHZhciBnbG9iYWxJbWFnZUNhY2hlID0gbmV3IExSVSg1MCk7XG4gICAgLyoqXG4gICAgICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIHZhciBaSW1hZ2UgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIH07XG5cbiAgICBaSW1hZ2UucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBaSW1hZ2UsXG5cbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBzcmMgPSBzdHlsZS5pbWFnZTtcbiAgICAgICAgICAgIHZhciBpbWFnZTtcbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGEgdXJsIHN0cmluZ1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0eWxlLmltYWdlIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FIENhc2UgY3JlYXRlIG1hbnkgaW1hZ2VzIHdpdGggc3JjXG4gICAgICAgICAgICBpZiAoIWltYWdlICYmIHNyYykge1xuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXQgZnJvbSBnbG9iYWwgaW1hZ2UgY2FjaGVcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQoc3JjKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZEltZ09iaikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVkSW1nT2JqLnBlbmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmoucGVuZGluZ1tpXS5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbWdPYmogPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBbdGhpc11cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gc3JjO1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxJbWFnZUNhY2hlLnB1dChzcmMsIGNhY2hlZEltZ09iaik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlID0gY2FjaGVkSW1nT2JqLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbWFnZSBpcyBub3QgY29tcGxldGUgZmluaXNoLCBhZGQgdG8gcGVuZGluZyBsaXN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2Uud2lkdGggfHwgIWltYWdlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW1nT2JqLnBlbmRpbmcucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8g5Zu+54mH5bey57uP5Yqg6L295a6M5oiQXG4gICAgICAgICAgICAgICAgLy8gaWYgKGltYWdlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKCFpbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIEVsc2UgaXMgY2FudmFzXG5cbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aCB8fCBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gc3R5bGUuaGVpZ2h0IHx8IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICAvLyDlm77niYfliqDovb3lpLHotKVcbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLndpZHRoIHx8ICFpbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAvLyDorr7nva50cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9yZGVyIHJhZGl1cyBjbGlwcGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnNXaWR0aCAmJiBzdHlsZS5zSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeSA9IHN0eWxlLnN5IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4LCBzeSwgc3R5bGUuc1dpZHRoLCBzdHlsZS5zSGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeCwgeSwgd2lkdGgsIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHlsZS5zeCAmJiBzdHlsZS5zeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSBzdHlsZS5zeDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzV2lkdGggPSB3aWR0aCAtIHN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc0hlaWdodCA9IGhlaWdodCAtIHN5O1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHdpZHRoLCBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIOWmguaenOayoeiuvue9ruWuveWSjOmrmOeahOivneiHquWKqOagueaNruWbvueJh+WuvemrmOiuvue9rlxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoISB0aGlzLl9yZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFpJbWFnZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlj6/nu5jliLbnmoTlm77lvaLln7rnsbtcbiAqIEJhc2UgY2xhc3Mgb2YgYWxsIGRpc3BsYXlhYmxlIGdyYXBoaWMgb2JqZWN0c1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqL1xuXG5cblxuICAgIHZhciB6clV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcblxuICAgIHZhciBTdHlsZSA9IHJlcXVpcmUoJy4vU3R5bGUnKTtcblxuICAgIHZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vRWxlbWVudCcpO1xuICAgIHZhciBSZWN0VGV4dCA9IHJlcXVpcmUoJy4vbWl4aW4vUmVjdFRleHQnKTtcbiAgICAvLyB2YXIgU3RhdGVmdWwgPSByZXF1aXJlKCcuL21peGluL1N0YXRlZnVsJyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL21peGluL1JlY3RUZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuXG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgICAgIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAvLyBFeHRlbmQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAgICAgbmFtZSAhPT0gJ3N0eWxlJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG9wdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9wdHMuc3R5bGUpO1xuXG4gICAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgICAgICAvLyBTaGFwZXMgZm9yIGNhc2NhZGUgY2xpcHBpbmcuXG4gICAgICAgIHRoaXMuX19jbGlwUGF0aHMgPSBbXTtcblxuICAgICAgICAvLyBGSVhNRSBTdGF0ZWZ1bCBtdXN0IGJlIG1peGluZWQgYWZ0ZXIgc3R5bGUgaXMgc2V0dGVkXG4gICAgICAgIC8vIFN0YXRlZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfVxuXG4gICAgRGlzcGxheWFibGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcblxuICAgICAgICB0eXBlOiAnZGlzcGxheWFibGUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNwbGF5YWJsZSDmmK/lkKbkuLrohI/vvIxQYWludGVyIOS4reS8muagueaNruivpeagh+iusOWIpOaWreaYr+WQpumcgOimgeaYr+WQpumcgOimgemHjeaWsOe7mOWItlxuICAgICAgICAgKiBEaXJ0eSBmbGFnLiBGcm9tIHdoaWNoIHBhaW50ZXIgd2lsbCBkZXRlcm1pbmUgaWYgdGhpcyBkaXNwbGF5YWJsZSBvYmplY3QgbmVlZHMgYnJ1c2hcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNfX2RpcnR5XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX19kaXJ0eTogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Zu+5b2i5piv5ZCm5Y+v6KeB77yM5Li6dHJ1ZeaXtuS4jee7mOWItuWbvuW9ou+8jOS9huaYr+S7jeiDveinpuWPkem8oOagh+S6i+S7tlxuICAgICAgICAgKiBJZiBpZ25vcmUgZHJhd2luZyBvZiB0aGUgZGlzcGxheWFibGUgb2JqZWN0LiBNb3VzZSBldmVudCB3aWxsIHN0aWxsIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBpbnZpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHo6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgejI6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHrlsYJsZXZlbO+8jOWGs+Wumue7mOeUu+WcqOWTquWxgmNhbnZhc+S4rVxuICAgICAgICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgemxldmVsOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKblj6/mi5bmi71cbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjZHJhZ2dhYmxlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5q2j5Zyo5ouW5ou9XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI2RyYWdnYWJsZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm55u45bqU6byg5qCH5LqL5Lu2XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHNpbGVudDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgY3VsbGluZzogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICAgICAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAgICAgICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAgICAgICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9oue7mOWItuaWueazlVxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhczJEUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgpIHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDojrflj5bmnIDlsI/ljIXlm7Tnm5JcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBJbnRlcmZhY2VcbiAgICAgICAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICog5Yik5pat5Z2Q5qCHIHgsIHkg5piv5ZCm5Zyo5Zu+5b2i5LiKXG4gICAgICAgICAqIElmIGRpc3BsYXlhYmxlIGVsZW1lbnQgY29udGFpbiBjb29yZCB4LCB5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN0Q29udGFpbih4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAgICAgICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDliKTmlq3lnZDmoIcgeCwgeSDmmK/lkKblnKjlm77lvaLnmoTljIXlm7Tnm5LkuIpcbiAgICAgICAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBjb29yZCA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmoIforrDlm77lvaLlhYPntKDkuLrohI/vvIzlubbkuJTlnKjkuIvkuIDluKfph43nu5hcbiAgICAgICAgICogTWFyayBkaXNwbGF5YWJsZSBlbGVtZW50IGRpcnR5IGFuZCByZWZyZXNoIG5leHQgZnJhbWVcbiAgICAgICAgICovXG4gICAgICAgIGRpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcblxuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWbvuW9ouaYr+WQpuS8muinpuWPkeS6i+S7tlxuICAgICAgICAgKiBJZiBkaXNwbGF5YWJsZSBvYmplY3QgYmluZGVkIGFueSBldmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gVE9ETywg6YCa6L+HIGJpbmQg57uR5a6a55qE5LqL5Lu2XG4gICAgICAgIC8vIGlzU2lsZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gIShcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmhvdmVyYWJsZSB8fCB0aGlzLmRyYWdnYWJsZVxuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZW1vdmUgfHwgdGhpcy5vbm1vdXNlb3ZlciB8fCB0aGlzLm9ubW91c2VvdXRcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAgICAgICAvLyAgICAgICAgIHx8IHRoaXMub25kcmFnZW50ZXIgfHwgdGhpcy5vbmRyYWdvdmVyIHx8IHRoaXMub25kcmFnbGVhdmVcbiAgICAgICAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJvcFxuICAgICAgICAvLyAgICAgKTtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsaWFzIGZvciBhbmltYXRlKCdzdHlsZScpXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICAgICAgICAgKi9cbiAgICAgICAgYW5pbWF0ZVN0eWxlOiBmdW5jdGlvbiAobG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc3R5bGUnLCBsb29wKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuYXR0cktWLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHNldFN0eWxlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoRGlzcGxheWFibGUsIEVsZW1lbnQpO1xuXG4gICAgenJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBSZWN0VGV4dCk7XG4gICAgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IERpc3BsYXlhYmxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1N0eWxlXG4gKi9cblxuXG5cbiAgICB2YXIgU1RZTEVfTElTVF9DT01NT04gPSBbXG4gICAgICAgICdsaW5lQ2FwJywgJ2xpbmVKb2luJywgJ21pdGVyTGltaXQnLFxuICAgICAgICAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknLCAnc2hhZG93Q29sb3InXG4gICAgXTtcblxuICAgIHZhciBTdHlsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5kRnJvbShvcHRzKTtcbiAgICB9O1xuXG4gICAgU3R5bGUucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBTdHlsZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6ICcjMDAwMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHN0cm9rZTogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHk6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIGxpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBzaGFkb3dCbHVyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lV2lkdGg6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcblxuICAgICAgICAvLyBCb3VuZGluZyByZWN0IHRleHQgY29uZmlndXJhdGlvblxuICAgICAgICAvLyBOb3QgYWZmZWN0ZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dEZpbGw6ICcjMDAwJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTdHJva2U6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgICAgICAgKiBbeCwgeV1cbiAgICAgICAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICogQGRlZmF1bHQgJ2luc2lkZSdcbiAgICAgICAgICovXG4gICAgICAgIHRleHRQb3NpdGlvbjogJ2luc2lkZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QmFzZWxpbmU6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0QWxpZ246IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHREaXN0YW5jZTogNSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRleHRTaGFkb3dCbHVyOiAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGV4dFNoYWRvd09mZnNldFg6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0U2hhZG93T2Zmc2V0WTogMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKi9cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGN0eCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9MSVNUX0NPTU1PTi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBTVFlMRV9MSVNUX0NPTU1PTltpXTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzW3N0eWxlTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHhbc3R5bGVOYW1lXSA9IHRoaXNbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3Ryb2tlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCAvIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc3Ryb2tlTm9TY2FsZSAmJiBlbCAmJiBlbC5nZXRMaW5lU2NhbGUpID8gZWwuZ2V0TGluZVNjYWxlKCkgOiAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgLy8gVXNlIGNhbnZhcyBncmFkaWVudCBpZiBoYXNcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC5jYW52YXNHcmFkaWVudCA/IGZpbGwuY2FudmFzR3JhZGllbnQgOiBmaWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cm9rZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgIC8vIFVzZSBjYW52YXMgZ3JhZGllbnQgaWYgaGFzXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLmNhbnZhc0dyYWRpZW50ID8gc3Ryb2tlLmNhbnZhc0dyYWRpZW50IDogc3Ryb2tlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ICE9IG51bGwgJiYgKGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMub3BhY2l0eSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVuZCBmcm9tIG90aGVyIHN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBvdGhlclN0eWxlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3ZlcndyaXRlXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKG92ZXJ3cml0ZSB8fCAhIHRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZEZyb20ob2JqLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvbmVcbiAgICAgICAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld1N0eWxlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIG5ld1N0eWxlLmV4dGVuZEZyb20odGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3U3R5bGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG4gICAgdmFyIG5hbWU7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IFNUWUxFX0xJU1RfQ09NTU9OLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBTVFlMRV9MSVNUX0NPTU1PTltpXTtcbiAgICAgICAgaWYgKCEobmFtZSBpbiBzdHlsZVByb3RvKSkge1xuICAgICAgICAgICAgc3R5bGVQcm90b1tuYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIE1peGluIGZvciBkcmF3aW5nIHRleHQgaW4gYSBlbGVtZW50IGJvdW5kaW5nIHJlY3RcbiAqIEBtb2R1bGUgenJlbmRlci9taXhpbi9SZWN0VGV4dFxuICovXG5cblxuXG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vLi4vY29udGFpbi90ZXh0Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICAgIHZhciBSZWN0VGV4dCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgZnVuY3Rpb24gcGFyc2VQZXJjZW50KHZhbHVlLCBtYXhWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIG1heFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oY3R4LCBtKSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgfVxuXG4gICAgUmVjdFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWN0VGV4dCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0ZXh0IGluIGEgcmVjdCB3aXRoIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICAgICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gdGV4dFJlY3QgQWx0ZXJuYXRpdmUgcHJlY2FsY3VsYXRlZCB0ZXh0IGJvdW5kaW5nIHJlY3RcbiAgICAgICAgICovXG4gICAgICAgIGRyYXdSZWN0VGV4dDogZnVuY3Rpb24gKGN0eCwgcmVjdCwgdGV4dFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgICAgICAgICAgIGlmICghdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgdmFyIHk7XG4gICAgICAgICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gc3R5bGUudGV4dERpc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgdmFyIGJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbjtcblxuICAgICAgICAgICAgdGV4dFJlY3QgPSB0ZXh0UmVjdCB8fCB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QodGV4dCwgZm9udCwgYWxpZ24sIGJhc2VsaW5lKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHJlY3QgdG8gdmlldyBzcGFjZVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIGludlRyYW5zZm9ybSA9IHRoaXMuaW52VHJhbnNmb3JtO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRtcFJlY3QuY29weShyZWN0KTtcbiAgICAgICAgICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGJhY2tcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2Zvcm0oY3R4LCBpbnZUcmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG4gICAgICAgICAgICBpZiAodGV4dFBvc2l0aW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBQZXJjZW50XG4gICAgICAgICAgICAgICAgeCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgICAgICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCAnbGVmdCc7XG4gICAgICAgICAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0UG9zaXRpb25PblJlY3QoXG4gICAgICAgICAgICAgICAgICAgIHRleHRQb3NpdGlvbiwgcmVjdCwgdGV4dFJlY3QsIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgICAgICAgICAgeSA9IHJlcy55O1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgYWxpZ24gYW5kIGJhc2VsaW5lIHdoZW4gaGFzIHRleHRQb3NpdGlvblxuICAgICAgICAgICAgICAgIGFsaWduID0gYWxpZ24gfHwgcmVzLnRleHRBbGlnbjtcbiAgICAgICAgICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lIHx8IHJlcy50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh2ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB5IC09IHRleHRSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgLT0gdGV4dFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vICd0b3AnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBiYXNlbGluZVxuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHRGaWxsID0gc3R5bGUudGV4dEZpbGw7XG4gICAgICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IHN0eWxlLnRleHRTdHJva2U7XG4gICAgICAgICAgICB0ZXh0RmlsbCAmJiAoY3R4LmZpbGxTdHlsZSA9IHRleHRGaWxsKTtcbiAgICAgICAgICAgIHRleHRTdHJva2UgJiYgKGN0eC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2UpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250O1xuXG4gICAgICAgICAgICAvLyBUZXh0IHNoYWRvd1xuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gc3R5bGUudGV4dFNoYWRvd0NvbG9yO1xuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gc3R5bGUudGV4dFNoYWRvd09mZnNldFg7XG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZO1xuXG4gICAgICAgICAgICB2YXIgdGV4dExpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIGN0eC5maWxsVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgIHRleHRTdHJva2UgJiYgY3R4LnN0cm9rZVRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB5ICs9IHRleHRSZWN0LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBhZ2FpblxuICAgICAgICAgICAgdHJhbnNmb3JtICYmIHNldFRyYW5zZm9ybShjdHgsIHRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBSZWN0VGV4dDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvbWl4aW4vUmVjdFRleHQuanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICB2YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB2YXIgVEVYVF9DQUNIRV9NQVggPSA1MDAwO1xuXG4gICAgdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKTtcbiAgICB2YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZGluZ1JlY3QnKTtcblxuICAgIGZ1bmN0aW9uIGdldFRleHRXaWR0aCh0ZXh0LCB0ZXh0Rm9udCkge1xuICAgICAgICB2YXIga2V5ID0gdGV4dCArICc6JyArIHRleHRGb250O1xuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gbWVhc3VyZVRleHQg5Y+v5Lul6KKr6KaG55uW5Lul5YW85a655LiN5pSv5oyBIENhbnZhcyDnmoTnjq/looNcbiAgICAgICAgICAgIHdpZHRoID0gIE1hdGgubWF4KHRleHRDb250YWluLm1lYXN1cmVUZXh0KHRleHRMaW5lc1tpXSwgdGV4dEZvbnQpLndpZHRoLCB3aWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dFdpZHRoQ2FjaGVDb3VudGVyID4gVEVYVF9DQUNIRV9NQVgpIHtcbiAgICAgICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG4gICAgICAgICAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRleHRXaWR0aENhY2hlQ291bnRlcisrO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleHRSZWN0KHRleHQsIHRleHRGb250LCB0ZXh0QWxpZ24sIHRleHRCYXNlbGluZSkge1xuICAgICAgICB2YXIgdGV4dExpbmVMZW4gPSAoKHRleHQgfHwgJycpICsgJycpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gZ2V0VGV4dFdpZHRoKHRleHQsIHRleHRGb250KTtcbiAgICAgICAgLy8gRklYTUUg6auY5bqm6K6h566X5q+U6L6D57KX5pq0XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0VGV4dFdpZHRoKCflm70nLCB0ZXh0Rm9udCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0TGluZUxlbiAqIGxpbmVIZWlnaHQ7XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvLyBUZXh0IGhhcyBhIHNwZWNpYWwgbGluZSBoZWlnaHQgcHJvcGVydHlcbiAgICAgICAgcmVjdC5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGNhc2UgJ2FscGhhYmV0aWMnOlxuICAgICAgICAgICAgICAgIHJlY3QueSAtPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICByZWN0LnkgLT0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdoYW5naW5nJzpcbiAgICAgICAgICAgIC8vIGNhc2UgJ3RvcCc6XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIHJlY3QueCAtPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICByZWN0LnggLT0gcmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAvLyBjYXNlICdsZWZ0JzpcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCh0ZXh0UG9zaXRpb24sIHJlY3QsIHRleHRSZWN0LCBkaXN0YW5jZSkge1xuXG4gICAgICAgIHZhciB4ID0gcmVjdC54O1xuICAgICAgICB2YXIgeSA9IHJlY3QueTtcblxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG5cbiAgICAgICAgdmFyIHRleHRIZWlnaHQgPSB0ZXh0UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyIC0gdGV4dEhlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIHRleHRBbGlnbiA9ICdsZWZ0JztcblxuICAgICAgICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgeSAtPSBkaXN0YW5jZSArIHRleHRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGUnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUxlZnQnOlxuICAgICAgICAgICAgICAgIHggKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVUb3AnOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNpZGVCb3R0b20nOlxuICAgICAgICAgICAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHkgKz0gaGVpZ2h0IC0gdGV4dEhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZVRvcFJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zaWRlQm90dG9tTGVmdCc6XG4gICAgICAgICAgICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB5ICs9IGhlaWdodCAtIHRleHRIZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2luc2lkZUJvdHRvbVJpZ2h0JzpcbiAgICAgICAgICAgICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgeSArPSBoZWlnaHQgLSB0ZXh0SGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgZWxsaXBzaXMgaWYgb3ZlcmZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRGb250XG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb250YWluZXJXaWR0aFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gW29wdGlvbnNdXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5lbGxpcHNpcz0nLi4uJ11cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1heEl0ZXJhdGlvbnM9M11cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXJhY3RlcnM9M11cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGV4dEVsbGlwc2lzKHRleHQsIHRleHRGb250LCBjb250YWluZXJXaWR0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcldpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRpb25zID0gdXRpbC5kZWZhdWx0cyh7XG4gICAgICAgICAgICBlbGxpcHNpczogJy4uLicsXG4gICAgICAgICAgICBtaW5DaGFyYWN0ZXJzOiAzLFxuICAgICAgICAgICAgbWF4SXRlcmF0aW9uczogMyxcbiAgICAgICAgICAgIGNuQ2hhcldpZHRoOiBnZXRUZXh0V2lkdGgoJ+WbvScsIHRleHRGb250KSxcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyDmnKrogIPomZHpnZ7nrYnlrr3lrZfkvZNcbiAgICAgICAgICAgIGFzY0NoYXJXaWR0aDogZ2V0VGV4dFdpZHRoKCdhJywgdGV4dEZvbnQpXG4gICAgICAgIH0sIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGNvbnRhaW5lcldpZHRoIC09IGdldFRleHRXaWR0aChvcHRpb25zLmVsbGlwc2lzKTtcblxuICAgICAgICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0TGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRleHRMaW5lc1tpXSA9IHRleHRMaW5lVHJ1bmNhdGUoXG4gICAgICAgICAgICAgICAgdGV4dExpbmVzW2ldLCB0ZXh0Rm9udCwgY29udGFpbmVyV2lkdGgsIG9wdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dExpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHRMaW5lVHJ1bmNhdGUodGV4dCwgdGV4dEZvbnQsIGNvbnRhaW5lcldpZHRoLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgIC8vIOeyl+ezmeW+l+WGmeeahO+8jOWwmuacquiAg+iZkeaAp+iDveWSjOWQhOenjeivreiogOOAgeWtl+S9k+eahOaViOaenOOAglxuICAgICAgICBmb3IgKHZhciBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9IGdldFRleHRXaWR0aCh0ZXh0LCB0ZXh0Rm9udCk7XG5cbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPCBjb250YWluZXJXaWR0aCB8fCBpID49IG9wdGlvbnMubWF4SXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1Ykxlbmd0aCA9IGkgPT09IDBcbiAgICAgICAgICAgICAgICA/IGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRhaW5lcldpZHRoLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogTWF0aC5mbG9vcih0ZXh0Lmxlbmd0aCAqIGNvbnRhaW5lcldpZHRoIC8gbGluZVdpZHRoKTtcblxuICAgICAgICAgICAgaWYgKHN1Ykxlbmd0aCA8IG9wdGlvbnMubWluQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgICAgIHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyKDAsIHN1Ykxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc3RpbWF0ZUxlbmd0aCh0ZXh0LCBjb250YWluZXJXaWR0aCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAodmFyIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuICYmIHdpZHRoIDwgY29udGFpbmVyV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgd2lkdGggKz0gKDAgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gMTI3KVxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5hc2NDaGFyV2lkdGggOiBvcHRpb25zLmNuQ2hhcldpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHZhciB0ZXh0Q29udGFpbiA9IHtcblxuICAgICAgICBnZXRXaWR0aDogZ2V0VGV4dFdpZHRoLFxuXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZ2V0VGV4dFJlY3QsXG5cbiAgICAgICAgYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0OiBhZGp1c3RUZXh0UG9zaXRpb25PblJlY3QsXG5cbiAgICAgICAgZWxsaXBzaXM6IHRleHRFbGxpcHNpcyxcblxuICAgICAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24gKHRleHQsIHRleHRGb250KSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdXRpbC5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRleHRGb250O1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRleHRDb250YWluO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gMzRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUueDtcbiAgICAgICAgICAgIHZhciB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHNoYXBlLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByID0gc2hhcGUucjtcbiAgICAgICAgICAgIHZhciByMTtcbiAgICAgICAgICAgIHZhciByMjtcbiAgICAgICAgICAgIHZhciByMztcbiAgICAgICAgICAgIHZhciByNDtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB3aWR0aCBhbmQgaGVpZ2h0IHRvIHBvc2l0aXZlIGZvciBiZXR0ZXIgYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICBpZiAod2lkdGggPCAwKSB7XG4gICAgICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHIgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHIxID0gcjMgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgICAgICAgICAgICAgICAgcjMgPSByWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcjEgPSByWzBdO1xuICAgICAgICAgICAgICAgICAgICByMiA9IHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHIzID0gclsyXTtcbiAgICAgICAgICAgICAgICAgICAgcjQgPSByWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHIxID0gcjIgPSByMyA9IHI0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvdGFsO1xuICAgICAgICAgICAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICAgICAgICAgICAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMyArIHI0O1xuICAgICAgICAgICAgICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSByMiArIHIzO1xuICAgICAgICAgICAgICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgICAgICAgICAgICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICAgICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHIyLCB5KTtcbiAgICAgICAgICAgIHIyICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcjJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgICAgICAgICAgIHIzICE9PSAwICYmIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcjMsIHkgKyBoZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgICByNCAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcjRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByMSk7XG4gICAgICAgICAgICByMSAhPT0gMCAmJiBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcjEsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3JvdW5kUmVjdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBTaW1wbGUgTFJVIGNhY2hlIHVzZSBkb3VibHkgbGlua2VkIGxpc3Rcbi8vIEBtb2R1bGUgenJlbmRlci9jb3JlL0xSVVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbGVuID0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGxpbmtlZExpc3RQcm90byA9IExpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyB2YWx1ZSBhdCB0aGUgdGFpbFxuICAgICAqIEBwYXJhbSAge30gdmFsXG4gICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgZW50cnkgPSBuZXcgRW50cnkodmFsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGFuIGVudHJ5IGF0IHRoZSB0YWlsXG4gICAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9IGVudHJ5XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5LnByZXYgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sZW4rKztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVudHJ5LlxuICAgICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIGxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXY7XG4gICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJcyBoZWFkXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSXMgdGFpbFxuICAgICAgICAgICAgdGhpcy50YWlsID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5uZXh0ID0gZW50cnkucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xlbi0tO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGlua2VkTGlzdFByb3RvLmxlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge30gdmFsXG4gICAgICovXG4gICAgdmFyIEVudHJ5ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExSVSBDYWNoZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9jb3JlL0xSVVxuICAgICAqL1xuICAgIHZhciBMUlUgPSBmdW5jdGlvbihtYXhTaXplKSB7XG5cbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cbiAgICAgICAgdGhpcy5fbWFwID0ge307XG5cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemUgfHwgMTA7XG4gICAgfTtcblxuICAgIHZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAge30gdmFsdWVcbiAgICAgKi9cbiAgICBMUlVQcm90by5wdXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgaWYgKG1hcFtrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBsaXN0LmxlbigpO1xuICAgICAgICAgICAgaWYgKGxlbiA+PSB0aGlzLl9tYXhTaXplICYmIGxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWRcbiAgICAgICAgICAgICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUobGVhc3RVc2VkRW50cnkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbGVhc3RVc2VkRW50cnkua2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbGlzdC5pbnNlcnQodmFsdWUpO1xuICAgICAgICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgICAgICAgICAgbWFwW2tleV0gPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4ge31cbiAgICAgKi9cbiAgICBMUlVQcm90by5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fbWFwW2tleV07XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgICAgICAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFB1dCB0aGUgbGF0ZXN0IHVzZWQgZW50cnkgaW4gdGhlIHRhaWxcbiAgICAgICAgICAgIGlmIChlbnRyeSAhPT0gbGlzdC50YWlsKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5yZW1vdmUoZW50cnkpO1xuICAgICAgICAgICAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAgICovXG4gICAgTFJVUHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbGlzdC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9tYXAgPSB7fTtcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMUlU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL0xSVS5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQk/oioLngrlcclxuICogMS5CT+aYr+S4gOS4quefqeW9olxyXG4gKiAyLkJP5pyJ5ZCN5a2XXHJcbiAqIDMuQk/mnInkuovku7blhrPnrZZbXe+8jOWPjOWHu+S6i+S7tuWGs+etluW8ueWHuuivpuaDhVxyXG4gKiA0LkJP5pyJ5aSW6ZSu5bGe5oCnW11cclxuICogNS5CT+acieWtkEJPXHJcbiAqIDYu5b2T5YmNQk/nibnmrorpopzoibLmmL7npLpcclxuICogNy7lj4zlh7tCT+W8ueWHukJP5bGe5oCn5Lul5Y+K5bGe5oCn5LqL5Lu25Yaz562W6aG16Z2iXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvQm9Ob2RlXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgQm9OYW1lID0gcmVxdWlyZSgnLi4vbm9kZS9Cb05hbWUnKTtcclxuICAgIHZhciBFdmVudERlY2lzaW9uID0gcmVxdWlyZSgnLi4vbm9kZS9FdmVudERlY2lzaW9uTm9kZScpO1xyXG4gICAgdmFyIExpbmUgPSByZXF1aXJlKCcuLi9ub2RlL0xpbmVOb2RlJyk7XHJcbiAgICB2YXIgQm9BdHRyID0gcmVxdWlyZSgnLi4vbm9kZS9Cb0F0dHJOb2RlJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgICAgICBpZDogU3RyaW5nIEJP5Li76ZSuLFxyXG4gICAgICogICAgICAgICAgbmFtZTogU3RyaW5nIEJP5ZCN5a2XLFxyXG4gICAgICogICAgICAgICAgYm9FdmVudEFycjogW10gQk/kuovku7blhrPnrZbmlbDnu4QsXHJcbiAgICAgKiAgICAgICAgICBib0F0dHJBcnI6IFtdIEJP5bGe5oCn5pWw57uEXHJcbiAgICAgKiAgICAgICAgICB9fSBib0RhdGEsIGJv5pWw5o2u5a+56LGhXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgIHN0YXJ0UG9zOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IOi1t+Wni+S9jee9rixcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlBdHRyRGF0YVR5cGU6IGJvb2xlYW4g5piv5ZCm5pi+56S65bGe5oCn5pWw5o2u57G75Z6LLFxyXG4gICAgICogICAgICAgICAgZGlzcGxheUF0dHJFdmVudDogYm9vbGVhbiDmmK/lkKbmmL7npLrlsZ7mgKfkuovku7blhrPnrZYsXHJcbiAgICAgKiAgICAgICAgICBib0NsaWNrYWJsZTogYm9vbGVhbiBCT+aYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBib1BvcHVwT3B0czogT2JqZWN0IEJP5by55Ye66aG16Z2i5Y+C5pWw77yMdXJsLHdpZHRoLGhlaWdodOetiVxyXG4gICAgICogICAgICAgICAgYm9FdmVudENsaWNrYWJsZTogYm9vbGVhbiBCT+S6i+S7tuWGs+etluaYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlXHJcbiAgICAgKiAgICAgICAgICBib0V2ZW50UG9wdXBPcHRzOiBPYmplY3QgQk/kuovku7blhrPnrZblvLnlh7rpobXpnaLlj4LmlbDvvIx1cmwsd2lkdGgsaGVpZ2h0562JXHJcbiAgICAgKiAgICAgICAgICBhdHRyRXZlbnRDbGlja2FibGU6IGJvb2xlYW4gQk/lsZ7mgKfkuovku7blhrPnrZbmmK/lkKbmlK/mjIHngrnlh7vkuovku7YsIOWPr+epuiDpu5jorqRmYWxzZVxyXG4gICAgICogICAgICAgICAgYXR0ckV2ZW50UG9wdXBPcHRzOiBPYmplY3Qg54K55Ye7Qk/lsZ7mgKfkuovku7blhrPnrZblvLnlh7rpobXpnaLlj4LmlbDvvIx1cmwsd2lkdGgsaGVpZ2h0562JXHJcbiAgICAgKiAgICAgICAgICBpc0N1cnJlbnQ6IGJvb2xlYW4g5piv5ZCm5Li65b2T5YmNQk9cclxuICAgICAqICAgICAgICAgIH19IG9wdHNcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCTyhib0RhdGEsIG9wdHMpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQk/mlbDmja5cclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IGJvRGF0YTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5Yid5aeL5Z2Q5qCH77yM55So5LqO5pyA5ZCO55S7Qk/nn6nlvaJcclxuICAgICAgICAgKiBAdHlwZSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX29yaVN0YXJ0UG9zID0gb3B0cy5zdGFydFBvcztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5q+P5Liq5o6n5Lu255qE6LW35aeL5Y+C54Wn5Z2Q5qCH77yM5q+P5Liq5o6n5Lu255S75a6M5LmL5ZCO6YO95Lya6YeN5paw6K6h566XXHJcbiAgICAgICAgICogQHR5cGUge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9uZXh0U3RhcnRQb3MgPSB7XHJcbiAgICAgICAgICAgIHg6IG9wdHMuc3RhcnRQb3MueCxcclxuICAgICAgICAgICAgeTogb3B0cy5zdGFydFBvcy55XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pi+56S65bGe5oCn5pWw5o2u57G75Z6LXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kaXNwbGF5QXR0ckRhdGFUeXBlID0gb3B0cy5kaXNwbGF5QXR0ckRhdGFUeXBlIHx8IGZhbHNlO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbmmL7npLrlsZ7mgKfkuovku7blhrPnrZZcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlBdHRyRXZlbnQgPSBvcHRzLmRpc3BsYXlBdHRyRXZlbnQgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIC8vVE9ET1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXNwbGF5QXR0ckV2ZW50KSB7XHJcbiAgICAgICAgICAgIENvbnN0LkJPX05PREVfV0lEVEggPSBDb25zdC5CT19OT0RFX1dJRFRIICogMztcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2Rpc3BsYXlBdHRyRGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgQ29uc3QuQk9fTk9ERV9XSURUSCA9IENvbnN0LkJPX05PREVfV0lEVEggKiAxLjU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbmlK/mjIHngrnlh7tcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvQ2xpY2thYmxlID0gb3B0cy5ib0NsaWNrYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ib1BvcHVwT3B0cyA9IG9wdHMuYm9Qb3B1cE9wdHM7XHJcbiAgICAgICAgdGhpcy5fYm9FdmVudENsaWNrYWJsZSA9IG9wdHMuYm9FdmVudENsaWNrYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ib0V2ZW50UG9wdXBPcHRzID0gb3B0cy5ib0V2ZW50UG9wdXBPcHRzO1xyXG4gICAgICAgIHRoaXMuX2F0dHJFdmVudENsaWNrYWJsZSA9IG9wdHMuYXR0ckV2ZW50Q2xpY2thYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2F0dHJFdmVudFBvcHVwT3B0cyA9IG9wdHMuYXR0ckV2ZW50UG9wdXBPcHRzO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiDmmK/lkKbmmK/lvZPliY1CT++8jOW9k+WJjUJP54m55q6K6aKc6Imy5pi+56S6XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9pc0N1cnJlbnQgPSBvcHRzLmlzQ3VycmVudCB8fCBmYWxzZTtcclxuXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJP55+p5b2i6auY5bqm77yM5qC55o2u5a6e6ZmF5YaF5a656K6h566XXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvU2hhcGVIZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcm91cOWuueWZqFxyXG4gICAgICAgICAqIEB0eXBlIHpyZW5kZXIvZ3JhcGhpYy9Hcm91cFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwLm5hbWUgPSB0aGlzLl9kYXRhLmlkO1xyXG4gICAgICAgIHRoaXMuX2dyb3VwLnNldEN1cnJlbnQgPSBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgLy9Hcm91cOacgOWQjuS4gOS4quaYr0JP55+p5b2iXHJcbiAgICAgICAgICAgIHZhciBfYm9TaGFwZSA9IHRoaXMuY2hpbGRBdCh0aGlzLmNoaWxkQ291bnQoKSAtIDEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBmaXNoLmV4dGVuZChfYm9TaGFwZS5zdHlsZSwgc3R5bGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy/pu5jorqTmlYjmnpxcclxuICAgICAgICAgICAgICAgIF9ib1NoYXBlLnN0eWxlLmZpbGwgPSAnIzY2Q0M5OSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHZhciBib1Byb3RvID0gQk8ucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+WQk/mlbTkvZPlm77lvaJcclxuICAgICAqIEByZXR1cm5zIHt6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uZ2V0U2hhcGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOiOt+WPluaVsOaNrlxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgYm9Qcm90by5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgfTtcclxuXHJcbiAgICBib1Byb3RvLmdldExheW91dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5sYXlvdXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDorr7nva7lvZPliY1CT+eJueauiua8lOekuuaYvuekulxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLnNldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy9CT+efqeW9ouaYr+acgOWQjuS4gOS4quWbvuW9olxyXG4gICAgICAgIHRoaXMuY2hpbGRBdCh0aGlzLmNoaWxkQ291bnQgLSAxKS5zdHlsZS5maWxsID0gJyM2NkNDOTknXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/mlbTkvZPlm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL0JP5ZCN5a2XXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlQm9OYW1lKCk7XHJcblxyXG4gICAgICAgIC8vQk/kuovku7blhrPnrZZcclxuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudERlY2lzaW9uKCk7XHJcblxyXG4gICAgICAgIC8vQk/lsZ7mgKdcclxuICAgICAgICB0aGlzLl9jcmVhdGVCb0F0dHIoKTtcclxuXHJcbiAgICAgICAgLy9CT+efqeW9olxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUJvU2hhcGUoKTtcclxuXHJcbiAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgQ29uc3QuQk9fTk9ERV9XSURUSCA9IDE4MDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/lkI3lrZfmlofmnKxcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX2NyZWF0ZUJvTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2JvTmFtZVNoYXBlID0gQm9OYW1lKHRoaXMuX2RhdGEubmFtZSwgdGhpcy5fbmV4dFN0YXJ0UG9zKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2JvQ2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIF9ib05hbWVTaGFwZS5jbGlja2FibGUgPSB0aGlzLl9ib0NsaWNrYWJsZTtcclxuICAgICAgICAgICAgX2JvTmFtZVNoYXBlLl9kYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgX2JvTmFtZVNoYXBlLl9ib1BvcHVwT3B0cyA9IHRoaXMuX2JvUG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBfYm9OYW1lU2hhcGUub25jbGljayA9IHRoaXMuX2NsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9ib05hbWVTaGFwZSk7XHJcbiAgICAgICAgdGhpcy5fY2FsTmV4dFNoYXBlU3RhcnRQb3MoX2JvTmFtZVNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJBCT+S6i+S7tuWGs+etllxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYm9Qcm90by5fY3JlYXRlRXZlbnREZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy/lpoLmnpzmsqHmnIlCT+S6i+S7tuWGs+etlu+8jOWImei/lOWbnlxyXG4gICAgICAgIGlmICghdGhpcy5fZGF0YS5ib0V2ZW50QXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfYm9FdmVudEFyciA9IHRoaXMuX2RhdGEuYm9FdmVudEFycixcclxuICAgICAgICAgICAgX2JvRXZlbnRMZW4gPSBfYm9FdmVudEFyci5sZW5ndGgsXHJcbiAgICAgICAgICAgIF9ldmVudFNoYXBlLFxyXG4gICAgICAgICAgICBfZXZlbnRPcHRzID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3M6IHRoaXMuX25leHRTdGFydFBvcyxcclxuICAgICAgICAgICAgICAgIGNsaWNrYWJsZTogdGhpcy5fYm9FdmVudENsaWNrYWJsZSxcclxuICAgICAgICAgICAgICAgIHBvcHVwT3B0czogdGhpcy5fYm9FdmVudFBvcHVwT3B0c1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ib0V2ZW50TGVuOyBpKyspIHtcclxuICAgICAgICAgICAgX2V2ZW50U2hhcGUgPSBuZXcgRXZlbnREZWNpc2lvbihfYm9FdmVudEFycltpXSwgX2V2ZW50T3B0cyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfZXZlbnRTaGFwZS5nZXRTaGFwZSgpKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsTmV4dFNoYXBlU3RhcnRQb3MoX2V2ZW50U2hhcGUuZ2V0U2hhcGUoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJBCT+WxnuaAp1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYm9Qcm90by5fY3JlYXRlQm9BdHRyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8v5aaC5p6c5rKh5pyJQk/lsZ7mgKfvvIzliJnov5Tlm55cclxuICAgICAgICBpZiAoIXRoaXMuX2RhdGEuYm9BdHRyQXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfYm9BdHRyQXJyID0gdGhpcy5fZGF0YS5ib0F0dHJBcnIsXHJcbiAgICAgICAgICAgIF9ib0F0dHJMZW4gPSBfYm9BdHRyQXJyLmxlbmd0aCxcclxuICAgICAgICAgICAgX2JvQXR0clNoYXBlLCBfbGluZVNoYXBlLFxyXG4gICAgICAgICAgICBfYXR0ckV2ZW50U3RhcnRQb3MgPSB7eDogdGhpcy5fbmV4dFN0YXJ0UG9zLnggKyBDb25zdC5CT19OT0RFX1dJRFRIIC8gMiwgeTogdGhpcy5fbmV4dFN0YXJ0UG9zLnl9O1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9ib0F0dHJMZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBfbGluZVNoYXBlID0gTGluZS5Cb0xpbmUodGhpcy5fbmV4dFN0YXJ0UG9zKTsgLy/lrp7nur9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9saW5lU2hhcGUgPSBMaW5lLkF0dHJMaW5lKHRoaXMuX25leHRTdGFydFBvcyk7Ly/omZrnur9cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9saW5lU2hhcGUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fY2FsTmV4dFNoYXBlU3RhcnRQb3MoX2xpbmVTaGFwZSk7XHJcblxyXG4gICAgICAgICAgICBfYm9BdHRyU2hhcGUgPSBuZXcgQm9BdHRyKF9ib0F0dHJBcnJbaV0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3M6IHRoaXMuX25leHRTdGFydFBvcyxcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RGF0YVR5cGU6IHRoaXMuX2Rpc3BsYXlBdHRyRGF0YVR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUV2ZW50RGVjaXNpb246IHRoaXMuX2Rpc3BsYXlBdHRyRXZlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRDbGlja2FibGU6IHRoaXMuX2F0dHJFdmVudENsaWNrYWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBldmVudFBvcHVwT3B0czogdGhpcy5fYXR0ckV2ZW50UG9wdXBPcHRzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfYm9BdHRyU2hhcGUuZ2V0U2hhcGUoKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbE5leHRTaGFwZVN0YXJ0UG9zKF9ib0F0dHJTaGFwZS5nZXRTaGFwZSgpKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlBdHRyRXZlbnQpIHtcclxuICAgICAgICAgICAgX2xpbmVTaGFwZSA9IExpbmUuQXR0ckV2ZW50TGluZShfYXR0ckV2ZW50U3RhcnRQb3MsXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0U3RhcnRQb3MueSAtIF9hdHRyRXZlbnRTdGFydFBvcy55XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwLmFkZChfbGluZVNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOiuoeeul+S4i+S4gOS4quWbvuW9oueahOW8gOWni+S9jee9ru+8jOS7peWPikJP55+p5b2i55qE6auY5bqmXHJcbiAgICAgKiBAcGFyYW0gY3VyU2hhcGUg5b2T5YmN5Zu+5b2iXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLl9jYWxOZXh0U2hhcGVTdGFydFBvcyA9IGZ1bmN0aW9uIChjdXJTaGFwZSkge1xyXG4gICAgICAgIC8v5LiL5LiA5Zu+5b2i6LW35aeL5L2N572uXHJcbiAgICAgICAgdGhpcy5fbmV4dFN0YXJ0UG9zLnkgKz0gY3VyU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0O1xyXG5cclxuICAgICAgICAvL0JP55+p5b2i6auY5bqm5aKe5YqgXHJcbiAgICAgICAgdGhpcy5fYm9TaGFwZUhlaWdodCArPSBjdXJTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUn+aIkEJP55+p5b2iXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib1Byb3RvLl9jcmVhdGVCb1NoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9ib1NoYXBlSGVpZ2h0ID4gQ29uc3QuQk9fTk9ERV9ERUZBVUxUX0hFSUdIVCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib1NoYXBlSGVpZ2h0IDogQ29uc3QuQk9fTk9ERV9ERUZBVUxUX0hFSUdIVCxcclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5SZWN0KHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBbdGhpcy5fb3JpU3RhcnRQb3MueCwgdGhpcy5fb3JpU3RhcnRQb3MueV0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgICAgICByOiA1LFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBDb25zdC5CT19OT0RFX1dJRFRILFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hUeXBlOiAnYm90aCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5faXNDdXJyZW50ID8gJyM2NkNDOTknIDogJ3doaXRlJyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZUNhcGU6ICdyb3VuZCdcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgemxldmVsOiAtMVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2JvQ2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLl9kYXRhID0gdGhpcy5fZGF0YTtcclxuICAgICAgICAgICAgc2hhcGUuX2JvUG9wdXBPcHRzID0gdGhpcy5fYm9Qb3B1cE9wdHM7XHJcblxyXG4gICAgICAgICAgICBzaGFwZS5jbGlja2FibGUgPSB0aGlzLl9ib0NsaWNrYWJsZTtcclxuICAgICAgICAgICAgc2hhcGUub25jbGljayA9IHRoaXMuX2NsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKHNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDngrnlh7vkuovku7ZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvUHJvdG8uX2NsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZmlzaC5leHRlbmQoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBEQVRBOiB0aGlzLl9kYXRhXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAwXHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2JvUG9wdXBPcHRzKTtcclxuXHJcbiAgICAgICAgZmlzaC5wb3B1cFZpZXcob3B0aW9ucyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQk87XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9Cb05vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICAgICAgQk9fTk9ERV9XSURUSDogMTgwLCAgICAvL0JP55+p5b2i5a695bqmXHJcbiAgICAgICAgQk9fTk9ERV9ERUZBVUxUX0hFSUdIVDogNjAsXHQvL0JP55+p5b2i6buY6K6k6auY5bqm77yM5Y2z5Y+q5pyJQk/lkI3lrZfnmoTmg4XlhrVcclxuICAgICAgICBCT19OT0RFX09GRlNFVF9YOiA5MCwgLy9CT+efqeW9oueahOawtOW5s+WBj+enu+mHjz3nn6nlvaLlrr3luqbnmoTkuIDoiKxcclxuICAgICAgICBCT19OT0RFX09GRlNFVF9ZOiA1MCwgLy9CT+efqeW9oueahOWeguebtOWBj+enu+mHj1xyXG5cclxuICAgICAgICBCT19OQU1FX0ZPTlQ6ICdib2xkIDE4cHggQXJpYWwnLCAvLydub3JtYWwgMTZweCB2ZXJkYW5hJywgICAgLy9CT+WQjeWtl+aWh+acrOagt+W8jyxcclxuICAgICAgICBCT19OQU1FX1BBRERJTkdfVE9QOiAxMCwgICAvL0JP5ZCN5a2X5LiO55+p5b2i5LiK6L655qGG55qE6Led56a7XHJcbiAgICAgICAgQk9fTkFNRV9QQURESU5HX0JPVFRPTTogMTUsICAgLy9CT+WQjeWtl+S4juS4i+S4gOS4quaOp+S7tu+8iOS6i+S7tuWGs+etluaIluiAheaoque6v++8ieeahOi3neemu1xyXG5cclxuICAgICAgICBCT19FVkVOVF9IRUlHSFQ6IDIwLCAgIC8vQk/kuovku7blhrPnrZblpJrovrnlvaLpq5jluqZcclxuICAgICAgICBCT19FVkVOVF9XSURUSDogMTQwLCAgIC8vQk/kuovku7blhrPnrZblpJrovrnlvaLlrr3luqZcclxuICAgICAgICBCT19FVkVOVF9GT05UOiAnbm9ybWFsIDE0cHggQXJpYWwnLCAgLy9CT+S6i+S7tuWGs+etluWQjeWtl+aWh+acrOagt+W8j1xyXG5cclxuICAgICAgICBCT19BVFRSX0ZPTlQ6ICdub3JtYWwgMTRweCBBcmlhbCcsICAgLy9CT+WxnuaAp+WQjeWtl+aWh+acrOagt+W8j1xyXG4gICAgICAgIEJPX0FUVFJfUEFERElOR19UT1A6IDUsICAgLy9CT+WxnuaAp+WQjeWtl+S4juefqeW9ouS4iui+ueahhueahOi3neemu1xyXG4gICAgICAgIEJPX0FUVFJfUEFERElOR19CT1RUT006IDUsICAgLy9CT+WxnuaAp+WQjeWtl+S4juS4i+S4gOS4quaOp+S7tu+8iOS6i+S7tuWGs+etluaIluiAheaoque6v++8ieeahOi3neemu1xyXG4gICAgICAgIEJPX0FUVFJfUEFERElOR19MRUZUOiA1LCAgIC8vQk/lsZ7mgKflkI3lrZfkuI7nn6nlvaLlt6bovrnmoYbnmoTot53nprtcclxuICAgICAgICBCT19BVFRSX0RBVEFfVFlQRV9QQURESU5HX1JJR0hUOiA1LCAvL0JP5bGe5oCn5pWw5o2u57G75Z6L5LiO55+p5b2i5Y+z6L655qGG55qE6Led56a7XHJcbiAgICAgICAgQk9fQVRUUl9FVkVOVF9XSURUSDogMTM1LCAgIC8vQk/lsZ7mgKfkuovku7blhrPnrZblpJrovrnlvaLlrr3luqZcclxuXHJcbiAgICAgICAgTElORV9EQVNIOiAxMCwgIC8v6Jma57q/XHJcbiAgICAgICAgUkVMQVRJT05fT0ZGU0VUOiA0MCwgICAvL+WFs+iBlOWFs+ezu+eahOWIneWni+WBj+enu+mHj++8jOWNs+esrOS4gOauteaKmOe6v+WuveW6plxyXG4gICAgICAgIFJFTEFUSU9OX0FSUk9XX1dJRFRIOiAxMCwgIC8v5YWz6IGU5YWz57O75LiJ6KeS566t5aS05rC05bmz5a695bqmXHJcbiAgICAgICAgUkVMQVRJT05fQVJST1dfSEVJR0hUOiA1LCAgLy/lhbPogZTlhbPns7vkuInop5Lnrq3lpLTlnoLnm7Tpq5jluqbnmoTkuIDljYpcclxuICAgICAgICBSRUxBVElPTl9URVhUX09GRlNFVF9YOiAxMCwgLy/lhbPogZTlhbPns7vmloflrZfor7TmmI7msLTlubPlgY/np7vph49cclxuICAgICAgICBSRUxBVElPTl9URVhUX09GRlNFVF9ZOiA1IC8v5YWz6IGU5YWz57O75paH5a2X6K+05piO5Z6C55u05YGP56e76YePXHJcbiAgICB9O1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYm8vbGliL21vZGVscy9Db25zdC5qc1xuICoqIG1vZHVsZSBpZCA9IDM4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQk/lkI3lrZdcclxuICogQG1vZHVsZSBmaXNoLXRvcG8tYm8vbm9kZS9Cb05hbWVcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29uc3QgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0LCBCT+WQjeWtl1xyXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBzdGFydFBvcywg6LW35aeL5L2N572uXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL1RleHR9XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQm9OYW1lKHRleHQsIHN0YXJ0UG9zKSB7XHJcbiAgICAgICAgdmFyIHggPSBzdGFydFBvcy54LFxyXG4gICAgICAgICAgICB5ID0gc3RhcnRQb3MueSArIENvbnN0LkJPX05BTUVfUEFERElOR19UT1AsIC8v5paH5a2X5Yiw55+p5b2i5LiK6L655qGG55qE6Led56a7IHBhZGRpbmctdG9wPTEwXHJcblxyXG4gICAgICAgICAgICBzaGFwZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRGb250OiBDb25zdC5CT19OQU1FX0ZPTlQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsICAvL+mdoOW3puW8gOWni++8jOS+v+S6juiuoeeul+S9jee9rlxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ3RvcCdcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFt4LCB5XVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy/mloflrZflsYXkuK3mmL7npLrvvIzph43mlrDorqHnrpfmlofmnKzmsLTlubPotbflp4vkvY3nva4gPSDnn6nlvaLmsLTlubPotbflp4vkvY3nva4gKyAoQk/nn6nlvaLlrr3luqYgLSDmlofmnKzlrr3luqYpLzJcclxuICAgICAgICBzaGFwZS5wb3NpdGlvblswXSArPSAoQ29uc3QuQk9fTk9ERV9XSURUSCAtIHNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoKSAvIDI7XHJcblxyXG4gICAgICAgIC8v6YeN5paw6K6+572uQk/lkI3lrZflm77lvaLpq5jluqYgPSDmlofmnKzpq5jluqYgKyBwYWRkaW5nLXRvcCArIHBhZGRpbmctYm90dG9tXHJcbiAgICAgICAgc2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0ICs9IENvbnN0LkJPX05BTUVfUEFERElOR19UT1AgKyBDb25zdC5CT19OQU1FX1BBRERJTkdfQk9UVE9NO1xyXG5cclxuICAgICAgICByZXR1cm4gc2hhcGU7XHJcbiAgICB9XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCb05hbWU7XHJcblxyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Zpc2gtdG9wby1iby9saWIvbm9kZS9Cb05hbWUuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXHJcblxyXG4gICAgdmFyIHpyVXRpbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvdXRpbCcpO1xyXG5cclxuICAgIHZhciBwYXRoVG9vbCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL3Rvb2wvcGF0aCcpO1xyXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcclxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoJyk7XHJcbiAgICB2YXIgY29sb3JUb29sID0gcmVxdWlyZSgnenJlbmRlci9saWIvdG9vbC9jb2xvcicpO1xyXG4gICAgdmFyIG1hdHJpeCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvcmUvbWF0cml4Jyk7XHJcbiAgICB2YXIgdmVjdG9yID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS92ZWN0b3InKTtcclxuICAgIHZhciBHcmFkaWVudCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQnKTtcclxuXHJcbiAgICB2YXIgZ3JhcGhpYyA9IHt9O1xyXG4gICAgZ3JhcGhpYy5VdGlsID0genJVdGlsO1xyXG4gICAgZ3JhcGhpYy5Hcm91cCA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW5lci9Hcm91cCcpO1xyXG5cclxuICAgIGdyYXBoaWMuSW1hZ2UgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5UZXh0ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy50ZXh0Q29udGFpbiA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dCcpO1xyXG5cclxuICAgIGdyYXBoaWMuQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUnKTtcclxuXHJcbiAgICBncmFwaGljLlNlY3RvciA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvU2VjdG9yJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5SaW5nID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5Z29uID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uJyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Qb2x5bGluZSA9IHJlcXVpcmUoJ3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLlJlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JlY3QnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmUgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0xpbmUnKTtcclxuXHJcbiAgICBncmFwaGljLkJlemllckN1cnZlID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZScpO1xyXG5cclxuICAgIGdyYXBoaWMuQXJjID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMnKTtcclxuXHJcbiAgICBncmFwaGljLkxpbmVhckdyYWRpZW50ID0gcmVxdWlyZSgnenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudCcpO1xyXG5cclxuICAgIGdyYXBoaWMuUmFkaWFsR3JhZGllbnQgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50Jyk7XHJcblxyXG4gICAgZ3JhcGhpYy5Cb3VuZGluZ1JlY3QgPSByZXF1aXJlKCd6cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdCcpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHNoYXBlIHdpdGggcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBncmFwaGljLmV4dGVuZFNoYXBlID0gZnVuY3Rpb24gKG9wdHMpIHtcclxuICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQob3B0cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kIHBhdGhcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5leHRlbmRQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBvcHRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdGhUb29sLmV4dGVuZEZyb21TdHJpbmcocGF0aERhdGEsIG9wdHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHBhdGggZWxlbWVudCBmcm9tIHBhdGggZGF0YSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoRGF0YVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGF5b3V0PWNvdmVyXSAnY2VudGVyJyBvciAnY292ZXInXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMubWFrZVBhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIG9wdHMsIHJlY3QsIGxheW91dCkge1xyXG4gICAgICAgIHZhciBwYXRoID0gcGF0aFRvb2wuY3JlYXRlRnJvbVN0cmluZyhwYXRoRGF0YSwgb3B0cyk7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nUmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XHJcbiAgICAgICAgaWYgKHJlY3QpIHtcclxuICAgICAgICAgICAgdmFyIGFzcGVjdCA9IGJvdW5kaW5nUmVjdC53aWR0aCAvIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAobGF5b3V0ID09PSAnY2VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlY3QgdG8gY2VudGVyLCBrZWVwIHdpZHRoIC8gaGVpZ2h0IHJhdGlvLlxyXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVjdC5oZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoIDw9IHJlY3Qud2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSByZWN0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIGFzcGVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjeCA9IHJlY3QueCArIHJlY3Qud2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN5ID0gcmVjdC55ICsgcmVjdC5oZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlY3QueCA9IGN4IC0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC55ID0gY3kgLSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplUGF0aChwYXRoLCByZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9O1xyXG5cclxuICAgIGdyYXBoaWMubWVyZ2VQYXRoID0gcGF0aFRvb2wubWVyZ2VQYXRoLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGEgcGF0aCB0byBmaXQgdGhlIHJlY3RcclxuICAgICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9QYXRofSBwYXRoXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVjdFxyXG4gICAgICovXHJcbiAgICBncmFwaGljLnJlc2l6ZVBhdGggPSBmdW5jdGlvbiAocGF0aCwgcmVjdCkge1xyXG4gICAgICAgIGlmICghcGF0aC5hcHBseVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGF0aFJlY3QgPSBwYXRoLmdldEJvdW5kaW5nUmVjdCgpO1xyXG5cclxuICAgICAgICB2YXIgbSA9IHBhdGhSZWN0LmNhbGN1bGF0ZVRyYW5zZm9ybShyZWN0KTtcclxuXHJcbiAgICAgICAgcGF0aC5hcHBseVRyYW5zZm9ybShtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnNoYXBlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS54MV1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW0uc2hhcGUueTFdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLngyXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS55Ml1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc3R5bGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnN0eWxlLmxpbmVXaWR0aF1cclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gTW9kaWZpZWQgcGFyYW1cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplTGluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIHZhciBzdWJQaXhlbE9wdGltaXplID0gZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplO1xyXG4gICAgICAgIHZhciBzaGFwZSA9IHBhcmFtLnNoYXBlO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGggPSBwYXJhbS5zdHlsZS5saW5lV2lkdGg7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZChzaGFwZS54MSAqIDIpID09PSByb3VuZChzaGFwZS54MiAqIDIpKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLngxID0gc2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLngxLCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocm91bmQoc2hhcGUueTEgKiAyKSA9PT0gcm91bmQoc2hhcGUueTIgKiAyKSkge1xyXG4gICAgICAgICAgICBzaGFwZS55MSA9IHNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS55MSwgbGluZVdpZHRoLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSByZWN0IGZvciBjYW52YXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW0uc2hhcGVdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnhdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLnldXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtLnNoYXBlLndpZHRoXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zaGFwZS5oZWlnaHRdXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtLnN0eWxlXVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbS5zdHlsZS5saW5lV2lkdGhdXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IE1vZGlmaWVkIHBhcmFtXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICB2YXIgc3ViUGl4ZWxPcHRpbWl6ZSA9IGdyYXBoaWMuc3ViUGl4ZWxPcHRpbWl6ZTtcclxuICAgICAgICB2YXIgc2hhcGUgPSBwYXJhbS5zaGFwZTtcclxuICAgICAgICB2YXIgbGluZVdpZHRoID0gcGFyYW0uc3R5bGUubGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBvcmlnaW5YID0gc2hhcGUueDtcclxuICAgICAgICB2YXIgb3JpZ2luWSA9IHNoYXBlLnk7XHJcbiAgICAgICAgdmFyIG9yaWdpbldpZHRoID0gc2hhcGUud2lkdGg7XHJcbiAgICAgICAgdmFyIG9yaWdpbkhlaWdodCA9IHNoYXBlLmhlaWdodDtcclxuICAgICAgICBzaGFwZS54ID0gc3ViUGl4ZWxPcHRpbWl6ZShzaGFwZS54LCBsaW5lV2lkdGgsIHRydWUpO1xyXG4gICAgICAgIHNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKHNoYXBlLnksIGxpbmVXaWR0aCwgdHJ1ZSk7XHJcbiAgICAgICAgc2hhcGUud2lkdGggPSBNYXRoLm1heChcclxuICAgICAgICAgICAgc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gc2hhcGUueCxcclxuICAgICAgICAgICAgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgc2hhcGUuaGVpZ2h0ID0gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgIHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBzaGFwZS55LFxyXG4gICAgICAgICAgICBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBTaG91bGQgYmUgbm9ubmVnYXRpdmUgaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHBvc2l0aXZlT3JOZWdhdGl2ZSBEZWZhdWx0IGZhbHNlIChuZWdhdGl2ZSkuXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wdGltaXplZCBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zdWJQaXhlbE9wdGltaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xyXG4gICAgICAgIC8vIEFzc3VyZSB0aGF0IChwb3NpdGlvbiArIGxpbmVXaWR0aCAvIDIpIGlzIG5lYXIgaW50ZWdlciBlZGdlLFxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBsaW5lIHdpbGwgYmUgZnV6enkgaW4gY2FudmFzLlxyXG4gICAgICAgIHZhciBkb3VibGVkUG9zaXRpb24gPSByb3VuZChwb3NpdGlvbiAqIDIpO1xyXG4gICAgICAgIHJldHVybiAoZG91YmxlZFBvc2l0aW9uICsgcm91bmQobGluZVdpZHRoKSkgJSAyID09PSAwXHJcbiAgICAgICAgICAgID8gZG91YmxlZFBvc2l0aW9uIC8gMlxyXG4gICAgICAgICAgICA6IChkb3VibGVkUG9zaXRpb24gKyAocG9zaXRpdmVPck5lZ2F0aXZlID8gMSA6IC0xKSkgLyAyO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRvU2luZ2xlRW50ZXJIb3ZlcihlbCkge1xyXG4gICAgICAgIGlmIChlbC5fX2lzSG92ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWwuX19ob3ZlclN0bERpcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJva2UgPSBlbC5zdHlsZS5zdHJva2U7XHJcbiAgICAgICAgICAgIHZhciBmaWxsID0gZWwuc3R5bGUuZmlsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBob3ZlclN0eWxlIG9uIG1vdXNlb3ZlclxyXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGVsLl9faG92ZXJTdGw7XHJcbiAgICAgICAgICAgIHZhciBsaWZ0ID0gY29sb3JUb29sLmxpZnQ7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuZmlsbCA9IGhvdmVyU3R5bGUuZmlsbFxyXG4gICAgICAgICAgICAgICAgfHwgKGZpbGwgJiYgKGZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCA/IGZpbGwgOiBsaWZ0KGZpbGwsIC0wLjEpKSk7XHJcbiAgICAgICAgICAgIGhvdmVyU3R5bGUuc3Ryb2tlID0gaG92ZXJTdHlsZS5zdHJva2VcclxuICAgICAgICAgICAgICAgIHx8IChzdHJva2UgJiYgKHN0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50ID8gc3Ryb2tlIDogbGlmdChzdHJva2UsIC0wLjEpKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBob3ZlclN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG92ZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFN0eWxlW25hbWVdID0gZWwuc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVsLl9fbm9ybWFsU3RsID0gbm9ybWFsU3R5bGU7XHJcblxyXG4gICAgICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuc2V0U3R5bGUoZWwuX19ob3ZlclN0bCk7XHJcbiAgICAgICAgZWwuejIgKz0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpIHtcclxuICAgICAgICBpZiAoIWVsLl9faXNIb3Zlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbm9ybWFsU3RsID0gZWwuX19ub3JtYWxTdGw7XHJcbiAgICAgICAgbm9ybWFsU3RsICYmIGVsLnNldFN0eWxlKG5vcm1hbFN0bCk7XHJcbiAgICAgICAgZWwuejIgLT0gMTtcclxuXHJcbiAgICAgICAgZWwuX19pc0hvdmVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZG9FbnRlckhvdmVyKGVsKSB7XHJcbiAgICAgICAgZWwudHlwZSA9PT0gJ2dyb3VwJ1xyXG4gICAgICAgICAgICA/IGVsLnRyYXZlcnNlKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09ICdncm91cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1NpbmdsZUVudGVySG92ZXIoY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICA6IGRvU2luZ2xlRW50ZXJIb3ZlcihlbCk7XHJcbiAgICB9XHJcbiAgICBncmFwaGljLmRvRW50ZXJIb3ZlciA9IGRvRW50ZXJIb3ZlcjtcclxuICAgIGZ1bmN0aW9uIGRvTGVhdmVIb3ZlcihlbCkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9TaW5nbGVMZWF2ZUhvdmVyKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBkb1NpbmdsZUxlYXZlSG92ZXIoZWwpO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5kb0xlYXZlSG92ZXIgPSBkb0xlYXZlSG92ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3RsKSB7XHJcbiAgICAgICAgLy8gSWYgZWxlbWVudCBoYXMgc2VwY2lmaWVkIGhvdmVyU3R5bGUsIHRoZW4gdXNlIGl0IGluc3RlYWQgb2YgZ2l2ZW4gaG92ZXJTdHlsZVxyXG4gICAgICAgIC8vIE9mdGVuIHVzZWQgd2hlbiBpdGVtIGdyb3VwIGhhcyBhIGxhYmVsIGVsZW1lbnQgYW5kIGl0J3MgaG92ZXJTdHlsZSBpcyBkaWZmZXJlbnRcclxuICAgICAgICBlbC5fX2hvdmVyU3RsID0gZWwuaG92ZXJTdHlsZSB8fCBob3ZlclN0bCB8fCB7fTtcclxuICAgICAgICBlbC5fX2hvdmVyU3RsRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ3JhcGhpYy5zZXRFbGVtZW50SG92ZXJTdGwgPSBzZXRFbGVtZW50SG92ZXJTdGw7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbkVsZW1lbnRNb3VzZU92ZXIoKSB7XHJcbiAgICAgICAgLy8gT25seSBpZiBlbGVtZW50IGlzIG5vdCBpbiBlbXBoYXNpcyBzdGF0dXNcclxuICAgICAgICAhdGhpcy5fX2lzRW1waGFzaXMgJiYgZG9FbnRlckhvdmVyKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRWxlbWVudE1vdXNlT3V0KCkge1xyXG4gICAgICAgIC8vIE9ubHkgaWYgZWxlbWVudCBpcyBub3QgaW4gZW1waGFzaXMgc3RhdHVzXHJcbiAgICAgICAgIXRoaXMuX19pc0VtcGhhc2lzICYmIGRvTGVhdmVIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBlbnRlckVtcGhhc2lzKCkge1xyXG4gICAgICAgIHRoaXMuX19pc0VtcGhhc2lzID0gdHJ1ZTtcclxuICAgICAgICBkb0VudGVySG92ZXIodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbGVhdmVFbXBoYXNpcygpIHtcclxuICAgICAgICB0aGlzLl9faXNFbXBoYXNpcyA9IGZhbHNlO1xyXG4gICAgICAgIGRvTGVhdmVIb3Zlcih0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBob3ZlciBzdHlsZSBvZiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2hvdmVyU3R5bGVdXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMuc2V0SG92ZXJTdHlsZSA9IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xyXG4gICAgICAgIGVsLnR5cGUgPT09ICdncm91cCdcclxuICAgICAgICAgICAgPyBlbC50cmF2ZXJzZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudEhvdmVyU3RsKGNoaWxkLCBob3ZlclN0eWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgOiBzZXRFbGVtZW50SG92ZXJTdGwoZWwsIGhvdmVyU3R5bGUpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBib3VuZCBoYW5kbGVyc1xyXG4gICAgICAgIGVsLm9uKCdtb3VzZW92ZXInLCBvbkVsZW1lbnRNb3VzZU92ZXIpXHJcbiAgICAgICAgICAub24oJ21vdXNlb3V0Jywgb25FbGVtZW50TW91c2VPdXQpO1xyXG5cclxuICAgICAgICAvLyBFbXBoYXNpcywgbm9ybWFsIGNhbiBiZSB0cmlnZ2VyZWQgbWFudWFsbHlcclxuICAgICAgICBlbC5vbignZW1waGFzaXMnLCBlbnRlckVtcGhhc2lzKVxyXG4gICAgICAgICAgLm9uKCdub3JtYWwnLCBsZWF2ZUVtcGhhc2lzKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGV4dCBvcHRpb24gaW4gdGhlIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGV4dFN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBsYWJlbE1vZGVsXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5zZXRUZXh0ID0gZnVuY3Rpb24gKHRleHRTdHlsZSwgbGFiZWxNb2RlbCwgY29sb3IpIHtcclxuICAgICAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygncG9zaXRpb24nKSB8fCAnaW5zaWRlJztcclxuICAgICAgICB2YXIgbGFiZWxDb2xvciA9IGxhYmVsUG9zaXRpb24uaW5kZXhPZignaW5zaWRlJykgPj0gMCA/ICd3aGl0ZScgOiBjb2xvcjtcclxuICAgICAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSBsYWJlbE1vZGVsLmdldE1vZGVsKCd0ZXh0U3R5bGUnKTtcclxuICAgICAgICB6clV0aWwuZXh0ZW5kKHRleHRTdHlsZSwge1xyXG4gICAgICAgICAgICB0ZXh0RGlzdGFuY2U6IGxhYmVsTW9kZWwuZ2V0U2hhbGxvdygnZGlzdGFuY2UnKSB8fCA1LFxyXG4gICAgICAgICAgICB0ZXh0Rm9udDogdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpLFxyXG4gICAgICAgICAgICB0ZXh0UG9zaXRpb246IGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgIHRleHRGaWxsOiB0ZXh0U3R5bGVNb2RlbC5nZXRUZXh0Q29sb3IoKSB8fCBsYWJlbENvbG9yXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGFuaW1hdGVPclNldFByb3BzKGlzVXBkYXRlLCBlbCwgcHJvcHMsIGFuaW1hdGFibGVNb2RlbCwgY2IpIHtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzVXBkYXRlID8gJ1VwZGF0ZScgOiAnJztcclxuICAgICAgICB2YXIgZHVyYXRpb24gPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkR1cmF0aW9uJyArIHBvc3RmaXgpO1xyXG4gICAgICAgIHZhciBhbmltYXRpb25FYXNpbmcgPSBhbmltYXRhYmxlTW9kZWxcclxuICAgICAgICAgICAgJiYgYW5pbWF0YWJsZU1vZGVsLmdldFNoYWxsb3coJ2FuaW1hdGlvbkVhc2luZycgKyBwb3N0Zml4KTtcclxuXHJcbiAgICAgICAgYW5pbWF0YWJsZU1vZGVsICYmIGFuaW1hdGFibGVNb2RlbC5nZXRTaGFsbG93KCdhbmltYXRpb24nKVxyXG4gICAgICAgICAgICA/IGVsLmFuaW1hdGVUbyhwcm9wcywgZHVyYXRpb24sIGFuaW1hdGlvbkVhc2luZywgY2IpXHJcbiAgICAgICAgICAgIDogKGVsLmF0dHIocHJvcHMpLCBjYiAmJiBjYigpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy51cGRhdGVQcm9wcyA9IHpyVXRpbC5jdXJyeShhbmltYXRlT3JTZXRQcm9wcywgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0IGdyYXBoaWMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBjb25maWd1cmF0aW9uIGluIHNlcmllc1xyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTplY2hhcnRzL21vZGVsL01vZGVsfSBbYW5pbWF0YWJsZU1vZGVsXVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcclxuICAgICAqL1xyXG4gICAgZ3JhcGhpYy5pbml0UHJvcHMgPSB6clV0aWwuY3VycnkoYW5pbWF0ZU9yU2V0UHJvcHMsIGZhbHNlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0cmFuc2Zvcm0gbWF0cml4IG9mIHRhcmdldCAocGFyYW0gdGFyZ2V0KSxcclxuICAgICAqIGluIGNvb3JkaW5hdGUgb2YgaXRzIGFuY2VzdG9yIChwYXJhbSBhbmNlc3RvcilcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGV9IHRhcmdldFxyXG4gICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfSBhbmNlc3RvclxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0YXJnZXQsIGFuY2VzdG9yKSB7XHJcbiAgICAgICAgdmFyIG1hdCA9IG1hdHJpeC5pZGVudGl0eShbXSk7XHJcblxyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICBtYXRyaXgubXVsKG1hdCwgdGFyZ2V0LmdldExvY2FsVHJhbnNmb3JtKCksIG1hdCk7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRyYW5zZm9ybSB0byBhbiB2ZXJ0ZXguXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZXJ0ZXggW3gsIHldXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59IFt4LCB5XVxyXG4gICAgICovXHJcbiAgICBncmFwaGljLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuICAgICAgICBpZiAoaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5pbnZlcnQoW10sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0oW10sIHZlcnRleCwgdHJhbnNmb3JtKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB0cmFuc2Zvcm0gVHJhbnNmb3JtIG1hdHJpeDogbGlrZSBbMSwgMCwgMCwgMSwgMCwgMF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGludmVydCBXaGV0aGVyIHVzZSBpbnZlcnQgbWF0cml4LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUcmFuc2Zvcm1lZCBkaXJlY3Rpb24uICdsZWZ0JyAncmlnaHQnICd0b3AnICdib3R0b20nXHJcbiAgICAgKi9cclxuICAgIGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdHJhbnNmb3JtLCBpbnZlcnQpIHtcclxuXHJcbiAgICAgICAgLy8gUGljayBhIGJhc2UsIGVuc3VyZSB0aGF0IHRyYW5zZm9ybSByZXN1bHQgd2lsbCBub3QgYmUgKDAsIDApLlxyXG4gICAgICAgIHZhciBoQmFzZSA9ICh0cmFuc2Zvcm1bNF0gPT09IDAgfHwgdHJhbnNmb3JtWzVdID09PSAwIHx8IHRyYW5zZm9ybVswXSA9PT0gMClcclxuICAgICAgICAgICAgPyAxIDogTWF0aC5hYnMoMiAqIHRyYW5zZm9ybVs0XSAvIHRyYW5zZm9ybVswXSk7XHJcbiAgICAgICAgdmFyIHZCYXNlID0gKHRyYW5zZm9ybVs0XSA9PT0gMCB8fCB0cmFuc2Zvcm1bNV0gPT09IDAgfHwgdHJhbnNmb3JtWzJdID09PSAwKVxyXG4gICAgICAgICAgICA/IDEgOiBNYXRoLmFicygyICogdHJhbnNmb3JtWzRdIC8gdHJhbnNmb3JtWzJdKTtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IFtcclxuICAgICAgICAgICAgZGlyZWN0aW9uID09PSAnbGVmdCcgPyAtaEJhc2UgOiBkaXJlY3Rpb24gPT09ICdyaWdodCcgPyBoQmFzZSA6IDAsXHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3RvcCcgPyAtdkJhc2UgOiBkaXJlY3Rpb24gPT09ICdib3R0b20nID8gdkJhc2UgOiAwXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgdmVydGV4ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybSh2ZXJ0ZXgsIHRyYW5zZm9ybSwgaW52ZXJ0KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHZlcnRleFswXSkgPiBNYXRoLmFicyh2ZXJ0ZXhbMV0pXHJcbiAgICAgICAgICAgID8gKHZlcnRleFswXSA+IDAgPyAncmlnaHQnIDogJ2xlZnQnKVxyXG4gICAgICAgICAgICA6ICh2ZXJ0ZXhbMV0gPiAwID8gJ2JvdHRvbScgOiAndG9wJyk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gZ3JhcGhpYztcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBQYXRoID0gcmVxdWlyZSgnLi4vZ3JhcGhpYy9QYXRoJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKCcuL3RyYW5zZm9ybVBhdGgnKTtcbiAgICB2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vY29yZS9tYXRyaXgnKTtcblxuICAgIC8vIGNvbW1hbmQgY2hhcnNcbiAgICB2YXIgY2MgPSBbXG4gICAgICAgICdtJywgJ00nLCAnbCcsICdMJywgJ3YnLCAnVicsICdoJywgJ0gnLCAneicsICdaJyxcbiAgICAgICAgJ2MnLCAnQycsICdxJywgJ1EnLCAndCcsICdUJywgJ3MnLCAnUycsICdhJywgJ0EnXG4gICAgXTtcblxuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aFNpbiA9IE1hdGguc2luO1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIFBJID0gTWF0aC5QSTtcblxuICAgIHZhciB2TWFnID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgICAgcmV0dXJuICh1WzBdICogdlswXSArIHVbMV0gKiB2WzFdKSAvICh2TWFnKHUpICogdk1hZyh2KSk7XG4gICAgfTtcbiAgICB2YXIgdkFuZ2xlID0gZnVuY3Rpb24odSwgdikge1xuICAgICAgICByZXR1cm4gKHVbMF0gKiB2WzFdIDwgdVsxXSAqIHZbMF0gPyAtMSA6IDEpXG4gICAgICAgICAgICAgICAgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0FyYyh4MSwgeTEsIHgyLCB5MiwgZmEsIGZzLCByeCwgcnksIHBzaURlZywgY21kLCBwYXRoKSB7XG4gICAgICAgIHZhciBwc2kgPSBwc2lEZWcgKiAoUEkgLyAxODAuMCk7XG4gICAgICAgIHZhciB4cCA9IG1hdGhDb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMFxuICAgICAgICAgICAgICAgICArIG1hdGhTaW4ocHNpKSAqICh5MSAtIHkyKSAvIDIuMDtcbiAgICAgICAgdmFyIHlwID0gLTEgKiBtYXRoU2luKHBzaSkgKiAoeDEgLSB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICAgICAgdmFyIGxhbWJkYSA9ICh4cCAqIHhwKSAvIChyeCAqIHJ4KSArICh5cCAqIHlwKSAvIChyeSAqIHJ5KTtcblxuICAgICAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgICAgICAgcnggKj0gbWF0aFNxcnQobGFtYmRhKTtcbiAgICAgICAgICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpXG4gICAgICAgICAgICAqIG1hdGhTcXJ0KCgoKHJ4ICogcngpICogKHJ5ICogcnkpKVxuICAgICAgICAgICAgICAgICAgICAtICgocnggKiByeCkgKiAoeXAgKiB5cCkpXG4gICAgICAgICAgICAgICAgICAgIC0gKChyeSAqIHJ5KSAqICh4cCAqIHhwKSkpIC8gKChyeCAqIHJ4KSAqICh5cCAqIHlwKVxuICAgICAgICAgICAgICAgICAgICArIChyeSAqIHJ5KSAqICh4cCAqIHhwKSlcbiAgICAgICAgICAgICAgICApIHx8IDA7XG5cbiAgICAgICAgdmFyIGN4cCA9IGYgKiByeCAqIHlwIC8gcnk7XG4gICAgICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgICAgICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjBcbiAgICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeHBcbiAgICAgICAgICAgICAgICAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gICAgICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMFxuICAgICAgICAgICAgICAgICsgbWF0aFNpbihwc2kpICogY3hwXG4gICAgICAgICAgICAgICAgKyBtYXRoQ29zKHBzaSkgKiBjeXA7XG5cbiAgICAgICAgdmFyIHRoZXRhID0gdkFuZ2xlKFsgMSwgMCBdLCBbICh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5IF0pO1xuICAgICAgICB2YXIgdSA9IFsgKHhwIC0gY3hwKSAvIHJ4LCAoeXAgLSBjeXApIC8gcnkgXTtcbiAgICAgICAgdmFyIHYgPSBbICgtMSAqIHhwIC0gY3hwKSAvIHJ4LCAoLTEgKiB5cCAtIGN5cCkgLyByeSBdO1xuICAgICAgICB2YXIgZFRoZXRhID0gdkFuZ2xlKHUsIHYpO1xuXG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2UmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICAgICAgZFRoZXRhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnMgPT09IDAgJiYgZFRoZXRhID4gMCkge1xuICAgICAgICAgICAgZFRoZXRhID0gZFRoZXRhIC0gMiAqIFBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcyA9PT0gMSAmJiBkVGhldGEgPCAwKSB7XG4gICAgICAgICAgICBkVGhldGEgPSBkVGhldGEgKyAyICogUEk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjeCwgY3ksIHJ4LCByeSwgdGhldGEsIGRUaGV0YSwgcHNpLCBmcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICAgICAgdmFyIGNzID0gZGF0YS5yZXBsYWNlKC8tL2csICcgLScpXG4gICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyAvZywgJywnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLywsL2csICcsJyk7XG5cbiAgICAgICAgdmFyIG47XG4gICAgICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgYXJyYXlcbiAgICAgICAgdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gICAgICAgIC8vIGluaXQgY29udGV4dCBwb2ludFxuICAgICAgICB2YXIgY3B4ID0gMDtcbiAgICAgICAgdmFyIGNweSA9IDA7XG5cbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aFByb3h5KCk7XG4gICAgICAgIHZhciBDTUQgPSBQYXRoUHJveHkuQ01EO1xuXG4gICAgICAgIHZhciBwcmV2Q21kO1xuICAgICAgICBmb3IgKG4gPSAxOyBuIDwgYXJyLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICB2YXIgc3RyID0gYXJyW25dO1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICAgICAgICB2YXIgcCA9IHN0ci5zbGljZSgxKS5yZXBsYWNlKC9lLC0vZywgJ2UtJykuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIHZhciBjbWQ7XG5cbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDAgJiYgcFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHBbaV0gPSBwYXJzZUZsb2F0KHBbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKG9mZiA8IHAubGVuZ3RoICYmICFpc05hTihwW29mZl0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY3RsUHR4O1xuICAgICAgICAgICAgICAgIHZhciBjdGxQdHk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcng7XG4gICAgICAgICAgICAgICAgdmFyIHJ5O1xuICAgICAgICAgICAgICAgIHZhciBwc2k7XG4gICAgICAgICAgICAgICAgdmFyIGZhO1xuICAgICAgICAgICAgICAgIHZhciBmcztcblxuICAgICAgICAgICAgICAgIHZhciB4MSA9IGNweDtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSBjcHk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IGwsIEgsIGgsIFYsIGFuZCB2IHRvIExcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gQ01ELkw7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbWQsIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ICs9IHBbb2ZmIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuQztcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHggKyBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gY3B5ICsgcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxID0gcFtvZmYrK10gKyBjcHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHgxLCB5MSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5RO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICByeSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnMgPSBwW29mZisrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzaSA9IHBbb2ZmKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZzID0gcFtvZmYrK107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSwgeTEsIGNweCwgY3B5LCBmYSwgZnMsIHJ4LCByeSwgcHNpLCBjbWQsIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgY21kID0gQ01ELlo7XG4gICAgICAgICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZDbWQgPSBjbWQ7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoLnRvU3RhdGljKCk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykge1xuICAgICAgICB2YXIgcGF0aFByb3h5ID0gY3JlYXRlUGF0aFByb3h5RnJvbVN0cmluZyhzdHIpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5zZXREYXRhKHBhdGhQcm94eS5kYXRhKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybSAmJiB0cmFuc2Zvcm1QYXRoKHBhdGgsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAvLyBTdmcgYW5kIHZtbCByZW5kZXJlciBkb24ndCBoYXZlIGNvbnRleHRcbiAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgb3B0cy5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hdHJpeC5tdWwodHJhbnNmb3JtLCBtLCB0cmFuc2Zvcm0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIFBhdGggY2xhc3MgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPdGhlciBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmRGcm9tU3RyaW5nOiBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5leHRlbmQoY3JlYXRlUGF0aE9wdGlvbnMoc3RyLCBvcHRzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1lcmdlIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAqL1xuICAgICAgICAvLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuICAgICAgICAvLyBUT0RPIHN0cm9rZSBkYXNoXG4gICAgICAgIC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cbiAgICAgICAgbWVyZ2VQYXRoOiBmdW5jdGlvbiAocGF0aEVscywgb3B0cykge1xuICAgICAgICAgICAgdmFyIHBhdGhMaXN0ID0gW107XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgcGF0aEVsO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoRWwuX19kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRWwuYnVpbGRQYXRoKHBhdGhFbC5wYXRoLCBwYXRoRWwuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXRoTGlzdC5wdXNoKHBhdGhFbC5wYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGhCdW5kbGUgPSBuZXcgUGF0aChvcHRzKTtcbiAgICAgICAgICAgIHBhdGhCdW5kbGUuYnVpbGRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoLmFwcGVuZFBhdGgocGF0aExpc3QpO1xuICAgICAgICAgICAgICAgIC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuICAgICAgICAgICAgICAgIHZhciBjdHggPSBwYXRoLmdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucmVidWlsZFBhdGgoY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aEJ1bmRsZTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi90b29sL3BhdGguanNcbiAqKiBtb2R1bGUgaWQgPSA0MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBQYXRoIGVsZW1lbnRcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL1BhdGhcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5Jyk7XG4gICAgdmFyIHBhdGhDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi9wYXRoJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICBmdW5jdGlvbiBwYXRoSGFzRmlsbChzdHlsZSkge1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgICAgIHJldHVybiBmaWxsICE9IG51bGwgJiYgZmlsbCAhPT0gJ25vbmUnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGhIYXNTdHJva2Uoc3R5bGUpIHtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gJ25vbmUnICYmIHN0eWxlLmxpbmVXaWR0aCA+IDA7XG4gICAgfVxuXG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuXG4gICAgLyoqXG4gICAgICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICAgICAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBhdGgob3B0cykge1xuICAgICAgICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIFBhdGgucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxuXG4gICAgICAgIHR5cGU6ICdwYXRoJyxcblxuICAgICAgICBfX2RpcnR5UGF0aDogdHJ1ZSxcblxuICAgICAgICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuXG4gICAgICAgIGJydXNoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICB2YXIgaGFzU3Ryb2tlID0gcGF0aEhhc1N0cm9rZShzdHlsZSk7XG4gICAgICAgICAgICB2YXIgaGFzRmlsbCA9IHBhdGhIYXNGaWxsKHN0eWxlKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZ3JhZGllbnQgYmVjYXVzZSBib3VuZGluZyByZWN0IG1heSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZpbGwgJiYgKHN0eWxlLmZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsbC51cGRhdGVDYW52YXNHcmFkaWVudCh0aGlzLCBjdHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU3Ryb2tlICYmIChzdHlsZS5zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuc3Ryb2tlLnVwZGF0ZUNhbnZhc0dyYWRpZW50KHRoaXMsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZS5iaW5kKGN0eCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuXG4gICAgICAgICAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgY3R4TGluZURhc2ggPSAhIWN0eC5zZXRMaW5lRGFzaDtcblxuICAgICAgICAgICAgLy8gUHJveHkgY29udGV4dFxuICAgICAgICAgICAgLy8gUmVidWlsZCBwYXRoIGluIGZvbGxvd2luZyAyIGNhc2VzXG4gICAgICAgICAgICAvLyAxLiBQYXRoIGlzIGRpcnR5XG4gICAgICAgICAgICAvLyAyLiBQYXRoIG5lZWRzIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZURhc2ggc3Ryb2tpbmcuXG4gICAgICAgICAgICAvLyAgICBJbiB0aGlzIGNhc2UsIGxpbmVEYXNoIGluZm9ybWF0aW9uIHdpbGwgbm90IGJlIHNhdmVkIGluIFBhdGhQcm94eVxuICAgICAgICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGggfHwgKFxuICAgICAgICAgICAgICAgIGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCAmJiBoYXNTdHJva2VcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5wYXRoLmJlZ2luUGF0aChjdHgpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0dGluZyBsaW5lIGRhc2ggYmVmb3JlIGJ1aWxkIHBhdGhcbiAgICAgICAgICAgICAgICBpZiAobGluZURhc2ggJiYgIWN0eExpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldExpbmVEYXNoT2Zmc2V0KGxpbmVEYXNoT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuICAgICAgICAgICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxheSBwYXRoIGJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNGaWxsICYmIHBhdGguZmlsbChjdHgpO1xuXG4gICAgICAgICAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoYXNTdHJva2UgJiYgcGF0aC5zdHJva2UoY3R4KTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0IHRleHRcbiAgICAgICAgICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlQ2ZnKSB7fSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gdGhpcy5fcmVjdDtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5lZWRzIHVwZGF0ZSByZWN0IHdpdGggc3Ryb2tlIGxpbmVXaWR0aCB3aGVuXG4gICAgICAgICAgICAgKiAxLiBFbGVtZW50IGNoYW5nZXMgc2NhbGUgb3IgbGluZVdpZHRoXG4gICAgICAgICAgICAgKiAyLiBGaXJzdCBjcmVhdGUgcmVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocGF0aEhhc1N0cm9rZShzdHlsZSkgJiYgKHRoaXMuX19kaXJ0eSB8fCAhdGhpcy5fcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVjdFdpdGhTdHJva2UgPSB0aGlzLl9yZWN0V2l0aFN0cm9rZVxuICAgICAgICAgICAgICAgICAgICB8fCAodGhpcy5fcmVjdFdpdGhTdHJva2UgPSByZWN0LmNsb25lKCkpO1xuICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7XG4gICAgICAgICAgICAgICAgLy8gRklYTUUgTXVzdCBhZnRlciB1cGRhdGVUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICB2YXIgdyA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAvLyBQRU5ESU5HLCBNaW4gbGluZSB3aWR0aCBpcyBuZWVkZWQgd2hlbiBsaW5lIGlzIGhvcml6b250YWwgb3IgdmVydGljYWxcbiAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhIYXNGaWxsKHN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgbGluZSB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIExpbmUgc2NhbGUgY2FuJ3QgYmUgMDtcbiAgICAgICAgICAgICAgICBpZiAobGluZVNjYWxlID4gMWUtMTApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdFdpdGhTdHJva2UuaGVpZ2h0ICs9IHcgLyBsaW5lU2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnggLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWN0V2l0aFN0cm9rZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICAgICAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFBvcyA9IHRoaXMudHJhbnNmb3JtQ29vcmRUb0xvY2FsKHgsIHkpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHggPSBsb2NhbFBvc1swXTtcbiAgICAgICAgICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuY29udGFpbih4LCB5KSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoSGFzU3Ryb2tlKHN0eWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZVNjYWxlID0gc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IHRoaXMuZ2V0TGluZVNjYWxlKCkgOiAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBMaW5lIHNjYWxlIGNhbid0IGJlIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgZXh0cmEgaG92ZXIgbGluZVdpZHRoIHdoZW4gdGhlcmUgYXJlIG5vIGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGF0aEhhc0ZpbGwoc3R5bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gTWF0aC5tYXgobGluZVdpZHRoLCB0aGlzLnN0cm9rZUNvbnRhaW5UaHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWluLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEsIGxpbmVXaWR0aCAvIGxpbmVTY2FsZSwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXRoSGFzRmlsbChzdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAgICAgICAqL1xuICAgICAgICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09MCkge1xuICAgICAgICAgICAgICAgIGRpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IG1hcmsgZGlydHksIG5vdCBtYXJrIGNsZWFuXG4gICAgICAgICAgICBpZiAoZGlydHlQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2RpcnR5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG5cbiAgICAgICAgICAgIC8vIFVzZWQgYXMgYSBjbGlwcGluZyBwYXRoXG4gICAgICAgICAgICBpZiAodGhpcy5fX2NsaXBUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGlhcyBmb3IgYW5pbWF0ZSgnc2hhcGUnKVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGVTaGFwZTogZnVuY3Rpb24gKGxvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoJ3NoYXBlJywgbG9vcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICAgICAgICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBGSVhNRVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXBlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2hhcGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRGlzcGxheWFibGUucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBrZXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2hhcGU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgLy8gUGF0aCBmcm9tIHN0cmluZyBtYXkgbm90IGhhdmUgc2hhcGVcbiAgICAgICAgICAgIGlmIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVbbmFtZV0gPSBrZXlbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExpbmVTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgICAgICAgIC8vIERldGVybWluYW50IG9mIGBtYCBtZWFucyBob3cgbXVjaCB0aGUgYXJlYSBpcyBlbmxhcmdlZCBieSB0aGVcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAgICAgICAgIC8vIGZvciB3aWR0aC5cbiAgICAgICAgICAgIHJldHVybiBtICYmIGFicyhtWzBdIC0gMSkgPiAxZS0xMCAmJiBhYnMobVszXSAtIDEpID4gMWUtMTBcbiAgICAgICAgICAgICAgICA/IE1hdGguc3FydChhYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSkpXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOaJqeWxleS4gOS4qiBQYXRoIGVsZW1lbnQsIOavlOWmguaYn+W9ou+8jOWchuetieOAglxuICAgICAqIEV4dGVuZCBhIHBhdGggZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy50eXBlIFBhdGggdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmJ1aWxkUGF0aCBPdmVyd3JpdGUgYnVpbGRQYXRoIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHMuc3R5bGVdIEV4dGVuZGVkIGRlZmF1bHQgc3R5bGUgY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0gRXh0ZW5kZWQgZGVmYXVsdCBzaGFwZSBjb25maWdcbiAgICAgKi9cbiAgICBQYXRoLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgICAgIFBhdGguY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgICAgICAgICAgaWYgKGRlZmF1bHRzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc3R5bGVcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIGRlZmF1bHQgc2hhcGVcbiAgICAgICAgICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0U2hhcGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gdGhpcy5zaGFwZSB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc1NoYXBlID0gdGhpcy5zaGFwZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAhIHRoaXNTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGVmYXVsdFNoYXBlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1NoYXBlW25hbWVdID0gZGVmYXVsdFNoYXBlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0cy5pbml0ICYmIGRlZmF1bHRzLmluaXQuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB6clV0aWwuaW5oZXJpdHMoU3ViLCBQYXRoKTtcblxuICAgICAgICAvLyBGSVhNRSDkuI3og70gZXh0ZW5kIHBvc2l0aW9uLCByb3RhdGlvbiDnrYnlvJXnlKjlr7nosaFcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSAnc3R5bGUnICYmIG5hbWUgIT09ICdzaGFwZScpIHtcbiAgICAgICAgICAgICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3ViO1xuICAgIH07XG5cbiAgICB6clV0aWwuaW5oZXJpdHMoUGF0aCwgRGlzcGxheWFibGUpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQYXRoO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICogUGF0aCDku6PnkIbvvIzlj6/ku6XlnKhgYnVpbGRQYXRoYOS4reeUqOS6juabv+S7o2BjdHhgLCDkvJrkv53lrZjmr4/kuKpwYXRo5pON5L2c55qE5ZG95Luk5YiwcGF0aENvbW1hbmRz5bGe5oCn5LitXG4gKiDlj6/ku6XnlKjkuo4gaXNJbnNpZGVQYXRoIOWIpOaWreS7peWPiuiOt+WPlmJvdW5kaW5nUmVjdFxuICpcbiAqIEBtb2R1bGUgenJlbmRlci9jb3JlL1BhdGhQcm94eVxuICogQGF1dGhvciBZaSBTaGVuIChodHRwOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG4gLy8gVE9ETyBnZXRUb3RhbExlbmd0aCwgZ2V0UG9pbnRBdExlbmd0aFxuXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuL2N1cnZlJyk7XG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xuICAgIHZhciBiYm94ID0gcmVxdWlyZSgnLi9iYm94Jyk7XG4gICAgdmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoJy4vQm91bmRpbmdSZWN0Jyk7XG5cbiAgICB2YXIgQ01EID0ge1xuICAgICAgICBNOiAxLFxuICAgICAgICBMOiAyLFxuICAgICAgICBDOiAzLFxuICAgICAgICBROiA0LFxuICAgICAgICBBOiA1LFxuICAgICAgICBaOiA2LFxuICAgICAgICAvLyBSZWN0XG4gICAgICAgIFI6IDdcbiAgICB9O1xuXG4gICAgdmFyIG1pbiA9IFtdO1xuICAgIHZhciBtYXggPSBbXTtcbiAgICB2YXIgbWluMiA9IFtdO1xuICAgIHZhciBtYXgyID0gW107XG4gICAgdmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aFNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgICB2YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUGF0aFByb3h5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XG5cbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl94aSA9IDA7XG4gICAgICAgIHRoaXMuX3lpID0gMDtcblxuICAgICAgICB0aGlzLl94MCA9IDA7XG4gICAgICAgIHRoaXMuX3kwID0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5b+r6YCf6K6h566XUGF0aOWMheWbtOebku+8iOW5tuS4jeaYr+acgOWwj+WMheWbtOebku+8iVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBQYXRoUHJveHkucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG5cbiAgICAgICAgX2xpbmVEYXNoOiBudWxsLFxuXG4gICAgICAgIF9kYXNoT2Zmc2V0OiAwLFxuXG4gICAgICAgIF9kYXNoSWR4OiAwLFxuXG4gICAgICAgIF9kYXNoU3VtOiAwLFxuXG4gICAgICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdHg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggPSBjdHg7XG5cbiAgICAgICAgICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgICAgIC8vIFJlc2V0XG4gICAgICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lRGFzaCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELk0sIHgsIHkpO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5tb3ZlVG8oeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIHgwLCB5MCwgeGksIHlpIOaYr+iusOW9leWcqCBfZGFzaGVkWFhYWFRvIOaWueazleS4reS9v+eUqFxuICAgICAgICAgICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgICAgICAgICAvLyDmnInlj6/og73lnKggYmVnaW5QYXRoIOS5i+WQjuebtOaOpeiwg+eUqCBsaW5lVG/vvIzov5nml7blgJkgeDAsIHkwIOmcgOimgVxuICAgICAgICAgICAgLy8g5ZyoIGxpbmVUbyDmlrnms5XkuK3orrDlvZXvvIzov5nph4zlhYjkuI3ogIPomZHov5nnp43mg4XlhrXvvIxkYXNoZWQgbGluZSDkuZ/lj6rlnKggSUUxMC0g5Lit5LiN5pSv5oyBXG4gICAgICAgICAgICB0aGlzLl94MCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkwsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELkMsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDM7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRGF0YShDTUQuUSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N0eCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feGkgPSB4MjtcbiAgICAgICAgICAgIHRoaXMuX3lpID0geTI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgdGhpcy5hZGREYXRhKFxuICAgICAgICAgICAgICAgIENNRC5BLCBjeCwgY3ksIHIsIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSwgMCwgYW50aWNsb2Nrd2lzZSA/IDAgOiAxXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByICsgY3g7XG4gICAgICAgICAgICB0aGlzLl94aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN4O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBhcmNUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguYXJjVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERhdGEoQ01ELlopO1xuXG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feDA7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95MDtcbiAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc0Rhc2goKSAmJiB0aGlzLl9kYXNoZWRMaW5lVG8oeDAsIHkwKTtcbiAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3hpID0geDA7XG4gICAgICAgICAgICB0aGlzLl95aSA9IHkwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRleHQg5LuO5aSW6YOo5Lyg5YWl77yM5Zug5Li65pyJ5Y+v6IO95pivIHJlYnVpbGRQYXRoIOWujOS5i+WQjuWGjSBmaWxs44CCXG4gICAgICAgICAqIHN0cm9rZSDlkIzmoLdcbiAgICAgICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIGZpbGw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICAgICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgICAgICAgKi9cbiAgICAgICAgc3Ryb2tlOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBjdHggJiYgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgdGhpcy50b1N0YXRpYygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICAgICAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICAgICAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgICAgICAgICBpZiAobGluZURhc2ggaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcblxuICAgICAgICAgICAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lRGFzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lRGFzaFN1bSArPSBsaW5lRGFzaFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGFzaFN1bSA9IGxpbmVEYXNoU3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOW/hemhu+WcqOWFtuWug+e7mOWItuWRveS7pOWJjeiwg+eUqFxuICAgICAgICAgKiBNdXN0IGJlIGludm9rZWQgYmVmb3JlIGFsbCBvdGhlciBwYXRoIGRyYXdpbmcgbWV0aG9kc1xuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICAgICAgICovXG4gICAgICAgIHNldExpbmVEYXNoT2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBsZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW47XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIOebtOaOpeiuvue9riBQYXRoIOaVsOaNrlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0YTogZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAoISAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5sZW5ndGggPT0gbGVuKSAmJiBoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gZGF0YVtpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fbGVuID0gbGVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmt7vliqDlrZDot6/lvoRcbiAgICAgICAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eXxBcnJheS48bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHk+fSBwYXRoXG4gICAgICAgICAqL1xuICAgICAgICBhcHBlbmRQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5ICYmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShvZmZzZXQgKyBhcHBlbmRTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBwZW5kUGF0aERhdGEgPSBwYXRoW2ldLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcHBlbmRQYXRoRGF0YS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbb2Zmc2V0KytdID0gYXBwZW5kUGF0aERhdGFba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGVuID0gb2Zmc2V0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDloavlhYUgUGF0aCDmlbDmja7jgIJcbiAgICAgICAgICog5bC96YeP5aSN55So6ICM5LiN55Sz5piO5paw55qE5pWw57uE44CC5aSn6YOo5YiG5Zu+5b2i6YeN57uY55qE5oyH5Luk5pWw5o2u6ZW/5bqm6YO95piv5LiN5Y+Y55qE44CCXG4gICAgICAgICAqL1xuICAgICAgICBhZGREYXRhOiBmdW5jdGlvbiAoY21kKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZW4gKyBhcmd1bWVudHMubGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICAgICAgLy8g5omA5Lul5LiN5aSf55So5pe26ZyA6KaB5omp5bGV5LiA5Liq5paw55qE5Yqo5oCB5pWw57uEXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kRGF0YSgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGFbdGhpcy5fbGVuKytdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wcmV2Q21kID0gY21kO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9leHBhbmREYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICBpZiAoISh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbmVlZHMganMgaW1wbGVtZW50ZWQgZGFzaGVkIGxpbmVcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9uZWVkc0Rhc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkTGluZVRvOiBmdW5jdGlvbiAoeDEsIHkxKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgICAgICAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgeCA9IHgwO1xuICAgICAgICAgICAgdmFyIHkgPSB5MDtcbiAgICAgICAgICAgIHZhciBkYXNoO1xuICAgICAgICAgICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcbiAgICAgICAgICAgIGR4IC89IGRpc3Q7XG4gICAgICAgICAgICBkeSAvPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZGFzaFN1bSArIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgICAgICAgICAgeCAtPSBvZmZzZXQgKiBkeDtcbiAgICAgICAgICAgIHkgLT0gb2Zmc2V0ICogZHk7XG5cbiAgICAgICAgICAgIHdoaWxlICgoZHggPj0gMCAmJiB4IDw9IHgxKSB8fCAoZHggPCAwICYmIHggPiB4MSkpIHtcbiAgICAgICAgICAgICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgICAgICAgICAgIGRhc2ggPSBsaW5lRGFzaFtpZHhdO1xuICAgICAgICAgICAgICAgIHggKz0gZHggKiBkYXNoO1xuICAgICAgICAgICAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rhc2hJZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmICgoZHggPiAwICYmIHggPCB4MCkgfHwgKGR4IDwgMCAmJiB4ID4geDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHhbaWR4ICUgMiA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuICAgICAgICAgICAgICAgICAgICBkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSxcbiAgICAgICAgICAgICAgICAgICAgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuICAgICAgICAgICAgZHggPSB4IC0geDE7XG4gICAgICAgICAgICBkeSA9IHkgLSB5MTtcbiAgICAgICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIE5vdCBhY2N1cmF0ZSBkYXNoZWQgbGluZSB0b1xuICAgICAgICBfZGFzaGVkQmV6aWVyVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgICAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsaW5lRGFzaCA9IHRoaXMuX2xpbmVEYXNoO1xuICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgICAgICAgICAgdmFyIHgwID0gdGhpcy5feGk7XG4gICAgICAgICAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgdmFyIGR4O1xuICAgICAgICAgICAgdmFyIGR5O1xuICAgICAgICAgICAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICAgICAgICAgICAgdmFyIGJlemllckxlbiA9IDA7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICAgICAgICAgIHZhciBuRGFzaCA9IGxpbmVEYXNoLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICB2YXIgeTtcblxuICAgICAgICAgICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICU9IGRhc2hTdW07XG4gICAgICAgICAgICAvLyBCZXppZXIgYXBwcm94IGxlbmd0aFxuICAgICAgICAgICAgZm9yICh0ID0gMDsgdCA8IDE7IHQgKz0gMC4xKSB7XG4gICAgICAgICAgICAgICAgZHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0ICsgMC4xKVxuICAgICAgICAgICAgICAgICAgICAtIGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHQpO1xuICAgICAgICAgICAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSlcbiAgICAgICAgICAgICAgICAgICAgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgICAgICAgICBiZXppZXJMZW4gKz0gbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG4gICAgICAgICAgICBmb3IgKDsgaWR4IDwgbkRhc2g7IGlkeCsrKSB7XG4gICAgICAgICAgICAgICAgdG1wTGVuICs9IGxpbmVEYXNoW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHRtcExlbiA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gKHRtcExlbiAtIG9mZnNldCkgLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgIHdoaWxlICh0IDw9IDEpIHtcblxuICAgICAgICAgICAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICB5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2UgbGluZSB0byBhcHByb3hpbWF0ZSBkYXNoZWQgYmV6aWVyXG4gICAgICAgICAgICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcbiAgICAgICAgICAgICAgICBpZHggJSAyID8gY3R4Lm1vdmVUbyh4LCB5KVxuICAgICAgICAgICAgICAgICAgICA6IGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgICAgICAgICAgICB0ICs9IGxpbmVEYXNoW2lkeF0gLyBiZXppZXJMZW47XG5cbiAgICAgICAgICAgICAgICBpZHggPSAoaWR4ICsgMSkgJSBuRGFzaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmluaXNoIHRoZSBsYXN0IHNlZ21lbnQgYW5kIGNhbGN1bGF0ZSB0aGUgbmV3IG9mZnNldFxuICAgICAgICAgICAgKGlkeCAlIDIgIT09IDApICYmIGN0eC5saW5lVG8oeDMsIHkzKTtcbiAgICAgICAgICAgIGR4ID0geDMgLSB4O1xuICAgICAgICAgICAgZHkgPSB5MyAtIHk7XG4gICAgICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgdmFyIHgzID0geDI7XG4gICAgICAgICAgICB2YXIgeTMgPSB5MjtcbiAgICAgICAgICAgIHgyID0gKHgyICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MiA9ICh5MiArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICAgICAgICAgIHkxID0gKHRoaXMuX3lpICsgMiAqIHkxKSAvIDM7XG5cbiAgICAgICAgICAgIHRoaXMuX2Rhc2hlZEJlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiDovazmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5IOWHj+WwkeWghuWGheWtmOWNoOeUqFxuICAgICAgICAgKiBDb252ZXJ0IGR5bmFtaWMgYXJyYXkgdG8gc3RhdGljIEZsb2F0MzJBcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdGF0aWM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gdGhpcy5fbGVuO1xuICAgICAgICAgICAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWluWzBdID0gbWluWzFdID0gbWluMlswXSA9IG1pbjJbMV0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgbWF4WzBdID0gbWF4WzFdID0gbWF4MlswXSA9IG1heDJbMV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgICAgIHZhciB4MCA9IDA7XG4gICAgICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIHZhciBjbWQgPSBkYXRhW2krK107XG5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOesrOS4gOS4quWRveS7pOaYryBMLCBDLCBRXG4gICAgICAgICAgICAgICAgICAgIC8vIOWImSBwcmV2aW91cyBwb2ludCDlkIznu5jliLblkb3ku6TnmoTnrKzkuIDkuKogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk5Li6IEFyYyDnmoTmg4XlhrXkuIvkvJrlnKjlkI7pnaLnibnmrorlpITnkIZcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgICAgIHgwID0geGk7XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlswXSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4MlsxXSA9IHkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5DOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmJveC5mcm9tQ3ViaWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjIsIG1heDJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21RdWFkcmF0aWMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBkYXRhW2krK10gKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5peL6L2sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MCA9IG1hdGhDb3Moc3RhcnRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkwID0gbWF0aFNpbihzdGFydEFuZ2xlKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJib3guZnJvbUFyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSwgbWluMiwgbWF4MlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgeGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGZyb21MaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBiYm94LmZyb21MaW5lKHgwLCB5MCwgeDAgKyB3aWR0aCwgeTAgKyBoZWlnaHQsIG1pbjIsIG1heDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVuaW9uXG4gICAgICAgICAgICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgICAgICAgICAgIHZlYzIubWF4KG1heCwgbWF4LCBtYXgyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gZGF0YVxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtaW5bMF0gPSBtaW5bMV0gPSBtYXhbMF0gPSBtYXhbMV0gPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChcbiAgICAgICAgICAgICAgICBtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlYnVpbGQgcGF0aCBmcm9tIGN1cnJlbnQgZGF0YVxuICAgICAgICAgKiBSZWJ1aWxkIHBhdGggd2lsbCBub3QgY29uc2lkZXIgamF2YXNjcmlwdCBpbXBsZW1lbnRlZCBsaW5lIGRhc2guXG4gICAgICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dH0gY3R4XG4gICAgICAgICAqL1xuICAgICAgICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIGQgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjspIHtcbiAgICAgICAgICAgICAgICB2YXIgY21kID0gZFtpKytdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIENNRC5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK11cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuUTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGRbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHNpID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZzID0gZFtpKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAocnggPiByeSkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWCA9IChyeCA+IHJ5KSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlWSA9IChyeCA+IHJ5KSA/IHJ5IC8gcnggOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKGN4LCBjeSwgciwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCAxIC0gZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgucmVjdChkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhQcm94eS5DTUQgPSBDTUQ7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhdGhQcm94eTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvcmUvUGF0aFByb3h5LmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIid1c2Ugc3RyaWN0Jztcbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIHYyQ3JlYXRlID0gdmVjMi5jcmVhdGU7XG4gICAgdmFyIHYyRGlzdFNxdWFyZSA9IHZlYzIuZGlzdFNxdWFyZTtcbiAgICB2YXIgbWF0aFBvdyA9IE1hdGgucG93O1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIHZhciBUSFJFRV9TUVJUID0gbWF0aFNxcnQoMyk7XG4gICAgdmFyIE9ORV9USElSRCA9IDEgLyAzO1xuXG4gICAgLy8g5Li05pe25Y+Y6YePXG4gICAgdmFyIF92MCA9IHYyQ3JlYXRlKCk7XG4gICAgdmFyIF92MSA9IHYyQ3JlYXRlKCk7XG4gICAgdmFyIF92MiA9IHYyQ3JlYXRlKCk7XG4gICAgLy8gdmFyIF92MyA9IHZlYzIuY3JlYXRlKCk7XG5cbiAgICBmdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiAtRVBTSUxPTiAmJiB2YWwgPCBFUFNJTE9OO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuInmrKHotJ3loZ7lsJTlgLxcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSlcbiAgICAgICAgICAgICArIHQgKiB0ICogKHQgKiBwMyArIDMgKiBvbmV0ICogcDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOWvvOaVsOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gMyAqIChcbiAgICAgICAgICAgICgocDEgLSBwMCkgKiBvbmV0ICsgMiAqIChwMiAtIHAxKSAqIHQpICogb25ldFxuICAgICAgICAgICAgKyAocDMgLSBwMikgKiB0ICogdFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IHJvb3RzXG4gICAgICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAgICAgICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgICAgICAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgICAgICAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICAgICAgICB2YXIgYyA9IDMgKiAocDEgIC0gcDApO1xuICAgICAgICB2YXIgZCA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gICAgICAgIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gICAgICAgIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG5cbiAgICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oQSkgJiYgaXNBcm91bmRaZXJvKEIpKSB7XG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGIpKSB7XG4gICAgICAgICAgICAgICAgcm9vdHNbMF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWMgLyBiOyAgLy90MSwgdDIsIHQzLCBiIGlzIG5vdCB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpc2MgPSBCICogQiAtIDQgKiBBICogQztcblxuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciBLID0gQiAvIEE7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgIC8vIHQxLCBhIGlzIG5vdCB6ZXJvXG4gICAgICAgICAgICAgICAgdmFyIHQyID0gLUsgLyAyOyAgLy8gdDIsIHQzXG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgICAgICAgICAgIHZhciBZMiA9IEEgKiBiICsgMS41ICogYSAqICgtQiAtIGRpc2NTcXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgVCA9ICgyICogQSAqIGIgLSAzICogYSAqIEIpIC8gKDIgKiBtYXRoU3FydChBICogQSAqIEEpKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBNYXRoLmFjb3MoVCkgLyAzO1xuICAgICAgICAgICAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAoLWIgLSAyICogQVNxcnQgKiB0bXApIC8gKDMgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgKyBBU3FydCAqICh0bXAgKyBUSFJFRV9TUVJUICogTWF0aC5zaW4odGhldGEpKSkgLyAoMyAqIGEpO1xuICAgICAgICAgICAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC855qE5L2N572uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAzXG4gICAgICogQHBhcmFtICB7QXJyYXkuPG51bWJlcj59IGV4dHJlbWFcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljRXh0cmVtYShwMCwgcDEsIHAyLCBwMywgZXh0cmVtYSkge1xuICAgICAgICB2YXIgYiA9IDYgKiBwMiAtIDEyICogcDEgKyA2ICogcDA7XG4gICAgICAgIHZhciBhID0gOSAqIHAxICsgMyAqIHAzIC0gMyAqIHAwIC0gOSAqIHAyO1xuICAgICAgICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcblxuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmIChpc0Fyb3VuZFplcm8oYSkpIHtcbiAgICAgICAgICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdDEgPSAtYyAvIGI7XG4gICAgICAgICAgICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWFbbisrXSA9IHQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gICAgICAgICAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtYVswXSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpc2MgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICAgICAgICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICB2YXIgdDIgPSAoLWIgLSBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtYVtuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOe7huWIhuS4ieasoei0neWhnuWwlOabsue6v1xuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gdFxuICAgICAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gICAgICAgIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gICAgICAgIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gICAgICAgIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG5cbiAgICAgICAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7XG4gICAgICAgIHZhciBwMTIzID0gKHAyMyAtIHAxMikgKiB0ICsgcDEyO1xuXG4gICAgICAgIHZhciBwMDEyMyA9IChwMTIzIC0gcDAxMikgKiB0ICsgcDAxMjtcbiAgICAgICAgLy8gU2VnMFxuICAgICAgICBvdXRbMF0gPSBwMDtcbiAgICAgICAgb3V0WzFdID0gcDAxO1xuICAgICAgICBvdXRbMl0gPSBwMDEyO1xuICAgICAgICBvdXRbM10gPSBwMDEyMztcbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbNF0gPSBwMDEyMztcbiAgICAgICAgb3V0WzVdID0gcDEyMztcbiAgICAgICAgb3V0WzZdID0gcDIzO1xuICAgICAgICBvdXRbN10gPSBwMztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDmipXlsITngrnliLDkuInmrKHotJ3loZ7lsJTmm7Lnur/kuIrvvIzov5Tlm57mipXlsITot53nprvjgIJcbiAgICAgKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTBcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gW291dF0g5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsXG4gICAgICAgIHgsIHksIG91dFxuICAgICkge1xuICAgICAgICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gICAgICAgIHZhciB0O1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgICAgICAgdmFyIGQgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgZDE7XG4gICAgICAgIHZhciBkMjtcblxuICAgICAgICBfdjBbMF0gPSB4O1xuICAgICAgICBfdjBbMV0gPSB5O1xuXG4gICAgICAgIC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAgICAgICAvLyBQRU5ESU5HXG4gICAgICAgIGZvciAodmFyIF90ID0gMDsgX3QgPCAxOyBfdCArPSAwLjA1KSB7XG4gICAgICAgICAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBfdCk7XG4gICAgICAgICAgICBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgICAgICAgICAgbmV4dCA9IHQgKyBpbnRlcnZhbDtcbiAgICAgICAgICAgIC8vIHQgLSBpbnRlcnZhbFxuICAgICAgICAgICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgICAgICAgICBfdjFbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBwcmV2KTtcblxuICAgICAgICAgICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IGN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIG5leHQpO1xuICAgICAgICAgICAgICAgIGQyID0gdjJEaXN0U3F1YXJlKF92MiwgX3YwKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkID0gZDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgb3V0WzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG4gICAgICAgICAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG4gICAgICAgIHJldHVybiBtYXRoU3FydChkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTlgLxcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljQXQocDAsIHAxLCBwMiwgdCkge1xuICAgICAgICB2YXIgb25ldCA9IDEgLSB0O1xuICAgICAgICByZXR1cm4gb25ldCAqIChvbmV0ICogcDAgKyAyICogdCAqIHAxKSArIHQgKiB0ICogcDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgICAgIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorqHnrpfkuozmrKHmlrnotJ3loZ7lsJTmlrnnqIvmoLlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOagueaVsOebrlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gICAgICAgIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgICAgICAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICAgICAgICB2YXIgYyA9IHAwIC0gdmFsO1xuXG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgICAgICAgICAgaWYgKGlzTm90QXJvdW5kWmVybyhiKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1jIC8gYjtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgICAgICAgICAgaWYgKGlzQXJvdW5kWmVybyhkaXNjKSkge1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IC1iIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgICAgICAgICAgIHZhciB0MSA9ICgtYiArIGRpc2NTcXJ0KSAvICgyICogYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgICAgICAgICAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RzW24rK10gPSB0MTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICByb290c1tuKytdID0gdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuoeeul+S6jOasoei0neWhnuWwlOaWueeoi+aegemZkOWAvFxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY0V4dHJlbXVtKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGRpdmlkZXIgPSBwMCArIHAyIC0gMiAqIHAxO1xuICAgICAgICBpZiAoZGl2aWRlciA9PT0gMCkge1xuICAgICAgICAgICAgLy8gcDEgaXMgY2VudGVyIG9mIHAwIGFuZCBwMlxuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAocDAgLSBwMSkgLyBkaXZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog57uG5YiG5LqM5qyh6LSd5aGe5bCU5puy57q/XG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gcXVhZHJhdGljU3ViZGl2aWRlKHAwLCBwMSwgcDIsIHQsIG91dCkge1xuICAgICAgICB2YXIgcDAxID0gKHAxIC0gcDApICogdCArIHAwO1xuICAgICAgICB2YXIgcDEyID0gKHAyIC0gcDEpICogdCArIHAxO1xuICAgICAgICB2YXIgcDAxMiA9IChwMTIgLSBwMDEpICogdCArIHAwMTtcblxuICAgICAgICAvLyBTZWcwXG4gICAgICAgIG91dFswXSA9IHAwO1xuICAgICAgICBvdXRbMV0gPSBwMDE7XG4gICAgICAgIG91dFsyXSA9IHAwMTI7XG5cbiAgICAgICAgLy8gU2VnMVxuICAgICAgICBvdXRbM10gPSBwMDEyO1xuICAgICAgICBvdXRbNF0gPSBwMTI7XG4gICAgICAgIG91dFs1XSA9IHAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOaKleWwhOeCueWIsOS6jOasoei0neWhnuWwlOabsue6v+S4iu+8jOi/lOWbnuaKleWwhOi3neemu+OAglxuICAgICAqIOaKleWwhOeCueacieWPr+iDveS8muacieS4gOS4quaIluiAheWkmuS4qu+8jOi/memHjOWPqui/lOWbnuWFtuS4rei3neemu+acgOefreeahOS4gOS4quOAglxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQg5oqV5bCE54K5XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHF1YWRyYXRpY1Byb2plY3RQb2ludChcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgeCwgeSwgb3V0XG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wb21heC5naXRodWIuaW8vYmV6aWVyaW5mby8jcHJvamVjdGlvbnNcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IDAuMDA1O1xuICAgICAgICB2YXIgZCA9IEluZmluaXR5O1xuXG4gICAgICAgIF92MFswXSA9IHg7XG4gICAgICAgIF92MFsxXSA9IHk7XG5cbiAgICAgICAgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gICAgICAgIC8vIFBFTkRJTkdcbiAgICAgICAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICAgICAgICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIF90KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdFNxdWFyZShfdjAsIF92MSk7XG4gICAgICAgICAgICBpZiAoZDEgPCBkKSB7XG4gICAgICAgICAgICAgICAgdCA9IF90O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gQXQgbW9zdCAzMiBpdGVyYXRpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgPCBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdCArIGludGVydmFsO1xuICAgICAgICAgICAgLy8gdCAtIGludGVydmFsXG4gICAgICAgICAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICAgICAgICAgIF92MVsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHByZXYpO1xuXG4gICAgICAgICAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgICAgICAgICBpZiAocHJldiA+PSAwICYmIGQxIDwgZCkge1xuICAgICAgICAgICAgICAgIHQgPSBwcmV2O1xuICAgICAgICAgICAgICAgIGQgPSBkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHQgKyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgICAgICAgICAgIF92MlsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIG5leHQpO1xuICAgICAgICAgICAgICAgIHZhciBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPD0gMSAmJiBkMiA8IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGQgPSBkMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVydmFsICo9IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdFxuICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBvdXRbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCB0KTtcbiAgICAgICAgICAgIG91dFsxXSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGludGVydmFsLCBpKTtcbiAgICAgICAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgICAgIGN1YmljQXQ6IGN1YmljQXQsXG5cbiAgICAgICAgY3ViaWNEZXJpdmF0aXZlQXQ6IGN1YmljRGVyaXZhdGl2ZUF0LFxuXG4gICAgICAgIGN1YmljUm9vdEF0OiBjdWJpY1Jvb3RBdCxcblxuICAgICAgICBjdWJpY0V4dHJlbWE6IGN1YmljRXh0cmVtYSxcblxuICAgICAgICBjdWJpY1N1YmRpdmlkZTogY3ViaWNTdWJkaXZpZGUsXG5cbiAgICAgICAgY3ViaWNQcm9qZWN0UG9pbnQ6IGN1YmljUHJvamVjdFBvaW50LFxuXG4gICAgICAgIHF1YWRyYXRpY0F0OiBxdWFkcmF0aWNBdCxcblxuICAgICAgICBxdWFkcmF0aWNEZXJpdmF0aXZlQXQ6IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCxcblxuICAgICAgICBxdWFkcmF0aWNSb290QXQ6IHF1YWRyYXRpY1Jvb3RBdCxcblxuICAgICAgICBxdWFkcmF0aWNFeHRyZW11bTogcXVhZHJhdGljRXh0cmVtdW0sXG5cbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlOiBxdWFkcmF0aWNTdWJkaXZpZGUsXG5cbiAgICAgICAgcXVhZHJhdGljUHJvamVjdFBvaW50OiBxdWFkcmF0aWNQcm9qZWN0UG9pbnRcbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29yZS9jdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEBhdXRob3IgWWkgU2hlbihodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuXG5cbiAgICB2YXIgdmVjMiA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi9jdXJ2ZScpO1xuXG4gICAgdmFyIGJib3ggPSB7fTtcbiAgICB2YXIgbWF0aE1pbiA9IE1hdGgubWluO1xuICAgIHZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgbWF0aENvcyA9IE1hdGguY29zO1xuXG4gICAgdmFyIHN0YXJ0ID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZW5kID0gdmVjMi5jcmVhdGUoKTtcbiAgICB2YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAvKipcbiAgICAgKiDku47pobbngrnmlbDnu4TkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gICAgICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gcG9pbnRzIOmhtueCueaVsOe7hFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbGVmdCA9IHBbMF07XG4gICAgICAgIHZhciByaWdodCA9IHBbMF07XG4gICAgICAgIHZhciB0b3AgPSBwWzFdO1xuICAgICAgICB2YXIgYm90dG9tID0gcFsxXTtcbiAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGxlZnQgPSBtYXRoTWluKGxlZnQsIHBbMF0pO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXRoTWF4KHJpZ2h0LCBwWzBdKTtcbiAgICAgICAgICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1hdGhNYXgoYm90dG9tLCBwWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pblswXSA9IGxlZnQ7XG4gICAgICAgIG1pblsxXSA9IHRvcDtcbiAgICAgICAgbWF4WzBdID0gcmlnaHQ7XG4gICAgICAgIG1heFsxXSA9IGJvdHRvbTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1heFxuICAgICAqL1xuICAgIGJib3guZnJvbUxpbmUgPSBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIG1pbiwgbWF4KSB7XG4gICAgICAgIG1pblswXSA9IG1hdGhNaW4oeDAsIHgxKTtcbiAgICAgICAgbWluWzFdID0gbWF0aE1pbih5MCwgeTEpO1xuICAgICAgICBtYXhbMF0gPSBtYXRoTWF4KHgwLCB4MSk7XG4gICAgICAgIG1heFsxXSA9IG1hdGhNYXgoeTAsIHkxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICog5LuO5LiJ6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIsIHAzKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQ3ViaWMgPSBmdW5jdGlvbihcbiAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgeERpbSA9IFtdO1xuICAgICAgICB2YXIgeURpbSA9IFtdO1xuICAgICAgICB2YXIgY3ViaWNFeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hO1xuICAgICAgICB2YXIgY3ViaWNBdCA9IGN1cnZlLmN1YmljQXQ7XG4gICAgICAgIHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b207XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbiA9IGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgeERpbSk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgeERpbVtpXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBjdWJpY0V4dHJlbWEoeTAsIHkxLCB5MiwgeTMsIHlEaW0pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB5RGltW2ldID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgeURpbVtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB4RGltLnB1c2goeDAsIHgzKTtcbiAgICAgICAgeURpbS5wdXNoKHkwLCB5Myk7XG5cbiAgICAgICAgbGVmdCA9IG1hdGhNaW4uYXBwbHkobnVsbCwgeERpbSk7XG4gICAgICAgIHJpZ2h0ID0gbWF0aE1heC5hcHBseShudWxsLCB4RGltKTtcbiAgICAgICAgdG9wID0gbWF0aE1pbi5hcHBseShudWxsLCB5RGltKTtcbiAgICAgICAgYm90dG9tID0gbWF0aE1heC5hcHBseShudWxsLCB5RGltKTtcblxuICAgICAgICBtaW5bMF0gPSBsZWZ0O1xuICAgICAgICBtaW5bMV0gPSB0b3A7XG4gICAgICAgIG1heFswXSA9IHJpZ2h0O1xuICAgICAgICBtYXhbMV0gPSBib3R0b207XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juS6jOmYtui0neWhnuWwlOabsue6vyhwMCwgcDEsIHAyKeS4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tUXVhZHJhdGljID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgICAgICAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gICAgICAgIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0O1xuICAgICAgICAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cbiAgICAgICAgdmFyIHR4ID1cbiAgICAgICAgICAgIG1hdGhNYXgoXG4gICAgICAgICAgICAgICAgbWF0aE1pbihxdWFkcmF0aWNFeHRyZW11bSh4MCwgeDEsIHgyKSwgMSksIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIHZhciB0eSA9XG4gICAgICAgICAgICBtYXRoTWF4KFxuICAgICAgICAgICAgICAgIG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5MiksIDEpLCAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICAgICAgICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcblxuICAgICAgICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MiwgeCk7XG4gICAgICAgIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkyLCB5KTtcbiAgICAgICAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDIsIHgpO1xuICAgICAgICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MiwgeSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIOS7juWchuW8p+S4reiuoeeul+WHuuacgOWwj+WMheWbtOebku+8jOWGmeWFpWBtaW5g5ZKMYG1heGDkuK1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbnRpY2xvY2t3aXNlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gICAgICovXG4gICAgYmJveC5mcm9tQXJjID0gZnVuY3Rpb24gKFxuICAgICAgICB4LCB5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBtaW4sIG1heFxuICAgICkge1xuICAgICAgICB2YXIgdmVjMk1pbiA9IHZlYzIubWluO1xuICAgICAgICB2YXIgdmVjMk1heCA9IHZlYzIubWF4O1xuXG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcblxuXG4gICAgICAgIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgICAgICAgICAgLy8gSXMgYSBjaXJjbGVcbiAgICAgICAgICAgIG1pblswXSA9IHggLSByeDtcbiAgICAgICAgICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICAgICAgICAgIG1heFswXSA9IHggKyByeDtcbiAgICAgICAgICAgIG1heFsxXSA9IHkgKyByeTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgICAgICAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuXG4gICAgICAgIGVuZFswXSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyB4O1xuICAgICAgICBlbmRbMV0gPSBtYXRoU2luKGVuZEFuZ2xlKSAqIHJ5ICsgeTtcblxuICAgICAgICB2ZWMyTWluKG1pbiwgc3RhcnQsIGVuZCk7XG4gICAgICAgIHZlYzJNYXgobWF4LCBzdGFydCwgZW5kKTtcblxuICAgICAgICAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuICAgICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSAlIChQSTIpO1xuICAgICAgICBpZiAoc3RhcnRBbmdsZSA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICAgICAgICB9XG4gICAgICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoUEkyKTtcbiAgICAgICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydEFuZ2xlIDwgZW5kQW5nbGUgJiYgYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBQSTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgICAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YXIgbnVtYmVyID0gMDtcbiAgICAgICAgLy8gdmFyIHN0ZXAgPSAoYW50aWNsb2Nrd2lzZSA/IC1NYXRoLlBJIDogTWF0aC5QSSkgLyAyO1xuICAgICAgICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPiBzdGFydEFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICAgICAgICAgICAgZXh0cmVtaXR5WzFdID0gbWF0aFNpbihhbmdsZSkgKiByeSArIHk7XG5cbiAgICAgICAgICAgICAgICB2ZWMyTWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICAgICAgICAgIHZlYzJNYXgobWF4LCBleHRyZW1pdHksIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBiYm94O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb3JlL2Jib3guanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgQ01EID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoUHJveHknKS5DTUQ7XG4gICAgdmFyIGxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbiAgICB2YXIgY3ViaWMgPSByZXF1aXJlKCcuL2N1YmljJyk7XG4gICAgdmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoJy4vcXVhZHJhdGljJyk7XG4gICAgdmFyIGFyYyA9IHJlcXVpcmUoJy4vYXJjJyk7XG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICB2YXIgd2luZGluZ0xpbmUgPSByZXF1aXJlKCcuL3dpbmRpbmdMaW5lJyk7XG5cbiAgICB2YXIgY29udGFpblN0cm9rZSA9IGxpbmUuY29udGFpblN0cm9rZTtcblxuICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcblxuICAgIHZhciBFUFNJTE9OID0gMWUtNDtcblxuICAgIGZ1bmN0aW9uIGlzQXJvdW5kRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDwgRVBTSUxPTjtcbiAgICB9XG5cbiAgICAvLyDkuLTml7bmlbDnu4RcbiAgICB2YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG4gICAgdmFyIGV4dHJlbWEgPSBbLTEsIC0xXTtcblxuICAgIGZ1bmN0aW9uIHN3YXBFeHRyZW1hKCkge1xuICAgICAgICB2YXIgdG1wID0gZXh0cmVtYVswXTtcbiAgICAgICAgZXh0cmVtYVswXSA9IGV4dHJlbWFbMV07XG4gICAgICAgIGV4dHJlbWFbMV0gPSB0bXA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2luZGluZ0N1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyICYmIHkgPiB5MylcbiAgICAgICAgICAgIHx8ICh5IDwgeTAgJiYgeSA8IHkxICYmIHkgPCB5MiAmJiB5IDwgeTMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG4gICAgICAgIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgdmFyIG5FeHRyZW1hID0gLTE7XG4gICAgICAgICAgICB2YXIgeTBfLCB5MV87XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSByb290c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5jdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgICAgICAgICAgICBpZiAoeF8gPCB4KSB7IC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5FeHRyZW1hIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBuRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYSh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRyZW1hWzFdIDwgZXh0cmVtYVswXSAmJiBuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3YXBFeHRyZW1hKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeTBfID0gY3VydmUuY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgZXh0cmVtYVswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuRXh0cmVtYSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOWIhuaIkOS4ieauteWNleiwg+WHveaVsFxuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGV4dHJlbWFbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTFfIDwgeTBfID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MyA8IHkxXyA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5YiG5oiQ5Lik5q615Y2V6LCD5Ye95pWwXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB5MF8gPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0geTMgPCB5MF8gPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpbmRpbmdRdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHkgPiB5MCAmJiB5ID4geTEgJiYgeSA+IHkyKVxuICAgICAgICAgICAgfHwgKHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuICAgICAgICBpZiAoblJvb3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW0oeTAsIHkxLCB5Mik7XG4gICAgICAgICAgICBpZiAodCA+PTAgJiYgdCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB5XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJvb3RzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhfID0gY3VydmUucXVhZHJhdGljQXQoeDAsIHgxLCB4Miwgcm9vdHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeF8gPiB4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocm9vdHNbaV0gPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHlfIDwgeTAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHkyIDwgeV8gPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKHhfID4geCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHkyIDwgeTAgPyAxIDogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPXG4gICAgLy8gQXJjIOaXi+i9rFxuICAgIGZ1bmN0aW9uIHdpbmRpbmdBcmMoXG4gICAgICAgIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHgsIHlcbiAgICApIHtcbiAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgICAgICAgcm9vdHNbMF0gPSAtdG1wO1xuICAgICAgICByb290c1sxXSA9IHRtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gICAgICAgIGlmIChkaWZmIDwgMWUtNCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgICAgICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgICAgICAgc3RhcnRBbmdsZSA9IDA7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICAgICAgICAgIHZhciBkaXIgPSBhbnRpY2xvY2t3aXNlID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHggPj0gcm9vdHNbMF0gKyBjeCAmJiB4IDw9IHJvb3RzWzFdICsgY3gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4odG1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gUEkyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHhfID0gcm9vdHNbaV07XG4gICAgICAgICAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHksIHhfKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gUEkyICsgYW5nbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbmdsZSArIFBJMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlICsgUEkyIDw9IGVuZEFuZ2xlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpciA9IC1kaXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdyArPSBkaXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgICAgICAgdmFyIHcgPSAwO1xuICAgICAgICB2YXIgeGkgPSAwO1xuICAgICAgICB2YXIgeWkgPSAwO1xuICAgICAgICB2YXIgeDAgPSAwO1xuICAgICAgICB2YXIgeTAgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICB2YXIgY21kID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBDbG9zZSBwcmV2aW91cyBzdWJwYXRoXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHhpLCB5aSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSArIDFdO1xuXG4gICAgICAgICAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgICAgICAgICB5MCA9IHlpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgICAgICAgICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgICAgICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFIOWcqOesrOS4gOS4quWRveS7pOS4uiBMLCBDLCBRIOeahOaXtuWAmeS8muiuoeeul+WHuiBOYU5cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1YmljLmNvbnRhaW5TdHJva2UoeGksIHlpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ICs9IHdpbmRpbmdDdWJpYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nUXVhZHJhdGljKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhpLCB5aSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCwgeVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBBcmMg5Yik5pat55qE5byA6ZSA5q+U6L6D5aSnXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnggPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIEFyYyDml4vovaxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBNYXRoLmNvcyh0aGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSBNYXRoLnNpbih0aGV0YSkgKiByeSArIGN5O1xuICAgICAgICAgICAgICAgICAgICAvLyDkuI3mmK/nm7TmjqXkvb/nlKggYXJjIOWRveS7pFxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgICAgICAgICAgICAgICB4MCA9IHgxO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB6ciDkvb/nlKhzY2FsZeadpeaooeaLn+akreWchiwg6L+Z6YeM5Lmf5a+5eOWBmuS4gOWumueahOe8qeaUvlxuICAgICAgICAgICAgICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCwgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3gsIHlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeGkgPSBNYXRoLmNvcyh0aGV0YSArIGRUaGV0YSkgKiByeCArIGN4O1xuICAgICAgICAgICAgICAgICAgICB5aSA9IE1hdGguc2luKHRoZXRhICsgZFRoZXRhKSAqIHJ5ICsgY3k7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgICAgICAgICAgIHgwID0geGkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHkwID0geWkgPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgxID0geDAgKyB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0geTAgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTAsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBjb250YWluU3Ryb2tlKHgxLCB5MSwgeDAsIHkxLCBsaW5lV2lkdGgsIHgsIHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGNvbnRhaW5TdHJva2UoeDAsIHkxLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeDEsIHkwLCB4MSwgeTEsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4MCwgeTEsIHgwLCB5MCwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpblN0cm9rZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aSwgeWksIHgwLCB5MCwgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSBhIHN1YnBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCB4MCwgeTAsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6KKr5Lu75L2V5LiA5LiqIHN1YnBhdGgg5YyF5ZCrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdHJva2UgJiYgIWlzQXJvdW5kRXF1YWwoeWksIHkwKSkge1xuICAgICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdyAhPT0gMDtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgY29udGFpbjogZnVuY3Rpb24gKHBhdGhEYXRhLCB4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpblBhdGgocGF0aERhdGEsIDAsIGZhbHNlLCB4LCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAocGF0aERhdGEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOe6v+auteWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICAgICAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgIHZhciBfYSA9IDA7XG4gICAgICAgICAgICB2YXIgX2IgPSB4MDtcbiAgICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeSA8IHkwIC0gX2wgJiYgeSA8IHkxIC0gX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHgwICE9PSB4MSkge1xuICAgICAgICAgICAgICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgICAgICAgICAgICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKSA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuICAgICAgICAgICAgdmFyIF9zID0gdG1wICogdG1wIC8gKF9hICogX2EgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiBfcyA8PSBfbCAvIDIgKiBfbCAvIDI7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvY29udGFpbi9saW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIGN1cnZlID0gcmVxdWlyZSgnLi4vY29yZS9jdXJ2ZScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTFcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeDNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeTNcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgY29udGFpblN0cm9rZTogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoeSA+IHkwICsgX2wgJiYgeSA+IHkxICsgX2wgJiYgeSA+IHkyICsgX2wgJiYgeSA+IHkzICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sICYmIHkgPCB5MiAtIF9sICYmIHkgPCB5MyAtIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA8IHgwIC0gX2wgJiYgeCA8IHgxIC0gX2wgJiYgeCA8IHgyIC0gX2wgJiYgeCA8IHgzIC0gX2wpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZCA9IGN1cnZlLmN1YmljUHJvamVjdFBvaW50KFxuICAgICAgICAgICAgICAgIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MyxcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiXG5cbiAgICB2YXIgY3VydmUgPSByZXF1aXJlKCcuLi9jb3JlL2N1cnZlJyk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOS6jOasoei0neWhnuWwlOabsue6v+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5MlxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sICYmIHkgPiB5MiArIF9sKVxuICAgICAgICAgICAgICAgIHx8ICh5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbClcbiAgICAgICAgICAgICAgICB8fCAoeCA+IHgwICsgX2wgJiYgeCA+IHgxICsgX2wgJiYgeCA+IHgyICsgX2wpXG4gICAgICAgICAgICAgICAgfHwgKHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sICYmIHggPCB4MiAtIF9sKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGQgPSBjdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQoXG4gICAgICAgICAgICAgICAgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgICB4LCB5LCBudWxsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGQgPD0gX2wgLyAyO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vcXVhZHJhdGljLmpzXG4gKiogbW9kdWxlIGlkID0gNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIG5vcm1hbGl6ZVJhZGlhbiA9IHJlcXVpcmUoJy4vdXRpbCcpLm5vcm1hbGl6ZVJhZGlhbjtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBjeVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gIHN0YXJ0QW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgZW5kQW5nbGVcbiAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBsaW5lV2lkdGhcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSAgeFxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBjb250YWluU3Ryb2tlOiBmdW5jdGlvbiAoXG4gICAgICAgICAgICBjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLFxuICAgICAgICAgICAgbGluZVdpZHRoLCB4LCB5XG4gICAgICAgICkge1xuXG4gICAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sID0gbGluZVdpZHRoO1xuXG4gICAgICAgICAgICB4IC09IGN4O1xuICAgICAgICAgICAgeSAtPSBjeTtcbiAgICAgICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgICAgICAgICBpZiAoKGQgLSBfbCA+IHIpIHx8IChkICsgX2wgPCByKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpICUgUEkyIDwgMWUtNCkge1xuICAgICAgICAgICAgICAgIC8vIElzIGEgY2lyY2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICAgICAgICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgICAgICAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBQSTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUpXG4gICAgICAgICAgICAgICAgfHwgKGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vYXJjLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBub3JtYWxpemVSYWRpYW46IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICAgICAgICBhbmdsZSAlPSBQSTI7XG4gICAgICAgICAgICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gUEkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgICAgICB9XG4gICAgfTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2NvbnRhaW4vdXRpbC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdpbmRpbmdMaW5lKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgICAgIGlmICgoeSA+IHkwICYmIHkgPiB5MSkgfHwgKHkgPCB5MCAmJiB5IDwgeTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeTEgPT09IHkwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlyID0geTEgPCB5MCA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHQgPSAoeSAtIHkwKSAvICh5MSAtIHkwKTtcbiAgICAgICAgdmFyIHhfID0gdCAqICh4MSAtIHgwKSArIHgwO1xuXG4gICAgICAgIHJldHVybiB4XyA+IHggPyBkaXIgOiAwO1xuICAgIH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuXG4gICAgdmFyIENNRCA9IHJlcXVpcmUoJy4uL2NvcmUvUGF0aFByb3h5JykuQ01EO1xuICAgIHZhciB2ZWMyID0gcmVxdWlyZSgnLi4vY29yZS92ZWN0b3InKTtcbiAgICB2YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG5cbiAgICB2YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xuICAgIHZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbiAgICB2YXIgbWF0aEF0YW4yID0gTWF0aC5hdGFuMjtcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1QYXRoKHBhdGgsIG0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gICAgICAgIHZhciBjbWQ7XG4gICAgICAgIHZhciBuUG9pbnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGs7XG4gICAgICAgIHZhciBwO1xuXG4gICAgICAgIHZhciBNID0gQ01ELk07XG4gICAgICAgIHZhciBDID0gQ01ELkM7XG4gICAgICAgIHZhciBMID0gQ01ELkw7XG4gICAgICAgIHZhciBSID0gQ01ELlI7XG4gICAgICAgIHZhciBBID0gQ01ELkE7XG4gICAgICAgIHZhciBRID0gQ01ELlE7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBkYXRhLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNtZCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgblBvaW50ID0gMDtcblxuICAgICAgICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE06XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTDpcbiAgICAgICAgICAgICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDOlxuICAgICAgICAgICAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFE6XG4gICAgICAgICAgICAgICAgICAgIG5Qb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQTpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBtWzRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG1bNV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeCA9IG1hdGhTcXJ0KG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSBtYXRoU3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gbWF0aEF0YW4yKC1tWzFdIC8gc3ksIG1bMF0gLyBzeCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGN4XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSB4O1xuICAgICAgICAgICAgICAgICAgICAvLyBjeVxuICAgICAgICAgICAgICAgICAgICBkYXRhW2krK10gKz0geTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSAqPSBzeDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdICo9IHN5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSArPSBhbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgcHNpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUjpcbiAgICAgICAgICAgICAgICAgICAgLy8geDAsIHkwXG4gICAgICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHBbMV0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIHgxLCB5MVxuICAgICAgICAgICAgICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgICAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICAgICAgICAgICAgcFsxXSA9IGRhdGFbaSsrXTtcblxuICAgICAgICAgICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgYmFja1xuICAgICAgICAgICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgICAgICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUGF0aDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL3Rvb2wvdHJhbnNmb3JtUGF0aC5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIFRleHQgZWxlbWVudFxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvVGV4dFxuICpcbiAqIFRPRE8gV3JhcHBpbmdcbiAqL1xuXG5cblxuICAgIHZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoJy4vRGlzcGxheWFibGUnKTtcbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG4gICAgdmFyIHRleHRDb250YWluID0gcmVxdWlyZSgnLi4vY29udGFpbi90ZXh0Jyk7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgenJlbmRlci9ncmFwaGljL1RleHRcbiAgICAgKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKi9cbiAgICB2YXIgVGV4dCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gICAgfTtcblxuICAgIFRleHQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNvbnN0cnVjdG9yOiBUZXh0LFxuXG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcblxuICAgICAgICBicnVzaDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICAgICAgICAgICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRleHQgPSBzdHlsZS50ZXh0O1xuICAgICAgICAgICAgdmFyIHRleHRGaWxsID0gc3R5bGUuZmlsbDtcbiAgICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuICAgICAgICAgICAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcblxuICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5iaW5kKGN0eCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oY3R4KTtcblxuICAgICAgICAgICAgICAgIHRleHRGaWxsICYmIChjdHguZmlsbFN0eWxlID0gdGV4dEZpbGwpO1xuICAgICAgICAgICAgICAgIHRleHRTdHJva2UgJiYgKGN0eC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2UpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBzdHlsZS50ZXh0Rm9udCB8fCBzdHlsZS5mb250O1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG5cbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUudGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LCBjdHguZm9udCwgc3R5bGUudGV4dEFsaWduLCAndG9wJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGV4dEJhc2VsaW5lXG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdHlsZS50ZXh0VmVydGljYWxBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5IC09IHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByZWN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICd0b3AnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gdGV4dENvbnRhaW4ubWVhc3VyZVRleHQoJ+WbvScsIGN0eC5mb250KS53aWR0aDtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0TGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3QoXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHQgKyAnJywgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udCwgc3R5bGUudGV4dEFsaWduLCBzdHlsZS50ZXh0QmFzZWxpbmVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlY3QueCArPSBzdHlsZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgcmVjdC55ICs9IHN0eWxlLnkgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWN0O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanNcbiAqKiBtb2R1bGUgaWQgPSA1NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiDlnIblvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9DaXJjbGVcbiAqL1xuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAnY2lyY2xlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGggOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgICAgICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgICAgICAgICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0NpcmNsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDU1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cblxuLy8gRklYTUUgY2xvY2t3aXNlIHNlZW1zIHdyb25nXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ3NlY3RvcicsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByMDogMCxcblxuICAgICAgICAgICAgcjogMCxcblxuICAgICAgICAgICAgc3RhcnRBbmdsZTogMCxcblxuICAgICAgICAgICAgZW5kQW5nbGU6IE1hdGguUEkgKiAyLFxuXG4gICAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG5cbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIHIwID0gTWF0aC5tYXgoc2hhcGUucjAgfHwgMCwgMCk7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzaGFwZS5zdGFydEFuZ2xlO1xuICAgICAgICAgICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuXG4gICAgICAgICAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICAgICAgICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHVuaXRYICogcjAgKyB4LCB1bml0WSAqIHIwICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5saW5lVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG5cbiAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuXG4gICAgICAgICAgICBjdHgubGluZVRvKFxuICAgICAgICAgICAgICAgIE1hdGguY29zKGVuZEFuZ2xlKSAqIHIwICsgeCxcbiAgICAgICAgICAgICAgICBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcjAsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCBjbG9ja3dpc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlnIbnjq9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JpbmdcbiAqL1xuXG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL1BhdGgnKS5leHRlbmQoe1xuXG4gICAgICAgIHR5cGU6ICdyaW5nJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgIHI6IDAsXG4gICAgICAgICAgICByMDogMFxuICAgICAgICB9LFxuXG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICAgICAgICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLmN5O1xuICAgICAgICAgICAgdmFyIFBJMiA9IE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHNoYXBlLnIsIDAsIFBJMiwgZmFsc2UpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUucjAsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL1JpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDlpJrovrnlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS9Qb2x5Z29uXG4gKi9cblxuXG4gICAgdmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKCcuLi9oZWxwZXIvcG9seScpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcbiAgICAgICAgXG4gICAgICAgIHR5cGU6ICdwb2x5Z29uJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgcG9pbnRzOiBudWxsLFxuXG4gICAgICAgICAgICBzbW9vdGg6IGZhbHNlLFxuXG4gICAgICAgICAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICAgICAgcG9seUhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWdvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcblxuICAgIHZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKCcuL3Ntb290aFNwbGluZScpO1xuICAgIHZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKCcuL3Ntb290aEJlemllcicpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUsIGNsb3NlUGF0aCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgICAgICAgICAgIHZhciBzbW9vdGggPSBzaGFwZS5zbW9vdGg7XG4gICAgICAgICAgICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IHNtb290aEJlemllcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cywgc21vb3RoLCBjbG9zZVBhdGgsIHNoYXBlLnNtb290aENvbnN0cmFpbnRcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKGNsb3NlUGF0aCA/IGxlbiA6IGxlbiAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjcDIgPSBjb250cm9sUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1soaSArIDEpICUgbGVuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNtb290aCA9PT0gJ3NwbGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsb3NlUGF0aCAmJiBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qc1xuICoqIG1vZHVsZSBpZCA9IDU5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIENhdG11bGwtUm9tIHNwbGluZSDmj5LlgLzmipjnur9cbiAqIEBtb2R1bGUgenJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICogQGF1dGhvciBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKiAgICAgICAgIEtlbmVyIChAS2VuZXIt5p6X5bOwLCBrZW5lci5saW5mZW5nQGdtYWlsLmNvbSlcbiAqICAgICAgICAgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuXG4gICAgLyoqXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0Mykge1xuICAgICAgICB2YXIgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gICAgICAgIHZhciB2MSA9IChwMyAtIHAxKSAqIDAuNTtcbiAgICAgICAgcmV0dXJuICgyICogKHAxIC0gcDIpICsgdjAgKyB2MSkgKiB0M1xuICAgICAgICAgICAgICAgICsgKC0zICogKHAxIC0gcDIpIC0gMiAqIHYwIC0gdjEpICogdDJcbiAgICAgICAgICAgICAgICArIHYwICogdCArIHAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9zaGFwZS91dGlsL3Ntb290aFNwbGluZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG9vcFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgaXNMb29wKSB7XG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgZGlzdGFuY2UgKz0gdmVjMi5kaXN0YW5jZShwb2ludHNbaSAtIDFdLCBwb2ludHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlZ3MgPSBkaXN0YW5jZSAvIDI7XG4gICAgICAgIHNlZ3MgPSBzZWdzIDwgbGVuID8gbGVuIDogc2VncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpIC8gKHNlZ3MgLSAxKSAqIChpc0xvb3AgPyBsZW4gOiBsZW4gLSAxKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBNYXRoLmZsb29yKHBvcyk7XG5cbiAgICAgICAgICAgIHZhciB3ID0gcG9zIC0gaWR4O1xuXG4gICAgICAgICAgICB2YXIgcDA7XG4gICAgICAgICAgICB2YXIgcDEgPSBwb2ludHNbaWR4ICUgbGVuXTtcbiAgICAgICAgICAgIHZhciBwMjtcbiAgICAgICAgICAgIHZhciBwMztcbiAgICAgICAgICAgIGlmICghaXNMb29wKSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbaWR4ID09PSAwID8gaWR4IDogaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgcDIgPSBwb2ludHNbaWR4ID4gbGVuIC0gMiA/IGxlbiAtIDEgOiBpZHggKyAxXTtcbiAgICAgICAgICAgICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcDAgPSBwb2ludHNbKGlkeCAtIDEgKyBsZW4pICUgbGVuXTtcbiAgICAgICAgICAgICAgICBwMiA9IHBvaW50c1soaWR4ICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3MiA9IHcgKiB3O1xuICAgICAgICAgICAgdmFyIHczID0gdyAqIHcyO1xuXG4gICAgICAgICAgICByZXQucHVzaChbXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0sIHcsIHcyLCB3MyksXG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICogICAgICAgICBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKiAgICAgICAgIGVycm9ycmlrIChlcnJvcnJpa0BnbWFpbC5jb20pXG4gKi9cblxuXG4gICAgdmFyIHZlYzIgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3ZlY3RvcicpO1xuICAgIHZhciB2Mk1pbiA9IHZlYzIubWluO1xuICAgIHZhciB2Mk1heCA9IHZlYzIubWF4O1xuICAgIHZhciB2MlNjYWxlID0gdmVjMi5zY2FsZTtcbiAgICB2YXIgdjJEaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2U7XG4gICAgdmFyIHYyQWRkID0gdmVjMi5hZGQ7XG5cbiAgICAvKipcbiAgICAgKiDotJ3loZ7lsJTlubPmu5Hmm7Lnur9cbiAgICAgKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMg57q/5q616aG254K55pWw57uEXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNtb290aCDlubPmu5HnrYnnuqcsIDAtMVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29uc3RyYWludCDlsIborqHnrpflh7rmnaXnmoTmjqfliLbngrnnuqbmnZ/lnKjkuIDkuKrljIXlm7Tnm5LlhoVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOavlOWmgiBbWzAsIDBdLCBbMTAwLCAxMDBdXSwg6L+Z5Liq5YyF5Zu055uS5Lya5LiOXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSDorqHnrpflh7rmnaXnmoTmjqfliLbngrnmlbDnu4RcbiAgICAgKi9cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gICAgICAgIHZhciBjcHMgPSBbXTtcblxuICAgICAgICB2YXIgdiA9IFtdO1xuICAgICAgICB2YXIgdjEgPSBbXTtcbiAgICAgICAgdmFyIHYyID0gW107XG4gICAgICAgIHZhciBwcmV2UG9pbnQ7XG4gICAgICAgIHZhciBuZXh0UG9pbnQ7XG5cbiAgICAgICAgdmFyIG1pbiwgbWF4O1xuICAgICAgICBpZiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgICAgICAgICBtYXggPSBbLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgICAgIHYyTWF4KG1heCwgbWF4LCBwb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8g5LiO5oyH5a6a55qE5YyF5Zu055uS5YGa5bm26ZuGXG4gICAgICAgICAgICB2Mk1pbihtaW4sIG1pbiwgY29uc3RyYWludFswXSk7XG4gICAgICAgICAgICB2Mk1heChtYXgsIG1heCwgY29uc3RyYWludFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzWyhpICsgMSkgJSBsZW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjcHMucHVzaCh2ZWMyLmNsb25lKHBvaW50c1tpXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2ZWMyLnN1Yih2LCBuZXh0UG9pbnQsIHByZXZQb2ludCk7XG5cbiAgICAgICAgICAgIC8vIHVzZSBkZWdyZWUgdG8gc2NhbGUgdGhlIGhhbmRsZSBsZW5ndGhcbiAgICAgICAgICAgIHYyU2NhbGUodiwgdiwgc21vb3RoKTtcblxuICAgICAgICAgICAgdmFyIGQwID0gdjJEaXN0YW5jZShwb2ludCwgcHJldlBvaW50KTtcbiAgICAgICAgICAgIHZhciBkMSA9IHYyRGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgICAgICAgICB2YXIgc3VtID0gZDAgKyBkMTtcbiAgICAgICAgICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkMCAvPSBzdW07XG4gICAgICAgICAgICAgICAgZDEgLz0gc3VtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgICAgICAgICAgdjJTY2FsZSh2MiwgdiwgZDEpO1xuICAgICAgICAgICAgdmFyIGNwMCA9IHYyQWRkKFtdLCBwb2ludCwgdjEpO1xuICAgICAgICAgICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDAsIGNwMCwgbWF4KTtcbiAgICAgICAgICAgICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgICAgICAgICAgICB2Mk1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgICAgICAgICBjcHMucHVzaChjcDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICAgICAgY3BzLnB1c2goY3BzLnNoaWZ0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNwcztcbiAgICB9O1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zbW9vdGhCZXppZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG5cblxuICAgIHZhciBwb2x5SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3BvbHknKTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG4gICAgICAgIFxuICAgICAgICB0eXBlOiAncG9seWxpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICBwb2ludHM6IG51bGwsXG5cbiAgICAgICAgICAgIHNtb290aDogZmFsc2UsXG5cbiAgICAgICAgICAgIHNtb290aENvbnN0cmFpbnQ6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuXG5cbiAgICB2YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZSgnLi4vaGVscGVyL3JvdW5kUmVjdCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAncmVjdCcsXG5cbiAgICAgICAgc2hhcGU6IHtcbiAgICAgICAgICAgIC8vIOW3puS4iuOAgeWPs+S4iuOAgeWPs+S4i+OAgeW3puS4i+inkueahOWNiuW+hOS+neasoeS4unIx44CBcjLjgIFyM+OAgXI0XG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6MSAgICAgICAgIOebuOW9k+S6jiBbMSwgMSwgMSwgMV1cbiAgICAgICAgICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgICAgICAgICAgLy8gcue8qeWGmeS4ulsxLCAyXSAgICDnm7jlvZPkuo4gWzEsIDIsIDEsIDJdXG4gICAgICAgICAgICAvLyBy57yp5YaZ5Li6WzEsIDIsIDNdIOebuOW9k+S6jiBbMSwgMiwgMywgMl1cbiAgICAgICAgICAgIHI6IDAsXG5cbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDBcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICB2YXIgeSA9IHNoYXBlLnk7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgICAgICAgICAgICBjdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvdW5kUmVjdEhlbHBlci5idWlsZFBhdGgoY3R4LCBzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qKlxuICog55u057q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lXG4gKi9cblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2xpbmUnLFxuXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAvLyBTdGFydCBwb2ludFxuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIC8vIEVuZCBwb2ludFxuICAgICAgICAgICAgeDI6IDAsXG4gICAgICAgICAgICB5MjogMCxcblxuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcblxuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgeDIgPSB4MSAqICgxIC0gcGVyY2VudCkgKyB4MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSAqICgxIC0gcGVyY2VudCkgKyB5MiAqIHBlcmNlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwb2ludCBhdCBwZXJjZW50XG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gcGVyY2VudFxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHBvaW50QXQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzaGFwZS54MSAqICgxIC0gcCkgKyBzaGFwZS54MiAqIHAsXG4gICAgICAgICAgICAgICAgc2hhcGUueTEgKiAoMSAtIHApICsgc2hhcGUueTIgKiBwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvTGluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIOi0neWhnuWwlOabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0JlemllckN1cnZlXG4gKi9cblxuXG4gICAgdmFyIGN1cnZlVG9vbCA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvY3VydmUnKTtcbiAgICB2YXIgcXVhZHJhdGljU3ViZGl2aWRlID0gY3VydmVUb29sLnF1YWRyYXRpY1N1YmRpdmlkZTtcbiAgICB2YXIgY3ViaWNTdWJkaXZpZGUgPSBjdXJ2ZVRvb2wuY3ViaWNTdWJkaXZpZGU7XG4gICAgdmFyIHF1YWRyYXRpY0F0ID0gY3VydmVUb29sLnF1YWRyYXRpY0F0O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmVUb29sLmN1YmljQXQ7XG5cbiAgICB2YXIgb3V0ID0gW107XG4gICAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9QYXRoJykuZXh0ZW5kKHtcblxuICAgICAgICB0eXBlOiAnYmV6aWVyLWN1cnZlJyxcblxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICB5MTogMCxcbiAgICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgICAgeTI6IDAsXG4gICAgICAgICAgICBjcHgxOiAwLFxuICAgICAgICAgICAgY3B5MTogMCxcbiAgICAgICAgICAgIC8vIGNweDI6IDAsXG4gICAgICAgICAgICAvLyBjcHkyOiAwXG5cbiAgICAgICAgICAgIC8vIEN1cnZlIHNob3cgcGVyY2VudCwgZm9yIGFuaW1hdGluZ1xuICAgICAgICAgICAgcGVyY2VudDogMVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgICAgICAgIGZpbGw6IG51bGxcbiAgICAgICAgfSxcblxuICAgICAgICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgICAgICAgICB2YXIgeDEgPSBzaGFwZS54MTtcbiAgICAgICAgICAgIHZhciB5MSA9IHNoYXBlLnkxO1xuICAgICAgICAgICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgICAgICAgICB2YXIgeTIgPSBzaGFwZS55MjtcbiAgICAgICAgICAgIHZhciBjcHgxID0gc2hhcGUuY3B4MTtcbiAgICAgICAgICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICAgICAgICAgIHZhciBjcHgyID0gc2hhcGUuY3B4MjtcbiAgICAgICAgICAgIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcbiAgICAgICAgICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG5cbiAgICAgICAgICAgIGlmIChjcHgyID09IG51bGwgfHwgY3B5MiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1YWRyYXRpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzJdO1xuICAgICAgICAgICAgICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB5MSwgY3B5MSwgeTIsIHBlcmNlbnQsIG91dFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBjcHkxID0gb3V0WzFdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IG91dFsyXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHgxLCBjcHgxLCBjcHgyLCB4MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgICAgICBjdWJpY1N1YmRpdmlkZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHkxLCBjcHkxLCBjcHkyLCB5MiwgcGVyY2VudCwgb3V0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgICAgICAgICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICAgICAgICAgICAgY3B4MSwgY3B5MSxcbiAgICAgICAgICAgICAgICAgICAgY3B4MiwgY3B5MixcbiAgICAgICAgICAgICAgICAgICAgeDIsIHkyXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7XG4gICAgICAgICAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgICAgICAgICB2YXIgY3B5MiA9IHNoYXBlLmNweTI7XG4gICAgICAgICAgICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljQXQoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCBwKSxcbiAgICAgICAgICAgICAgICAgICAgcXVhZHJhdGljQXQoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCBwKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBjdWJpY0F0KHNoYXBlLngxLCBzaGFwZS5jcHgxLCBzaGFwZS5jcHgxLCBzaGFwZS54MiwgcCksXG4gICAgICAgICAgICAgICAgICAgIGN1YmljQXQoc2hhcGUueTEsIHNoYXBlLmNweTEsIHNoYXBlLmNweTEsIHNoYXBlLnkyLCBwKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbiBcblxuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vUGF0aCcpLmV4dGVuZCh7XG5cbiAgICAgICAgdHlwZTogJ2FyYycsXG5cbiAgICAgICAgc2hhcGU6IHtcblxuICAgICAgICAgICAgY3g6IDAsXG5cbiAgICAgICAgICAgIGN5OiAwLFxuXG4gICAgICAgICAgICByOiAwLFxuXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgICAgICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG5cbiAgICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0eWxlOiB7XG5cbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuXG4gICAgICAgICAgICBmaWxsOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuXG4gICAgICAgICAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgICAgICAgICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5tYXgoc2hhcGUuciwgMCk7XG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBzaGFwZS5jbG9ja3dpc2U7XG5cbiAgICAgICAgICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG5cbiAgICAgICAgICAgIGN0eC5tb3ZlVG8odW5pdFggKiByICsgeCwgdW5pdFkgKiByICsgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHgsIHksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCAhY2xvY2t3aXNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanNcbiAqKiBtb2R1bGUgaWQgPSA2NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeTI9MF1cbiAgICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjb2xvclN0b3BzXG4gICAgICovXG4gICAgdmFyIExpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24gKHgsIHksIHgyLCB5MiwgY29sb3JTdG9wcykge1xuICAgICAgICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcblxuICAgICAgICB0aGlzLnkgPSB5ID09IG51bGwgPyAwIDogeTtcblxuICAgICAgICB0aGlzLngyID0geDIgPT0gbnVsbCA/IDEgOiB4MjtcblxuICAgICAgICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjtcblxuICAgICAgICBHcmFkaWVudC5jYWxsKHRoaXMsIGNvbG9yU3RvcHMpO1xuICAgIH07XG5cbiAgICBMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50LFxuXG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuXG4gICAgICAgIHVwZGF0ZUNhbnZhc0dyYWRpZW50OiBmdW5jdGlvbiAoc2hhcGUsIGN0eCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBzaGFwZS5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgICAgIC8vIHZhciBzaXplID1cbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy54ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICAgICAgICAgIHZhciB4MiA9IHRoaXMueDIgKiByZWN0LndpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnkgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgICAgICAgICAgIHZhciB5MiA9IHRoaXMueTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcblxuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgyLCB5Mik7XG5cbiAgICAgICAgICAgIHZhciBjb2xvclN0b3BzID0gdGhpcy5jb2xvclN0b3BzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKFxuICAgICAgICAgICAgICAgICAgICBjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FudmFzR3JhZGllbnQgPSBjYW52YXNHcmFkaWVudDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHpyVXRpbC5pbmhlcml0cyhMaW5lYXJHcmFkaWVudCwgR3JhZGllbnQpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaW5lYXJHcmFkaWVudDtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbiAgICB2YXIgenJVdGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJyk7XG5cbiAgICB2YXIgR3JhZGllbnQgPSByZXF1aXJlKCcuL0dyYWRpZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiB4LCB5LCByIGFyZSBhbGwgcGVyY2VudCBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wLjVdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3I9MC41XVxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtjb2xvclN0b3BzXVxuICAgICAqL1xuICAgIHZhciBSYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCByLCBjb2xvclN0b3BzKSB7XG4gICAgICAgIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG5cbiAgICAgICAgdGhpcy55ID0geSA9PSBudWxsID8gMC41IDogeTtcblxuICAgICAgICB0aGlzLnIgPSByID09IG51bGwgPyAwLjUgOiByO1xuXG4gICAgICAgIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG4gICAgfTtcblxuICAgIFJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnQsXG5cbiAgICAgICAgdHlwZTogJ3JhZGlhbCcsXG5cbiAgICAgICAgdXBkYXRlQ2FudmFzR3JhZGllbnQ6IGZ1bmN0aW9uIChzaGFwZSwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHNoYXBlLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgLy8gdmFyIG1heCA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMueCAqIHdpZHRoICsgcmVjdC54O1xuICAgICAgICAgICAgdmFyIHkgPSB0aGlzLnkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuciAqIG1pbjtcblxuICAgICAgICAgICAgdmFyIGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHgsIHksIHIpO1xuXG4gICAgICAgICAgICB2YXIgY29sb3JTdG9wcyA9IHRoaXMuY29sb3JTdG9wcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JTdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdG9wc1tpXS5vZmZzZXQsIGNvbG9yU3RvcHNbaV0uY29sb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNhbnZhc0dyYWRpZW50ID0gY2FudmFzR3JhZGllbnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgenJVdGlsLmluaGVyaXRzKFJhZGlhbEdyYWRpZW50LCBHcmFkaWVudCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhZGlhbEdyYWRpZW50O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34venJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog5LqL5Lu25Yaz562W5aSa6L655b2iXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvRXZlbnREZWNpc2lvbk5vZGVcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcbiAgICB2YXIgQ29uc3QgPSByZXF1aXJlKCcuLi9tb2RlbHMvQ29uc3QnKTtcclxuICAgIHZhciBncmFwaGljID0gcmVxdWlyZShcIi4uLy4uLy4uL2Zpc2gtdG9wby1jb3JlL2xpYi9ncmFwaGljLmpzXCIpO1xyXG5cclxuICAgIGZ1bmN0aW9uIEV2ZW50RGVjaXNpb25Ob2RlKGRhdGEsIG9wdHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCT+WxnuaAp+aVsOaNrlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog6LW35aeL5L2N572u5Z2Q5qCHXHJcbiAgICAgICAgICogQHR5cGUge3N0YXJ0UG9zfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3RhcnRQb3MgPSBvcHRzLnN0YXJ0UG9zO1xyXG5cclxuICAgICAgICB0aGlzLl90eXBlID0gb3B0cy50eXBlIHx8ICdib0V2ZW50JztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pSv5oyB54K55Ye7XHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jbGlja2FibGUgPSBvcHRzLmNsaWNrYWJsZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb3B1cE9wdHMgPSBvcHRzLnBvcHVwT3B0cztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3JvdXDlrrnlmahcclxuICAgICAgICAgKiBAdHlwZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLl9ncm91cC5uYW1lID0gdGhpcy5fZGF0YS5pZDtcclxuXHJcbiAgICAgICAgLy/nlJ/miJBCT+WxnuaAp+WbvuW9olxyXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBldmVudFByb3RvID0gRXZlbnREZWNpc2lvbk5vZGUucHJvdG90eXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog6I635Y+W5YWz57O75pW05L2T5Zu+5b2iXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL0dyb3VwfVxyXG4gICAgICovXHJcbiAgICBldmVudFByb3RvLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDkuovku7blhrPnrZblm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGV2ZW50UHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+Wkmui+ueW9olxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUV2ZW50U2hhcGUoKTtcclxuICAgICAgICAvL+aWh+Wtl1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUVWZW50TmFtZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOS6i+S7tuWGs+etluWkmui+ueW9olxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZXZlbnRQcm90by5fY3JlYXRlRXZlbnRTaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgLy/lpJrovrnlvaLpq5jluqZcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gQ29uc3QuQk9fRVZFTlRfSEVJR0hULFxyXG4gICAgICAgICAgICB4ID0gdGhpcy5fc3RhcnRQb3MueCArIDEsXHJcbiAgICAgICAgICAgIHkgPSB0aGlzLl9zdGFydFBvcy55LFxyXG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuX3R5cGUgPT0gJ2JvRXZlbnQnID8gQ29uc3QuQk9fRVZFTlRfV0lEVEggOiBDb25zdC5CT19BVFRSX0VWRU5UX1dJRFRILFxyXG5cclxuICAgICAgICAgICAgc2hhcGUgPSBuZXcgZ3JhcGhpYy5Qb2x5Z29uKHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX2RhdGEuaWQsXHJcbiAgICAgICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBbeCwgeV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgd2lkdGggLSAxMCwgeV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLyAyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3ggKyB3aWR0aCAtIDEwLCB5ICsgaGVpZ2h0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW3gsIHkgKyBoZWlnaHRdXVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICcjRkZDQ0NDJyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAuNzVcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIHNoYXBlLmNsaWNrYWJsZSA9IHRoaXMuX2NsaWNrYWJsZTtcclxuICAgICAgICAgICAgc2hhcGUuX2RhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICBzaGFwZS5fcG9wdXBPcHRzID0gdGhpcy5fcG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBzaGFwZS5vbmNsaWNrID0gdGhpcy5fY2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKHNoYXBlKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDngrnlh7vkuovku7ZcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGV2ZW50UHJvdG8uX2NsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZmlzaC5leHRlbmQoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb246IHtcclxuICAgICAgICAgICAgICAgICAgICBEQVRBOiB0aGlzLl9kYXRhXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDgwMCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogNTAwXHJcbiAgICAgICAgICAgIH0sIHRoaXMuX3BvcHVwT3B0cyk7XHJcblxyXG4gICAgICAgIGZpc2gucG9wdXBWaWV3KG9wdGlvbnMpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOS6i+S7tuWGs+etluWQjeensFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZXZlbnRQcm90by5fY3JlYXRlRVZlbnROYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcy5fc3RhcnRQb3MueCArICh0aGlzLl90eXBlID09ICdib0V2ZW50JyA/IENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZUIDogMTUpLFxyXG4gICAgICAgICAgICB5ID0gdGhpcy5fc3RhcnRQb3MueSxcclxuXHJcbiAgICAgICAgICAgIGV2ZW50TmFtZVNoYXBlID0gbmV3IGdyYXBoaWMuVGV4dCh7XHJcbiAgICAgICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuX2RhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fRVZFTlRfRk9OVCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JywgIC8v6Z2g5bem5byA5aeL77yM5L6/5LqO6K6h566X5L2N572uXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2xpY2thYmxlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50TmFtZVNoYXBlLmNsaWNrYWJsZSA9IHRoaXMuX2NsaWNrYWJsZTtcclxuICAgICAgICAgICAgZXZlbnROYW1lU2hhcGUuX2RhdGEgPSB0aGlzLl9kYXRhO1xyXG4gICAgICAgICAgICBldmVudE5hbWVTaGFwZS5fcG9wdXBPcHRzID0gdGhpcy5fcG9wdXBPcHRzO1xyXG4gICAgICAgICAgICBldmVudE5hbWVTaGFwZS5vbmNsaWNrID0gdGhpcy5fY2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9ncm91cC5hZGQoZXZlbnROYW1lU2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RGVjaXNpb25Ob2RlO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvRXZlbnREZWNpc2lvbk5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIEJP55+p5b2i5YaF6YOo55qE5qiq57q/77yM5YiG5Li65a6e57q/5ZKM6Jma57q/5Lik56eNXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvTGluZU5vZGVcclxuICogQ3JlYXRlZCBieSBtYWppYW5hbiBvbiAxNi81LzE5LlxyXG4gKi9cclxuXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuICAgIHZhciB1dGlsID0gcmVxdWlyZSgnenJlbmRlci9saWIvY29yZS91dGlsJyk7XHJcbiAgICAvKipcclxuICAgICAqIEJP5ZCN5a2X5LiL6Z2i55qE5a6e546wXHJcbiAgICAgKiBAcGFyYW0ge3t4OiAqLCB5OiAqfX0gc3RhcnRQb3MsIOW8gOWni+WdkOagh1xyXG4gICAgICogQHJldHVybnMge3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lfVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJvTGluZShzdGFydFBvcykge1xyXG5cclxuICAgICAgICB2YXIgZW5kUG9zID0ge3g6IHN0YXJ0UG9zLnggKyBDb25zdC5CT19OT0RFX1dJRFRILCB5OiBzdGFydFBvcy55fTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lKHN0YXJ0UG9zLCBlbmRQb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQk/lsZ7mgKfkuYvpl7TnmoTomZrnur9cclxuICAgICAqIEBwYXJhbSB7e3g6ICosIHk6ICp9fSBzdGFydFBvcywg5byA5aeL5Z2Q5qCHXHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmV9XHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQXR0ckxpbmUoc3RhcnRQb3MpIHtcclxuXHJcbiAgICAgICAgdmFyIGVuZFBvcyA9IHt4OiBzdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCwgeTogc3RhcnRQb3MueX0sXHJcbiAgICAgICAgICAgIHN0eWxlID0ge2xpbmVEYXNoOiBbQ29uc3QuTElORV9EQVNIXX07XHJcblxyXG4gICAgICAgIHJldHVybiBfbGluZShzdGFydFBvcywgZW5kUG9zLCBzdHlsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCT+WxnuaAp+S4jkJP5LqL5Lu25Yaz562W5LmL6Ze055qE5Z6C55u06Jma57q/XHJcbiAgICAgKiBAcGFyYW0ge3t4OiAqLCB5OiAqfX0gc3RhcnRQb3MsIOW8gOWni+WdkOagh1xyXG4gICAgICogQHBhcmFtIHtpbnR9IGF0dHJIZWlnaHQsIOmrmOW6plxyXG4gICAgICogQHJldHVybnMge3pyZW5kZXIvZ3JhcGhpYy9zaGFwZS9MaW5lfVxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEF0dHJFdmVudExpbmUoc3RhcnRQb3MsIGF0dHJIZWlnaHQpIHtcclxuICAgICAgICB2YXIgZW5kUG9zID0ge3g6IHN0YXJ0UG9zLngsIHk6IHN0YXJ0UG9zLnkgKyBhdHRySGVpZ2h0fSxcclxuICAgICAgICAgICAgc3R5bGUgPSB7bGluZURhc2g6IFtDb25zdC5MSU5FX0RBU0hdfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF9saW5lKHN0YXJ0UG9zLCBlbmRQb3MsIHN0eWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUu+e6v1xyXG4gICAgICogQHBhcmFtIHt7eDogKiwgeTogKn19IHN0YXJ0UG9zLCDlvIDlp4vlnZDmoIdcclxuICAgICAqIEBwYXJhbSB7e3g6ICosIHk6ICp9fSBlbmRQb3MsIOe7k+adn+WdkOagh1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlLCDmoLflvI8s5Y+v56m6XHJcbiAgICAgKiBAcmV0dXJucyB7enJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmV9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfbGluZShzdGFydFBvcywgZW5kUG9zLCBzdHlsZSkge1xyXG5cclxuICAgICAgICB2YXIgX3N0eWxlID0ge1xyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDAuNSxcclxuICAgICAgICAgICAgcGVyY2VudDogMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHV0aWwuZXh0ZW5kKF9zdHlsZSwgc3R5bGUpO1xyXG5cclxuICAgICAgICB2YXIgc2hhcGUgPSBuZXcgZ3JhcGhpYy5MaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHBvaW50XHJcbiAgICAgICAgICAgICAgICB4MTogc3RhcnRQb3MueCxcclxuICAgICAgICAgICAgICAgIHkxOiBzdGFydFBvcy55LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuZCBwb2ludFxyXG4gICAgICAgICAgICAgICAgeDI6IGVuZFBvcy54LFxyXG4gICAgICAgICAgICAgICAgeTI6IGVuZFBvcy55LFxyXG5cclxuICAgICAgICAgICAgICAgIHBlcmNlbnQ6IDFcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiBfc3R5bGVcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgICAgICBCb0xpbmU6IEJvTGluZSxcclxuICAgICAgICBBdHRyTGluZTogQXR0ckxpbmUsXHJcbiAgICAgICAgQXR0ckV2ZW50TGluZTogQXR0ckV2ZW50TGluZVxyXG4gICAgfTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvTGluZU5vZGUuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXHJcbiAqIEJP5bGe5oCnXHJcbiAqIDEuQk/lsZ7mgKflkI3lrZdcclxuICogMi5CT+WxnuaAp+aVsOaNruexu+Wei1xyXG4gKiAzLkJP5bGe5oCn5LqL5Lu25Yaz562WXHJcbiAqIEBtb2R1bGUgZmlzaC10b3BvLWJvL25vZGUvQm9BdHRyTm9kZVxyXG4gKiBDcmVhdGVkIGJ5IG1hamlhbmFuIG9uIDE2LzUvMTkuXHJcbiAqL1xyXG5cclxuICAgIHZhciBDb25zdCA9IHJlcXVpcmUoJy4uL21vZGVscy9Db25zdCcpO1xyXG4gICAgdmFyIEV2ZW50RGVjaXNpb24gPSByZXF1aXJlKCcuLi9ub2RlL0V2ZW50RGVjaXNpb25Ob2RlJyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3tcclxuICAgICAqICAgICAgICAgIGlkOiBTdHJpbmcgYm/lsZ7mgKfmoIfor4YsXHJcbiAgICAgKiAgICAgICAgICBjb2RlOiBTdHJpbmcgYm/lsZ7mgKfnvJbnoIFcclxuICAgICAqICAgICAgICAgIGtleVZhbHVlOiBib29sZWFuIOaYr+WQpuS4uuS4u+mUrixcclxuICAgICAqICAgICAgICAgIGRhdGFUeXBlOiBTdHJpbmcg5bGe5oCn5pWw5o2u57G75Z6LLFxyXG4gICAgICogICAgICAgICAgYm9BdHRyRXZlbnRBcnI6W10g5bGe5oCn5LqL5Lu25Yaz562W5pWw57uEXHJcbiAgICAgKiAgICAgICAgICB9fSBib0F0dHJEYXRhIEJP5bGe5oCn5pWw5o2u5a+56LGhLFxyXG4gICAgICogQHBhcmFtIHt7XHJcbiAgICAgKiAgICAgICAgICBzdGFydFBvczoge3g6IG51bWJlciwgeTogbnVtYmVyfei1t+Wni+S9jee9rixcclxuICAgICAqICAgICAgICAgIGRpc3BsYXlEYXRhVHlwZTogYm9vbGVhbiDmmK/lkKbmmL7npLrmlbDmja7nsbvlnossXHJcbiAgICAgKiAgICAgICAgICBkaXNwbGF5RXZlbnREZWNpc2lvbjogYm9vbGVhbiDmmK/lkKbmmL7npLrkuovku7blhrPnrZYsXHJcbiAgICAgKiAgICAgICAgICBldmVudENsaWNrYWJsZTogYm9vbGVhbiBCT+WxnuaAp+S6i+S7tuWGs+etluaYr+WQpuaUr+aMgeeCueWHu+S6i+S7tiwg5Y+v56m6IOm7mOiupGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZXZlbnRQb3B1cE9wdHM6IE9iamVjdCDngrnlh7tCT+WxnuaAp+S6i+S7tuWGs+etluW8ueWHuumhtemdouWPguaVsO+8jHVybCx3aWR0aCxoZWlnaHTnrYksXHJcbiAgICAgKiAgICAgICAgICB9fSBvcHRzXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQm9BdHRyKGJvQXR0ckRhdGEsIG9wdHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCT+WxnuaAp+aVsOaNrlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kYXRhID0gYm9BdHRyRGF0YTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5Li65Li76ZSuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9rZXlWYWx1ZSA9IGJvQXR0ckRhdGEua2V5VmFsdWUgfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOi1t+Wni+S9jee9ruWdkOagh1xyXG4gICAgICAgICAqIEB0eXBlIHtzdGFydFBvc31cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0UG9zID0gb3B0cy5zdGFydFBvcztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pi+56S65pWw5o2u57G75Z6LXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kaXNwbGF5RGF0YVR5cGUgPSBvcHRzLmRpc3BsYXlEYXRhVHlwZSB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICog5piv5ZCm5pi+56S65LqL5Lu25Yaz562WXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kaXNwbGF5RXZlbnREZWNpc2lvbiA9IG9wdHMuZGlzcGxheUV2ZW50RGVjaXNpb24gfHwgZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIOaYr+WQpuaUr+aMgeeCueWHu1xyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZXZlbnRDbGlja2FibGUgPSBvcHRzLmV2ZW50Q2xpY2thYmxlIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50UG9wdXBPcHRzID0gb3B0cy5ldmVudFBvcHVwT3B0cztcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3JvdXDlrrnlmahcclxuICAgICAgICAgKiBAdHlwZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcclxuICAgICAgICB0aGlzLl9ncm91cC5uYW1lID0gdGhpcy5fZGF0YS5pZDtcclxuXHJcbiAgICAgICAgLy/nlJ/miJBCT+WxnuaAp+WbvuW9olxyXG4gICAgICAgIHRoaXMuX3JlbmRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBib0F0dHJQcm90byA9IEJvQXR0ci5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blhbPns7vmlbTkvZPlm77lvaJcclxuICAgICAqIEByZXR1cm5zIHt6cmVuZGVyL2dyYXBoaWMvR3JvdXB9XHJcbiAgICAgKi9cclxuICAgIGJvQXR0clByb3RvLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQQk/lsZ7mgKflm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGJvQXR0clByb3RvLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy/lsZ7mgKflkI3lrZdcclxuICAgICAgICB0aGlzLl9jcmVhdGVUZXh0KCk7XHJcblxyXG4gICAgICAgIC8v5bGe5oCn5pWw5o2u57G75Z6LXHJcbiAgICAgICAgdGhpcy5fY3JlYXRlRGF0YVR5cGUoKTtcclxuXHJcbiAgICAgICAgLy/lsZ7mgKfkuovku7blhrPnrZZcclxuICAgICAgICB0aGlzLl9jcmVhdGVFdmVudERlY2lzaW9uKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bGe5oCn5ZCN5a2XXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib0F0dHJQcm90by5fY3JlYXRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgdmFyIHggPSB0aGlzLl9zdGFydFBvcy54ICsgQ29uc3QuQk9fQVRUUl9QQURESU5HX0xFRlQsXHJcbiAgICAgICAgICAgIHkgPSB0aGlzLl9zdGFydFBvcy55LFxyXG5cclxuICAgICAgICAgICAgYXR0ck5hbWVTaGFwZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLl9kYXRhLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEZvbnQ6IENvbnN0LkJPX0FUVFJfRk9OVCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JywgIC8v6Z2g5bem5byA5aeL77yM5L6/5LqO6K6h566X5L2N572uXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAndG9wJyxcclxuICAgICAgICAgICAgICAgICAgICAvL2xpbmVXaWR0aDogMSxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsOiB0aGlzLl9rZXlWYWx1ZSA/ICdyZWQnIDogJ2JsYWNrJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL+mHjeaWsOiuvue9ruWbvuW9oumrmOW6piA9IOaWh+acrOmrmOW6piArIHBhZGRpbmctdG9wICsgcGFkZGluZy1ib3R0b21cclxuICAgICAgICBhdHRyTmFtZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLmhlaWdodCArPSBDb25zdC5CT19BVFRSX1BBRERJTkdfVE9QICsgQ29uc3QuQk9fQVRUUl9QQURESU5HX0JPVFRPTTtcclxuICAgICAgICAvL+mHjeaWsOiuvue9ruWbvuW9oumrmOW6piA9IEJP55+p5b2i5a695bqm77yM55So5LqO5ZCO57utUmVsYXRpb27nlLvlm77orqHnrpdcclxuICAgICAgICBhdHRyTmFtZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLndpZHRoID0gQ29uc3QuQk9fTk9ERV9XSURUSDtcclxuXHJcbiAgICAgICAgLy/ph43mlrDorr7nva5C6LW35aeL5rC05bmz5Z2Q5qCHID0g5YeP5Y675YGP56e76YePXHJcbiAgICAgICAgYXR0ck5hbWVTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS54ICs9IC1Db25zdC5CT19BVFRSX1BBRERJTkdfTEVGVDtcclxuICAgICAgICAvL2F0dHJOYW1lU2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkueSA9ICsgYXR0ck5hbWVTaGFwZS5wb3NpdGlvblsxXTtcclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKGF0dHJOYW1lU2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOWxnuaAp+aVsOaNruexu+Wei1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgYm9BdHRyUHJvdG8uX2NyZWF0ZURhdGFUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGlzcGxheURhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4ID0gdGhpcy5fc3RhcnRQb3MueCArIENvbnN0LkJPX05PREVfV0lEVEggLSAxMCxcclxuICAgICAgICAgICAgeSA9IHRoaXMuX3N0YXJ0UG9zLnksXHJcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XHJcblxyXG4gICAgICAgIC8v5aaC5p6c6L+Y6KaB5pi+56S65LqL5Lu25Yaz562W77yM5YiZ5a695bqm6YeN5paw6K6h566XXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlFdmVudERlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgeCA9IHRoaXMuX3N0YXJ0UG9zLnggKyBDb25zdC5CT19OT0RFX1dJRFRIIC8gMztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfZGF0YVR5cGVTaGFwZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fZGF0YS5kYXRhVHlwZSB8fCAnJyxcclxuICAgICAgICAgICAgICAgIHRleHRGb250OiBDb25zdC5CT19BVFRSX0ZPTlQsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiwgIC8v6Z2g5bem5byA5aeL77yM5L6/5LqO6K6h566X5L2N572uXHJcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnLFxyXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBwb3NpdGlvbjogW3gsIHldXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2dyb3VwLmFkZChfZGF0YVR5cGVTaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog5bGe5oCn5LqL5Lu25Yaz562WXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBib0F0dHJQcm90by5fY3JlYXRlRXZlbnREZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Rpc3BsYXlFdmVudERlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBfYm9BdHRyRXZlbnRBcnIgPSB0aGlzLl9kYXRhLmJvQXR0ckV2ZW50QXJyIHx8IFtdLFxyXG4gICAgICAgICAgICBfYm9BdHRyRXZlbnRMZW4gPSBfYm9BdHRyRXZlbnRBcnIubGVuZ3RoLFxyXG4gICAgICAgICAgICBwYWRkaW5nID0gKF9ib0F0dHJFdmVudExlbiA+IDEpID8gMTAgOiAwLFxyXG4gICAgICAgICAgICBfc3RhcnRQb3MgPSB7XHJcbiAgICAgICAgICAgICAgICB4OiB0aGlzLl9zdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAvIDIgKyBDb25zdC5CT19BVFRSX0VWRU5UX1dJRFRIICogKF9ib0F0dHJFdmVudExlbiAtIDEpIC0gcGFkZGluZyxcclxuICAgICAgICAgICAgICAgIHk6IHRoaXMuX3N0YXJ0UG9zLnlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy/ku47lj7PlkJHlt6bnlLvvvIxcclxuICAgICAgICBmb3IgKHZhciBpID0gX2JvQXR0ckV2ZW50TGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKG5ldyBFdmVudERlY2lzaW9uKF9ib0F0dHJFdmVudEFycltpXSwge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRQb3M6IF9zdGFydFBvcyxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdib0F0dHJFdmVudCcsXHJcbiAgICAgICAgICAgICAgICBjbGlja2FibGU6IHRoaXMuX2V2ZW50Q2xpY2thYmxlLFxyXG4gICAgICAgICAgICAgICAgcG9wdXBPcHRzOiB0aGlzLl9ldmVudFBvcHVwT3B0c1xyXG4gICAgICAgICAgICB9KS5nZXRTaGFwZSgpKTtcclxuICAgICAgICAgICAgX3N0YXJ0UG9zID0ge3g6IF9zdGFydFBvcy54IC0gQ29uc3QuQk9fQVRUUl9FVkVOVF9XSURUSCArIDEwLCB5OiBfc3RhcnRQb3MueX07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qX3N0YXJ0UG9zID0ge1xyXG4gICAgICAgICB4OiB0aGlzLl9zdGFydFBvcy54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAvIDIsXHJcbiAgICAgICAgIHk6IHRoaXMuX3N0YXJ0UG9zLnl9O1xyXG5cclxuICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYm9BdHRyRXZlbnRMZW47IGkrKykge1xyXG4gICAgICAgICB0aGlzLl9ncm91cC5hZGQoZXZlbnQuQm9BdHRyRXZlbnQoX2JvQXR0ckV2ZW50QXJyW2ldLCBfc3RhcnRQb3MsIGkgKyAyKSk7XHJcbiAgICAgICAgIF9zdGFydFBvcyA9IHt4OiBfc3RhcnRQb3MueCArIENvbnN0LkJPX0FUVFJfRVZFTlRfV0lEVEggLSA1LCB5OiBfc3RhcnRQb3MueX07XHJcbiAgICAgICAgIH0qL1xyXG5cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gQm9BdHRyO1xyXG5cclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9maXNoLXRvcG8tYm8vbGliL25vZGUvQm9BdHRyTm9kZS5qc1xuICoqIG1vZHVsZSBpZCA9IDcxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICog55So5p2l5Yib5bu65YWz6IGU5YWz57O7XHJcbiAqIOWFs+iBlOWFs+ezu+WMheaLrOaKmOe6v+OAgeeureWktOOAgeWFs+ezu+aWh+Wtl+ivtOaYjlxyXG4gKiBAbW9kdWxlIGZpc2gtdG9wby1iby9ub2RlL1JlbGF0aW9uXHJcbiAqIENyZWF0ZWQgYnkgbWFqaWFuYW4gb24gMTYvNS8xOS5cclxuICovXHJcblxyXG4gICAgdmFyIENvbnN0ID0gcmVxdWlyZSgnLi4vbW9kZWxzL0NvbnN0Jyk7XHJcbiAgICB2YXIgZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9maXNoLXRvcG8tY29yZS9saWIvZ3JhcGhpYy5qc1wiKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc291cmNlU2hhcGUsIOW8gOWni+WbvuW9olxyXG4gICAgICogQHBhcmFtIHRhcmdldFNoYXBlLCDnm67moIflm77lvaJcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2VUZXh0LCDlhbPns7vlvIDlp4vmloflrZfor7TmmI4s5Y+v56m6XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0VGV4dCwg5YWz57O757uT5p2f5paH5a2X6K+05piOLOWPr+epulxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlbGF0aW9uKHNvdXJjZVNoYXBlLCB0YXJnZXRTaGFwZSwgc291cmNlVGV4dCwgdGFyZ2V0VGV4dCkge1xyXG4gICAgICAgIHRoaXMuX3NvdXJjZVRleHQgPSBzb3VyY2VUZXh0O1xyXG4gICAgICAgIHRoaXMuX3RhcmdldFRleHQgPSB0YXJnZXRUZXh0O1xyXG5cclxuICAgICAgICB0aGlzLl9ncm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XHJcblxyXG4gICAgICAgIC8v5bem5L6n5byA5aeL5L2N572uXHJcbiAgICAgICAgdGhpcy5fbFN0YXJ0UG9zID0ge1xyXG4gICAgICAgICAgICB4OiBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS54IC0gQ29uc3QuQk9fQVRUUl9QQURESU5HX0xFRlQsXHJcbiAgICAgICAgICAgIHk6IHNvdXJjZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLnkgKyBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy/lt6bkvqfnu5PmnZ/kvY3nva5cclxuICAgICAgICB0aGlzLl9sRW5kUG9zID0ge1xyXG4gICAgICAgICAgICB4OiB0YXJnZXRTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS54IC0gQ29uc3QuQk9fQVRUUl9QQURESU5HX0xFRlQsXHJcbiAgICAgICAgICAgIHk6IHRhcmdldFNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLnkgKyB0YXJnZXRTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy/lj7PkvqflvIDlp4vkvY3nva5cclxuICAgICAgICB0aGlzLl9yU3RhcnRQb3MgPSB7XHJcbiAgICAgICAgICAgIHg6IHNvdXJjZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLnggKyBDb25zdC5CT19OT0RFX1dJRFRIIC0gQ29uc3QuQk9fQVRUUl9QQURESU5HX0xFRlQsXHJcbiAgICAgICAgICAgIHk6IHNvdXJjZVNoYXBlLmdldEJvdW5kaW5nUmVjdCgpLnkgKyBzb3VyY2VTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS5oZWlnaHQgLyAyXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy/lj7Pkvqfnu5PmnZ/kvY3nva5cclxuICAgICAgICB0aGlzLl9yRW5kUG9zID0ge1xyXG4gICAgICAgICAgICB4OiB0YXJnZXRTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS54ICsgQ29uc3QuQk9fTk9ERV9XSURUSCAtIENvbnN0LkJPX0FUVFJfUEFERElOR19MRUZULFxyXG4gICAgICAgICAgICB5OiB0YXJnZXRTaGFwZS5nZXRCb3VuZGluZ1JlY3QoKS55ICsgdGFyZ2V0U2hhcGUuZ2V0Qm91bmRpbmdSZWN0KCkuaGVpZ2h0IC8gMlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8v5Yik5pat55S757q/5pa55ZCRXHJcbiAgICAgICAgdGhpcy5fbGVmdERpcmVjdGlvbiA9IHRoaXMuX2xTdGFydFBvcy54IC0gdGhpcy5fbEVuZFBvcy54IDw9IDA7XHJcblxyXG4gICAgICAgIC8v55Sf5oiQ5Zu+5b2iXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJlbGF0aW9uUHJvdG8gPSBSZWxhdGlvbi5wcm90b3R5cGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDojrflj5blhbPns7vmlbTkvZPlm77lvaJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICByZWxhdGlvblByb3RvLmdldFNoYXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cDtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDlhbPns7vmlbTkvZPlm77lvaJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHJlbGF0aW9uUHJvdG8uX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL+eUu+e6v1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZUxpbmUoKTtcclxuXHJcbiAgICAgICAgLy/nrq3lpLRcclxuICAgICAgICB0aGlzLl9jcmVhdGVBcnJvdygpO1xyXG5cclxuICAgICAgICAvL+WFs+ezu+ivtOaYjuaWh+Wtl1xyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVRleHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDnlJ/miJDlhbPns7vmipjnur9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHJlbGF0aW9uUHJvdG8uX2NyZWF0ZUxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9saW5lUG9pbnRzID0gW107XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9sZWZ0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIC8v56ys5LiA54K5XHJcbiAgICAgICAgICAgIF9saW5lUG9pbnRzLnB1c2goW3RoaXMuX2xTdGFydFBvcy54LCB0aGlzLl9sU3RhcnRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+esrOS6jOeCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9sU3RhcnRQb3MueCAtIENvbnN0LlJFTEFUSU9OX09GRlNFVCwgdGhpcy5fbFN0YXJ0UG9zLnldKTtcclxuICAgICAgICAgICAgLy/nrKzkuInngrlcclxuICAgICAgICAgICAgX2xpbmVQb2ludHMucHVzaChbdGhpcy5fbFN0YXJ0UG9zLnggLSBDb25zdC5SRUxBVElPTl9PRkZTRVQsIHRoaXMuX2xFbmRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+esrOWbm+eCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9sRW5kUG9zLngsIHRoaXMuX2xFbmRQb3MueV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy/nrKzkuIDngrlcclxuICAgICAgICAgICAgX2xpbmVQb2ludHMucHVzaChbdGhpcy5fclN0YXJ0UG9zLngsIHRoaXMuX3JTdGFydFBvcy55XSk7XHJcbiAgICAgICAgICAgIC8v56ys5LqM54K5XHJcbiAgICAgICAgICAgIF9saW5lUG9pbnRzLnB1c2goW3RoaXMuX3JTdGFydFBvcy54ICsgQ29uc3QuUkVMQVRJT05fT0ZGU0VULCB0aGlzLl9sU3RhcnRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+esrOS4ieeCuVxyXG4gICAgICAgICAgICBfbGluZVBvaW50cy5wdXNoKFt0aGlzLl9yU3RhcnRQb3MueCArIENvbnN0LlJFTEFUSU9OX09GRlNFVCwgdGhpcy5fckVuZFBvcy55XSk7XHJcbiAgICAgICAgICAgIC8v56ys5Zub54K5XHJcbiAgICAgICAgICAgIF9saW5lUG9pbnRzLnB1c2goW3RoaXMuX3JFbmRQb3MueCwgdGhpcy5fckVuZFBvcy55XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX2xpbmVTaGFwZSA9IG5ldyBncmFwaGljLlBvbHlsaW5lKHtcclxuICAgICAgICAgICAgc2hhcGU6IHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogX2xpbmVQb2ludHNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbGw6ICdibHVlJyxcclxuICAgICAgICAgICAgICAgIHN0cm9rZTogJ2JsdWUnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9saW5lU2hhcGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIOeUn+aIkOeureWktOWbvuW9olxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcmVsYXRpb25Qcm90by5fY3JlYXRlQXJyb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hcnJvd1BvaW50cyA9IFtdO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fbGVmdERpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAvL+WPs+S+p+esrOS4gOeCuVxyXG4gICAgICAgICAgICBfYXJyb3dQb2ludHMucHVzaChbdGhpcy5fbEVuZFBvcy54LCB0aGlzLl9sRW5kUG9zLnldKTtcclxuICAgICAgICAgICAgLy/kuIvpnaLnrKzkuozngrlcclxuICAgICAgICAgICAgX2Fycm93UG9pbnRzLnB1c2goW3RoaXMuX2xFbmRQb3MueCAtIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9sRW5kUG9zLnkgKyBDb25zdC5SRUxBVElPTl9BUlJPV19IRUlHSFRdKTtcclxuICAgICAgICAgICAgLy/kuIrpnaLnrKzkuInngrlcclxuICAgICAgICAgICAgX2Fycm93UG9pbnRzLnB1c2goW3RoaXMuX2xFbmRQb3MueCAtIENvbnN0LlJFTEFUSU9OX0FSUk9XX1dJRFRILCB0aGlzLl9sRW5kUG9zLnkgLSBDb25zdC5SRUxBVElPTl9BUlJPV19IRUlHSFRdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8v5bem5L6n56ys5LiA54K5XHJcbiAgICAgICAgICAgIF9hcnJvd1BvaW50cy5wdXNoKFt0aGlzLl9yRW5kUG9zLngsIHRoaXMuX3JFbmRQb3MueV0pO1xyXG4gICAgICAgICAgICAvL+S4i+mdouesrOS6jOeCuVxyXG4gICAgICAgICAgICBfYXJyb3dQb2ludHMucHVzaChbdGhpcy5fckVuZFBvcy54ICsgQ29uc3QuUkVMQVRJT05fQVJST1dfV0lEVEgsIHRoaXMuX3JFbmRQb3MueSArIENvbnN0LlJFTEFUSU9OX0FSUk9XX0hFSUdIVF0pO1xyXG4gICAgICAgICAgICAvL+S4iumdouesrOS4ieeCuVxyXG4gICAgICAgICAgICBfYXJyb3dQb2ludHMucHVzaChbdGhpcy5fckVuZFBvcy54ICsgQ29uc3QuUkVMQVRJT05fQVJST1dfV0lEVEgsIHRoaXMuX3JFbmRQb3MueSAtIENvbnN0LlJFTEFUSU9OX0FSUk9XX0hFSUdIVF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIF9hcnJvd1NoYXBlID0gbmV3IGdyYXBoaWMuUG9seWxpbmUoe1xyXG4gICAgICAgICAgICBzaGFwZToge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzOiBfYXJyb3dQb2ludHNcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnYmx1ZScsXHJcbiAgICAgICAgICAgICAgICBzdHJva2U6ICdibHVlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuX2dyb3VwLmFkZChfYXJyb3dTaGFwZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICog55Sf5oiQ5paH5a2X6K+05piOXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByZWxhdGlvblByb3RvLl9jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfc291cmNlVGV4dFBvcyxcclxuICAgICAgICAgICAgX3RhcmdldFRleHRQb3MsXHJcbiAgICAgICAgICAgIF90ZXh0QWxpZ247XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9sZWZ0RGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0UG9zID0gW3RoaXMuX2xTdGFydFBvcy54IC0gMTAsIHRoaXMuX2xTdGFydFBvcy55IC0gQ29uc3QuUkVMQVRJT05fVEVYVF9PRkZTRVRfWV07XHJcbiAgICAgICAgICAgIF90YXJnZXRUZXh0UG9zID0gW3RoaXMuX2xFbmRQb3MueCAtIDEwIC0gQ29uc3QuUkVMQVRJT05fQVJST1dfV0lEVEgsIHRoaXMuX2xFbmRQb3MueSAtIENvbnN0LlJFTEFUSU9OX1RFWFRfT0ZGU0VUX1ldO1xyXG4gICAgICAgICAgICBfdGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0UG9zID0gW3RoaXMuX3JTdGFydFBvcy54ICsgMTAsIHRoaXMuX3JTdGFydFBvcy55IC0gQ29uc3QuUkVMQVRJT05fVEVYVF9PRkZTRVRfWV07XHJcbiAgICAgICAgICAgIF90YXJnZXRUZXh0UG9zID0gW3RoaXMuX3JFbmRQb3MueCArIDEwICsgQ29uc3QuUkVMQVRJT05fQVJST1dfV0lEVEgsIHRoaXMuX3JFbmRQb3MueSAtIENvbnN0LlJFTEFUSU9OX1RFWFRfT0ZGU0VUX1ldO1xyXG4gICAgICAgICAgICBfdGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy/lvIDlp4vmloflrZdcclxuICAgICAgICBpZiAodGhpcy5fc291cmNlVGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgX3NyY1RleHRTaGFwZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IF9zb3VyY2VUZXh0UG9zLFxyXG5cclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fc291cmNlVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fQVRUUl9GT05ULFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogX3RleHRBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdidXR0b20nLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF9zcmNUZXh0U2hhcGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy/nu5PmnZ/mloflrZdcclxuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0VGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgX3RhcmdldFRleHRTaGFwZSA9IG5ldyBncmFwaGljLlRleHQoe1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IF90YXJnZXRUZXh0UG9zLFxyXG5cclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5fdGFyZ2V0VGV4dCxcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0Rm9udDogQ29uc3QuQk9fQVRUUl9GT05ULFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogX3RleHRBbGlnbixcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmU6ICdidXR0b20nLFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JvdXAuYWRkKF90YXJnZXRUZXh0U2hhcGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gUmVsYXRpb247XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvZmlzaC10b3BvLWJvL2xpYi9ub2RlL1JlbGF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=