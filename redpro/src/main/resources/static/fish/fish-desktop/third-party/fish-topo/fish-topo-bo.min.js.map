{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","fish-topo-bo.js","webpack:/webpack/bootstrap 916e37e37ced298188d3","webpack:///index.bo.js","webpack:///lib/fish-topo-bo/lib/FishTopoBo.js","webpack:///~/zrender/lib/zrender.js","webpack:///~/zrender/lib/core/guid.js","webpack:///~/zrender/lib/core/env.js","webpack:///~/zrender/lib/Handler.js","webpack:///~/zrender/lib/core/event.js","webpack:///~/zrender/lib/mixin/Eventful.js","webpack:///~/zrender/lib/core/util.js","webpack:///~/zrender/lib/graphic/Gradient.js","webpack:///~/zrender/lib/mixin/Draggable.js","webpack:///~/zrender/lib/core/GestureMgr.js","webpack:///~/zrender/lib/Storage.js","webpack:///~/zrender/lib/container/Group.js","webpack:///~/zrender/lib/Element.js","webpack:///~/zrender/lib/mixin/Transformable.js","webpack:///~/zrender/lib/core/matrix.js","webpack:///~/zrender/lib/core/vector.js","webpack:///~/zrender/lib/mixin/Animatable.js","webpack:///~/zrender/lib/animation/Animator.js","webpack:///~/zrender/lib/animation/Clip.js","webpack:///~/zrender/lib/animation/easing.js","webpack:///~/zrender/lib/tool/color.js","webpack:///~/zrender/lib/core/log.js","webpack:///~/zrender/lib/config.js","webpack:///~/zrender/lib/core/BoundingRect.js","webpack:///~/zrender/lib/animation/Animation.js","webpack:///~/zrender/lib/Painter.js","webpack:///~/zrender/lib/Layer.js","webpack:///~/zrender/lib/graphic/Image.js","webpack:///~/zrender/lib/graphic/Displayable.js","webpack:///~/zrender/lib/graphic/Style.js","webpack:///~/zrender/lib/graphic/mixin/RectText.js","webpack:///~/zrender/lib/contain/text.js","webpack:///~/zrender/lib/graphic/helper/roundRect.js","webpack:///~/zrender/lib/core/LRU.js","webpack:///lib/fish-topo-bo/lib/node/BoNode.js","webpack:///lib/fish-topo-bo/lib/models/Const.js","webpack:///lib/fish-topo-bo/lib/node/BoName.js","webpack:///lib/fish-topo-core/lib/graphic.js","webpack:///~/zrender/lib/tool/path.js","webpack:///~/zrender/lib/graphic/Path.js","webpack:///~/zrender/lib/core/PathProxy.js","webpack:///~/zrender/lib/core/curve.js","webpack:///~/zrender/lib/core/bbox.js","webpack:///~/zrender/lib/contain/path.js","webpack:///~/zrender/lib/contain/line.js","webpack:///~/zrender/lib/contain/cubic.js","webpack:///~/zrender/lib/contain/quadratic.js","webpack:///~/zrender/lib/contain/arc.js","webpack:///~/zrender/lib/contain/util.js","webpack:///~/zrender/lib/contain/windingLine.js","webpack:///~/zrender/lib/tool/transformPath.js","webpack:///~/zrender/lib/graphic/Text.js","webpack:///~/zrender/lib/graphic/shape/Circle.js","webpack:///~/zrender/lib/graphic/shape/Sector.js","webpack:///~/zrender/lib/graphic/shape/Ring.js","webpack:///~/zrender/lib/graphic/shape/Polygon.js","webpack:///~/zrender/lib/graphic/helper/poly.js","webpack:///~/zrender/lib/graphic/helper/smoothSpline.js","webpack:///~/zrender/lib/graphic/helper/smoothBezier.js","webpack:///~/zrender/lib/graphic/shape/Polyline.js","webpack:///~/zrender/lib/graphic/shape/Rect.js","webpack:///~/zrender/lib/graphic/shape/Line.js","webpack:///~/zrender/lib/graphic/shape/BezierCurve.js","webpack:///~/zrender/lib/graphic/shape/Arc.js","webpack:///~/zrender/lib/graphic/LinearGradient.js","webpack:///~/zrender/lib/graphic/RadialGradient.js","webpack:///lib/fish-topo-bo/lib/node/EventDecisionNode.js","webpack:///lib/fish-topo-bo/lib/node/LineNode.js","webpack:///lib/fish-topo-bo/lib/node/BoAttrNode.js","webpack:///lib/fish-topo-bo/lib/node/Relation.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","FishTopoBo","dom","opts","nowZoom","canScale","_zr","zr","init","renderer","devicePixelRatio","util","BoNode","Relation","Const","graphic","eventTool","fishTopoProto","prototype","group","Group","groupDrag","add","zrScale","resize","addBo","boData","_setParent","layout","x","startPos","y","level","_bfs","_moveRightByParent","boNode","getShape","addChildBo","child","childCnt","length","childBoArr","i","parent","next","_levelMaxPos","_queue","push","tmp","shift","BO_NODE_WIDTH","_moveRightByChild","BO_NODE_OFFSET_X","width","moved","_moveRightByPrevious","parentBoNode","boNodeHeight","getBoundingRect","height","getLayout","BO_NODE_OFFSET_Y","getData","relationNode","relation","_relationLen","j","sourceId","targetId","sourceText","targetText","childOfName","setCurrentBo","boId","style","childCount","childAt","name","setCurrent","clear","type","zoom","zoomDelta","zoomX","zoomY","that","target","pos","position","scale","newZoom","_zoom","zoomScale","attr","getWidth","getHeight","on","e","stop","event","wheelDelta","offsetX","offsetY","groupDragFunction","moveDrag","gx","gy","min","max","sX","clientX","startX","sY","clientY","startY","nowGroupPosition","groupPositionX","groupPositionY","endDrag","off","moveFunction","upFunction","cancelBubble","drag","node","GroupNode","nodeMessage","shape","nodeXY","movePosition","moveX","moveY","groupNode","reDraw","alarm","newAlarmPosition","ConnectionManager","refreshLineByNode","layoutNode","forceLayoutOption","nodes","allNodes","_","indexOf","alarmPositionX","alarmPositionY","isdraggable","idBase","Date","instances","DOM_ATTRIBUTE_KEY","fishTopoBo","version","dependencies","zrender","Error","defaults","showGridLine","gridLineSpacing","setAttribute","getInstanceByDom","key","getAttribute","dispose","chart","topo","zrUtil","isDom","isDisposed","delInstance","guid","env","Handler","Storage","Animation","useVML","canvasSupported","painterCtors","canvas","ZRender","getInstance","registerPainter","Ctor","self","storage","rendererType","vml","painter","handler","getViewportRoot","animation","stage","update","_needsRefresh","refreshImmediately","start","oldDelFromMap","delFromMap","oldAddToMap","addToMap","elId","el","get","removeSelfFromZr","addSelfToZr","constructor","getId","addRoot","remove","delRoot","configLayer","zLevel","config","refresh","clearAnimation","toDataURL","backgroundColor","args","pathToImage","setDefaultCursorStyle","cursorStyle","eventName","eventHandler","context","trigger","idStart","detect","ua","os","browser","webkit","match","android","ipad","ipod","iphone","webos","touchpad","kindle","silk","blackberry","bb10","rimtabletos","playbook","chrome","firefox","safari","webview","ie","edge","ios","replace","tablet","phone","document","createElement","getContext","touchEventsSupported","window","pointerEventsSupported","navigator","userAgent","makeEventPacket","eveType","zrX","zrY","gestureEvent","pinchX","pinchY","pinchScale","zrDelta","processGesture","zrHandler","gestureMgr","_gestureMgr","gestureInfo","recognize","findHover","_dispatchProxy","initDomHandler","instance","makeMouseHandler","fn","_touching","apply","arguments","handlerNames","touchHandlerNames","concat","pointerHandlerNames","_handlers","bind","domHandlers","mouseHandlerNames","isHover","displayable","rectHover","clipPath","contain","setTouchTimer","clearTimeout","_touchTimer","setTimeout","usePointerEvent","useTouchEvent","eventNameFix","Draggable","GestureMgr","Eventful","TOUCH_CLICK_DELAY","addEventListener","removeEventListener","normalizeEvent","mousemove","hovered","lastHovered","_hovered","cursor","_defaultCursorStyle","__zr","mouseout","element","toElement","relatedTarget","nodeType","parentNode","touchstart","_lastTouchMoment","mousedown","touchmove","touchend","mouseup","click","each","mountHandlers","_lastX","_lastY","dispatch","eventArgs","targetEl","eventPacket","eachOtherLayer","layer","exclude","list","getDisplayList","silent","ignore","mixin","getBoundingClientRect","left","top","eventType","isTouch","touch","targetTouches","changedTouches","rBounding","box","detail","isDomLevel2","attachEvent","detachEvent","preventDefault","stopPropagation","returnValue","Dispatcher","arrySlice","Array","slice","_$handlers","one","_h","h","ctx","isSilent","newList","l","argLen","len","splice","triggerWithContext","clone","source","result","isBuildInObject","hasOwnProperty","merge","overwrite","isObject","targetProp","sourceProp","isArray","mergeAll","targetAndSources","extend","overlay","createCanvas","_ctx","array","value","inherits","clazz","baseClazz","F","clazzPrototype","prop","superClass","isArrayLike","data","obj","cb","forEach","nativeForEach","map","nativeMap","reduce","memo","nativeReduce","filter","nativeFilter","find","func","nativeSlice","curry","objToString","isFunction","isString","BUILTIN_OBJECT","Gradient","retrieve","values","Function","assert","condition","message","[object Function]","[object RegExp]","[object Date]","[object Error]","[object CanvasGradient]","Object","toString","arrayProto","noop","colorStops","addColorStop","offset","color","_dragStart","_drag","_dragEnd","draggingTarget","draggable","_draggingTarget","dragging","_x","_y","dx","dy","drift","dropTarget","lastDropTarget","_dropTarget","dist","pointPair","Math","sqrt","center","_track","_doTrack","_recognize","touches","trackItem","points","recognizers","pinch","track","trackLen","pinchEnd","pinchPre","isFinite","pinchCenter","shapeCompareFunc","a","b","zlevel","z","z2","__renderidx","_elements","_roots","_displayList","_displayListLen","includeIgnore","updateDisplayList","roots","displayList","_updateAndAddDisplayable","sort","clipPaths","beforeUpdate","afterUpdate","updateTransform","children","_children","__dirty","__clipPaths","addChildrenToStorage","delChildrenFromStorage","idx","__storage","dirty","elements","_renderList","Element","BoundingRect","_doAdd","addBefore","nextSibling","removeAll","eachChild","traverse","includeChildren","rect","tmpRect","tmpMat","invisible","childRect","transform","getLocalTransform","copy","applyTransform","union","Transformable","Animatable","decomposeTransform","attrKV","hide","show","setClipPath","removeClipPath","__clipTarget","animators","addAnimator","removeAnimator","isNotAroundZero","val","EPSILON","matrix","vector","mIdentity","identity","rotation","origin","transformableProto","needLocalTransform","parentHasTransform","create","mul","invTransform","invert","rotate","setTransform","tmpTransform","sx","sy","atan2","transformCoordToLocal","v2","transformCoordToGlobal","ArrayCtor","Float32Array","out","m1","m2","out0","out1","out2","out3","out4","out5","translate","v","rad","aa","ac","atx","ab","ad","aty","st","sin","ct","cos","vx","vy","det","set","v1","scaleAndAdd","sub","lenSquare","div","dot","s","normalize","d","distance","distanceSquare","negate","lerp","t","lengthSquare","distSquare","Animator","log","animate","path","loop","animatingShape","pathSplitted","split","animator","during","done","stopAnimation","forwardToLast","animateTo","time","delay","easing","callback","count","_animateToShallow","objShallow","propertyCount","props","when","defaultGetter","defaultSetter","interpolateNumber","p0","p1","percent","interpolateString","interpolateArray","arrDim","len2","fillArr","arr0","arr1","arr0Len","arr1Len","isPreviousLarger","arraySlice","isArraySame","catmullRomInterpolateArray","p2","p3","t2","t3","catmullRomInterpolate","v0","cloneValue","ret","rgba2String","rgba","floor","join","createTrackClip","oneTrackDone","keyframes","propName","getter","_getter","setter","_setter","useSpline","trackMaxTime","firstVal","isValueArray","isValueColor","isValueString","kfPercents","kfValues","prevValue","isAllValueEqual","colorArray","parse","lastValue","_target","w","lastFrame","lastFramePercent","onframe","frame","range","clip","Clip","life","_loop","_delay","ondestroy","_tracks","_clipCount","_doneList","_onframeList","_clipList","tracks","_doneCallback","doneList","lastClip","clipCount","addClip","oldOnFrame","clipList","removeClip","getClips","options","_life","_initialized","gap","onrestart","easingFuncs","step","_startTime","getTime","easingFunc","schedule","fire","restart","_needsRemove","remainder","arg","linear","k","quadraticIn","quadraticOut","quadraticInOut","cubicIn","cubicOut","cubicInOut","quarticIn","quarticOut","quarticInOut","quinticIn","quinticOut","quinticInOut","sinusoidalIn","PI","sinusoidalOut","sinusoidalInOut","exponentialIn","pow","exponentialOut","exponentialInOut","circularIn","circularOut","circularInOut","elasticIn","asin","elasticOut","elasticInOut","backIn","backOut","backInOut","bounceIn","bounceOut","bounceInOut","clampCssByte","round","clampCssAngle","clampCssFloat","f","parseCssInt","str","charAt","parseFloat","parseInt","parseCssFloat","cssHueToRgb","colorStr","toLowerCase","kCSSColorTable","op","ep","fname","substr","params","alpha","pop","hsla2rgba","iv","hsla","rgba2hsla","H","S","R","G","B","vMin","vMax","delta","L","deltaR","deltaG","deltaB","lift","colorArr","stringify","toHex","fastMapToColor","normalizedValue","colors","leftIndex","rightIndex","ceil","leftColor","rightColor","dv","mapToColor","fullOutput","mapIntervalToColor","interval","info0","info1","end","modifyHSL","modifyAlpha","arrColor","transparent","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","debugMode","console","dpr","vec2","v2ApplyTransform","mathMin","mathAbs","abs","mathMax","other","calculateTransform","intersect","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","requestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","_clips","_running","_time","clips","_update","deferredEvents","deferredClips","parseInt10","isLayerValid","isBuildin","preProcessLayer","__unusedCount","postProcessLayer","isDisplayableCulled","viewRect","isClipPathChanged","prevClipPaths","doClip","beginPath","buildPath","Layer","Painter","singleCanvas","nodeName","toUpperCase","_singleCanvas","rootStyle","innerHTML","_width","_height","mainLayer","initContext","_layers","0","_zlevelList","_getWidth","_getHeight","domRoot","_domRoot","domRootStyle","overflow","appendChild","_layerConfig","_createPathToImage","isSingleCanvas","paintAll","zlevelList","_paintList","_updateLayerStatus","currentLayer","currentZLevel","viewWidth","viewHeight","eachBuildinLayer","prevElClipPaths","elZLevel","getLayer","opacity","culling","restore","save","beforeBrush","brush","afterBrush","insertLayer","layersMap","prevLayer","prevDom","insertBefore","firstChild","eachLayer","getLayers","layers","elCounts","elCount","_clearLayer","layerConfig","delLayer","removeChild","display","clearLayer","getRenderedCanvas","imageLayer","pixelRatio","clearColor","stl","defaultView","getComputedStyle","clientWidth","paddingLeft","paddingRight","clientHeight","paddingTop","paddingBottom","_pathToImage","clearRect","pathTransform","ImageShape","imgShape","image","me","returnFalse","createDom","newDom","newDomStyle","domStyle","onselectstart","domBack","ctxBack","motionBlur","lastFrameAlpha","createBackBuffer","clearAll","haveClearColor","haveMotionBLur","globalCompositeOperation","drawImage","fillStyle","fillRect","globalAlpha","Displayable","roundRectHelper","LRU","globalImageCache","ZImage","src","_image","cachedImgObj","Image","onload","pending","put","r","sWidth","sHeight","text","drawRectText","_rect","Style","RectText","rectContain","coord","animateStyle","setStyle","STYLE_LIST_COMMON","extendFrom","fill","stroke","lineDash","lineDashOffset","shadowBlur","shadowOffsetX","shadowOffsetY","lineWidth","strokeNoScale","textFill","textStroke","textPosition","textBaseline","textAlign","textVerticalAlign","textDistance","textShadowBlur","textShadowOffsetX","textShadowOffsetY","styleName","getLineScale","canvasGradient","strokeStyle","otherStyle","newStyle","styleProto","parsePercent","maxValue","lastIndexOf","textContain","textRect","align","font","textFont","baseline","verticalAlign","res","adjustTextPositionOnRect","shadowColor","textShadowColor","textLines","fillText","strokeText","lineHeight","getTextWidth","textWidthCache","measureText","textWidthCacheCounter","TEXT_CACHE_MAX","getTextRect","textLineLen","textHeight","halfHeight","textEllipsis","containerWidth","ellipsis","minCharacters","maxIterations","cnCharWidth","ascCharWidth","textLineTruncate","subLength","estimateLength","charCode","charCodeAt","r1","r2","r3","r4","total","moveTo","lineTo","quadraticCurveTo","LinkedList","head","tail","_len","linkedListProto","insert","entry","Entry","insertEntry","prev","maxSize","_list","_map","_maxSize","LRUProto","leastUsedEntry","BO","_data","_oriStartPos","_nextStartPos","_displayAttrDataType","displayAttrDataType","_displayAttrEvent","displayAttrEvent","_boClickable","boClickable","_boPopupOpts","boPopupOpts","_boEventClickable","boEventClickable","_boEventPopupOpts","boEventPopupOpts","_attrEventClickable","attrEventClickable","_attrEventPopupOpts","attrEventPopupOpts","_isCurrent","isCurrent","_boShapeHeight","_group","_boShape","fish","_render","BoName","EventDecision","Line","BoAttr","boProto","_createBoName","_createEventDecision","_createBoAttr","_createBoShape","_boNameShape","clickable","onclick","_click","_calNextShapeStartPos","boEventArr","_eventShape","_boEventArr","_boEventLen","_eventOpts","popupOpts","boAttrArr","_boAttrShape","_lineShape","_boAttrArr","_boAttrLen","_attrEventStartPos","BoLine","AttrLine","displayDataType","displayEventDecision","eventClickable","eventPopupOpts","AttrEventLine","curShape","BO_NODE_DEFAULT_HEIGHT","Rect","brushType","lineCape","viewOption","DATA","popupView","BO_NAME_FONT","BO_NAME_PADDING_TOP","BO_NAME_PADDING_BOTTOM","BO_EVENT_HEIGHT","BO_EVENT_WIDTH","BO_EVENT_FONT","BO_ATTR_FONT","BO_ATTR_PADDING_TOP","BO_ATTR_PADDING_BOTTOM","BO_ATTR_PADDING_LEFT","BO_ATTR_DATA_TYPE_PADDING_RIGHT","BO_ATTR_EVENT_WIDTH","LINE_DASH","RELATION_OFFSET","RELATION_ARROW_WIDTH","RELATION_ARROW_HEIGHT","RELATION_TEXT_OFFSET_X","RELATION_TEXT_OFFSET_Y","Text","doSingleEnterHover","__isHover","__hoverStlDirty","hoverStyle","__hoverStl","colorTool","normalStyle","__normalStl","doSingleLeaveHover","normalStl","doEnterHover","doLeaveHover","setElementHoverStl","hoverStl","onElementMouseOver","__isEmphasis","onElementMouseOut","enterEmphasis","leaveEmphasis","animateOrSetProps","isUpdate","animatableModel","postfix","duration","getShallow","animationEasing","pathTool","Path","Util","Circle","Sector","Ring","Polygon","Polyline","BezierCurve","Arc","LinearGradient","RadialGradient","extendShape","extendPath","pathData","extendFromString","makePath","createFromString","boundingRect","aspect","cx","cy","resizePath","mergePath","pathRect","subPixelOptimizeLine","param","subPixelOptimize","x1","x2","y1","y2","subPixelOptimizeRect","originX","originY","originWidth","originHeight","positiveOrNegative","doubledPosition","setHoverStyle","setText","textStyle","labelModel","labelPosition","labelColor","textStyleModel","getModel","getFont","getTextColor","updateProps","initProps","getTransform","ancestor","mat","vertex","transformDirection","direction","hBase","vBase","processArc","fa","fs","rx","ry","psiDeg","cmd","psi","xp","mathCos","mathSin","yp","lambda","mathSqrt","cxp","cyp","theta","vAngle","u","dTheta","vRatio","addData","createPathProxyFromString","n","cs","cc","RegExp","prevCmd","arr","cpx","cpy","PathProxy","CMD","isNaN","ctlPtx","ctlPty","M","C","Q","A","Z","toStatic","createPathOptions","pathProxy","setData","transformPath","rebuildPath","vMag","acos","pathEls","pathEl","pathList","pathBundle","appendPath","pathHasFill","pathHasStroke","pathContain","__dirtyPath","strokeContainThreshold","hasStroke","hasFill","updateCanvasGradient","ctxLineDash","setLineDash","setLineDashOffset","shapeCfg","rectWithStroke","_rectWithStroke","lineScale","localPos","containStroke","dirtyPath","animateShape","setShape","Sub","defaultShape","thisShape","curve","bbox","min2","max2","hasTypedArray","_xi","_yi","_x0","_y0","_lineDash","_dashOffset","_dashIdx","_dashSum","_needsDash","_dashedLineTo","bezierCurveTo","x3","y3","_dashedBezierTo","_dashedQuadraticTo","arc","startAngle","endAngle","anticlockwise","arcTo","radius","closePath","x0","y0","lineDashSum","appendSize","appendPathData","_expandData","_prevCmd","newData","dash","dashSum","nDash","cubicAt","bezierLen","tmpLen","Number","MAX_VALUE","xi","yi","fromLine","fromCubic","fromQuadratic","fromArc","scaleX","scaleY","isEllipse","isAroundZero","onet","cubicDerivativeAt","cubicRootAt","t1","disc","K","discSqrt","Y1","Y2","mathPow","ONE_THIRD","T","ASqrt","THREE_SQRT","cubicExtrema","extrema","cubicSubdivide","p01","p12","p23","p012","p123","p0123","cubicProjectPoint","d1","d2","Infinity","_v0","_t","_v1","v2DistSquare","_v2","quadraticAt","quadraticDerivativeAt","quadraticRootAt","quadraticExtremum","divider","quadraticSubdivide","quadraticProjectPoint","v2Create","extremity","PI2","fromPoints","right","bottom","xDim","yDim","tx","ty","vec2Min","vec2Max","diff","angle","isAroundEqual","swapExtrema","windingCubic","nRoots","y0_","y1_","nExtrema","x_","windingQuadratic","y_","windingArc","dir","normalizeRadian","containPath","isStroke","windingLine","cubic","quadratic","line","_l","_a","_b","_s","nPoint","mathAtan2","r0","clockwise","unitX","unitY","polyHelper","smooth","smoothConstraint","smoothSpline","smoothBezier","controlPoints","cp1","cp2","interpolate","isLoop","segs","w2","w3","v2Min","v2Max","v2Scale","v2Distance","v2Add","constraint","prevPoint","nextPoint","cps","point","d0","sum","cp0","pointAt","curveTool","cpx1","cpy1","cpx2","cpy2","createLinearGradient","createRadialGradient","EventDecisionNode","_startPos","_type","_clickable","_popupOpts","eventProto","_createEventShape","_createEVentName","eventNameShape","endPos","_line","attrHeight","_style","strokeColor","boAttrData","_keyValue","keyValue","_displayDataType","_displayEventDecision","_eventClickable","_eventPopupOpts","boAttrProto","_createText","_createDataType","attrNameShape","_dataTypeShape","dataType","_boAttrEventArr","boAttrEventArr","_boAttrEventLen","padding","sourceShape","targetShape","_sourceText","_targetText","_lStartPos","_lEndPos","_rStartPos","_rEndPos","_leftDirection","relationProto","_createLine","_createArrow","_linePoints","_arrowPoints","_arrowShape","_sourceTextPos","_targetTextPos","_textAlign","_srcTextShape","_targetTextShape"],"mappings":"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","file":"fish-topo-bo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"fishTopoBo\"] = factory();\n\telse\n\t\troot[\"fishTopoBo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Export fishTopo as CommonJS module\r\n\t */\r\n\tmodule.exports = __webpack_require__(2);\r\n\t\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t *\r\n\t */\r\n\t\r\n\t    var zr = __webpack_require__(3);\r\n\t    var util = __webpack_require__(9);\r\n\t    var BoNode = __webpack_require__(37);\r\n\t    var Relation = __webpack_require__(72);\r\n\t    var Const = __webpack_require__(38);\r\n\t    var graphic = __webpack_require__(40);\r\n\t    var eventTool = __webpack_require__(7);\r\n\t\r\n\t    function FishTopoBo(dom, opts) {\r\n\t        /**\r\n\t         * 缩放\r\n\t         * @type {number}\r\n\t         */\r\n\t        this.nowZoom = 1;\r\n\t        this.canScale = true;\r\n\t\r\n\t        /**\r\n\t         * 初始化zrender\r\n\t         */\r\n\t        this._zr = zr.init(dom, {\r\n\t            renderer: opts.renderer || 'canvas',\r\n\t            devicePixelRatio: opts.devicePixelRatio\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var fishTopoProto = FishTopoBo.prototype;\r\n\t\r\n\t    /**\r\n\t     * 初始化\r\n\t     */\r\n\t    fishTopoProto.init = function () {\r\n\t        this.group = new graphic.Group();\r\n\t        this.groupDrag(this.group);\r\n\t        this._zr.add(this.group);\r\n\t        this.zrScale();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n\t     */\r\n\t    fishTopoProto.resize = function () {\r\n\t        this._zr.resize();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加BO\r\n\t     * @param {Object} boData, bo数据\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupUrl: String 点击BO弹出页面地址\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          }} opts\r\n\t     * @returns {*}\r\n\t     */\r\n\t    fishTopoProto.addBo = function (boData, opts) {\r\n\t        //设置BO父子关系，便于后续整体移动\r\n\t        this._setParent(boData);\r\n\t\r\n\t        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n\t        boData.layout = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y,\r\n\t            level: 1\r\n\t        };\r\n\t\r\n\t        //计算BO的X坐标\r\n\t        this._bfs(boData);\r\n\t\r\n\t        //按照起始坐标整体左移\r\n\t        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\t\r\n\t        //画BO\r\n\t        var boNode = new BoNode(boData, opts);\r\n\t        this.group.add(boNode.getShape());\r\n\t\r\n\t        //创建子BO\r\n\t        this.addChildBo(boNode, opts);\r\n\t\r\n\t        return boNode;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置BO的父子关系\r\n\t     * @param {Object} boData BO数据\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._setParent = function (boData) {\r\n\t        if (boData.child) {\r\n\t            var childCnt = boData.child.length,\r\n\t                childBoArr = boData.child;\r\n\t            for (var i = 0; i < childCnt; i++) {\r\n\t                childBoArr[i].parent = boData;\r\n\t                if (childBoArr[i + 1]) {\r\n\t                    childBoArr[i].next = childBoArr[i + 1];\r\n\t                }\r\n\t                //设置最后子节点的next=下一个父节点的第一个子节点\r\n\t                else if (boData.next && boData.next.child) {\r\n\t                    childBoArr[i].next = boData.next.child[0];\r\n\t                }\r\n\t                this._setParent(childBoArr[i]);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * Breadth-First-Search 计算X坐标\r\n\t     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n\t     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n\t     * @param boData\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._bfs = function (boData) {\r\n\t        //用于保存每个level的最大坐标值\r\n\t        this._levelMaxPos = {};\r\n\t\r\n\t        this._queue = [];   //存放BO数据\r\n\t        this._queue.push(boData);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift();\r\n\t            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //该level第一个节点\r\n\t            if (!this._levelMaxPos[tmp.layout.level]) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前就是最右侧的节点\r\n\t            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n\t            else {\r\n\t                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n\t                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\t\r\n\t            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n\t            if (tmp.child) {\r\n\t                var childCnt = tmp.child.length;\r\n\t\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t\r\n\t                    tmp.child[i].layout = {\r\n\t                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n\t                        level: tmp.layout.level + 1\r\n\t                    };\r\n\t\r\n\t                    this._queue.push(tmp.child[i]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByChild = function (boData, width) {\r\n\t        if (boData) {\r\n\t\r\n\t            if (!boData.layout.moved) {\r\n\t\r\n\t                if (boData.layout.level == 1) {\r\n\t                    boData.layout.x += width / 2;\r\n\t                } else {\r\n\t                    boData.layout.x += width;\r\n\t                }\r\n\t\r\n\t                boData.layout.moved = true;\r\n\t            }\r\n\t            //当前节点的下一节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t            //当前节点的父节点整体右移\r\n\t            this._moveRightByChild(boData.parent, width);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 前一个节点右移的时候，所有后面的节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            boData.layout.moved = true;\r\n\t            //当前节点的所有后续节点整体右移\r\n\t            this._moveRightByPrevious(boData.next, width);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 父节点右移时，所有子节点整体右移\r\n\t     * @param boData\r\n\t     * @param width\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto._moveRightByParent = function (boData, width) {\r\n\t        if (boData) {\r\n\t            boData.layout.x += width;\r\n\t            if (boData.child) {\r\n\t                for (var i = 0; i < boData.child.length; i++) {\r\n\t                    this._moveRightByParent(boData.child[i], width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 添加子BO\r\n\t     * @param {BoNode} parentBoNode\r\n\t     * @param {Object} opts\r\n\t     * @private\r\n\t     */\r\n\t    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\t\r\n\t        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n\t        this._queue.push(parentBoNode);\r\n\t\r\n\t        while (this._queue.length > 0) {\r\n\t            var tmp = this._queue.shift(),\r\n\t                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n\t            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n\t            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            //如果是该Level第一个节点，或者当低于原来的节点\r\n\t            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n\t                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n\t                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n\t            }\r\n\t\r\n\t            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\t\r\n\t            if (tmp.getData().child) {\r\n\t\r\n\t                var childBoArr = tmp.getData().child,\r\n\t                    childCnt = childBoArr.length,\r\n\t                    boNode,\r\n\t                    relationNode;\r\n\t\r\n\t                //该level所有子节点的起始Y坐标都相同\r\n\t                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n\t                for (var i = 0; i < childCnt; i++) {\r\n\t                    opts.startPos.x = childBoArr[i].layout.x;\r\n\t                    childBoArr[i].layout.y = opts.startPos.y;\r\n\t                    boNode = new BoNode(childBoArr[i], opts);\r\n\t                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\t\r\n\t                    this.group.add(boNode.getShape());\r\n\t                    this._queue.push(boNode);\r\n\t\r\n\t                    //BO关系\r\n\t                    if (childBoArr[i].relation) {\r\n\t                        var _relationLen = childBoArr[i].relation.length;\r\n\t                        for (var j = 0; j < _relationLen; j++) {\r\n\t                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n\t                                targetId = childBoArr[i].relation[j].targetId,\r\n\t                                sourceText = childBoArr[i].relation[j].sourceText,\r\n\t                                targetText = childBoArr[i].relation[j].targetText;\r\n\t\r\n\t                            relationNode = new Relation(\r\n\t                                boNode.getShape().childOfName(sourceId),\r\n\t                                tmp.getShape().childOfName(targetId),\r\n\t                                sourceText,\r\n\t                                targetText\r\n\t                            );\r\n\t                            this.group.add(relationNode.getShape());\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO为特殊样式\r\n\t     * @param {String} boId, BO标识\r\n\t     * @param {Object} style, BO特殊样式,可空\r\n\t     */\r\n\t    fishTopoProto.setCurrentBo = function (boId, style) {\r\n\t        var length = this.group.childCount();\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (this.group.childAt(i).name == boId) {\r\n\t                this.group.childAt(i).setCurrent(style);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 清空\r\n\t     */\r\n\t    fishTopoProto.clear = function () {\r\n\t        this._zr.clear();\r\n\t        this.group = new graphic.Group();\r\n\t        this._zr.add(this.group);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 缩放功能\r\n\t     * @param type\r\n\t     */\r\n\t    fishTopoProto.zrScale = function (type) {\r\n\t        var that = this;\r\n\t        if (type) {\r\n\t            if (type == \"narrowing\") {\r\n\t                var zoomDelta = 1 / 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t            if (type == \"enlarge\") {\r\n\t                var zoomDelta = 1.1;\r\n\t                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n\t            }\r\n\t        } else {\r\n\t            that._zr.on('mousewheel', function (e) {\r\n\t                eventTool.stop(e.event);\r\n\t                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n\t                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n\t            });\r\n\t        }\r\n\t        ;\r\n\t        function zoom(zoomDelta, zoomX, zoomY) {\r\n\t            if (that.canScale == false) {\r\n\t                return;\r\n\t            }\r\n\t            var target = that.group;\r\n\t            if (target) {\r\n\t                var pos = target.position;\r\n\t                var scale = target.scale;\r\n\t                var newZoom = that._zoom = that._zoom || 1;\r\n\t                newZoom *= zoomDelta;\r\n\t                var zoomScale = newZoom / that._zoom;\r\n\t                // if(newZoom>2.6||newZoom<0.38){\r\n\t                //     return;\r\n\t                // };\r\n\t                that._zoom = newZoom;\r\n\t\r\n\t                that.nowZoom = newZoom;\r\n\t                // Keep the mouse center when scaling\r\n\t                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n\t                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n\t                scale[0] *= zoomScale;\r\n\t                scale[1] *= zoomScale;\r\n\t                target.attr(\"position\", [pos[0], pos[1]]);\r\n\t                target.attr(\"scale\", [scale[0], scale[1]]);\r\n\t                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽Group\r\n\t     */\r\n\t    fishTopoProto.groupDrag = function () {\r\n\t        var that = this;\r\n\t        that._zr.on(\"mousedown\", function (e) {\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = that.group.position;\r\n\t            var groupPositionX = that.group.position[0];\r\n\t            var groupPositionY = that.group.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t\r\n\t            function moveDrag(e) {\r\n\t                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n\t                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n\t                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n\t                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n\t                var min = [10 - (width + gx), 10 - (height + gy)];\r\n\t                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n\t                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n\t                nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n\t                    return;\r\n\t                } else {\r\n\t                    that.group.attr(\"position\", nowGroupPosition);\r\n\t                }\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 拖拽\r\n\t     * @param node\r\n\t     */\r\n\t    fishTopoProto.drag = function (node) {\r\n\t        var that = this;\r\n\t        node.on(\"mousedown\", function (e) {\r\n\t            if (this.isdraggable == false) {\r\n\t                return;\r\n\t            }\r\n\t            groupDragFunction(e);\r\n\t            e.cancelBubble = true;\r\n\t        });\r\n\t        function groupDragFunction(e) {\r\n\t            var startX = e.event.clientX;\r\n\t            var startY = e.event.clientY;\r\n\t            var moveFunction = function (e) {\r\n\t                moveDrag(e);\r\n\t            }\r\n\t            var nowGroupPosition = node.position;\r\n\t            var groupPositionX = node.position[0];\r\n\t            var groupPositionY = node.position[1];\r\n\t            var alarmPositionX, alarmPositionY;\r\n\t            if (node.alarm) {\r\n\t                var newAlarmPosition = node.alarm.position;\r\n\t                alarmPositionX = node.alarm.position[0];\r\n\t                alarmPositionY = node.alarm.position[1];\r\n\t            }\r\n\t            ;\r\n\t            function moveDrag(e) {\r\n\t                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n\t                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n\t                if (node.parent && node.parent instanceof GroupNode) {\r\n\t                    //放入node现有数值，用于重绘group\r\n\t                    var nodeMessage = {\r\n\t                        width: node.shape.width,\r\n\t                        height: node.shape.height,\r\n\t                        position: node.position,\r\n\t                        nodeXY: [node.shape.x, node.shape.y],\r\n\t                        movePosition: [groupPositionX, groupPositionY],\r\n\t                        moveX: sX,\r\n\t                        moveY: sY\r\n\t                    };\r\n\t                    var groupNode = node.parent;\r\n\t                    groupNode.reDraw(nodeMessage, node);\r\n\t                } else {\r\n\t                    nowGroupPosition[0] = groupPositionX + (sX);\r\n\t                    nowGroupPosition[1] = groupPositionY + (sY);\r\n\t                    node.attr(\"position\", nowGroupPosition);\r\n\t                    if (node.alarm) {\r\n\t                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n\t                        node.alarm.attr(\"position\", newAlarmPosition);\r\n\t                    }\r\n\t                    ;\r\n\t                }\r\n\t                ConnectionManager.refreshLineByNode(node);\r\n\t            }\r\n\t\r\n\t            that._zr.on('mousemove', moveFunction);\r\n\t            var upFunction = function (e) {\r\n\t                endDrag(e);\r\n\t            }\r\n\t            //拖拽结束\r\n\t            function endDrag(e) {\r\n\t                that._zr.off('mousemove', moveFunction);\r\n\t                that._zr.off('mouseup', upFunction);\r\n\t                that._zr.off(\"globalout\", upFunction);\r\n\t                //布局重新计算\r\n\t                if (node.layout) {\r\n\t                    that.layoutNode(\"tree\", {\"node\": node});\r\n\t                }\r\n\t                if (that.forceLayoutOption) {\r\n\t                    var nodes = that.forceLayoutOption.allNodes;\r\n\t                    if (_.indexOf(nodes, node) != -1) {\r\n\t                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n\t                    }\r\n\t                }\r\n\t                ;\r\n\t            }\r\n\t\r\n\t            that._zr.on('mouseup', upFunction);\r\n\t            that._zr.on(\"globalout\", upFunction);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    // ---------对外暴露fishTopoBo------------------\r\n\t    var idBase = new Date() - 0;\r\n\t    var instances = {};\r\n\t    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n\t    var fishTopoBo = {\r\n\t        /**\r\n\t         * @type {number}\r\n\t         */\r\n\t        version: '1.0.0',\r\n\t        dependencies: {\r\n\t            zrender: '3.0.4'\r\n\t        }\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {HTMLDomElement} dom\r\n\t     * @param {Object} opts\r\n\t     */\r\n\t    fishTopoBo.init = function (dom, opts) {\r\n\t        if (!dom) {\r\n\t            throw new Error('Initialize failed: invalid dom.');\r\n\t        }\r\n\t\r\n\t        opts = opts || {};\r\n\t        // Default value\r\n\t        util.defaults(opts,\r\n\t            {\r\n\t                type: \"bpmn\",\r\n\t                showGridLine: true,\r\n\t                devicePixelRatio: 1,\r\n\t                gridLineSpacing:10\r\n\t            }\r\n\t        );\r\n\t\r\n\t        var fishTopoBo = new FishTopoBo(dom, opts);\r\n\t        fishTopoBo.init();\r\n\t\r\n\t        fishTopoBo.id = 'ft_' + idBase++;\r\n\t        instances[fishTopoBo.id] = fishTopoBo;\r\n\t\r\n\t        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\t\r\n\t        return fishTopoBo;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * @param  {HTMLDomElement} dom\r\n\t     * @return {fishTopo}\r\n\t     */\r\n\t    fishTopoBo.getInstanceByDom = function (dom) {\r\n\t        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n\t        return instances[key];\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Dispose a fishTopo instance\r\n\t     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n\t     */\r\n\t    fishTopoBo.dispose = function (chart) {\r\n\t        var topo;\r\n\t        if (zrUtil.isDom(chart)) {\r\n\t            topo = fishTopoBo.getInstanceByDom(chart);\r\n\t        }\r\n\t        else if (typeof chart === 'string') {\r\n\t            topo = instances[chart];\r\n\t        }\r\n\t        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n\t            topo.dispose();\r\n\t        }\r\n\t    };\r\n\t\r\n\t    module.exports = fishTopoBo;\r\n\t\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * ZRender, a high performance 2d drawing library.\n\t *\n\t * Copyright (c) 2013, Baidu Inc.\n\t * All rights reserved.\n\t *\n\t * LICENSE\n\t * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n\t */\n\t// Global defines\n\t\n\t    var guid = __webpack_require__(4);\n\t    var env = __webpack_require__(5);\n\t\n\t    var Handler = __webpack_require__(6);\n\t    var Storage = __webpack_require__(13);\n\t    var Animation = __webpack_require__(27);\n\t\n\t    var useVML = !env.canvasSupported;\n\t\n\t    var painterCtors = {\n\t        canvas: __webpack_require__(28)\n\t    };\n\t\n\t    var instances = {};    // ZRender实例map索引\n\t\n\t    var zrender = {};\n\t    /**\n\t     * @type {string}\n\t     */\n\t    zrender.version = '3.0.4';\n\t\n\t    /**\n\t     * @param {HTMLElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.init = function(dom, opts) {\n\t        var zr = new ZRender(guid(), dom, opts);\n\t        instances[zr.id] = zr;\n\t        return zr;\n\t    };\n\t\n\t    /**\n\t     * Dispose zrender instance\n\t     * @param {module:zrender/ZRender} zr\n\t     */\n\t    zrender.dispose = function (zr) {\n\t        if (zr) {\n\t            zr.dispose();\n\t        }\n\t        else {\n\t            for (var key in instances) {\n\t                instances[key].dispose();\n\t            }\n\t            instances = {};\n\t        }\n\t\n\t        return zrender;\n\t    };\n\t\n\t    /**\n\t     * 获取zrender实例\n\t     * @param {string} id ZRender对象索引\n\t     * @return {module:zrender/ZRender}\n\t     */\n\t    zrender.getInstance = function (id) {\n\t        return instances[id];\n\t    };\n\t\n\t    zrender.registerPainter = function (name, Ctor) {\n\t        painterCtors[name] = Ctor;\n\t    };\n\t\n\t    function delInstance(id) {\n\t        delete instances[id];\n\t    }\n\t\n\t    /**\n\t     * @module zrender/ZRender\n\t     */\n\t    /**\n\t     * @constructor\n\t     * @alias module:zrender/ZRender\n\t     * @param {string} id\n\t     * @param {HTMLDomElement} dom\n\t     * @param {Object} opts\n\t     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n\t     * @param {number} [opts.devicePixelRatio]\n\t     */\n\t    var ZRender = function(id, dom, opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {HTMLDomElement}\n\t         */\n\t        this.dom = dom;\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.id = id;\n\t\n\t        var self = this;\n\t        var storage = new Storage();\n\t\n\t        var rendererType = opts.renderer;\n\t        if (useVML) {\n\t            if (!painterCtors.vml) {\n\t                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n\t            }\n\t            rendererType = 'vml';\n\t        }\n\t        else if (!rendererType || !painterCtors[rendererType]) {\n\t            rendererType = 'canvas';\n\t        }\n\t        var painter = new painterCtors[rendererType](dom, storage, opts);\n\t\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t        if (!env.node) {\n\t            this.handler = new Handler(painter.getViewportRoot(), storage, painter);\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/animation/Animation}\n\t         */\n\t        this.animation = new Animation({\n\t            stage: {\n\t                update: function () {\n\t                    if (self._needsRefresh) {\n\t                        self.refreshImmediately();\n\t                    }\n\t                }\n\t            }\n\t        });\n\t        this.animation.start();\n\t\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._needsRefresh;\n\t\n\t        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n\t        // FIXME 有点ugly\n\t        var oldDelFromMap = storage.delFromMap;\n\t        var oldAddToMap = storage.addToMap;\n\t\n\t        storage.delFromMap = function (elId) {\n\t            var el = storage.get(elId);\n\t\n\t            oldDelFromMap.call(storage, elId);\n\t\n\t            el && el.removeSelfFromZr(self);\n\t        };\n\t\n\t        storage.addToMap = function (el) {\n\t            oldAddToMap.call(storage, el);\n\t\n\t            el.addSelfToZr(self);\n\t        };\n\t    };\n\t\n\t    ZRender.prototype = {\n\t\n\t        constructor: ZRender,\n\t        /**\n\t         * 获取实例唯一标识\n\t         * @return {string}\n\t         */\n\t        getId: function () {\n\t            return this.id;\n\t        },\n\t\n\t        /**\n\t         * 添加元素\n\t         * @param  {string|module:zrender/Element} el\n\t         */\n\t        add: function (el) {\n\t            this.storage.addRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 删除元素\n\t         * @param  {string|module:zrender/Element} el\n\t         */\n\t        remove: function (el) {\n\t            this.storage.delRoot(el);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制配置项\n\t         *\n\t         * @param {string} zLevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t        */\n\t        configLayer: function (zLevel, config) {\n\t            this.painter.configLayer(zLevel, config);\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 视图更新\n\t         */\n\t        refreshImmediately: function () {\n\t            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n\t            // Or it will cause zrender refreshes again and again.\n\t            this._needsRefresh = false;\n\t            this.painter.refresh();\n\t            /**\n\t             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n\t             */\n\t            this._needsRefresh = false;\n\t        },\n\t\n\t        /**\n\t         * 标记视图在浏览器下一帧需要绘制\n\t         */\n\t        refresh: function() {\n\t            this._needsRefresh = true;\n\t        },\n\t\n\t        /**\n\t         * 调整视图大小\n\t         */\n\t        resize: function() {\n\t            this.painter.resize();\n\t            this.handler && this.handler.resize();\n\t        },\n\t\n\t        /**\n\t         * 停止所有动画\n\t         */\n\t        clearAnimation: function () {\n\t            this.animation.clear();\n\t        },\n\t\n\t        /**\n\t         * 获取视图宽度\n\t         */\n\t        getWidth: function() {\n\t            return this.painter.getWidth();\n\t        },\n\t\n\t        /**\n\t         * 获取视图高度\n\t         */\n\t        getHeight: function() {\n\t            return this.painter.getHeight();\n\t        },\n\t\n\t        /**\n\t         * 图像导出\n\t         * @param {string} type\n\t         * @param {string} [backgroundColor='#fff'] 背景色\n\t         * @return {string} 图片的Base64 url\n\t         */\n\t        toDataURL: function(type, backgroundColor, args) {\n\t            return this.painter.toDataURL(type, backgroundColor, args);\n\t        },\n\t\n\t        /**\n\t         * 将常规shape转成image shape\n\t         * @param {module:zrender/graphic/Path} e\n\t         * @param {number} width\n\t         * @param {number} height\n\t         */\n\t        pathToImage: function(e, width, height) {\n\t            var id = guid();\n\t            return this.painter.pathToImage(id, e, width, height);\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} cursorStyle 例如 crosshair\n\t         */\n\t        setDefaultCursorStyle: function (cursorStyle) {\n\t            this.handler.setDefaultCursorStyle(cursorStyle);\n\t        },\n\t\n\t        /**\n\t         * 事件绑定\n\t         *\n\t         * @param {string} eventName 事件名称\n\t         * @param {Function} eventHandler 响应函数\n\t         * @param {Object} [context] 响应函数\n\t         */\n\t        on: function(eventName, eventHandler, context) {\n\t            this.handler && this.handler.on(eventName, eventHandler, context);\n\t        },\n\t\n\t        /**\n\t         * 事件解绑定，参数为空则解绑所有自定义事件\n\t         *\n\t         * @param {string} eventName 事件名称\n\t         * @param {Function} eventHandler 响应函数\n\t         */\n\t        off: function(eventName, eventHandler) {\n\t            this.handler && this.handler.off(eventName, eventHandler);\n\t        },\n\t\n\t        /**\n\t         * 事件触发\n\t         *\n\t         * @param {string} eventName 事件名称，resize，hover，drag，etc\n\t         * @param {event=} event event dom事件对象\n\t         */\n\t        trigger: function (eventName, event) {\n\t            this.handler && this.handler.trigger(eventName, event);\n\t        },\n\t\n\t\n\t        /**\n\t         * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用\n\t         */\n\t        clear: function () {\n\t            this.storage.delRoot();\n\t            this.painter.clear();\n\t        },\n\t\n\t        /**\n\t         * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用\n\t         */\n\t        dispose: function () {\n\t            this.animation.stop();\n\t\n\t            this.clear();\n\t            this.storage.dispose();\n\t            this.painter.dispose();\n\t            this.handler && this.handler.dispose();\n\t\n\t            this.animation =\n\t            this.storage =\n\t            this.painter =\n\t            this.handler = null;\n\t\n\t            delInstance(this.id);\n\t        }\n\t    };\n\t\n\t    module.exports = zrender;\n\t\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * zrender: 生成唯一id\n\t *\n\t * @author errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t        var idStart = 0x0907;\n\t\n\t        module.exports = function () {\n\t            return 'zr_' + (idStart++);\n\t        };\n\t    \n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * echarts设备环境识别\n\t *\n\t * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n\t * @author firede[firede@firede.us]\n\t * @desc thanks zepto.\n\t */\n\t\n\t    var env = {};\n\t    if (typeof navigator === 'undefined') {\n\t        // In node\n\t        env = {\n\t            browser: {},\n\t            os: {},\n\t            node: true,\n\t            // Assume canvas is supported\n\t            canvasSupported: true\n\t        };\n\t    }\n\t    else {\n\t        env = detect(navigator.userAgent);\n\t    }\n\t\n\t    module.exports = env;\n\t\n\t    // Zepto.js\n\t    // (c) 2010-2013 Thomas Fuchs\n\t    // Zepto.js may be freely distributed under the MIT license.\n\t\n\t    function detect(ua) {\n\t        var os = {};\n\t        var browser = {};\n\t        var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n\t        var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n\t        var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n\t        var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n\t        var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n\t        var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n\t        var touchpad = webos && ua.match(/TouchPad/);\n\t        var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n\t        var silk = ua.match(/Silk\\/([\\d._]+)/);\n\t        var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n\t        var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n\t        var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n\t        var playbook = ua.match(/PlayBook/);\n\t        var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\t        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n\t        var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n\t        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\t        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n\t            // IE 11 Trident/7.0; rv:11.0\n\t            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n\t        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\t\n\t        // Todo: clean this up with a better OS/browser seperation:\n\t        // - discern (more) between multiple browsers on android\n\t        // - decide if kindle fire in silk mode is android or not\n\t        // - Firefox on Android doesn't specify the Android version\n\t        // - possibly devide in os, device and browser hashes\n\t\n\t        if (browser.webkit = !!webkit) browser.version = webkit[1];\n\t\n\t        if (android) os.android = true, os.version = android[2];\n\t        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n\t        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n\t        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n\t        if (webos) os.webos = true, os.version = webos[2];\n\t        if (touchpad) os.touchpad = true;\n\t        if (blackberry) os.blackberry = true, os.version = blackberry[2];\n\t        if (bb10) os.bb10 = true, os.version = bb10[2];\n\t        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n\t        if (playbook) browser.playbook = true;\n\t        if (kindle) os.kindle = true, os.version = kindle[1];\n\t        if (silk) browser.silk = true, browser.version = silk[1];\n\t        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n\t        if (chrome) browser.chrome = true, browser.version = chrome[1];\n\t        if (firefox) browser.firefox = true, browser.version = firefox[1];\n\t        if (ie) browser.ie = true, browser.version = ie[1];\n\t        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n\t        if (webview) browser.webview = true;\n\t        if (ie) browser.ie = true, browser.version = ie[1];\n\t        if (edge) browser.edge = true, browser.version = edge[1];\n\t\n\t        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n\t            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n\t        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||\n\t            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n\t            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\t\n\t        return {\n\t            browser: browser,\n\t            os: os,\n\t            node: false,\n\t            // 原生canvas支持，改极端点了\n\t            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n\t            canvasSupported : document.createElement('canvas').getContext ? true : false,\n\t            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n\t            // works on most browsers\n\t            // IE10/11 does not support touch event, and MS Edge supports them but not by\n\t            // default, so we dont check navigator.maxTouchPoints for them here.\n\t            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n\t            // <http://caniuse.com/#search=pointer%20event>.\n\t            pointerEventsSupported: 'onpointerdown' in window\n\t                // Firefox supports pointer but not by default,\n\t                // only MS browsers are reliable on pointer events currently.\n\t                && (browser.edge || (browser.ie && browser.version >= 10))\n\t        };\n\t    }\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Handler控制模块\n\t * @module zrender/Handler\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (shenyi.914@gmail.com)\n\t */\n\t\n\t\n\t    var env = __webpack_require__(5);\n\t    var eventTool = __webpack_require__(7);\n\t    var util = __webpack_require__(9);\n\t    var Draggable = __webpack_require__(11);\n\t    var GestureMgr = __webpack_require__(12);\n\t\n\t    var Eventful = __webpack_require__(8);\n\t\n\t    var mouseHandlerNames = [\n\t        'click', 'dblclick', 'mousewheel', 'mouseout'\n\t    ];\n\t    !usePointerEvent() && mouseHandlerNames.push(\n\t        'mouseup', 'mousedown', 'mousemove'\n\t    );\n\t\n\t    var touchHandlerNames = [\n\t        'touchstart', 'touchend', 'touchmove'\n\t    ];\n\t\n\t    var pointerHandlerNames = [\n\t        'pointerdown', 'pointerup', 'pointermove'\n\t    ];\n\t\n\t    var TOUCH_CLICK_DELAY = 300;\n\t\n\t    // touch指尖错觉的尝试偏移量配置\n\t    // var MOBILE_TOUCH_OFFSETS = [\n\t    //     { x: 10 },\n\t    //     { x: -20 },\n\t    //     { x: 10, y: 10 },\n\t    //     { y: -20 }\n\t    // ];\n\t\n\t    var addEventListener = eventTool.addEventListener;\n\t    var removeEventListener = eventTool.removeEventListener;\n\t    var normalizeEvent = eventTool.normalizeEvent;\n\t\n\t    function makeEventPacket(eveType, target, event) {\n\t        return {\n\t            type: eveType,\n\t            event: event,\n\t            target: target,\n\t            cancelBubble: false,\n\t            offsetX: event.zrX,\n\t            offsetY: event.zrY,\n\t            gestureEvent: event.gestureEvent,\n\t            pinchX: event.pinchX,\n\t            pinchY: event.pinchY,\n\t            pinchScale: event.pinchScale,\n\t            wheelDelta: event.zrDelta\n\t        };\n\t    }\n\t\n\t    var domHandlers = {\n\t        /**\n\t         * Mouse move handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mousemove: function (event) {\n\t            event = normalizeEvent(this.root, event);\n\t\n\t            var x = event.zrX;\n\t            var y = event.zrY;\n\t\n\t            var hovered = this.findHover(x, y, null);\n\t            var lastHovered = this._hovered;\n\t\n\t            this._hovered = hovered;\n\t\n\t            this.root.style.cursor = hovered ? hovered.cursor : this._defaultCursorStyle;\n\t            // Mouse out on previous hovered element\n\t            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n\t                this._dispatchProxy(lastHovered, 'mouseout', event);\n\t            }\n\t\n\t            // Mouse moving on one element\n\t            this._dispatchProxy(hovered, 'mousemove', event);\n\t\n\t            // Mouse over on a new element\n\t            if (hovered && hovered !== lastHovered) {\n\t                this._dispatchProxy(hovered, 'mouseover', event);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Mouse out handler\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        mouseout: function (event) {\n\t            event = normalizeEvent(this.root, event);\n\t\n\t            var element = event.toElement || event.relatedTarget;\n\t            if (element != this.root) {\n\t                while (element && element.nodeType != 9) {\n\t                    // 忽略包含在root中的dom引起的mouseOut\n\t                    if (element === this.root) {\n\t                        return;\n\t                    }\n\t\n\t                    element = element.parentNode;\n\t                }\n\t            }\n\t\n\t            this._dispatchProxy(this._hovered, 'mouseout', event);\n\t\n\t            this.trigger('globalout', {\n\t                event: event\n\t            });\n\t        },\n\t\n\t        /**\n\t         * Touch开始响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchstart: function (event) {\n\t            // FIXME\n\t            // 移动端可能需要default行为，例如静态图表时。\n\t            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n\t            event = normalizeEvent(this.root, event);\n\t\n\t            this._lastTouchMoment = new Date();\n\t\n\t            processGesture(this, event, 'start');\n\t\n\t            // 平板补充一次findHover\n\t            // this._mobileFindFixed(event);\n\t            // Trigger mousemove and mousedown\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            domHandlers.mousedown.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch移动响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchmove: function (event) {\n\t            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n\t            event = normalizeEvent(this.root, event);\n\t\n\t            processGesture(this, event, 'change');\n\t\n\t            // Mouse move should always be triggered no matter whether\n\t            // there is gestrue event, because mouse move and pinch may\n\t            // be used at the same time.\n\t            domHandlers.mousemove.call(this, event);\n\t\n\t            setTouchTimer(this);\n\t        },\n\t\n\t        /**\n\t         * Touch结束响应函数\n\t         * @inner\n\t         * @param {Event} event\n\t         */\n\t        touchend: function (event) {\n\t            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n\t            event = normalizeEvent(this.root, event);\n\t\n\t            processGesture(this, event, 'end');\n\t\n\t            domHandlers.mouseup.call(this, event);\n\t\n\t            // click event should always be triggered no matter whether\n\t            // there is gestrue event. System click can not be prevented.\n\t            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n\t                // this._mobileFindFixed(event);\n\t                domHandlers.click.call(this, event);\n\t            }\n\t\n\t            setTouchTimer(this);\n\t        }\n\t    };\n\t\n\t    // Common handlers\n\t    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n\t        domHandlers[name] = function (event) {\n\t            event = normalizeEvent(this.root, event);\n\t            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n\t            var hovered = this.findHover(event.zrX, event.zrY, null);\n\t            this._dispatchProxy(hovered, name, event);\n\t        };\n\t    });\n\t\n\t    // Pointer event handlers\n\t    // util.each(['pointerdown', 'pointermove', 'pointerup'], function (name) {\n\t    //     domHandlers[name] = function (event) {\n\t    //         var mouseName = name.replace('pointer', 'mouse');\n\t    //         domHandlers[mouseName].call(this, event);\n\t    //     };\n\t    // });\n\t\n\t    function processGesture(zrHandler, event, stage) {\n\t        var gestureMgr = zrHandler._gestureMgr;\n\t\n\t        stage === 'start' && gestureMgr.clear();\n\t\n\t        var gestureInfo = gestureMgr.recognize(\n\t            event,\n\t            zrHandler.findHover(event.zrX, event.zrY, null)\n\t        );\n\t\n\t        stage === 'end' && gestureMgr.clear();\n\t\n\t        if (gestureInfo) {\n\t            // eventTool.stop(event);\n\t            var type = gestureInfo.type;\n\t            event.gestureEvent = type;\n\t\n\t            zrHandler._dispatchProxy(gestureInfo.target, type, gestureInfo.event);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 为控制类实例初始化dom 事件处理函数\n\t     *\n\t     * @inner\n\t     * @param {module:zrender/Handler} instance 控制类实例\n\t     */\n\t    function initDomHandler(instance) {\n\t        var handlerNames = touchHandlerNames.concat(pointerHandlerNames);\n\t        for (var i = 0; i < handlerNames.length; i++) {\n\t            var name = handlerNames[i];\n\t            instance._handlers[name] = util.bind(domHandlers[name], instance);\n\t        }\n\t\n\t        for (var i = 0; i < mouseHandlerNames.length; i++) {\n\t            var name = mouseHandlerNames[i];\n\t            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n\t        }\n\t\n\t        function makeMouseHandler(fn, instance) {\n\t            return function () {\n\t                if (instance._touching) {\n\t                    return;\n\t                }\n\t                return fn.apply(instance, arguments);\n\t            };\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Handler\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Eventful\n\t     * @param {HTMLElement} root Main HTML element for painting.\n\t     * @param {module:zrender/Storage} storage Storage instance.\n\t     * @param {module:zrender/Painter} painter Painter instance.\n\t     */\n\t    var Handler = function(root, storage, painter) {\n\t        Eventful.call(this);\n\t\n\t        this.root = root;\n\t        this.storage = storage;\n\t        this.painter = painter;\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._hovered;\n\t\n\t        /**\n\t         * @private\n\t         * @type {Date}\n\t         */\n\t        this._lastTouchMoment;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastX;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._lastY;\n\t\n\t        /**\n\t         * @private\n\t         * @type {string}\n\t         */\n\t        this._defaultCursorStyle = 'default';\n\t\n\t        /**\n\t         * @private\n\t         * @type {module:zrender/core/GestureMgr}\n\t         */\n\t        this._gestureMgr = new GestureMgr();\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Function>}\n\t         */\n\t        this._handlers = [];\n\t\n\t        /**\n\t         * @private\n\t         * @type {boolean}\n\t         */\n\t        this._touching = false;\n\t\n\t        /**\n\t         * @private\n\t         * @type {number}\n\t         */\n\t        this._touchTimer;\n\t\n\t        initDomHandler(this);\n\t\n\t        if (usePointerEvent()) {\n\t            mountHandlers(pointerHandlerNames, this);\n\t        }\n\t        else if (useTouchEvent()) {\n\t            mountHandlers(touchHandlerNames, this);\n\t\n\t            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n\t            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n\t        }\n\t\n\t        // Considering some devices that both enable touch and mouse event (like MS Surface\n\t        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n\t        // mouse event can not be handle in those devices.\n\t        mountHandlers(mouseHandlerNames, this);\n\t\n\t        Draggable.call(this);\n\t\n\t        function mountHandlers(handlerNames, instance) {\n\t            util.each(handlerNames, function (name) {\n\t                addEventListener(root, eventNameFix(name), instance._handlers[name]);\n\t            }, instance);\n\t        }\n\t    };\n\t\n\t    Handler.prototype = {\n\t\n\t        constructor: Handler,\n\t\n\t        /**\n\t         * Resize\n\t         */\n\t        resize: function (event) {\n\t            this._hovered = null;\n\t        },\n\t\n\t        /**\n\t         * Dispatch event\n\t         * @param {string} eventName\n\t         * @param {event=} eventArgs\n\t         */\n\t        dispatch: function (eventName, eventArgs) {\n\t            var handler = this._handlers[eventName];\n\t            handler && handler.call(this, eventArgs);\n\t        },\n\t\n\t        /**\n\t         * Dispose\n\t         */\n\t        dispose: function () {\n\t            var root = this.root;\n\t\n\t            var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\t\n\t            for (var i = 0; i < handlerNames.length; i++) {\n\t                var name = handlerNames[i];\n\t                removeEventListener(root, eventNameFix(name), this._handlers[name]);\n\t            }\n\t\n\t            this.root =\n\t            this.storage =\n\t            this.painter = null;\n\t        },\n\t\n\t        /**\n\t         * 设置默认的cursor style\n\t         * @param {string} cursorStyle 例如 crosshair\n\t         */\n\t        setDefaultCursorStyle: function (cursorStyle) {\n\t            this._defaultCursorStyle = cursorStyle;\n\t        },\n\t\n\t        /**\n\t         * 事件分发代理\n\t         *\n\t         * @private\n\t         * @param {Object} targetEl 目标图形元素\n\t         * @param {string} eventName 事件名称\n\t         * @param {Object} event 事件对象\n\t         */\n\t        _dispatchProxy: function (targetEl, eventName, event) {\n\t            var eventHandler = 'on' + eventName;\n\t            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\t\n\t            var el = targetEl;\n\t\n\t            while (el) {\n\t                el[eventHandler]\n\t                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\t\n\t                el.trigger(eventName, eventPacket);\n\t\n\t                el = el.parent;\n\t\n\t                if (eventPacket.cancelBubble) {\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (!eventPacket.cancelBubble) {\n\t                // 冒泡到顶级 zrender 对象\n\t                this.trigger(eventName, eventPacket);\n\t                // 分发事件到用户自定义层\n\t                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\t                this.painter && this.painter.eachOtherLayer(function (layer) {\n\t                    if (typeof(layer[eventHandler]) == 'function') {\n\t                        layer[eventHandler].call(layer, eventPacket);\n\t                    }\n\t                    if (layer.trigger) {\n\t                        layer.trigger(eventName, eventPacket);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {module:zrender/graphic/Displayable} exclude\n\t         * @method\n\t         */\n\t        findHover: function(x, y, exclude) {\n\t            var list = this.storage.getDisplayList();\n\t            for (var i = list.length - 1; i >= 0 ; i--) {\n\t                if (!list[i].silent\n\t                 && list[i] !== exclude\n\t                 // getDisplayList may include ignored item in VML mode\n\t                 && !list[i].ignore\n\t                 && isHover(list[i], x, y)) {\n\t                    return list[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function isHover(displayable, x, y) {\n\t        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n\t            var p = displayable.parent;\n\t            while (p) {\n\t                if (p.clipPath && !p.clipPath.contain(x, y))  {\n\t                    // Clipped by parents\n\t                    return false;\n\t                }\n\t                p = p.parent;\n\t            }\n\t            return true;\n\t        }\n\t\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * Prevent mouse event from being dispatched after Touch Events action\n\t     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n\t     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n\t     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n\t     * Result: Blocking Mouse Events for 700ms.\n\t     */\n\t    function setTouchTimer(instance) {\n\t        instance._touching = true;\n\t        clearTimeout(instance._touchTimer);\n\t        instance._touchTimer = setTimeout(function () {\n\t            instance._touching = false;\n\t        }, 700);\n\t    }\n\t\n\t    /**\n\t     * Althought MS Surface support screen touch, IE10/11 do not support\n\t     * touch event and MS Edge supported them but not by default (but chrome\n\t     * and firefox do). Thus we use Pointer event on MS browsers to handle touch.\n\t     */\n\t    function usePointerEvent() {\n\t        // TODO\n\t        // pointermove event dont trigger when using finger.\n\t        // We may figger it out latter.\n\t        return false;\n\t        // return env.pointerEventsSupported\n\t            // In no-touch device we dont use pointer evnets but just\n\t            // use mouse event for avoiding problems.\n\t            // && window.navigator.maxTouchPoints;\n\t    }\n\t\n\t    function useTouchEvent() {\n\t        return env.touchEventsSupported;\n\t    }\n\t\n\t    function eventNameFix(name) {\n\t        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n\t    }\n\t\n\t    util.mixin(Handler, Eventful);\n\t    util.mixin(Handler, Draggable);\n\t\n\t    module.exports = Handler;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 事件辅助类\n\t * @module zrender/core/event\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t */\n\t\n\t\n\t    var Eventful = __webpack_require__(8);\n\t\n\t    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\t\n\t    function getBoundingClientRect(el) {\n\t        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n\t        return el.getBoundingClientRect ? el.getBoundingClientRect() : { left: 0, top: 0};\n\t    }\n\t    /**\n\t     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n\t     */\n\t    function normalizeEvent(el, e) {\n\t\n\t        e = e || window.event;\n\t\n\t        if (e.zrX != null) {\n\t            return e;\n\t        }\n\t\n\t        var eventType = e.type;\n\t        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\t\n\t        if (!isTouch) {\n\t            var box = getBoundingClientRect(el);\n\t            e.zrX = e.clientX - box.left;\n\t            e.zrY = e.clientY - box.top;\n\t            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n\t        }\n\t        else {\n\t            var touch = eventType != 'touchend'\n\t                            ? e.targetTouches[0]\n\t                            : e.changedTouches[0];\n\t            if (touch) {\n\t                var rBounding = getBoundingClientRect(el);\n\t                // touch事件坐标是全屏的~\n\t                e.zrX = touch.clientX - rBounding.left;\n\t                e.zrY = touch.clientY - rBounding.top;\n\t            }\n\t        }\n\t\n\t        return e;\n\t    }\n\t\n\t    function addEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.addEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.attachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    function removeEventListener(el, name, handler) {\n\t        if (isDomLevel2) {\n\t            el.removeEventListener(name, handler);\n\t        }\n\t        else {\n\t            el.detachEvent('on' + name, handler);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 停止冒泡和阻止默认行为\n\t     * @memberOf module:zrender/core/event\n\t     * @method\n\t     * @param {Event} e : event对象\n\t     */\n\t    var stop = isDomLevel2\n\t        ? function (e) {\n\t            e.preventDefault();\n\t            e.stopPropagation();\n\t            e.cancelBubble = true;\n\t        }\n\t        : function (e) {\n\t            e.returnValue = false;\n\t            e.cancelBubble = true;\n\t        };\n\t\n\t    module.exports = {\n\t        normalizeEvent: normalizeEvent,\n\t        addEventListener: addEventListener,\n\t        removeEventListener: removeEventListener,\n\t\n\t        stop: stop,\n\t        // 做向上兼容\n\t        Dispatcher: Eventful\n\t    };\n\t\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 事件扩展\n\t * @module zrender/mixin/Eventful\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var arrySlice = Array.prototype.slice;\n\t    var zrUtil = __webpack_require__(9);\n\t    var indexOf = zrUtil.indexOf;\n\t\n\t    /**\n\t     * 事件分发器\n\t     * @alias module:zrender/mixin/Eventful\n\t     * @constructor\n\t     */\n\t    var Eventful = function () {\n\t        this._$handlers = {};\n\t    };\n\t\n\t    Eventful.prototype = {\n\t\n\t        constructor: Eventful,\n\t\n\t        /**\n\t         * 单次触发绑定，trigger后销毁\n\t         *\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 响应函数\n\t         * @param {Object} context\n\t         */\n\t        one: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            if (indexOf(_h[event], event) >= 0) {\n\t                return this;\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: true,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 绑定事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} handler 事件处理函数\n\t         * @param {Object} [context]\n\t         */\n\t        on: function (event, handler, context) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!handler || !event) {\n\t                return this;\n\t            }\n\t\n\t            if (!_h[event]) {\n\t                _h[event] = [];\n\t            }\n\t\n\t            _h[event].push({\n\t                h: handler,\n\t                one: false,\n\t                ctx: context || this\n\t            });\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 是否绑定了事件\n\t         * @param  {string}  event\n\t         * @return {boolean}\n\t         */\n\t        isSilent: function (event) {\n\t            var _h = this._$handlers;\n\t            return _h[event] && _h[event].length;\n\t        },\n\t\n\t        /**\n\t         * 解绑事件\n\t         * @param {string} event 事件名\n\t         * @param {Function} [handler] 事件处理函数\n\t         */\n\t        off: function (event, handler) {\n\t            var _h = this._$handlers;\n\t\n\t            if (!event) {\n\t                this._$handlers = {};\n\t                return this;\n\t            }\n\t\n\t            if (handler) {\n\t                if (_h[event]) {\n\t                    var newList = [];\n\t                    for (var i = 0, l = _h[event].length; i < l; i++) {\n\t                        if (_h[event][i]['h'] != handler) {\n\t                            newList.push(_h[event][i]);\n\t                        }\n\t                    }\n\t                    _h[event] = newList;\n\t                }\n\t\n\t                if (_h[event] && _h[event].length === 0) {\n\t                    delete _h[event];\n\t                }\n\t            }\n\t            else {\n\t                delete _h[event];\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 事件分发\n\t         *\n\t         * @param {string} type 事件类型\n\t         */\n\t        trigger: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 3) {\n\t                    args = arrySlice.call(args, 1);\n\t                }\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(_h[i]['ctx']);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(_h[i]['ctx'], args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 带有context的事件分发, 最后一个参数是事件回调的context\n\t         * @param {string} type 事件类型\n\t         */\n\t        triggerWithContext: function (type) {\n\t            if (this._$handlers[type]) {\n\t                var args = arguments;\n\t                var argLen = args.length;\n\t\n\t                if (argLen > 4) {\n\t                    args = arrySlice.call(args, 1, args.length - 1);\n\t                }\n\t                var ctx = args[args.length - 1];\n\t\n\t                var _h = this._$handlers[type];\n\t                var len = _h.length;\n\t                for (var i = 0; i < len;) {\n\t                    // Optimize advise from backbone\n\t                    switch (argLen) {\n\t                        case 1:\n\t                            _h[i]['h'].call(ctx);\n\t                            break;\n\t                        case 2:\n\t                            _h[i]['h'].call(ctx, args[1]);\n\t                            break;\n\t                        case 3:\n\t                            _h[i]['h'].call(ctx, args[1], args[2]);\n\t                            break;\n\t                        default:\n\t                            // have more than 2 given arguments\n\t                            _h[i]['h'].apply(ctx, args);\n\t                            break;\n\t                    }\n\t\n\t                    if (_h[i]['one']) {\n\t                        _h.splice(i, 1);\n\t                        len--;\n\t                    }\n\t                    else {\n\t                        i++;\n\t                    }\n\t                }\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    // 对象可以通过 onxxxx 绑定事件\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onclick\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseout\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousemove\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousewheel\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmousedown\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#onmouseup\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragstart\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragend\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragenter\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragleave\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondragover\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t    /**\n\t     * @event module:zrender/mixin/Eventful#ondrop\n\t     * @type {Function}\n\t     * @default null\n\t     */\n\t\n\t    module.exports = Eventful;\n\t\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t */\n\t\n\t    var Gradient = __webpack_require__(10);\n\t    // 用于处理merge时无法遍历Date等对象的问题\n\t    var BUILTIN_OBJECT = {\n\t        '[object Function]': 1,\n\t        '[object RegExp]': 1,\n\t        '[object Date]': 1,\n\t        '[object Error]': 1,\n\t        '[object CanvasGradient]': 1\n\t    };\n\t\n\t    var objToString = Object.prototype.toString;\n\t\n\t    var arrayProto = Array.prototype;\n\t    var nativeForEach = arrayProto.forEach;\n\t    var nativeFilter = arrayProto.filter;\n\t    var nativeSlice = arrayProto.slice;\n\t    var nativeMap = arrayProto.map;\n\t    var nativeReduce = arrayProto.reduce;\n\t\n\t    /**\n\t     * @param {*} source\n\t     * @return {*} 拷贝后的新对象\n\t     */\n\t    function clone(source) {\n\t        if (typeof source == 'object' && source !== null) {\n\t            var result = source;\n\t            if (source instanceof Array) {\n\t                result = [];\n\t                for (var i = 0, len = source.length; i < len; i++) {\n\t                    result[i] = clone(source[i]);\n\t                }\n\t            }\n\t            else if (\n\t                !isBuildInObject(source)\n\t                // 是否为 dom 对象\n\t                && !isDom(source)\n\t            ) {\n\t                result = {};\n\t                for (var key in source) {\n\t                    if (source.hasOwnProperty(key)) {\n\t                        result[key] = clone(source[key]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            return result;\n\t        }\n\t\n\t        return source;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolean} [overwrite=false]\n\t     */\n\t    function merge(target, source, overwrite) {\n\t        // We should escapse that source is string\n\t        // and enter for ... in ...\n\t        if (!isObject(source) || !isObject(target)) {\n\t            return overwrite ? clone(source) : target;\n\t        }\n\t\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                var targetProp = target[key];\n\t                var sourceProp = source[key];\n\t\n\t                if (isObject(sourceProp)\n\t                    && isObject(targetProp)\n\t                    && !isArray(sourceProp)\n\t                    && !isArray(targetProp)\n\t                    && !isDom(sourceProp)\n\t                    && !isDom(targetProp)\n\t                    && !isBuildInObject(sourceProp)\n\t                    && !isBuildInObject(targetProp)\n\t                ) {\n\t                    // 如果需要递归覆盖，就递归调用merge\n\t                    merge(targetProp, sourceProp, overwrite);\n\t                }\n\t                else if (overwrite || !(key in target)) {\n\t                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n\t                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n\t                    target[key] = clone(source[key], true);\n\t                }\n\t            }\n\t        }\n\t\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {Array} targetAndSources The first item is target, and the rests are source.\n\t     * @param {boolean} [overwrite=false]\n\t     * @return {*} target\n\t     */\n\t    function mergeAll(targetAndSources, overwrite) {\n\t        var result = targetAndSources[0];\n\t        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n\t            result = merge(result, targetAndSources[i], overwrite);\n\t        }\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     */\n\t    function extend(target, source) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    /**\n\t     * @param {*} target\n\t     * @param {*} source\n\t     * @param {boolen} [overlay=false]\n\t     */\n\t    function defaults(target, source, overlay) {\n\t        for (var key in source) {\n\t            if (source.hasOwnProperty(key)\n\t                && (overlay ? source[key] != null : target[key] == null)\n\t            ) {\n\t                target[key] = source[key];\n\t            }\n\t        }\n\t        return target;\n\t    }\n\t\n\t    function createCanvas() {\n\t        return document.createElement('canvas');\n\t    }\n\t    // FIXME\n\t    var _ctx;\n\t    function getContext() {\n\t        if (!_ctx) {\n\t            // Use util.createCanvas instead of createCanvas\n\t            // because createCanvas may be overwritten in different environment\n\t            _ctx = util.createCanvas().getContext('2d');\n\t        }\n\t        return _ctx;\n\t    }\n\t\n\t    /**\n\t     * 查询数组中元素的index\n\t     */\n\t    function indexOf(array, value) {\n\t        if (array) {\n\t            if (array.indexOf) {\n\t                return array.indexOf(value);\n\t            }\n\t            for (var i = 0, len = array.length; i < len; i++) {\n\t                if (array[i] === value) {\n\t                    return i;\n\t                }\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t\n\t    /**\n\t     * 构造类继承关系\n\t     *\n\t     * @param {Function} clazz 源类\n\t     * @param {Function} baseClazz 基类\n\t     */\n\t    function inherits(clazz, baseClazz) {\n\t        var clazzPrototype = clazz.prototype;\n\t        function F() {}\n\t        F.prototype = baseClazz.prototype;\n\t        clazz.prototype = new F();\n\t\n\t        for (var prop in clazzPrototype) {\n\t            clazz.prototype[prop] = clazzPrototype[prop];\n\t        }\n\t        clazz.prototype.constructor = clazz;\n\t        clazz.superClass = baseClazz;\n\t    }\n\t\n\t    /**\n\t     * @param {Object|Function} target\n\t     * @param {Object|Function} sorce\n\t     * @param {boolean} overlay\n\t     */\n\t    function mixin(target, source, overlay) {\n\t        target = 'prototype' in target ? target.prototype : target;\n\t        source = 'prototype' in source ? source.prototype : source;\n\t\n\t        defaults(target, source, overlay);\n\t    }\n\t\n\t    /**\n\t     * @param {Array|TypedArray} data\n\t     */\n\t    function isArrayLike(data) {\n\t        if (! data) {\n\t            return;\n\t        }\n\t        if (typeof data == 'string') {\n\t            return false;\n\t        }\n\t        return typeof data.length == 'number';\n\t    }\n\t\n\t    /**\n\t     * 数组或对象遍历\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Object|Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     */\n\t    function each(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.forEach && obj.forEach === nativeForEach) {\n\t            obj.forEach(cb, context);\n\t        }\n\t        else if (obj.length === +obj.length) {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                cb.call(context, obj[i], i, obj);\n\t            }\n\t        }\n\t        else {\n\t            for (var key in obj) {\n\t                if (obj.hasOwnProperty(key)) {\n\t                    cb.call(context, obj[key], key, obj);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组映射\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function map(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.map && obj.map === nativeMap) {\n\t            return obj.map(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                result.push(cb.call(context, obj[i], i, obj));\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {Object} [memo]\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function reduce(obj, cb, memo, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.reduce && obj.reduce === nativeReduce) {\n\t            return obj.reduce(cb, memo, context);\n\t        }\n\t        else {\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                memo = cb.call(context, memo, obj[i], i, obj);\n\t            }\n\t            return memo;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组过滤\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function filter(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        if (obj.filter && obj.filter === nativeFilter) {\n\t            return obj.filter(cb, context);\n\t        }\n\t        else {\n\t            var result = [];\n\t            for (var i = 0, len = obj.length; i < len; i++) {\n\t                if (cb.call(context, obj[i], i, obj)) {\n\t                    result.push(obj[i]);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 数组项查找\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Array} obj\n\t     * @param {Function} cb\n\t     * @param {*} [context]\n\t     * @return {Array}\n\t     */\n\t    function find(obj, cb, context) {\n\t        if (!(obj && cb)) {\n\t            return;\n\t        }\n\t        for (var i = 0, len = obj.length; i < len; i++) {\n\t            if (cb.call(context, obj[i], i, obj)) {\n\t                return obj[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Function} func\n\t     * @param {*} context\n\t     * @return {Function}\n\t     */\n\t    function bind(func, context) {\n\t        var args = nativeSlice.call(arguments, 2);\n\t        return function () {\n\t            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Function} func\n\t     * @param {...}\n\t     * @return {Function}\n\t     */\n\t    function curry(func) {\n\t        var args = nativeSlice.call(arguments, 1);\n\t        return function () {\n\t            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isArray(value) {\n\t        return objToString.call(value) === '[object Array]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isFunction(value) {\n\t        return typeof value === 'function';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isString(value) {\n\t        return objToString.call(value) === '[object String]';\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isObject(value) {\n\t        // Avoid a V8 JIT bug in Chrome 19-20.\n\t        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n\t        var type = typeof value;\n\t        return type === 'function' || (!!value && type == 'object');\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isBuildInObject(value) {\n\t        return !!BUILTIN_OBJECT[objToString.call(value)]\n\t            || (value instanceof Gradient);\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {*} value\n\t     * @return {boolean}\n\t     */\n\t    function isDom(value) {\n\t        return value && value.nodeType === 1\n\t               && typeof(value.nodeName) == 'string';\n\t    }\n\t\n\t    /**\n\t     * If value1 is not null, then return value1, otherwise judget rest of values.\n\t     * @param  {*...} values\n\t     * @return {*} Final value\n\t     */\n\t    function retrieve(values) {\n\t        for (var i = 0, len = arguments.length; i < len; i++) {\n\t            if (arguments[i] != null) {\n\t                return arguments[i];\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @memberOf module:zrender/tool/util\n\t     * @param {Array} arr\n\t     * @param {number} startIndex\n\t     * @param {number} endIndex\n\t     * @return {Array}\n\t     */\n\t    function slice() {\n\t        return Function.call.apply(nativeSlice, arguments);\n\t    }\n\t\n\t    /**\n\t     * @param {boolean} condition\n\t     * @param {string} message\n\t     */\n\t    function assert(condition, message) {\n\t        if (!condition) {\n\t            throw new Error(message);\n\t        }\n\t    }\n\t\n\t    var util = {\n\t        inherits: inherits,\n\t        mixin: mixin,\n\t        clone: clone,\n\t        merge: merge,\n\t        mergeAll: mergeAll,\n\t        extend: extend,\n\t        defaults: defaults,\n\t        getContext: getContext,\n\t        createCanvas: createCanvas,\n\t        indexOf: indexOf,\n\t        slice: slice,\n\t        find: find,\n\t        isArrayLike: isArrayLike,\n\t        each: each,\n\t        map: map,\n\t        reduce: reduce,\n\t        filter: filter,\n\t        bind: bind,\n\t        curry: curry,\n\t        isArray: isArray,\n\t        isString: isString,\n\t        isObject: isObject,\n\t        isFunction: isFunction,\n\t        isBuildInObject: isBuildInObject,\n\t        isDom: isDom,\n\t        retrieve: retrieve,\n\t        assert: assert,\n\t        noop: function () {}\n\t    };\n\t    module.exports = util;\n\t\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    /**\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var Gradient = function (colorStops) {\n\t\n\t        this.colorStops = colorStops || [];\n\t    };\n\t\n\t    Gradient.prototype = {\n\t\n\t        constructor: Gradient,\n\t\n\t        addColorStop: function (offset, color) {\n\t            this.colorStops.push({\n\t\n\t                offset: offset,\n\t\n\t                color: color\n\t            });\n\t        }\n\t    };\n\t\n\t    module.exports = Gradient;\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t// TODO Draggable for group\n\t// FIXME Draggable on element which has parent rotation or scale\n\t\n\t    function Draggable() {\n\t\n\t        this.on('mousedown', this._dragStart, this);\n\t        this.on('mousemove', this._drag, this);\n\t        this.on('mouseup', this._dragEnd, this);\n\t        this.on('globalout', this._dragEnd, this);\n\t        // this._dropTarget = null;\n\t        // this._draggingTarget = null;\n\t\n\t        // this._x = 0;\n\t        // this._y = 0;\n\t    }\n\t\n\t    Draggable.prototype = {\n\t\n\t        constructor: Draggable,\n\t\n\t        _dragStart: function (e) {\n\t            var draggingTarget = e.target;\n\t            if (draggingTarget && draggingTarget.draggable) {\n\t                this._draggingTarget = draggingTarget;\n\t                draggingTarget.dragging = true;\n\t                this._x = e.offsetX;\n\t                this._y = e.offsetY;\n\t\n\t                this._dispatchProxy(draggingTarget, 'dragstart', e.event);\n\t            }\n\t        },\n\t\n\t        _drag: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t            if (draggingTarget) {\n\t\n\t                var x = e.offsetX;\n\t                var y = e.offsetY;\n\t\n\t                var dx = x - this._x;\n\t                var dy = y - this._y;\n\t                this._x = x;\n\t                this._y = y;\n\t\n\t                draggingTarget.drift(dx, dy, e);\n\t                this._dispatchProxy(draggingTarget, 'drag', e.event);\n\t\n\t                var dropTarget = this.findHover(x, y, draggingTarget);\n\t                var lastDropTarget = this._dropTarget;\n\t                this._dropTarget = dropTarget;\n\t\n\t                if (draggingTarget !== dropTarget) {\n\t                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n\t                        this._dispatchProxy(lastDropTarget, 'dragleave', e.event);\n\t                    }\n\t                    if (dropTarget && dropTarget !== lastDropTarget) {\n\t                        this._dispatchProxy(dropTarget, 'dragenter', e.event);\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        _dragEnd: function (e) {\n\t            var draggingTarget = this._draggingTarget;\n\t\n\t            if (draggingTarget) {\n\t                draggingTarget.dragging = false;\n\t            }\n\t\n\t            this._dispatchProxy(draggingTarget, 'dragend', e.event);\n\t\n\t            if (this._dropTarget) {\n\t                this._dispatchProxy(this._dropTarget, 'drop', e.event);\n\t            }\n\t\n\t            this._draggingTarget = null;\n\t            this._dropTarget = null;\n\t        }\n\t\n\t    };\n\t\n\t    module.exports = Draggable;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t/**\n\t * Only implements needed gestures for mobile.\n\t */\n\t\n\t\n\t    var GestureMgr = function () {\n\t\n\t        /**\n\t         * @private\n\t         * @type {Array.<Object>}\n\t         */\n\t        this._track = [];\n\t    };\n\t\n\t    GestureMgr.prototype = {\n\t\n\t        constructor: GestureMgr,\n\t\n\t        recognize: function (event, target) {\n\t            this._doTrack(event, target);\n\t            return this._recognize(event);\n\t        },\n\t\n\t        clear: function () {\n\t            this._track.length = 0;\n\t            return this;\n\t        },\n\t\n\t        _doTrack: function (event, target) {\n\t            var touches = event.touches;\n\t\n\t            if (!touches) {\n\t                return;\n\t            }\n\t\n\t            var trackItem = {\n\t                points: [],\n\t                touches: [],\n\t                target: target,\n\t                event: event\n\t            };\n\t\n\t            for (var i = 0, len = touches.length; i < len; i++) {\n\t                var touch = touches[i];\n\t                trackItem.points.push([touch.clientX, touch.clientY]);\n\t                trackItem.touches.push(touch);\n\t            }\n\t\n\t            this._track.push(trackItem);\n\t        },\n\t\n\t        _recognize: function (event) {\n\t            for (var eventName in recognizers) {\n\t                if (recognizers.hasOwnProperty(eventName)) {\n\t                    var gestureInfo = recognizers[eventName](this._track, event);\n\t                    if (gestureInfo) {\n\t                        return gestureInfo;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    function dist(pointPair) {\n\t        var dx = pointPair[1][0] - pointPair[0][0];\n\t        var dy = pointPair[1][1] - pointPair[0][1];\n\t\n\t        return Math.sqrt(dx * dx + dy * dy);\n\t    }\n\t\n\t    function center(pointPair) {\n\t        return [\n\t            (pointPair[0][0] + pointPair[1][0]) / 2,\n\t            (pointPair[0][1] + pointPair[1][1]) / 2\n\t        ];\n\t    }\n\t\n\t    var recognizers = {\n\t\n\t        pinch: function (track, event) {\n\t            var trackLen = track.length;\n\t\n\t            if (!trackLen) {\n\t                return;\n\t            }\n\t\n\t            var pinchEnd = (track[trackLen - 1] || {}).points;\n\t            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\t\n\t            if (pinchPre\n\t                && pinchPre.length > 1\n\t                && pinchEnd\n\t                && pinchEnd.length > 1\n\t            ) {\n\t                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n\t                !isFinite(pinchScale) && (pinchScale = 1);\n\t\n\t                event.pinchScale = pinchScale;\n\t\n\t                var pinchCenter = center(pinchEnd);\n\t                event.pinchX = pinchCenter[0];\n\t                event.pinchY = pinchCenter[1];\n\t\n\t                return {\n\t                    type: 'pinch',\n\t                    target: track[0].target,\n\t                    event: event\n\t                };\n\t            }\n\t        }\n\t\n\t        // Only pinch currently.\n\t    };\n\t\n\t    module.exports = GestureMgr;\n\t\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Storage内容仓库模块\n\t * @module zrender/Storage\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t * @author errorrik (errorrik@gmail.com)\n\t * @author pissang (https://github.com/pissang/)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(9);\n\t\n\t    var Group = __webpack_require__(14);\n\t\n\t    function shapeCompareFunc(a, b) {\n\t        if (a.zlevel === b.zlevel) {\n\t            if (a.z === b.z) {\n\t                if (a.z2 === b.z2) {\n\t                    return a.__renderidx - b.__renderidx;\n\t                }\n\t                return a.z2 - b.z2;\n\t            }\n\t            return a.z - b.z;\n\t        }\n\t        return a.zlevel - b.zlevel;\n\t    }\n\t    /**\n\t     * 内容仓库 (M)\n\t     * @alias module:zrender/Storage\n\t     * @constructor\n\t     */\n\t    var Storage = function () {\n\t        // 所有常规形状，id索引的map\n\t        this._elements = {};\n\t\n\t        this._roots = [];\n\t\n\t        this._displayList = [];\n\t\n\t        this._displayListLen = 0;\n\t    };\n\t\n\t    Storage.prototype = {\n\t\n\t        constructor: Storage,\n\t\n\t        /**\n\t         * 返回所有图形的绘制队列\n\t         * @param {boolean} [update=false] 是否在返回前更新该数组\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n\t         *\n\t         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n\t         * @return {Array.<module:zrender/graphic/Displayable>}\n\t         */\n\t        getDisplayList: function (update, includeIgnore) {\n\t            includeIgnore = includeIgnore || false;\n\t            if (update) {\n\t                this.updateDisplayList(includeIgnore);\n\t            }\n\t            return this._displayList;\n\t        },\n\t\n\t        /**\n\t         * 更新图形的绘制队列。\n\t         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n\t         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n\t         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n\t         */\n\t        updateDisplayList: function (includeIgnore) {\n\t            this._displayListLen = 0;\n\t            var roots = this._roots;\n\t            var displayList = this._displayList;\n\t            for (var i = 0, len = roots.length; i < len; i++) {\n\t                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n\t            }\n\t            displayList.length = this._displayListLen;\n\t\n\t            for (var i = 0, len = displayList.length; i < len; i++) {\n\t                displayList[i].__renderidx = i;\n\t            }\n\t\n\t            displayList.sort(shapeCompareFunc);\n\t        },\n\t\n\t        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\t\n\t            if (el.ignore && !includeIgnore) {\n\t                return;\n\t            }\n\t\n\t            el.beforeUpdate();\n\t\n\t            el.update();\n\t\n\t            el.afterUpdate();\n\t\n\t            var clipPath = el.clipPath;\n\t            if (clipPath) {\n\t                // clipPath 的变换是基于 group 的变换\n\t                clipPath.parent = el;\n\t                clipPath.updateTransform();\n\t\n\t                // FIXME 效率影响\n\t                if (clipPaths) {\n\t                    clipPaths = clipPaths.slice();\n\t                    clipPaths.push(clipPath);\n\t                }\n\t                else {\n\t                    clipPaths = [clipPath];\n\t                }\n\t            }\n\t\n\t            if (el.type == 'group') {\n\t                var children = el._children;\n\t\n\t                for (var i = 0; i < children.length; i++) {\n\t                    var child = children[i];\n\t\n\t                    // Force to mark as dirty if group is dirty\n\t                    // FIXME __dirtyPath ?\n\t                    child.__dirty = el.__dirty || child.__dirty;\n\t\n\t                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n\t                }\n\t\n\t                // Mark group clean here\n\t                el.__dirty = false;\n\t\n\t            }\n\t            else {\n\t                el.__clipPaths = clipPaths;\n\t\n\t                this._displayList[this._displayListLen++] = el;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 添加图形(Shape)或者组(Group)到根节点\n\t         * @param {module:zrender/Element} el\n\t         */\n\t        addRoot: function (el) {\n\t            // Element has been added\n\t            if (this._elements[el.id]) {\n\t                return;\n\t            }\n\t\n\t            if (el instanceof Group) {\n\t                el.addChildrenToStorage(this);\n\t            }\n\t\n\t            this.addToMap(el);\n\t            this._roots.push(el);\n\t        },\n\t\n\t        /**\n\t         * 删除指定的图形(Shape)或者组(Group)\n\t         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n\t         */\n\t        delRoot: function (elId) {\n\t            if (elId == null) {\n\t                // 不指定elId清空\n\t                for (var i = 0; i < this._roots.length; i++) {\n\t                    var root = this._roots[i];\n\t                    if (root instanceof Group) {\n\t                        root.delChildrenFromStorage(this);\n\t                    }\n\t                }\n\t\n\t                this._elements = {};\n\t                this._roots = [];\n\t                this._displayList = [];\n\t                this._displayListLen = 0;\n\t\n\t                return;\n\t            }\n\t\n\t            if (elId instanceof Array) {\n\t                for (var i = 0, l = elId.length; i < l; i++) {\n\t                    this.delRoot(elId[i]);\n\t                }\n\t                return;\n\t            }\n\t\n\t            var el;\n\t            if (typeof(elId) == 'string') {\n\t                el = this._elements[elId];\n\t            }\n\t            else {\n\t                el = elId;\n\t            }\n\t\n\t            var idx = util.indexOf(this._roots, el);\n\t            if (idx >= 0) {\n\t                this.delFromMap(el.id);\n\t                this._roots.splice(idx, 1);\n\t                if (el instanceof Group) {\n\t                    el.delChildrenFromStorage(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        addToMap: function (el) {\n\t            if (el instanceof Group) {\n\t                el.__storage = this;\n\t            }\n\t            el.dirty();\n\t\n\t            this._elements[el.id] = el;\n\t\n\t            return this;\n\t        },\n\t\n\t        get: function (elId) {\n\t            return this._elements[elId];\n\t        },\n\t\n\t        delFromMap: function (elId) {\n\t            var elements = this._elements;\n\t            var el = elements[elId];\n\t            if (el) {\n\t                delete elements[elId];\n\t                if (el instanceof Group) {\n\t                    el.__storage = null;\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清空并且释放Storage\n\t         */\n\t        dispose: function () {\n\t            this._elements =\n\t            this._renderList =\n\t            this._roots = null;\n\t        }\n\t    };\n\t\n\t    module.exports = Storage;\n\t\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n\t * @module zrender/graphic/Group\n\t * @example\n\t *     var Group = require('zrender/lib/container/Group');\n\t *     var Circle = require('zrender/lib/graphic/shape/Circle');\n\t *     var g = new Group();\n\t *     g.position[0] = 100;\n\t *     g.position[1] = 100;\n\t *     g.add(new Circle({\n\t *         style: {\n\t *             x: 100,\n\t *             y: 100,\n\t *             r: 20,\n\t *         }\n\t *     }));\n\t *     zr.add(g);\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(9);\n\t    var Element = __webpack_require__(15);\n\t    var BoundingRect = __webpack_require__(26);\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Group\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @extends module:zrender/mixin/Eventful\n\t     */\n\t    var Group = function (opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        for (var key in opts) {\n\t            this[key] = opts[key];\n\t        }\n\t\n\t        this._children = [];\n\t\n\t        this.__storage = null;\n\t\n\t        this.__dirty = true;\n\t    };\n\t\n\t    Group.prototype = {\n\t\n\t        constructor: Group,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        type: 'group',\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/Element>}\n\t         */\n\t        children: function () {\n\t            return this._children.slice();\n\t        },\n\t\n\t        /**\n\t         * 获取指定 index 的儿子节点\n\t         * @param  {number} idx\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childAt: function (idx) {\n\t            return this._children[idx];\n\t        },\n\t\n\t        /**\n\t         * 获取指定名字的儿子节点\n\t         * @param  {string} name\n\t         * @return {module:zrender/Element}\n\t         */\n\t        childOfName: function (name) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                if (children[i].name === name) {\n\t                    return children[i];\n\t                }\n\t             }\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        childCount: function () {\n\t            return this._children.length;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点到最后\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        add: function (child) {\n\t            if (child && child !== this && child.parent !== this) {\n\t\n\t                this._children.push(child);\n\t\n\t                this._doAdd(child);\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 添加子节点在 nextSibling 之前\n\t         * @param {module:zrender/Element} child\n\t         * @param {module:zrender/Element} nextSibling\n\t         */\n\t        addBefore: function (child, nextSibling) {\n\t            if (child && child !== this && child.parent !== this\n\t                && nextSibling && nextSibling.parent === this) {\n\t\n\t                var children = this._children;\n\t                var idx = children.indexOf(nextSibling);\n\t\n\t                if (idx >= 0) {\n\t                    children.splice(idx, 0, child);\n\t                    this._doAdd(child);\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _doAdd: function (child) {\n\t            if (child.parent) {\n\t                child.parent.remove(child);\n\t            }\n\t\n\t            child.parent = this;\n\t\n\t            var storage = this.__storage;\n\t            var zr = this.__zr;\n\t            if (storage && storage !== child.__storage) {\n\t\n\t                storage.addToMap(child);\n\t\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 移除子节点\n\t         * @param {module:zrender/Element} child\n\t         */\n\t        remove: function (child) {\n\t            var zr = this.__zr;\n\t            var storage = this.__storage;\n\t            var children = this._children;\n\t\n\t            var idx = zrUtil.indexOf(children, child);\n\t            if (idx < 0) {\n\t                return this;\n\t            }\n\t            children.splice(idx, 1);\n\t\n\t            child.parent = null;\n\t\n\t            if (storage) {\n\t\n\t                storage.delFromMap(child.id);\n\t\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t\n\t            zr && zr.refresh();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 移除所有子节点\n\t         */\n\t        removeAll: function () {\n\t            var children = this._children;\n\t            var storage = this.__storage;\n\t            var child;\n\t            var i;\n\t            for (i = 0; i < children.length; i++) {\n\t                child = children[i];\n\t                if (storage) {\n\t                    storage.delFromMap(child.id);\n\t                    if (child instanceof Group) {\n\t                        child.delChildrenFromStorage(storage);\n\t                    }\n\t                }\n\t                child.parent = null;\n\t            }\n\t            children.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 遍历所有子节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        eachChild: function (cb, context) {\n\t            var children = this._children;\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                cb.call(context, child, i);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 深度优先遍历所有子孙节点\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                cb.call(context, child);\n\t\n\t                if (child.type === 'group') {\n\t                    child.traverse(cb, context);\n\t                }\n\t            }\n\t            return this;\n\t        },\n\t\n\t        addChildrenToStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.addToMap(child);\n\t                if (child instanceof Group) {\n\t                    child.addChildrenToStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        delChildrenFromStorage: function (storage) {\n\t            for (var i = 0; i < this._children.length; i++) {\n\t                var child = this._children[i];\n\t                storage.delFromMap(child.id);\n\t                if (child instanceof Group) {\n\t                    child.delChildrenFromStorage(storage);\n\t                }\n\t            }\n\t        },\n\t\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t            this.__zr && this.__zr.refresh();\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function (includeChildren) {\n\t            // TODO Caching\n\t            // TODO Transform\n\t            var rect = null;\n\t            var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t            var children = includeChildren || this._children;\n\t            var tmpMat = [];\n\t\n\t            for (var i = 0; i < children.length; i++) {\n\t                var child = children[i];\n\t                if (child.ignore || child.invisible) {\n\t                    continue;\n\t                }\n\t\n\t                var childRect = child.getBoundingRect();\n\t                var transform = child.getLocalTransform(tmpMat);\n\t                if (transform) {\n\t                    tmpRect.copy(childRect);\n\t                    tmpRect.applyTransform(transform);\n\t                    rect = rect || tmpRect.clone();\n\t                    rect.union(tmpRect);\n\t                }\n\t                else {\n\t                    rect = rect || childRect.clone();\n\t                    rect.union(childRect);\n\t                }\n\t            }\n\t            return rect || tmpRect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Group, Element);\n\t\n\t    module.exports = Group;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/Element\n\t */\n\t\n\t\n\t    var guid = __webpack_require__(4);\n\t    var Eventful = __webpack_require__(8);\n\t    var Transformable = __webpack_require__(16);\n\t    var Animatable = __webpack_require__(19);\n\t    var zrUtil = __webpack_require__(9);\n\t\n\t    /**\n\t     * @alias module:zrender/Element\n\t     * @constructor\n\t     * @extends {module:zrender/mixin/Animatable}\n\t     * @extends {module:zrender/mixin/Transformable}\n\t     * @extends {module:zrender/mixin/Eventful}\n\t     */\n\t    var Element = function (opts) {\n\t\n\t        Transformable.call(this, opts);\n\t        Eventful.call(this, opts);\n\t        Animatable.call(this, opts);\n\t\n\t        /**\n\t         * 画布元素ID\n\t         * @type {string}\n\t         */\n\t        this.id = opts.id || guid();\n\t    };\n\t\n\t    Element.prototype = {\n\t\n\t        /**\n\t         * 元素类型\n\t         * Element type\n\t         * @type {string}\n\t         */\n\t        type: 'element',\n\t\n\t        /**\n\t         * 元素名字\n\t         * Element name\n\t         * @type {string}\n\t         */\n\t        name: '',\n\t\n\t        /**\n\t         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n\t         * ZRender instance will be assigned when element is associated with zrender\n\t         * @name module:/zrender/Element#__zr\n\t         * @type {module:zrender/ZRender}\n\t         */\n\t        __zr: null,\n\t\n\t        /**\n\t         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n\t         * If ignore drawing and events of the element object\n\t         * @name module:/zrender/Element#ignore\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        ignore: false,\n\t\n\t        /**\n\t         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n\t         * 该路径会继承被裁减对象的变换\n\t         * @type {module:zrender/graphic/Path}\n\t         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n\t         * @readOnly\n\t         */\n\t        clipPath: null,\n\t\n\t        /**\n\t         * Drift element\n\t         * @param  {number} dx dx on the global space\n\t         * @param  {number} dy dy on the global space\n\t         */\n\t        drift: function (dx, dy) {\n\t            switch (this.draggable) {\n\t                case 'horizontal':\n\t                    dy = 0;\n\t                    break;\n\t                case 'vertical':\n\t                    dx = 0;\n\t                    break;\n\t            }\n\t\n\t            var m = this.transform;\n\t            if (!m) {\n\t                m = this.transform = [1, 0, 0, 1, 0, 0];\n\t            }\n\t            m[4] += dx;\n\t            m[5] += dy;\n\t\n\t            this.decomposeTransform();\n\t            this.dirty();\n\t        },\n\t\n\t        /**\n\t         * Hook before update\n\t         */\n\t        beforeUpdate: function () {},\n\t        /**\n\t         * Hook after update\n\t         */\n\t        afterUpdate: function () {},\n\t        /**\n\t         * Update each frame\n\t         */\n\t        update: function () {\n\t            this.updateTransform();\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {},\n\t\n\t        /**\n\t         * @protected\n\t         */\n\t        attrKV: function (key, value) {\n\t            if (key === 'position' || key === 'scale' || key === 'origin') {\n\t                // Copy the array\n\t                if (value) {\n\t                    var target = this[key];\n\t                    if (!target) {\n\t                        target = this[key] = [];\n\t                    }\n\t                    target[0] = value[0];\n\t                    target[1] = value[1];\n\t                }\n\t            }\n\t            else {\n\t                this[key] = value;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Hide the element\n\t         */\n\t        hide: function () {\n\t            this.ignore = true;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * Show the element\n\t         */\n\t        show: function () {\n\t            this.ignore = false;\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * @param {string|Object} key\n\t         * @param {*} value\n\t         */\n\t        attr: function (key, value) {\n\t            if (typeof key === 'string') {\n\t                this.attrKV(key, value);\n\t            }\n\t            else if (zrUtil.isObject(key)) {\n\t                for (var name in key) {\n\t                    if (key.hasOwnProperty(name)) {\n\t                        this.attrKV(name, key[name]);\n\t                    }\n\t                }\n\t            }\n\t            this.dirty();\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/graphic/Path} clipPath\n\t         */\n\t        setClipPath: function (clipPath) {\n\t            var zr = this.__zr;\n\t            if (zr) {\n\t                clipPath.addSelfToZr(zr);\n\t            }\n\t\n\t            // Remove previous clip path\n\t            if (this.clipPath && this.clipPath !== clipPath) {\n\t                this.removeClipPath();\n\t            }\n\t\n\t            this.clipPath = clipPath;\n\t            clipPath.__zr = zr;\n\t            clipPath.__clipTarget = this;\n\t\n\t            this.dirty();\n\t        },\n\t\n\t        /**\n\t         */\n\t        removeClipPath: function () {\n\t            var clipPath = this.clipPath;\n\t            if (clipPath) {\n\t                if (clipPath.__zr) {\n\t                    clipPath.removeSelfFromZr(clipPath.__zr);\n\t                }\n\t\n\t                clipPath.__zr = null;\n\t                clipPath.__clipTarget = null;\n\t                this.clipPath = null;\n\t\n\t                this.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Add self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        addSelfToZr: function (zr) {\n\t            this.__zr = zr;\n\t            // 添加动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.addAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.addSelfToZr(zr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Remove self from zrender instance.\n\t         * Not recursively because it will be invoked when element added to storage.\n\t         * @param {module:zrender/ZRender} zr\n\t         */\n\t        removeSelfFromZr: function (zr) {\n\t            this.__zr = null;\n\t            // 移除动画\n\t            var animators = this.animators;\n\t            if (animators) {\n\t                for (var i = 0; i < animators.length; i++) {\n\t                    zr.animation.removeAnimator(animators[i]);\n\t                }\n\t            }\n\t\n\t            if (this.clipPath) {\n\t                this.clipPath.removeSelfFromZr(zr);\n\t            }\n\t        }\n\t    };\n\t\n\t    zrUtil.mixin(Element, Animatable);\n\t    zrUtil.mixin(Element, Transformable);\n\t    zrUtil.mixin(Element, Eventful);\n\t\n\t    module.exports = Element;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 提供变换扩展\n\t * @module zrender/mixin/Transformable\n\t * @author pissang (https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var matrix = __webpack_require__(17);\n\t    var vector = __webpack_require__(18);\n\t    var mIdentity = matrix.identity;\n\t\n\t    var EPSILON = 5e-5;\n\t\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/mixin/Transformable\n\t     * @constructor\n\t     */\n\t    var Transformable = function (opts) {\n\t        opts = opts || {};\n\t        // If there are no given position, rotation, scale\n\t        if (!opts.position) {\n\t            /**\n\t             * 平移\n\t             * @type {Array.<number>}\n\t             * @default [0, 0]\n\t             */\n\t            this.position = [0, 0];\n\t        }\n\t        if (opts.rotation == null) {\n\t            /**\n\t             * 旋转\n\t             * @type {Array.<number>}\n\t             * @default 0\n\t             */\n\t            this.rotation = 0;\n\t        }\n\t        if (!opts.scale) {\n\t            /**\n\t             * 缩放\n\t             * @type {Array.<number>}\n\t             * @default [1, 1]\n\t             */\n\t            this.scale = [1, 1];\n\t        }\n\t        /**\n\t         * 旋转和缩放的原点\n\t         * @type {Array.<number>}\n\t         * @default null\n\t         */\n\t        this.origin = this.origin || null;\n\t    };\n\t\n\t    var transformableProto = Transformable.prototype;\n\t    transformableProto.transform = null;\n\t\n\t    /**\n\t     * 判断是否需要有坐标变换\n\t     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n\t     */\n\t    transformableProto.needLocalTransform = function () {\n\t        return isNotAroundZero(this.rotation)\n\t            || isNotAroundZero(this.position[0])\n\t            || isNotAroundZero(this.position[1])\n\t            || isNotAroundZero(this.scale[0] - 1)\n\t            || isNotAroundZero(this.scale[1] - 1);\n\t    };\n\t\n\t    transformableProto.updateTransform = function () {\n\t        var parent = this.parent;\n\t        var parentHasTransform = parent && parent.transform;\n\t        var needLocalTransform = this.needLocalTransform();\n\t\n\t        var m = this.transform;\n\t        if (!(needLocalTransform || parentHasTransform)) {\n\t            m && mIdentity(m);\n\t            return;\n\t        }\n\t\n\t        m = m || matrix.create();\n\t\n\t        if (needLocalTransform) {\n\t            this.getLocalTransform(m);\n\t        }\n\t        else {\n\t            mIdentity(m);\n\t        }\n\t\n\t        // 应用父节点变换\n\t        if (parentHasTransform) {\n\t            if (needLocalTransform) {\n\t                matrix.mul(m, parent.transform, m);\n\t            }\n\t            else {\n\t                matrix.copy(m, parent.transform);\n\t            }\n\t        }\n\t        // 保存这个变换矩阵\n\t        this.transform = m;\n\t\n\t        this.invTransform = this.invTransform || matrix.create();\n\t        matrix.invert(this.invTransform, m);\n\t    };\n\t\n\t    transformableProto.getLocalTransform = function (m) {\n\t        m = m || [];\n\t        mIdentity(m);\n\t\n\t        var origin = this.origin;\n\t\n\t        var scale = this.scale;\n\t        var rotation = this.rotation;\n\t        var position = this.position;\n\t        if (origin) {\n\t            // Translate to origin\n\t            m[4] -= origin[0];\n\t            m[5] -= origin[1];\n\t        }\n\t        matrix.scale(m, m, scale);\n\t        if (rotation) {\n\t            matrix.rotate(m, m, rotation);\n\t        }\n\t        if (origin) {\n\t            // Translate back from origin\n\t            m[4] += origin[0];\n\t            m[5] += origin[1];\n\t        }\n\t\n\t        m[4] += position[0];\n\t        m[5] += position[1];\n\t\n\t        return m;\n\t    };\n\t    /**\n\t     * 将自己的transform应用到context上\n\t     * @param {Context2D} ctx\n\t     */\n\t    transformableProto.setTransform = function (ctx) {\n\t        var m = this.transform;\n\t        if (m) {\n\t            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\t        }\n\t    };\n\t\n\t    var tmpTransform = [];\n\t\n\t    /**\n\t     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n\t     */\n\t    transformableProto.decomposeTransform = function () {\n\t        if (!this.transform) {\n\t            return;\n\t        }\n\t        var parent = this.parent;\n\t        var m = this.transform;\n\t        if (parent && parent.transform) {\n\t            // Get local transform and decompose them to position, scale, rotation\n\t            matrix.mul(tmpTransform, parent.invTransform, m);\n\t            m = tmpTransform;\n\t        }\n\t        var sx = m[0] * m[0] + m[1] * m[1];\n\t        var sy = m[2] * m[2] + m[3] * m[3];\n\t        var position = this.position;\n\t        var scale = this.scale;\n\t        if (isNotAroundZero(sx - 1)) {\n\t            sx = Math.sqrt(sx);\n\t        }\n\t        if (isNotAroundZero(sy - 1)) {\n\t            sy = Math.sqrt(sy);\n\t        }\n\t        if (m[0] < 0) {\n\t            sx = -sx;\n\t        }\n\t        if (m[3] < 0) {\n\t            sy = -sy;\n\t        }\n\t        position[0] = m[4];\n\t        position[1] = m[5];\n\t        scale[0] = sx;\n\t        scale[1] = sy;\n\t        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n\t    };\n\t\n\t    /**\n\t     * 变换坐标位置到 shape 的局部坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToLocal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var invTransform = this.invTransform;\n\t        if (invTransform) {\n\t            vector.applyTransform(v2, v2, invTransform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    /**\n\t     * 变换局部坐标位置到全局坐标空间\n\t     * @method\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @return {Array.<number>}\n\t     */\n\t    transformableProto.transformCoordToGlobal = function (x, y) {\n\t        var v2 = [x, y];\n\t        var transform = this.transform;\n\t        if (transform) {\n\t            vector.applyTransform(v2, v2, transform);\n\t        }\n\t        return v2;\n\t    };\n\t\n\t    module.exports = Transformable;\n\t\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t    /**\n\t     * 3x2矩阵操作类\n\t     * @exports zrender/tool/matrix\n\t     */\n\t    var matrix = {\n\t        /**\n\t         * 创建一个单位矩阵\n\t         * @return {Float32Array|Array.<number>}\n\t         */\n\t        create : function() {\n\t            var out = new ArrayCtor(6);\n\t            matrix.identity(out);\n\t\n\t            return out;\n\t        },\n\t        /**\n\t         * 设置矩阵为单位矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         */\n\t        identity : function(out) {\n\t            out[0] = 1;\n\t            out[1] = 0;\n\t            out[2] = 0;\n\t            out[3] = 1;\n\t            out[4] = 0;\n\t            out[5] = 0;\n\t            return out;\n\t        },\n\t        /**\n\t         * 复制矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m\n\t         */\n\t        copy: function(out, m) {\n\t            out[0] = m[0];\n\t            out[1] = m[1];\n\t            out[2] = m[2];\n\t            out[3] = m[3];\n\t            out[4] = m[4];\n\t            out[5] = m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 矩阵相乘\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} m1\n\t         * @param {Float32Array|Array.<number>} m2\n\t         */\n\t        mul : function (out, m1, m2) {\n\t            // Consider matrix.mul(m, m2, m);\n\t            // where out is the same as m2.\n\t            // So use temp variable to escape error.\n\t            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n\t            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n\t            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n\t            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n\t            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n\t            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n\t            out[0] = out0;\n\t            out[1] = out1;\n\t            out[2] = out2;\n\t            out[3] = out3;\n\t            out[4] = out4;\n\t            out[5] = out5;\n\t            return out;\n\t        },\n\t        /**\n\t         * 平移变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        translate : function(out, a, v) {\n\t            out[0] = a[0];\n\t            out[1] = a[1];\n\t            out[2] = a[2];\n\t            out[3] = a[3];\n\t            out[4] = a[4] + v[0];\n\t            out[5] = a[5] + v[1];\n\t            return out;\n\t        },\n\t        /**\n\t         * 旋转变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {number} rad\n\t         */\n\t        rotate : function(out, a, rad) {\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t            var st = Math.sin(rad);\n\t            var ct = Math.cos(rad);\n\t\n\t            out[0] = aa * ct + ab * st;\n\t            out[1] = -aa * st + ab * ct;\n\t            out[2] = ac * ct + ad * st;\n\t            out[3] = -ac * st + ct * ad;\n\t            out[4] = ct * atx + st * aty;\n\t            out[5] = ct * aty - st * atx;\n\t            return out;\n\t        },\n\t        /**\n\t         * 缩放变换\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         * @param {Float32Array|Array.<number>} v\n\t         */\n\t        scale : function(out, a, v) {\n\t            var vx = v[0];\n\t            var vy = v[1];\n\t            out[0] = a[0] * vx;\n\t            out[1] = a[1] * vy;\n\t            out[2] = a[2] * vx;\n\t            out[3] = a[3] * vy;\n\t            out[4] = a[4] * vx;\n\t            out[5] = a[5] * vy;\n\t            return out;\n\t        },\n\t        /**\n\t         * 求逆矩阵\n\t         * @param {Float32Array|Array.<number>} out\n\t         * @param {Float32Array|Array.<number>} a\n\t         */\n\t        invert : function(out, a) {\n\t\n\t            var aa = a[0];\n\t            var ac = a[2];\n\t            var atx = a[4];\n\t            var ab = a[1];\n\t            var ad = a[3];\n\t            var aty = a[5];\n\t\n\t            var det = aa * ad - ab * ac;\n\t            if (!det) {\n\t                return null;\n\t            }\n\t            det = 1.0 / det;\n\t\n\t            out[0] = ad * det;\n\t            out[1] = -ab * det;\n\t            out[2] = -ac * det;\n\t            out[3] = aa * det;\n\t            out[4] = (ac * aty - ad * atx) * det;\n\t            out[5] = (ab * atx - aa * aty) * det;\n\t            return out;\n\t        }\n\t    };\n\t\n\t    module.exports = matrix;\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\n\t    var ArrayCtor = typeof Float32Array === 'undefined'\n\t        ? Array\n\t        : Float32Array;\n\t\n\t    /**\n\t     * @typedef {Float32Array|Array.<number>} Vector2\n\t     */\n\t    /**\n\t     * 二维向量类\n\t     * @exports zrender/tool/vector\n\t     */\n\t    var vector = {\n\t        /**\n\t         * 创建一个向量\n\t         * @param {number} [x=0]\n\t         * @param {number} [y=0]\n\t         * @return {Vector2}\n\t         */\n\t        create: function (x, y) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = x || 0;\n\t            out[1] = y || 0;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 复制向量数据\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        copy: function (out, v) {\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 克隆一个向量\n\t         * @param {Vector2} v\n\t         * @return {Vector2}\n\t         */\n\t        clone: function (v) {\n\t            var out = new ArrayCtor(2);\n\t            out[0] = v[0];\n\t            out[1] = v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 设置向量的两个项\n\t         * @param {Vector2} out\n\t         * @param {number} a\n\t         * @param {number} b\n\t         * @return {Vector2} 结果\n\t         */\n\t        set: function (out, a, b) {\n\t            out[0] = a;\n\t            out[1] = b;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        add: function (out, v1, v2) {\n\t            out[0] = v1[0] + v2[0];\n\t            out[1] = v1[1] + v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量缩放后相加\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} a\n\t         */\n\t        scaleAndAdd: function (out, v1, v2, a) {\n\t            out[0] = v1[0] + v2[0] * a;\n\t            out[1] = v1[1] + v2[1] * a;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量相减\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        sub: function (out, v1, v2) {\n\t            out[0] = v1[0] - v2[0];\n\t            out[1] = v1[1] - v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量长度\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        len: function (v) {\n\t            return Math.sqrt(this.lenSquare(v));\n\t        },\n\t\n\t        /**\n\t         * 向量长度平方\n\t         * @param {Vector2} v\n\t         * @return {number}\n\t         */\n\t        lenSquare: function (v) {\n\t            return v[0] * v[0] + v[1] * v[1];\n\t        },\n\t\n\t        /**\n\t         * 向量乘法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        mul: function (out, v1, v2) {\n\t            out[0] = v1[0] * v2[0];\n\t            out[1] = v1[1] * v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量除法\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         */\n\t        div: function (out, v1, v2) {\n\t            out[0] = v1[0] / v2[0];\n\t            out[1] = v1[1] / v2[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量点乘\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        dot: function (v1, v2) {\n\t            return v1[0] * v2[0] + v1[1] * v2[1];\n\t        },\n\t\n\t        /**\n\t         * 向量缩放\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {number} s\n\t         */\n\t        scale: function (out, v, s) {\n\t            out[0] = v[0] * s;\n\t            out[1] = v[1] * s;\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 向量归一化\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        normalize: function (out, v) {\n\t            var d = vector.len(v);\n\t            if (d === 0) {\n\t                out[0] = 0;\n\t                out[1] = 0;\n\t            }\n\t            else {\n\t                out[0] = v[0] / d;\n\t                out[1] = v[1] / d;\n\t            }\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 计算向量间距离\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distance: function (v1, v2) {\n\t            return Math.sqrt(\n\t                (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n\t            );\n\t        },\n\t\n\t        /**\n\t         * 向量距离平方\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @return {number}\n\t         */\n\t        distanceSquare: function (v1, v2) {\n\t            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n\t                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n\t        },\n\t\n\t        /**\n\t         * 求负向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         */\n\t        negate: function (out, v) {\n\t            out[0] = -v[0];\n\t            out[1] = -v[1];\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 插值两个点\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v1\n\t         * @param {Vector2} v2\n\t         * @param {number} t\n\t         */\n\t        lerp: function (out, v1, v2, t) {\n\t            out[0] = v1[0] + t * (v2[0] - v1[0]);\n\t            out[1] = v1[1] + t * (v2[1] - v1[1]);\n\t            return out;\n\t        },\n\t\n\t        /**\n\t         * 矩阵左乘向量\n\t         * @param {Vector2} out\n\t         * @param {Vector2} v\n\t         * @param {Vector2} m\n\t         */\n\t        applyTransform: function (out, v, m) {\n\t            var x = v[0];\n\t            var y = v[1];\n\t            out[0] = m[0] * x + m[2] * y + m[4];\n\t            out[1] = m[1] * x + m[3] * y + m[5];\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最小值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        min: function (out, v1, v2) {\n\t            out[0] = Math.min(v1[0], v2[0]);\n\t            out[1] = Math.min(v1[1], v2[1]);\n\t            return out;\n\t        },\n\t        /**\n\t         * 求两个向量最大值\n\t         * @param  {Vector2} out\n\t         * @param  {Vector2} v1\n\t         * @param  {Vector2} v2\n\t         */\n\t        max: function (out, v1, v2) {\n\t            out[0] = Math.max(v1[0], v2[0]);\n\t            out[1] = Math.max(v1[1], v2[1]);\n\t            return out;\n\t        }\n\t    };\n\t\n\t    vector.length = vector.len;\n\t    vector.lengthSquare = vector.lenSquare;\n\t    vector.dist = vector.distance;\n\t    vector.distSquare = vector.distanceSquare;\n\t\n\t    module.exports = vector;\n\t\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module zrender/mixin/Animatable\n\t */\n\t\n\t\n\t    var Animator = __webpack_require__(20);\n\t    var util = __webpack_require__(9);\n\t    var isString = util.isString;\n\t    var isFunction = util.isFunction;\n\t    var isObject = util.isObject;\n\t    var log = __webpack_require__(24);\n\t\n\t    /**\n\t     * @alias modue:zrender/mixin/Animatable\n\t     * @constructor\n\t     */\n\t    var Animatable = function () {\n\t\n\t        /**\n\t         * @type {Array.<module:zrender/animation/Animator>}\n\t         * @readOnly\n\t         */\n\t        this.animators = [];\n\t    };\n\t\n\t    Animatable.prototype = {\n\t\n\t        constructor: Animatable,\n\t\n\t        /**\n\t         * 动画\n\t         *\n\t         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n\t         * @param {boolean} [loop] 动画是否循环\n\t         * @return {module:zrender/animation/Animator}\n\t         * @example:\n\t         *     el.animate('style', false)\n\t         *         .when(1000, {x: 10} )\n\t         *         .done(function(){ // Animation done })\n\t         *         .start()\n\t         */\n\t        animate: function (path, loop) {\n\t            var target;\n\t            var animatingShape = false;\n\t            var el = this;\n\t            var zr = this.__zr;\n\t            if (path) {\n\t                var pathSplitted = path.split('.');\n\t                var prop = el;\n\t                // If animating shape\n\t                animatingShape = pathSplitted[0] === 'shape';\n\t                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n\t                    if (!prop) {\n\t                        continue;\n\t                    }\n\t                    prop = prop[pathSplitted[i]];\n\t                }\n\t                if (prop) {\n\t                    target = prop;\n\t                }\n\t            }\n\t            else {\n\t                target = el;\n\t            }\n\t\n\t            if (!target) {\n\t                log(\n\t                    'Property \"'\n\t                    + path\n\t                    + '\" is not existed in element '\n\t                    + el.id\n\t                );\n\t                return;\n\t            }\n\t\n\t            var animators = el.animators;\n\t\n\t            var animator = new Animator(target, loop);\n\t\n\t            animator.during(function (target) {\n\t                el.dirty(animatingShape);\n\t            })\n\t            .done(function () {\n\t                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n\t                animators.splice(util.indexOf(animators, animator), 1);\n\t            });\n\t\n\t            animators.push(animator);\n\t\n\t            // If animate after added to the zrender\n\t            if (zr) {\n\t                zr.animation.addAnimator(animator);\n\t            }\n\t\n\t            return animator;\n\t        },\n\t\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stopAnimation: function (forwardToLast) {\n\t            var animators = this.animators;\n\t            var len = animators.length;\n\t            for (var i = 0; i < len; i++) {\n\t                animators[i].stop(forwardToLast);\n\t            }\n\t            animators.length = 0;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param {Object} target\n\t         * @param {number} [time=500] Time in ms\n\t         * @param {string} [easing='linear']\n\t         * @param {number} [delay=0]\n\t         * @param {Function} [callback]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el.animateTo({\n\t         *      position: [10, 10]\n\t         *  }, function () { // done })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n\t         *  el.animateTo({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100, 'cubicOut', function () { // done })\n\t         */\n\t         // TODO Return animation key\n\t        animateTo: function (target, time, delay, easing, callback) {\n\t            // animateTo(target, time, easing, callback);\n\t            if (isString(delay)) {\n\t                callback = easing;\n\t                easing = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, delay, callback);\n\t            else if (isFunction(easing)) {\n\t                callback = easing;\n\t                easing = 'linear';\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, time, callback);\n\t            else if (isFunction(delay)) {\n\t                callback = delay;\n\t                delay = 0;\n\t            }\n\t            // animateTo(target, callback)\n\t            else if (isFunction(time)) {\n\t                callback = time;\n\t                time = 500;\n\t            }\n\t            // animateTo(target)\n\t            else if (!time) {\n\t                time = 500;\n\t            }\n\t            // Stop all previous animations\n\t            this.stopAnimation();\n\t            this._animateToShallow('', this, target, time, delay, easing, callback);\n\t\n\t            // Animators may be removed immediately after start\n\t            // if there is nothing to animate\n\t            var animators = this.animators.slice();\n\t            var count = animators.length;\n\t            function done() {\n\t                count--;\n\t                if (!count) {\n\t                    callback && callback();\n\t                }\n\t            }\n\t\n\t            // No animators. This should be checked before animators[i].start(),\n\t            // because 'done' may be executed immediately if no need to animate.\n\t            if (!count) {\n\t                callback && callback();\n\t            }\n\t            // Start after all animators created\n\t            // Incase any animator is done immediately when all animation properties are not changed\n\t            for (var i = 0; i < animators.length; i++) {\n\t                animators[i]\n\t                    .done(done)\n\t                    .start(easing);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         * @param {string} path=''\n\t         * @param {Object} source=this\n\t         * @param {Object} target\n\t         * @param {number} [time=500]\n\t         * @param {number} [delay=0]\n\t         *\n\t         * @example\n\t         *  // Animate position\n\t         *  el._animateToShallow({\n\t         *      position: [10, 10]\n\t         *  })\n\t         *\n\t         *  // Animate shape, style and position in 100ms, delayed 100ms\n\t         *  el._animateToShallow({\n\t         *      shape: {\n\t         *          width: 500\n\t         *      },\n\t         *      style: {\n\t         *          fill: 'red'\n\t         *      }\n\t         *      position: [10, 10]\n\t         *  }, 100, 100)\n\t         */\n\t        _animateToShallow: function (path, source, target, time, delay) {\n\t            var objShallow = {};\n\t            var propertyCount = 0;\n\t            for (var name in target) {\n\t                if (source[name] != null) {\n\t                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n\t                        this._animateToShallow(\n\t                            path ? path + '.' + name : name,\n\t                            source[name],\n\t                            target[name],\n\t                            time,\n\t                            delay\n\t                        );\n\t                    }\n\t                    else {\n\t                        objShallow[name] = target[name];\n\t                        propertyCount++;\n\t                    }\n\t                }\n\t                else if (target[name] != null) {\n\t                    // Attr directly if not has property\n\t                    // FIXME, if some property not needed for element ?\n\t                    if (!path) {\n\t                        this.attr(name, target[name]);\n\t                    }\n\t                    else {  // Shape or style\n\t                        var props = {};\n\t                        props[path] = {};\n\t                        props[path][name] = target[name];\n\t                        this.attr(props);\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (propertyCount > 0) {\n\t                this.animate(path, false)\n\t                    .when(time == null ? 500 : time, objShallow)\n\t                    .delay(delay || 0);\n\t            }\n\t\n\t            return this;\n\t        }\n\t    };\n\t\n\t    module.exports = Animatable;\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/animation/Animator\n\t */\n\t\n\t\n\t    var Clip = __webpack_require__(21);\n\t    var color = __webpack_require__(23);\n\t    var util = __webpack_require__(9);\n\t    var isArrayLike = util.isArrayLike;\n\t\n\t    var arraySlice = Array.prototype.slice;\n\t\n\t    function defaultGetter(target, key) {\n\t        return target[key];\n\t    }\n\t\n\t    function defaultSetter(target, key, value) {\n\t        target[key] = value;\n\t    }\n\t\n\t    /**\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} percent\n\t     * @return {number}\n\t     */\n\t    function interpolateNumber(p0, p1, percent) {\n\t        return (p1 - p0) * percent + p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {string} p0\n\t     * @param  {string} p1\n\t     * @param  {number} percent\n\t     * @return {string}\n\t     */\n\t    function interpolateString(p0, p1, percent) {\n\t        return percent > 0.5 ? p1 : p0;\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {number} percent\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function interpolateArray(p0, p1, percent, out, arrDim) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = interpolateNumber(p0[i], p1[i], percent);\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = interpolateNumber(\n\t                        p0[i][j], p1[i][j], percent\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function fillArr(arr0, arr1, arrDim) {\n\t        var arr0Len = arr0.length;\n\t        var arr1Len = arr1.length;\n\t        if (arr0Len === arr1Len) {\n\t            return;\n\t        }\n\t        // FIXME Not work for TypedArray\n\t        var isPreviousLarger = arr0Len > arr1Len;\n\t        if (isPreviousLarger) {\n\t            // Cut the previous\n\t            arr0.length = arr1Len;\n\t        }\n\t        else {\n\t            // Fill the previous\n\t            for (var i = arr0Len; i < arr1Len; i++) {\n\t                arr0.push(\n\t                    arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n\t                );\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param  {Array} arr0\n\t     * @param  {Array} arr1\n\t     * @param  {number} arrDim\n\t     * @return {boolean}\n\t     */\n\t    function isArraySame(arr0, arr1, arrDim) {\n\t        if (arr0 === arr1) {\n\t            return true;\n\t        }\n\t        var len = arr0.length;\n\t        if (len !== arr1.length) {\n\t            return false;\n\t        }\n\t        if (arrDim === 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                if (arr0[i] !== arr1[i]) {\n\t                    return false;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var len2 = arr0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    if (arr0[i][j] !== arr1[i][j]) {\n\t                        return false;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate array\n\t     * @param  {Array} p0\n\t     * @param  {Array} p1\n\t     * @param  {Array} p2\n\t     * @param  {Array} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @param  {Array} out\n\t     * @param  {number} arrDim\n\t     */\n\t    function catmullRomInterpolateArray(\n\t        p0, p1, p2, p3, t, t2, t3, out, arrDim\n\t    ) {\n\t        var len = p0.length;\n\t        if (arrDim == 1) {\n\t            for (var i = 0; i < len; i++) {\n\t                out[i] = catmullRomInterpolate(\n\t                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n\t                );\n\t            }\n\t        }\n\t        else {\n\t            var len2 = p0[0].length;\n\t            for (var i = 0; i < len; i++) {\n\t                for (var j = 0; j < len2; j++) {\n\t                    out[i][j] = catmullRomInterpolate(\n\t                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n\t                        t, t2, t3\n\t                    );\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Catmull Rom interpolate number\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {number} t2\n\t     * @param  {number} t3\n\t     * @return {number}\n\t     */\n\t    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    function cloneValue(value) {\n\t        if (isArrayLike(value)) {\n\t            var len = value.length;\n\t            if (isArrayLike(value[0])) {\n\t                var ret = [];\n\t                for (var i = 0; i < len; i++) {\n\t                    ret.push(arraySlice.call(value[i]));\n\t                }\n\t                return ret;\n\t            }\n\t\n\t            return arraySlice.call(value);\n\t        }\n\t\n\t        return value;\n\t    }\n\t\n\t    function rgba2String(rgba) {\n\t        rgba[0] = Math.floor(rgba[0]);\n\t        rgba[1] = Math.floor(rgba[1]);\n\t        rgba[2] = Math.floor(rgba[2]);\n\t\n\t        return 'rgba(' + rgba.join(',') + ')';\n\t    }\n\t\n\t    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n\t        var getter = animator._getter;\n\t        var setter = animator._setter;\n\t        var useSpline = easing === 'spline';\n\t\n\t        var trackLen = keyframes.length;\n\t        if (!trackLen) {\n\t            return;\n\t        }\n\t        // Guess data type\n\t        var firstVal = keyframes[0].value;\n\t        var isValueArray = isArrayLike(firstVal);\n\t        var isValueColor = false;\n\t        var isValueString = false;\n\t\n\t        // For vertices morphing\n\t        var arrDim = (\n\t                isValueArray\n\t                && isArrayLike(firstVal[0])\n\t            )\n\t            ? 2 : 1;\n\t        var trackMaxTime;\n\t        // Sort keyframe as ascending\n\t        keyframes.sort(function(a, b) {\n\t            return a.time - b.time;\n\t        });\n\t\n\t        trackMaxTime = keyframes[trackLen - 1].time;\n\t        // Percents of each keyframe\n\t        var kfPercents = [];\n\t        // Value of each keyframe\n\t        var kfValues = [];\n\t        var prevValue = keyframes[0].value;\n\t        var isAllValueEqual = true;\n\t        for (var i = 0; i < trackLen; i++) {\n\t            kfPercents.push(keyframes[i].time / trackMaxTime);\n\t            // Assume value is a color when it is a string\n\t            var value = keyframes[i].value;\n\t\n\t            // Check if value is equal, deep check if value is array\n\t            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n\t                || (!isValueArray && value === prevValue))) {\n\t                isAllValueEqual = false;\n\t            }\n\t            prevValue = value;\n\t\n\t            // Try converting a string to a color array\n\t            if (typeof value == 'string') {\n\t                var colorArray = color.parse(value);\n\t                if (colorArray) {\n\t                    value = colorArray;\n\t                    isValueColor = true;\n\t                }\n\t                else {\n\t                    isValueString = true;\n\t                }\n\t            }\n\t            kfValues.push(value);\n\t        }\n\t        if (isAllValueEqual) {\n\t            return;\n\t        }\n\t\n\t        if (isValueArray) {\n\t            var lastValue = kfValues[trackLen - 1];\n\t            // Polyfill array\n\t            for (var i = 0; i < trackLen - 1; i++) {\n\t                fillArr(kfValues[i], lastValue, arrDim);\n\t            }\n\t            fillArr(getter(animator._target, propName), lastValue, arrDim);\n\t        }\n\t\n\t        // Cache the key of last frame to speed up when\n\t        // animation playback is sequency\n\t        var lastFrame = 0;\n\t        var lastFramePercent = 0;\n\t        var start;\n\t        var w;\n\t        var p0;\n\t        var p1;\n\t        var p2;\n\t        var p3;\n\t\n\t        if (isValueColor) {\n\t            var rgba = [0, 0, 0, 0];\n\t        }\n\t\n\t        var onframe = function (target, percent) {\n\t            // Find the range keyframes\n\t            // kf1-----kf2---------current--------kf3\n\t            // find kf2 and kf3 and do interpolation\n\t            var frame;\n\t            if (percent < lastFramePercent) {\n\t                // Start from next key\n\t                start = Math.min(lastFrame + 1, trackLen - 1);\n\t                for (frame = start; frame >= 0; frame--) {\n\t                    if (kfPercents[frame] <= percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame, trackLen - 2);\n\t            }\n\t            else {\n\t                for (frame = lastFrame; frame < trackLen; frame++) {\n\t                    if (kfPercents[frame] > percent) {\n\t                        break;\n\t                    }\n\t                }\n\t                frame = Math.min(frame - 1, trackLen - 2);\n\t            }\n\t            lastFrame = frame;\n\t            lastFramePercent = percent;\n\t\n\t            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n\t            if (range === 0) {\n\t                return;\n\t            }\n\t            else {\n\t                w = (percent - kfPercents[frame]) / range;\n\t            }\n\t            if (useSpline) {\n\t                p1 = kfValues[frame];\n\t                p0 = kfValues[frame === 0 ? frame : frame - 1];\n\t                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n\t                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\t                if (isValueArray) {\n\t                    catmullRomInterpolateArray(\n\t                        p0, p1, p2, p3, w, w * w, w * w * w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        value = catmullRomInterpolateArray(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(p1, p2, w);\n\t                    }\n\t                    else {\n\t                        value = catmullRomInterpolate(\n\t                            p0, p1, p2, p3, w, w * w, w * w * w\n\t                        );\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t            else {\n\t                if (isValueArray) {\n\t                    interpolateArray(\n\t                        kfValues[frame], kfValues[frame + 1], w,\n\t                        getter(target, propName),\n\t                        arrDim\n\t                    );\n\t                }\n\t                else {\n\t                    var value;\n\t                    if (isValueColor) {\n\t                        interpolateArray(\n\t                            kfValues[frame], kfValues[frame + 1], w,\n\t                            rgba, 1\n\t                        );\n\t                        value = rgba2String(rgba);\n\t                    }\n\t                    else if (isValueString) {\n\t                        // String is step(0.5)\n\t                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    else {\n\t                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n\t                    }\n\t                    setter(\n\t                        target,\n\t                        propName,\n\t                        value\n\t                    );\n\t                }\n\t            }\n\t        };\n\t\n\t        var clip = new Clip({\n\t            target: animator._target,\n\t            life: trackMaxTime,\n\t            loop: animator._loop,\n\t            delay: animator._delay,\n\t            onframe: onframe,\n\t            ondestroy: oneTrackDone\n\t        });\n\t\n\t        if (easing && easing !== 'spline') {\n\t            clip.easing = easing;\n\t        }\n\t\n\t        return clip;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animator\n\t     * @constructor\n\t     * @param {Object} target\n\t     * @param {boolean} loop\n\t     * @param {Function} getter\n\t     * @param {Function} setter\n\t     */\n\t    var Animator = function(target, loop, getter, setter) {\n\t        this._tracks = {};\n\t        this._target = target;\n\t\n\t        this._loop = loop || false;\n\t\n\t        this._getter = getter || defaultGetter;\n\t        this._setter = setter || defaultSetter;\n\t\n\t        this._clipCount = 0;\n\t\n\t        this._delay = 0;\n\t\n\t        this._doneList = [];\n\t\n\t        this._onframeList = [];\n\t\n\t        this._clipList = [];\n\t    };\n\t\n\t    Animator.prototype = {\n\t        /**\n\t         * 设置动画关键帧\n\t         * @param  {number} time 关键帧时间，单位是ms\n\t         * @param  {Object} props 关键帧的属性值，key-value表示\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        when: function(time /* ms */, props) {\n\t            var tracks = this._tracks;\n\t            for (var propName in props) {\n\t                if (!tracks[propName]) {\n\t                    tracks[propName] = [];\n\t                    // Invalid value\n\t                    var value = this._getter(this._target, propName);\n\t                    if (value == null) {\n\t                        // zrLog('Invalid property ' + propName);\n\t                        continue;\n\t                    }\n\t                    // If time is 0\n\t                    //  Then props is given initialize value\n\t                    // Else\n\t                    //  Initialize value from current prop value\n\t                    if (time !== 0) {\n\t                        tracks[propName].push({\n\t                            time: 0,\n\t                            value: cloneValue(value)\n\t                        });\n\t                    }\n\t                }\n\t                tracks[propName].push({\n\t                    time: time,\n\t                    value: props[propName]\n\t                });\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画每一帧的回调函数\n\t         * @param  {Function} callback\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        during: function (callback) {\n\t            this._onframeList.push(callback);\n\t            return this;\n\t        },\n\t\n\t        _doneCallback: function () {\n\t            // Clear all tracks\n\t            this._tracks = {};\n\t            // Clear all clips\n\t            this._clipList.length = 0;\n\t\n\t            var doneList = this._doneList;\n\t            var len = doneList.length;\n\t            for (var i = 0; i < len; i++) {\n\t                doneList[i].call(this);\n\t            }\n\t        },\n\t        /**\n\t         * 开始执行动画\n\t         * @param  {string|Function} easing\n\t         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        start: function (easing) {\n\t\n\t            var self = this;\n\t            var clipCount = 0;\n\t\n\t            var oneTrackDone = function() {\n\t                clipCount--;\n\t                if (!clipCount) {\n\t                    self._doneCallback();\n\t                }\n\t            };\n\t\n\t            var lastClip;\n\t            for (var propName in this._tracks) {\n\t                var clip = createTrackClip(\n\t                    this, easing, oneTrackDone,\n\t                    this._tracks[propName], propName\n\t                );\n\t                if (clip) {\n\t                    this._clipList.push(clip);\n\t                    clipCount++;\n\t\n\t                    // If start after added to animation\n\t                    if (this.animation) {\n\t                        this.animation.addClip(clip);\n\t                    }\n\t\n\t                    lastClip = clip;\n\t                }\n\t            }\n\t\n\t            // Add during callback on the last clip\n\t            if (lastClip) {\n\t                var oldOnFrame = lastClip.onframe;\n\t                lastClip.onframe = function (target, percent) {\n\t                    oldOnFrame(target, percent);\n\t\n\t                    for (var i = 0; i < self._onframeList.length; i++) {\n\t                        self._onframeList[i](target, percent);\n\t                    }\n\t                };\n\t            }\n\t\n\t            if (!clipCount) {\n\t                this._doneCallback();\n\t            }\n\t            return this;\n\t        },\n\t        /**\n\t         * 停止动画\n\t         * @param {boolean} forwardToLast If move to last frame before stop\n\t         */\n\t        stop: function (forwardToLast) {\n\t            var clipList = this._clipList;\n\t            var animation = this.animation;\n\t            for (var i = 0; i < clipList.length; i++) {\n\t                var clip = clipList[i];\n\t                if (forwardToLast) {\n\t                    // Move to last frame before stop\n\t                    clip.onframe(this._target, 1);\n\t                }\n\t                animation && animation.removeClip(clip);\n\t            }\n\t            clipList.length = 0;\n\t        },\n\t        /**\n\t         * 设置动画延迟开始的时间\n\t         * @param  {number} time 单位ms\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        delay: function (time) {\n\t            this._delay = time;\n\t            return this;\n\t        },\n\t        /**\n\t         * 添加动画结束的回调\n\t         * @param  {Function} cb\n\t         * @return {module:zrender/animation/Animator}\n\t         */\n\t        done: function(cb) {\n\t            if (cb) {\n\t                this._doneList.push(cb);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:zrender/animation/Clip>}\n\t         */\n\t        getClips: function () {\n\t            return this._clipList;\n\t        }\n\t    };\n\t\n\t    module.exports = Animator;\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 动画主控制器\n\t * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n\t * @config life(1000) 动画时长\n\t * @config delay(0) 动画延迟时间\n\t * @config loop(true)\n\t * @config gap(0) 循环的间隔时间\n\t * @config onframe\n\t * @config easing(optional)\n\t * @config ondestroy(optional)\n\t * @config onrestart(optional)\n\t *\n\t * TODO pause\n\t */\n\t\n\t\n\t    var easingFuncs = __webpack_require__(22);\n\t\n\t    function Clip(options) {\n\t\n\t        this._target = options.target;\n\t\n\t        // 生命周期\n\t        this._life = options.life || 1000;\n\t        // 延时\n\t        this._delay = options.delay || 0;\n\t        // 开始时间\n\t        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\t        this._initialized = false;\n\t\n\t        // 是否循环\n\t        this.loop = options.loop == null ? false : options.loop;\n\t\n\t        this.gap = options.gap || 0;\n\t\n\t        this.easing = options.easing || 'Linear';\n\t\n\t        this.onframe = options.onframe;\n\t        this.ondestroy = options.ondestroy;\n\t        this.onrestart = options.onrestart;\n\t    }\n\t\n\t    Clip.prototype = {\n\t\n\t        constructor: Clip,\n\t\n\t        step: function (time) {\n\t            // Set startTime on first step, or _startTime may has milleseconds different between clips\n\t            // PENDING\n\t            if (!this._initialized) {\n\t                this._startTime = new Date().getTime() + this._delay;\n\t                this._initialized = true;\n\t            }\n\t\n\t            var percent = (time - this._startTime) / this._life;\n\t\n\t            // 还没开始\n\t            if (percent < 0) {\n\t                return;\n\t            }\n\t\n\t            percent = Math.min(percent, 1);\n\t\n\t            var easing = this.easing;\n\t            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n\t            var schedule = typeof easingFunc === 'function'\n\t                ? easingFunc(percent)\n\t                : percent;\n\t\n\t            this.fire('frame', schedule);\n\t\n\t            // 结束\n\t            if (percent == 1) {\n\t                if (this.loop) {\n\t                    this.restart();\n\t                    // 重新开始周期\n\t                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\t                    return 'restart';\n\t                }\n\t\n\t                // 动画完成将这个控制器标识为待删除\n\t                // 在Animation.update中进行批量删除\n\t                this._needsRemove = true;\n\t                return 'destroy';\n\t            }\n\t\n\t            return null;\n\t        },\n\t\n\t        restart: function() {\n\t            var time = new Date().getTime();\n\t            var remainder = (time - this._startTime) % this._life;\n\t            this._startTime = new Date().getTime() - remainder + this.gap;\n\t\n\t            this._needsRemove = false;\n\t        },\n\t\n\t        fire: function(eventType, arg) {\n\t            eventType = 'on' + eventType;\n\t            if (this[eventType]) {\n\t                this[eventType](this._target, arg);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Clip;\n\t\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t/**\n\t * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n\t * @see http://sole.github.io/tween.js/examples/03_graphs.html\n\t * @exports zrender/animation/easing\n\t */\n\t\n\t    var easing = {\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        linear: function (k) {\n\t            return k;\n\t        },\n\t\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticIn: function (k) {\n\t            return k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticOut: function (k) {\n\t            return k * (2 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quadraticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k;\n\t            }\n\t            return -0.5 * (--k * (k - 2) - 1);\n\t        },\n\t\n\t        // 三次方的缓动（t^3）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicIn: function (k) {\n\t            return k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicOut: function (k) {\n\t            return --k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        cubicInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k + 2);\n\t        },\n\t\n\t        // 四次方的缓动（t^4）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticIn: function (k) {\n\t            return k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticOut: function (k) {\n\t            return 1 - (--k * k * k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quarticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k;\n\t            }\n\t            return -0.5 * ((k -= 2) * k * k * k - 2);\n\t        },\n\t\n\t        // 五次方的缓动（t^5）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticIn: function (k) {\n\t            return k * k * k * k * k;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticOut: function (k) {\n\t            return --k * k * k * k * k + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        quinticInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * k * k * k * k * k;\n\t            }\n\t            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t        },\n\t\n\t        // 正弦曲线的缓动（sin(t)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalIn: function (k) {\n\t            return 1 - Math.cos(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalOut: function (k) {\n\t            return Math.sin(k * Math.PI / 2);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        sinusoidalInOut: function (k) {\n\t            return 0.5 * (1 - Math.cos(Math.PI * k));\n\t        },\n\t\n\t        // 指数曲线的缓动（2^t）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialIn: function (k) {\n\t            return k === 0 ? 0 : Math.pow(1024, k - 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialOut: function (k) {\n\t            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        exponentialInOut: function (k) {\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * Math.pow(1024, k - 1);\n\t            }\n\t            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n\t        },\n\t\n\t        // 圆形曲线的缓动（sqrt(1-t^2)）\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularIn: function (k) {\n\t            return 1 - Math.sqrt(1 - k * k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularOut: function (k) {\n\t            return Math.sqrt(1 - (--k * k));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        circularInOut: function (k) {\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n\t            }\n\t            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t        },\n\t\n\t        // 创建类似于弹簧在停止前来回振荡的动画\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticIn: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return -(a * Math.pow(2, 10 * (k -= 1)) *\n\t                        Math.sin((k - s) * (2 * Math.PI) / p));\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            return (a * Math.pow(2, -10 * k) *\n\t                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        elasticInOut: function (k) {\n\t            var s;\n\t            var a = 0.1;\n\t            var p = 0.4;\n\t            if (k === 0) {\n\t                return 0;\n\t            }\n\t            if (k === 1) {\n\t                return 1;\n\t            }\n\t            if (!a || a < 1) {\n\t                a = 1; s = p / 4;\n\t            }\n\t            else {\n\t                s = p * Math.asin(1 / a) / (2 * Math.PI);\n\t            }\n\t            if ((k *= 2) < 1) {\n\t                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p));\n\t            }\n\t            return a * Math.pow(2, -10 * (k -= 1))\n\t                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\t\n\t        },\n\t\n\t        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backIn: function (k) {\n\t            var s = 1.70158;\n\t            return k * k * ((s + 1) * k - s);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backOut: function (k) {\n\t            var s = 1.70158;\n\t            return --k * k * ((s + 1) * k + s) + 1;\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        backInOut: function (k) {\n\t            var s = 1.70158 * 1.525;\n\t            if ((k *= 2) < 1) {\n\t                return 0.5 * (k * k * ((s + 1) * k - s));\n\t            }\n\t            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t        },\n\t\n\t        // 创建弹跳效果\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceIn: function (k) {\n\t            return 1 - easing.bounceOut(1 - k);\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceOut: function (k) {\n\t            if (k < (1 / 2.75)) {\n\t                return 7.5625 * k * k;\n\t            }\n\t            else if (k < (2 / 2.75)) {\n\t                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t            }\n\t            else if (k < (2.5 / 2.75)) {\n\t                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t            }\n\t            else {\n\t                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t            }\n\t        },\n\t        /**\n\t        * @param {number} k\n\t        * @return {number}\n\t        */\n\t        bounceInOut: function (k) {\n\t            if (k < 0.5) {\n\t                return easing.bounceIn(k * 2) * 0.5;\n\t            }\n\t            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n\t        }\n\t    };\n\t\n\t    module.exports = easing;\n\t\n\t\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/tool/color\n\t */\n\t\n\t\n\t    var kCSSColorTable = {\n\t        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n\t        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n\t        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n\t        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n\t        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n\t        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n\t        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n\t        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n\t        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n\t        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n\t        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n\t        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n\t        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n\t        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n\t        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n\t        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n\t        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n\t        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n\t        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n\t        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n\t        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n\t        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n\t        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n\t        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n\t        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n\t        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n\t        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n\t        'gray': [128,128,128,1], 'green': [0,128,0,1],\n\t        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n\t        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n\t        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n\t        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n\t        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n\t        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n\t        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n\t        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n\t        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n\t        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n\t        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n\t        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n\t        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n\t        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n\t        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n\t        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n\t        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n\t        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n\t        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n\t        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n\t        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n\t        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n\t        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n\t        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n\t        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n\t        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n\t        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n\t        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n\t        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n\t        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n\t        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n\t        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n\t        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n\t        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n\t        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n\t        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n\t        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n\t        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n\t        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n\t        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n\t        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n\t        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n\t        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n\t        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n\t        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n\t        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n\t    };\n\t\n\t    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 255 ? 255 : i;\n\t    }\n\t\n\t    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n\t        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n\t        return i < 0 ? 0 : i > 360 ? 360 : i;\n\t    }\n\t\n\t    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n\t        return f < 0 ? 0 : f > 1 ? 1 : f;\n\t    }\n\t\n\t    function parseCssInt(str) {  // int or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssByte(parseFloat(str) / 100 * 255);\n\t        }\n\t        return clampCssByte(parseInt(str, 10));\n\t    }\n\t\n\t    function parseCssFloat(str) {  // float or percentage.\n\t        if (str.length && str.charAt(str.length - 1) === '%') {\n\t            return clampCssFloat(parseFloat(str) / 100);\n\t        }\n\t        return clampCssFloat(parseFloat(str));\n\t    }\n\t\n\t    function cssHueToRgb(m1, m2, h) {\n\t        if (h < 0) {\n\t            h += 1;\n\t        }\n\t        else if (h > 1) {\n\t            h -= 1;\n\t        }\n\t\n\t        if (h * 6 < 1) {\n\t            return m1 + (m2 - m1) * h * 6;\n\t        }\n\t        if (h * 2 < 1) {\n\t            return m2;\n\t        }\n\t        if (h * 3 < 2) {\n\t            return m1 + (m2 - m1) * (2/3 - h) * 6;\n\t        }\n\t        return m1;\n\t    }\n\t\n\t    function lerp(a, b, p) {\n\t        return a + (b - a) * p;\n\t    }\n\t\n\t    /**\n\t     * @param {string} colorStr\n\t     * @return {Array.<number>}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function parse(colorStr) {\n\t        if (!colorStr) {\n\t            return;\n\t        }\n\t        // colorStr may be not string\n\t        colorStr = colorStr + '';\n\t        // Remove all whitespace, not compliant, but should just be more accepting.\n\t        var str = colorStr.replace(/ /g, '').toLowerCase();\n\t\n\t        // Color keywords (and transparent) lookup.\n\t        if (str in kCSSColorTable) {\n\t            return kCSSColorTable[str].slice();  // dup.\n\t        }\n\t\n\t        // #abc and #abc123 syntax.\n\t        if (str.charAt(0) === '#') {\n\t            if (str.length === 4) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xfff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n\t                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n\t                    (iv & 0xf) | ((iv & 0xf) << 4),\n\t                    1\n\t                ];\n\t            }\n\t            else if (str.length === 7) {\n\t                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n\t                if (!(iv >= 0 && iv <= 0xffffff)) {\n\t                    return;  // Covers NaN.\n\t                }\n\t                return [\n\t                    (iv & 0xff0000) >> 16,\n\t                    (iv & 0xff00) >> 8,\n\t                    iv & 0xff,\n\t                    1\n\t                ];\n\t            }\n\t\n\t            return;\n\t        }\n\t        var op = str.indexOf('('), ep = str.indexOf(')');\n\t        if (op !== -1 && ep + 1 === str.length) {\n\t            var fname = str.substr(0, op);\n\t            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n\t            var alpha = 1;  // To allow case fallthrough.\n\t            switch (fname) {\n\t                case 'rgba':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n\t                // Fall through.\n\t                case 'rgb':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return [\n\t                        parseCssInt(params[0]),\n\t                        parseCssInt(params[1]),\n\t                        parseCssInt(params[2]),\n\t                        alpha\n\t                    ];\n\t                case 'hsla':\n\t                    if (params.length !== 4) {\n\t                        return;\n\t                    }\n\t                    params[3] = parseCssFloat(params[3]);\n\t                    return hsla2rgba(params);\n\t                case 'hsl':\n\t                    if (params.length !== 3) {\n\t                        return;\n\t                    }\n\t                    return hsla2rgba(params);\n\t                default:\n\t                    return;\n\t            }\n\t        }\n\t\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} hsla\n\t     * @return {Array.<number>} rgba\n\t     */\n\t    function hsla2rgba(hsla) {\n\t        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n\t        // NOTE(deanm): According to the CSS spec s/l should only be\n\t        // percentages, but we don't bother and let float or percentage.\n\t        var s = parseCssFloat(hsla[1]);\n\t        var l = parseCssFloat(hsla[2]);\n\t        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\t        var m1 = l * 2 - m2;\n\t\n\t        var rgba = [\n\t            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n\t            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n\t        ];\n\t\n\t        if (hsla.length === 4) {\n\t            rgba[3] = hsla[3];\n\t        }\n\t\n\t        return rgba;\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<number>} rgba\n\t     * @return {Array.<number>} hsla\n\t     */\n\t    function rgba2hsla(rgba) {\n\t        if (!rgba) {\n\t            return;\n\t        }\n\t\n\t        // RGB from 0 to 255\n\t        var R = rgba[0] / 255;\n\t        var G = rgba[1] / 255;\n\t        var B = rgba[2] / 255;\n\t\n\t        var vMin = Math.min(R, G, B); // Min. value of RGB\n\t        var vMax = Math.max(R, G, B); // Max. value of RGB\n\t        var delta = vMax - vMin; // Delta RGB value\n\t\n\t        var L = (vMax + vMin) / 2;\n\t        var H;\n\t        var S;\n\t        // HSL results from 0 to 1\n\t        if (delta === 0) {\n\t            H = 0;\n\t            S = 0;\n\t        }\n\t        else {\n\t            if (L < 0.5) {\n\t                S = delta / (vMax + vMin);\n\t            }\n\t            else {\n\t                S = delta / (2 - vMax - vMin);\n\t            }\n\t\n\t            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n\t            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n\t            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\t\n\t            if (R === vMax) {\n\t                H = deltaB - deltaG;\n\t            }\n\t            else if (G === vMax) {\n\t                H = (1 / 3) + deltaR - deltaB;\n\t            }\n\t            else if (B === vMax) {\n\t                H = (2 / 3) + deltaG - deltaR;\n\t            }\n\t\n\t            if (H < 0) {\n\t                H += 1;\n\t            }\n\t\n\t            if (H > 1) {\n\t                H -= 1;\n\t            }\n\t        }\n\t\n\t        var hsla = [H * 360, S, L];\n\t\n\t        if (rgba[3] != null) {\n\t            hsla.push(rgba[3]);\n\t        }\n\t\n\t        return hsla;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number} level\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function lift(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            for (var i = 0; i < 3; i++) {\n\t                if (level < 0) {\n\t                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n\t                }\n\t                else {\n\t                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n\t                }\n\t            }\n\t            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @return {string}\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function toHex(color, level) {\n\t        var colorArr = parse(color);\n\t        if (colorArr) {\n\t            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<Array.<number>>} colors List of rgba color array\n\t     * @param {Array.<number>} [out] Mapped gba color array\n\t     * @return {Array.<number>}\n\t     */\n\t    function fastMapToColor(normalizedValue, colors, out) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t        out = out || [0, 0, 0, 0];\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = colors[leftIndex];\n\t        var rightColor = colors[rightIndex];\n\t        var dv = value - leftIndex;\n\t        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n\t        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n\t        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n\t        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n\t        return out;\n\t    }\n\t    /**\n\t     * @param {number} normalizedValue A float between 0 and 1.\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {boolean=} fullOutput Default false.\n\t     * @return {(string|Object)} Result color. If fullOutput,\n\t     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapToColor(normalizedValue, colors, fullOutput) {\n\t        if (!(colors && colors.length)\n\t            || !(normalizedValue >= 0 && normalizedValue <= 1)\n\t        ) {\n\t            return;\n\t        }\n\t\n\t        var value = normalizedValue * (colors.length - 1);\n\t        var leftIndex = Math.floor(value);\n\t        var rightIndex = Math.ceil(value);\n\t        var leftColor = parse(colors[leftIndex]);\n\t        var rightColor = parse(colors[rightIndex]);\n\t        var dv = value - leftIndex;\n\t\n\t        var color = stringify(\n\t            [\n\t                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n\t                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n\t                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n\t                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n\t            ],\n\t            'rgba'\n\t        );\n\t\n\t        return fullOutput\n\t            ? {\n\t                color: color,\n\t                leftIndex: leftIndex,\n\t                rightIndex: rightIndex,\n\t                value: value\n\t            }\n\t            : color;\n\t    }\n\t\n\t    /**\n\t     * @param {Array<number>} interval  Array length === 2,\n\t     *                                  each item is normalized value ([0, 1]).\n\t     * @param {Array.<string>} colors Color list.\n\t     * @return {Array.<Object>} colors corresponding to the interval,\n\t     *                          each item is {color: 'xxx', offset: ...}\n\t     *                          where offset is between 0 and 1.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function mapIntervalToColor(interval, colors) {\n\t        if (interval.length !== 2 || interval[1] < interval[0]) {\n\t            return;\n\t        }\n\t\n\t        var info0 = mapToColor(interval[0], colors, true);\n\t        var info1 = mapToColor(interval[1], colors, true);\n\t\n\t        var result = [{color: info0.color, offset: 0}];\n\t\n\t        var during = info1.value - info0.value;\n\t        var start = Math.max(info0.value, info0.rightIndex);\n\t        var end = Math.min(info1.value, info1.leftIndex);\n\t\n\t        for (var i = start; during > 0 && i <= end; i++) {\n\t            result.push({\n\t                color: colors[i],\n\t                offset: (i - info0.value) / during\n\t            });\n\t        }\n\t        result.push({color: info1.color, offset: 1});\n\t\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} h 0 ~ 360, ignore when null.\n\t     * @param {number=} s 0 ~ 1, ignore when null.\n\t     * @param {number=} l 0 ~ 1, ignore when null.\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyHSL(color, h, s, l) {\n\t        color = parse(color);\n\t\n\t        if (color) {\n\t            color = rgba2hsla(color);\n\t            h != null && (color[0] = clampCssAngle(h));\n\t            s != null && (color[1] = parseCssFloat(s));\n\t            l != null && (color[2] = parseCssFloat(l));\n\t\n\t            return stringify(hsla2rgba(color), 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {string} color\n\t     * @param {number=} alpha 0 ~ 1\n\t     * @return {string} Color string in rgba format.\n\t     * @memberOf module:zrender/util/color\n\t     */\n\t    function modifyAlpha(color, alpha) {\n\t        color = parse(color);\n\t\n\t        if (color && alpha != null) {\n\t            color[3] = clampCssFloat(alpha);\n\t            return stringify(color, 'rgba');\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @param {Array.<string>} colors Color list.\n\t     * @param {string} type 'rgba', 'hsva', ...\n\t     * @return {string} Result color.\n\t     */\n\t    function stringify(arrColor, type) {\n\t        if (type === 'rgb' || type === 'hsv' || type === 'hsl') {\n\t            arrColor = arrColor.slice(0, 3);\n\t        }\n\t        return type + '(' + arrColor.join(',') + ')';\n\t    }\n\t\n\t    module.exports = {\n\t        parse: parse,\n\t        lift: lift,\n\t        toHex: toHex,\n\t        fastMapToColor: fastMapToColor,\n\t        mapToColor: mapToColor,\n\t        mapIntervalToColor: mapIntervalToColor,\n\t        modifyHSL: modifyHSL,\n\t        modifyAlpha: modifyAlpha,\n\t        stringify: stringify\n\t    };\n\t\n\t\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t        var config = __webpack_require__(25);\n\t\n\t        /**\n\t         * @exports zrender/tool/log\n\t         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t         */\n\t        module.exports = function() {\n\t            if (config.debugMode === 0) {\n\t                return;\n\t            }\n\t            else if (config.debugMode == 1) {\n\t                for (var k in arguments) {\n\t                    throw new Error(arguments[k]);\n\t                }\n\t            }\n\t            else if (config.debugMode > 1) {\n\t                for (var k in arguments) {\n\t                    console.log(arguments[k]);\n\t                }\n\t            }\n\t        };\n\t\n\t        /* for debug\n\t        return function(mes) {\n\t            document.getElementById('wrong-message').innerHTML =\n\t                mes + ' ' + (new Date() - 0)\n\t                + '<br/>' \n\t                + document.getElementById('wrong-message').innerHTML;\n\t        };\n\t        */\n\t    \n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t\n\t    var dpr = 1;\n\t    // If in browser environment\n\t    if (typeof window !== 'undefined') {\n\t        dpr = Math.max(window.devicePixelRatio || 1, 1);\n\t    }\n\t    /**\n\t     * config默认配置项\n\t     * @exports zrender/config\n\t     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t     */\n\t    var config = {\n\t        /**\n\t         * debug日志选项：catchBrushException为true下有效\n\t         * 0 : 不生成debug数据，发布用\n\t         * 1 : 异常抛出，调试用\n\t         * 2 : 控制台输出，调试用\n\t         */\n\t        debugMode: 0,\n\t\n\t        // retina 屏幕优化\n\t        devicePixelRatio: dpr\n\t    };\n\t    module.exports = config;\n\t\n\t\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * @module echarts/core/BoundingRect\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(18);\n\t    var matrix = __webpack_require__(17);\n\t\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var mathMin = Math.min;\n\t    var mathAbs = Math.abs;\n\t    var mathMax = Math.max;\n\t    /**\n\t     * @alias module:echarts/core/BoundingRect\n\t     */\n\t    function BoundingRect(x, y, width, height) {\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.x = x;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.y = y;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.width = width;\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.height = height;\n\t    }\n\t\n\t    BoundingRect.prototype = {\n\t\n\t        constructor: BoundingRect,\n\t\n\t        /**\n\t         * @param {module:echarts/core/BoundingRect} other\n\t         */\n\t        union: function (other) {\n\t            var x = mathMin(other.x, this.x);\n\t            var y = mathMin(other.y, this.y);\n\t\n\t            this.width = mathMax(\n\t                    other.x + other.width,\n\t                    this.x + this.width\n\t                ) - x;\n\t            this.height = mathMax(\n\t                    other.y + other.height,\n\t                    this.y + this.height\n\t                ) - y;\n\t            this.x = x;\n\t            this.y = y;\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} m\n\t         * @methods\n\t         */\n\t        applyTransform: (function () {\n\t            var min = [];\n\t            var max = [];\n\t            return function (m) {\n\t                // In case usage like this\n\t                // el.getBoundingRect().applyTransform(el.transform)\n\t                // And element has no transform\n\t                if (!m) {\n\t                    return;\n\t                }\n\t                min[0] = this.x;\n\t                min[1] = this.y;\n\t                max[0] = this.x + this.width;\n\t                max[1] = this.y + this.height;\n\t\n\t                v2ApplyTransform(min, min, m);\n\t                v2ApplyTransform(max, max, m);\n\t\n\t                this.x = mathMin(min[0], max[0]);\n\t                this.y = mathMin(min[1], max[1]);\n\t                this.width = mathAbs(max[0] - min[0]);\n\t                this.height = mathAbs(max[1] - min[1]);\n\t            };\n\t        })(),\n\t\n\t        /**\n\t         * Calculate matrix of transforming from self to target rect\n\t         * @param  {module:zrender/core/BoundingRect} b\n\t         * @return {Array.<number>}\n\t         */\n\t        calculateTransform: function (b) {\n\t            var a = this;\n\t            var sx = b.width / a.width;\n\t            var sy = b.height / a.height;\n\t\n\t            var m = matrix.create();\n\t\n\t            // 矩阵右乘\n\t            matrix.translate(m, m, [-a.x, -a.y]);\n\t            matrix.scale(m, m, [sx, sy]);\n\t            matrix.translate(m, m, [b.x, b.y]);\n\t\n\t            return m;\n\t        },\n\t\n\t        /**\n\t         * @param {(module:echarts/core/BoundingRect|Object)} b\n\t         * @return {boolean}\n\t         */\n\t        intersect: function (b) {\n\t            var a = this;\n\t            var ax0 = a.x;\n\t            var ax1 = a.x + a.width;\n\t            var ay0 = a.y;\n\t            var ay1 = a.y + a.height;\n\t\n\t            var bx0 = b.x;\n\t            var bx1 = b.x + b.width;\n\t            var by0 = b.y;\n\t            var by1 = b.y + b.height;\n\t\n\t            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var rect = this;\n\t            return x >= rect.x\n\t                && x <= (rect.x + rect.width)\n\t                && y >= rect.y\n\t                && y <= (rect.y + rect.height);\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/core/BoundingRect}\n\t         */\n\t        clone: function () {\n\t            return new BoundingRect(this.x, this.y, this.width, this.height);\n\t        },\n\t\n\t        /**\n\t         * Copy from another rect\n\t         */\n\t        copy: function (other) {\n\t            this.x = other.x;\n\t            this.y = other.y;\n\t            this.width = other.width;\n\t            this.height = other.height;\n\t        }\n\t    };\n\t\n\t    module.exports = BoundingRect;\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 动画主类, 调度和管理所有动画控制器\n\t *\n\t * @module zrender/animation/Animation\n\t * @author pissang(https://github.com/pissang)\n\t */\n\t// TODO Additive animation\n\t// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n\t// https://developer.apple.com/videos/wwdc2014/#236\n\t\n\t\n\t    var util = __webpack_require__(9);\n\t    var Dispatcher = __webpack_require__(7).Dispatcher;\n\t\n\t    var requestAnimationFrame = (typeof window !== 'undefined' &&\n\t                                    (window.requestAnimationFrame\n\t                                    || window.msRequestAnimationFrame\n\t                                    || window.mozRequestAnimationFrame\n\t                                    || window.webkitRequestAnimationFrame))\n\t                                || function (func) {\n\t                                    setTimeout(func, 16);\n\t                                };\n\t\n\t    var Animator = __webpack_require__(20);\n\t    /**\n\t     * @typedef {Object} IZRenderStage\n\t     * @property {Function} update\n\t     */\n\t\n\t    /**\n\t     * @alias module:zrender/animation/Animation\n\t     * @constructor\n\t     * @param {Object} [options]\n\t     * @param {Function} [options.onframe]\n\t     * @param {IZRenderStage} [options.stage]\n\t     * @example\n\t     *     var animation = new Animation();\n\t     *     var obj = {\n\t     *         x: 100,\n\t     *         y: 100\n\t     *     };\n\t     *     animation.animate(node.position)\n\t     *         .when(1000, {\n\t     *             x: 500,\n\t     *             y: 500\n\t     *         })\n\t     *         .when(2000, {\n\t     *             x: 100,\n\t     *             y: 100\n\t     *         })\n\t     *         .start('spline');\n\t     */\n\t    var Animation = function (options) {\n\t\n\t        options = options || {};\n\t\n\t        this.stage = options.stage || {};\n\t\n\t        this.onframe = options.onframe || function() {};\n\t\n\t        // private properties\n\t        this._clips = [];\n\t\n\t        this._running = false;\n\t\n\t        this._time = 0;\n\t\n\t        Dispatcher.call(this);\n\t    };\n\t\n\t    Animation.prototype = {\n\t\n\t        constructor: Animation,\n\t        /**\n\t         * 添加 clip\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        addClip: function (clip) {\n\t            this._clips.push(clip);\n\t        },\n\t        /**\n\t         * 添加 animator\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        addAnimator: function (animator) {\n\t            animator.animation = this;\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.addClip(clips[i]);\n\t            }\n\t        },\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Clip} clip\n\t         */\n\t        removeClip: function(clip) {\n\t            var idx = util.indexOf(this._clips, clip);\n\t            if (idx >= 0) {\n\t                this._clips.splice(idx, 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除动画片段\n\t         * @param {module:zrender/animation/Animator} animator\n\t         */\n\t        removeAnimator: function (animator) {\n\t            var clips = animator.getClips();\n\t            for (var i = 0; i < clips.length; i++) {\n\t                this.removeClip(clips[i]);\n\t            }\n\t            animator.animation = null;\n\t        },\n\t\n\t        _update: function() {\n\t\n\t            var time = new Date().getTime();\n\t            var delta = time - this._time;\n\t            var clips = this._clips;\n\t            var len = clips.length;\n\t\n\t            var deferredEvents = [];\n\t            var deferredClips = [];\n\t            for (var i = 0; i < len; i++) {\n\t                var clip = clips[i];\n\t                var e = clip.step(time);\n\t                // Throw out the events need to be called after\n\t                // stage.update, like destroy\n\t                if (e) {\n\t                    deferredEvents.push(e);\n\t                    deferredClips.push(clip);\n\t                }\n\t            }\n\t\n\t            // Remove the finished clip\n\t            for (var i = 0; i < len;) {\n\t                if (clips[i]._needsRemove) {\n\t                    clips[i] = clips[len - 1];\n\t                    clips.pop();\n\t                    len--;\n\t                }\n\t                else {\n\t                    i++;\n\t                }\n\t            }\n\t\n\t            len = deferredEvents.length;\n\t            for (var i = 0; i < len; i++) {\n\t                deferredClips[i].fire(deferredEvents[i]);\n\t            }\n\t\n\t            this._time = time;\n\t\n\t            this.onframe(delta);\n\t\n\t            this.trigger('frame', delta);\n\t\n\t            if (this.stage.update) {\n\t                this.stage.update();\n\t            }\n\t        },\n\t        /**\n\t         * 开始运行动画\n\t         */\n\t        start: function () {\n\t            var self = this;\n\t\n\t            this._running = true;\n\t\n\t            function step() {\n\t                if (self._running) {\n\t\n\t                    requestAnimationFrame(step);\n\t\n\t                    self._update();\n\t                }\n\t            }\n\t\n\t            this._time = new Date().getTime();\n\t            requestAnimationFrame(step);\n\t        },\n\t        /**\n\t         * 停止运行动画\n\t         */\n\t        stop: function () {\n\t            this._running = false;\n\t        },\n\t        /**\n\t         * 清除所有动画片段\n\t         */\n\t        clear: function () {\n\t            this._clips = [];\n\t        },\n\t        /**\n\t         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n\t         * @param  {Object} target\n\t         * @param  {Object} options\n\t         * @param  {boolean} [options.loop=false] 是否循环播放动画\n\t         * @param  {Function} [options.getter=null]\n\t         *         如果指定getter函数，会通过getter函数取属性值\n\t         * @param  {Function} [options.setter=null]\n\t         *         如果指定setter函数，会通过setter函数设置属性值\n\t         * @return {module:zrender/animation/Animation~Animator}\n\t         */\n\t        animate: function (target, options) {\n\t            options = options || {};\n\t            var animator = new Animator(\n\t                target,\n\t                options.loop,\n\t                options.getter,\n\t                options.setter\n\t            );\n\t\n\t            return animator;\n\t        }\n\t    };\n\t\n\t    util.mixin(Animation, Dispatcher);\n\t\n\t    module.exports = Animation;\n\t\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Default canvas painter\n\t * @module zrender/Painter\n\t * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t *         pissang (https://www.github.com/pissang)\n\t */\n\t \n\t\n\t    var config = __webpack_require__(25);\n\t    var util = __webpack_require__(9);\n\t    var log = __webpack_require__(24);\n\t    var BoundingRect = __webpack_require__(26);\n\t\n\t    var Layer = __webpack_require__(29);\n\t\n\t    function parseInt10(val) {\n\t        return parseInt(val, 10);\n\t    }\n\t\n\t    function isLayerValid(layer) {\n\t        if (!layer) {\n\t            return false;\n\t        }\n\t\n\t        if (layer.isBuildin) {\n\t            return true;\n\t        }\n\t\n\t        if (typeof(layer.resize) !== 'function'\n\t            || typeof(layer.refresh) !== 'function'\n\t        ) {\n\t            return false;\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    function preProcessLayer(layer) {\n\t        layer.__unusedCount++;\n\t    }\n\t\n\t    function postProcessLayer(layer) {\n\t        layer.__dirty = false;\n\t        if (layer.__unusedCount == 1) {\n\t            layer.clear();\n\t        }\n\t    }\n\t\n\t    var tmpRect = new BoundingRect(0, 0, 0, 0);\n\t    var viewRect = new BoundingRect(0, 0, 0, 0);\n\t    function isDisplayableCulled(el, width, height) {\n\t        tmpRect.copy(el.getBoundingRect());\n\t        if (el.transform) {\n\t            tmpRect.applyTransform(el.transform);\n\t        }\n\t        viewRect.width = width;\n\t        viewRect.height = height;\n\t        return !tmpRect.intersect(viewRect);\n\t    }\n\t\n\t    function isClipPathChanged(clipPaths, prevClipPaths) {\n\t        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n\t            return true;\n\t        }\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            if (clipPaths[i] !== prevClipPaths[i]) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\t\n\t    function doClip(clipPaths, ctx) {\n\t        for (var i = 0; i < clipPaths.length; i++) {\n\t            var clipPath = clipPaths[i];\n\t            var m;\n\t            if (clipPath.transform) {\n\t                m = clipPath.transform;\n\t                ctx.transform(\n\t                    m[0], m[1],\n\t                    m[2], m[3],\n\t                    m[4], m[5]\n\t                );\n\t            }\n\t            var path = clipPath.path;\n\t            path.beginPath(ctx);\n\t            clipPath.buildPath(path, clipPath.shape);\n\t            ctx.clip();\n\t            // Transform back\n\t            if (clipPath.transform) {\n\t                m = clipPath.invTransform;\n\t                ctx.transform(\n\t                    m[0], m[1],\n\t                    m[2], m[3],\n\t                    m[4], m[5]\n\t                );\n\t            }\n\t        }\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Painter\n\t     * @constructor\n\t     * @param {HTMLElement} root 绘图容器\n\t     * @param {module:zrender/Storage} storage\n\t     * @param {Ojbect} opts\n\t     */\n\t    var Painter = function (root, storage, opts) {\n\t        var singleCanvas = !root.nodeName // In node ?\n\t            || root.nodeName.toUpperCase() === 'CANVAS';\n\t\n\t        opts = opts || {};\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n\t        /**\n\t         * @type {boolean}\n\t         * @private\n\t         */\n\t        this._singleCanvas = singleCanvas;\n\t        /**\n\t         * 绘图容器\n\t         * @type {HTMLElement}\n\t         */\n\t        this.root = root;\n\t\n\t        var rootStyle = root.style;\n\t\n\t        // In node environment using node-canvas\n\t        if (rootStyle) {\n\t            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n\t            rootStyle['-webkit-user-select'] = 'none';\n\t            rootStyle['user-select'] = 'none';\n\t            rootStyle['-webkit-touch-callout'] = 'none';\n\t\n\t            root.innerHTML = '';\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/Storage}\n\t         */\n\t        this.storage = storage;\n\t\n\t        if (!singleCanvas) {\n\t            var width = this._getWidth();\n\t            var height = this._getHeight();\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            var domRoot = document.createElement('div');\n\t            this._domRoot = domRoot;\n\t            var domRootStyle = domRoot.style;\n\t\n\t            // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domRootStyle.position = 'relative';\n\t            domRootStyle.overflow = 'hidden';\n\t            domRootStyle.width = this._width + 'px';\n\t            domRootStyle.height = this._height + 'px';\n\t            root.appendChild(domRoot);\n\t\n\t            /**\n\t             * @type {Object.<key, module:zrender/Layer>}\n\t             * @private\n\t             */\n\t            this._layers = {};\n\t            /**\n\t             * @type {Array.<number>}\n\t             * @private\n\t             */\n\t            this._zlevelList = [];\n\t        }\n\t        else {\n\t            // Use canvas width and height directly\n\t            var width = root.width;\n\t            var height = root.height;\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            // Create layer if only one given canvas\n\t            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n\t            var mainLayer = new Layer(root, this, 1);\n\t            mainLayer.initContext();\n\t            // FIXME Use canvas width and height\n\t            // mainLayer.resize(width, height);\n\t            this._layers = {\n\t                0: mainLayer\n\t            };\n\t            this._zlevelList = [0];\n\t        }\n\t\n\t        this._layerConfig = {};\n\t\n\t        this.pathToImage = this._createPathToImage();\n\t    };\n\t\n\t    Painter.prototype = {\n\t\n\t        constructor: Painter,\n\t\n\t        /**\n\t         * If painter use a single canvas\n\t         * @return {boolean}\n\t         */\n\t        isSingleCanvas: function () {\n\t            return this._singleCanvas;\n\t        },\n\t        /**\n\t         * @return {HTMLDivElement}\n\t         */\n\t        getViewportRoot: function () {\n\t            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n\t        },\n\t\n\t        /**\n\t         * 刷新\n\t         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n\t         */\n\t        refresh: function (paintAll) {\n\t            var list = this.storage.getDisplayList(true);\n\t            var zlevelList = this._zlevelList;\n\t\n\t            this._paintList(list, paintAll);\n\t\n\t            // Paint custum layers\n\t            for (var i = 0; i < zlevelList.length; i++) {\n\t                var z = zlevelList[i];\n\t                var layer = this._layers[z];\n\t                if (!layer.isBuildin && layer.refresh) {\n\t                    layer.refresh();\n\t                }\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        _paintList: function (list, paintAll) {\n\t\n\t            if (paintAll == null) {\n\t                paintAll = false;\n\t            }\n\t\n\t            this._updateLayerStatus(list);\n\t\n\t            var currentLayer;\n\t            var currentZLevel;\n\t            var ctx;\n\t\n\t            var viewWidth = this._width;\n\t            var viewHeight = this._height;\n\t\n\t            this.eachBuildinLayer(preProcessLayer);\n\t\n\t            // var invTransform = [];\n\t            var prevElClipPaths = null;\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n\t                // Change draw layer\n\t                if (currentZLevel !== elZLevel) {\n\t                    // Only 0 zlevel if only has one canvas\n\t                    currentZLevel = elZLevel;\n\t                    currentLayer = this.getLayer(currentZLevel);\n\t\n\t                    if (!currentLayer.isBuildin) {\n\t                        log(\n\t                            'ZLevel ' + currentZLevel\n\t                            + ' has been used by unkown layer ' + currentLayer.id\n\t                        );\n\t                    }\n\t\n\t                    ctx = currentLayer.ctx;\n\t\n\t                    // Reset the count\n\t                    currentLayer.__unusedCount = 0;\n\t\n\t                    if (currentLayer.__dirty || paintAll) {\n\t                        currentLayer.clear();\n\t                    }\n\t                }\n\t\n\t                if (\n\t                    (currentLayer.__dirty || paintAll)\n\t                    // Ignore invisible element\n\t                    && !el.invisible\n\t                    // Ignore transparent element\n\t                    && el.style.opacity !== 0\n\t                    // Ignore scale 0 element, in some environment like node-canvas\n\t                    // Draw a scale 0 element can cause all following draw wrong\n\t                    && el.scale[0] && el.scale[1]\n\t                    // Ignore culled element\n\t                    && !(el.culling && isDisplayableCulled(el, viewWidth, viewHeight))\n\t                ) {\n\t                    var clipPaths = el.__clipPaths;\n\t\n\t                    // Optimize when clipping on group with several elements\n\t                    if (isClipPathChanged(clipPaths, prevElClipPaths)) {\n\t                        // If has previous clipping state, restore from it\n\t                        if (prevElClipPaths) {\n\t                            ctx.restore();\n\t                        }\n\t                        // New clipping state\n\t                        if (clipPaths) {\n\t                            ctx.save();\n\t                            doClip(clipPaths, ctx);\n\t                        }\n\t                        prevElClipPaths = clipPaths;\n\t                    }\n\t                    // TODO Use events ?\n\t                    el.beforeBrush && el.beforeBrush(ctx);\n\t                    el.brush(ctx, false);\n\t                    el.afterBrush && el.afterBrush(ctx);\n\t                }\n\t\n\t                el.__dirty = false;\n\t            }\n\t\n\t            // If still has clipping state\n\t            if (prevElClipPaths) {\n\t                ctx.restore();\n\t            }\n\t\n\t            this.eachBuildinLayer(postProcessLayer);\n\t        },\n\t\n\t        /**\n\t         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n\t         * @param {number} zlevel\n\t         * @return {module:zrender/Layer}\n\t         */\n\t        getLayer: function (zlevel) {\n\t            if (this._singleCanvas) {\n\t                return this._layers[0];\n\t            }\n\t\n\t            var layer = this._layers[zlevel];\n\t            if (!layer) {\n\t                // Create a new layer\n\t                layer = new Layer('zr_' + zlevel, this, this.dpr);\n\t                layer.isBuildin = true;\n\t\n\t                if (this._layerConfig[zlevel]) {\n\t                    util.merge(layer, this._layerConfig[zlevel], true);\n\t                }\n\t\n\t                this.insertLayer(zlevel, layer);\n\t\n\t                // Context is created after dom inserted to document\n\t                // Or excanvas will get 0px clientWidth and clientHeight\n\t                layer.initContext();\n\t            }\n\t\n\t            return layer;\n\t        },\n\t\n\t        insertLayer: function (zlevel, layer) {\n\t\n\t            var layersMap = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var len = zlevelList.length;\n\t            var prevLayer = null;\n\t            var i = -1;\n\t            var domRoot = this._domRoot;\n\t\n\t            if (layersMap[zlevel]) {\n\t                log('ZLevel ' + zlevel + ' has been used already');\n\t                return;\n\t            }\n\t            // Check if is a valid layer\n\t            if (!isLayerValid(layer)) {\n\t                log('Layer of zlevel ' + zlevel + ' is not valid');\n\t                return;\n\t            }\n\t\n\t            if (len > 0 && zlevel > zlevelList[0]) {\n\t                for (i = 0; i < len - 1; i++) {\n\t                    if (\n\t                        zlevelList[i] < zlevel\n\t                        && zlevelList[i + 1] > zlevel\n\t                    ) {\n\t                        break;\n\t                    }\n\t                }\n\t                prevLayer = layersMap[zlevelList[i]];\n\t            }\n\t            zlevelList.splice(i + 1, 0, zlevel);\n\t\n\t            if (prevLayer) {\n\t                var prevDom = prevLayer.dom;\n\t                if (prevDom.nextSibling) {\n\t                    domRoot.insertBefore(\n\t                        layer.dom,\n\t                        prevDom.nextSibling\n\t                    );\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t            else {\n\t                if (domRoot.firstChild) {\n\t                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n\t                }\n\t                else {\n\t                    domRoot.appendChild(layer.dom);\n\t                }\n\t            }\n\t\n\t            layersMap[zlevel] = layer;\n\t        },\n\t\n\t        // Iterate each layer\n\t        eachLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                cb.call(context, this._layers[z], z);\n\t            }\n\t        },\n\t\n\t        // Iterate each buildin layer\n\t        eachBuildinLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        // Iterate each other layer except buildin layer\n\t        eachOtherLayer: function (cb, context) {\n\t            var zlevelList = this._zlevelList;\n\t            var layer;\n\t            var z;\n\t            var i;\n\t            for (i = 0; i < zlevelList.length; i++) {\n\t                z = zlevelList[i];\n\t                layer = this._layers[z];\n\t                if (! layer.isBuildin) {\n\t                    cb.call(context, layer, z);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 获取所有已创建的层\n\t         * @param {Array.<module:zrender/Layer>} [prevLayer]\n\t         */\n\t        getLayers: function () {\n\t            return this._layers;\n\t        },\n\t\n\t        _updateLayerStatus: function (list) {\n\t\n\t            var layers = this._layers;\n\t\n\t            var elCounts = {};\n\t\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                elCounts[z] = layer.elCount;\n\t                layer.elCount = 0;\n\t            });\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                var el = list[i];\n\t                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n\t                var layer = layers[zlevel];\n\t                if (layer) {\n\t                    layer.elCount++;\n\t                    // 已经被标记为需要刷新\n\t                    if (layer.__dirty) {\n\t                        continue;\n\t                    }\n\t                    layer.__dirty = el.__dirty;\n\t                }\n\t            }\n\t\n\t            // 层中的元素数量有发生变化\n\t            this.eachBuildinLayer(function (layer, z) {\n\t                if (elCounts[z] !== layer.elCount) {\n\t                    layer.__dirty = true;\n\t                }\n\t            });\n\t        },\n\t\n\t        /**\n\t         * 清除hover层外所有内容\n\t         */\n\t        clear: function () {\n\t            this.eachBuildinLayer(this._clearLayer);\n\t            return this;\n\t        },\n\t\n\t        _clearLayer: function (layer) {\n\t            layer.clear();\n\t        },\n\t\n\t        /**\n\t         * 修改指定zlevel的绘制参数\n\t         *\n\t         * @param {string} zlevel\n\t         * @param {Object} config 配置对象\n\t         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n\t         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n\t         * @param {number} [config.lastFrameAlpha=0.7]\n\t         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         */\n\t        configLayer: function (zlevel, config) {\n\t            if (config) {\n\t                var layerConfig = this._layerConfig;\n\t                if (!layerConfig[zlevel]) {\n\t                    layerConfig[zlevel] = config;\n\t                }\n\t                else {\n\t                    util.merge(layerConfig[zlevel], config, true);\n\t                }\n\t\n\t                var layer = this._layers[zlevel];\n\t\n\t                if (layer) {\n\t                    util.merge(layer, layerConfig[zlevel], true);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 删除指定层\n\t         * @param {number} zlevel 层所在的zlevel\n\t         */\n\t        delLayer: function (zlevel) {\n\t            var layers = this._layers;\n\t            var zlevelList = this._zlevelList;\n\t            var layer = layers[zlevel];\n\t            if (!layer) {\n\t                return;\n\t            }\n\t            layer.dom.parentNode.removeChild(layer.dom);\n\t            delete layers[zlevel];\n\t\n\t            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n\t        },\n\t\n\t        /**\n\t         * 区域大小变化后重绘\n\t         */\n\t        resize: function (width, height) {\n\t            var domRoot = this._domRoot;\n\t            // FIXME Why ?\n\t            domRoot.style.display = 'none';\n\t\n\t            width = width || this._getWidth();\n\t            height = height || this._getHeight();\n\t\n\t            domRoot.style.display = '';\n\t\n\t            // 优化没有实际改变的resize\n\t            if (this._width != width || height != this._height) {\n\t                domRoot.style.width = width + 'px';\n\t                domRoot.style.height = height + 'px';\n\t\n\t                for (var id in this._layers) {\n\t                    this._layers[id].resize(width, height);\n\t                }\n\t\n\t                this.refresh(true);\n\t            }\n\t\n\t            this._width = width;\n\t            this._height = height;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 清除单独的一个层\n\t         * @param {number} zlevel\n\t         */\n\t        clearLayer: function (zlevel) {\n\t            var layer = this._layers[zlevel];\n\t            if (layer) {\n\t                layer.clear();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 释放\n\t         */\n\t        dispose: function () {\n\t            this.root.innerHTML = '';\n\t\n\t            this.root =\n\t            this.storage =\n\t\n\t            this._domRoot =\n\t            this._layers = null;\n\t        },\n\t\n\t        /**\n\t         * Get canvas which has all thing rendered\n\t         * @param {Object} opts\n\t         * @param {string} [opts.backgroundColor]\n\t         */\n\t        getRenderedCanvas: function (opts) {\n\t            opts = opts || {};\n\t            if (this._singleCanvas) {\n\t                return this._layers[0].dom;\n\t            }\n\t\n\t            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n\t            imageLayer.initContext();\n\t\n\t            var ctx = imageLayer.ctx;\n\t            imageLayer.clearColor = opts.backgroundColor;\n\t            imageLayer.clear();\n\t\n\t            var displayList = this.storage.getDisplayList(true);\n\t\n\t            for (var i = 0; i < displayList.length; i++) {\n\t                var el = displayList[i];\n\t                if (!el.invisible) {\n\t                    el.beforeBrush && el.beforeBrush(ctx);\n\t                    // TODO Check image cross origin\n\t                    el.brush(ctx, false);\n\t                    el.afterBrush && el.afterBrush(ctx);\n\t                }\n\t            }\n\t\n\t            return imageLayer.dom;\n\t        },\n\t        /**\n\t         * 获取绘图区域宽度\n\t         */\n\t        getWidth: function () {\n\t            return this._width;\n\t        },\n\t\n\t        /**\n\t         * 获取绘图区域高度\n\t         */\n\t        getHeight: function () {\n\t            return this._height;\n\t        },\n\t\n\t        _getWidth: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            // FIXME Better way to get the width and height when element has not been append to the document\n\t            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n\t                    - (parseInt10(stl.paddingLeft) || 0)\n\t                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n\t        },\n\t\n\t        _getHeight: function () {\n\t            var root = this.root;\n\t            var stl = document.defaultView.getComputedStyle(root);\n\t\n\t            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n\t                    - (parseInt10(stl.paddingTop) || 0)\n\t                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n\t        },\n\t\n\t        _pathToImage: function (id, path, width, height, dpr) {\n\t            var canvas = document.createElement('canvas');\n\t            var ctx = canvas.getContext('2d');\n\t\n\t            canvas.width = width * dpr;\n\t            canvas.height = height * dpr;\n\t\n\t            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\t\n\t            var pathTransform = {\n\t                position: path.position,\n\t                rotation: path.rotation,\n\t                scale: path.scale\n\t            };\n\t            path.position = [0, 0, 0];\n\t            path.rotation = 0;\n\t            path.scale = [1, 1];\n\t            if (path) {\n\t                path.brush(ctx);\n\t            }\n\t\n\t            var ImageShape = __webpack_require__(30);\n\t            var imgShape = new ImageShape({\n\t                id: id,\n\t                style: {\n\t                    x: 0,\n\t                    y: 0,\n\t                    image: canvas\n\t                }\n\t            });\n\t\n\t            if (pathTransform.position != null) {\n\t                imgShape.position = path.position = pathTransform.position;\n\t            }\n\t\n\t            if (pathTransform.rotation != null) {\n\t                imgShape.rotation = path.rotation = pathTransform.rotation;\n\t            }\n\t\n\t            if (pathTransform.scale != null) {\n\t                imgShape.scale = path.scale = pathTransform.scale;\n\t            }\n\t\n\t            return imgShape;\n\t        },\n\t\n\t        _createPathToImage: function () {\n\t            var me = this;\n\t\n\t            return function (id, e, width, height) {\n\t                return me._pathToImage(\n\t                    id, e, width, height, me.dpr\n\t                );\n\t            };\n\t        }\n\t    };\n\t\n\t    module.exports = Painter;\n\t\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/Layer\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var util = __webpack_require__(9);\n\t    var config = __webpack_require__(25);\n\t\n\t    function returnFalse() {\n\t        return false;\n\t    }\n\t\n\t    /**\n\t     * 创建dom\n\t     *\n\t     * @inner\n\t     * @param {string} id dom id 待用\n\t     * @param {string} type dom type，such as canvas, div etc.\n\t     * @param {Painter} painter painter instance\n\t     * @param {number} number\n\t     */\n\t    function createDom(id, type, painter, dpr) {\n\t        var newDom = document.createElement(type);\n\t        var width = painter.getWidth();\n\t        var height = painter.getHeight();\n\t\n\t        var newDomStyle = newDom.style;\n\t        // 没append呢，请原谅我这样写，清晰~\n\t        newDomStyle.position = 'absolute';\n\t        newDomStyle.left = 0;\n\t        newDomStyle.top = 0;\n\t        newDomStyle.width = width + 'px';\n\t        newDomStyle.height = height + 'px';\n\t        newDom.width = width * dpr;\n\t        newDom.height = height * dpr;\n\t\n\t        // id不作为索引用，避免可能造成的重名，定义为私有属性\n\t        newDom.setAttribute('data-zr-dom-id', id);\n\t        return newDom;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/Layer\n\t     * @constructor\n\t     * @extends module:zrender/mixin/Transformable\n\t     * @param {string} id\n\t     * @param {module:zrender/Painter} painter\n\t     * @param {number} [dpr]\n\t     */\n\t    var Layer = function(id, painter, dpr) {\n\t        var dom;\n\t        dpr = dpr || config.devicePixelRatio;\n\t        if (typeof id === 'string') {\n\t            dom = createDom(id, 'canvas', painter, dpr);\n\t        }\n\t        // Not using isDom because in node it will return false\n\t        else if (util.isObject(id)) {\n\t            dom = id;\n\t            id = dom.id;\n\t        }\n\t        this.id = id;\n\t        this.dom = dom;\n\t\n\t        var domStyle = dom.style;\n\t        if (domStyle) { // Not in node\n\t            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\t            domStyle['-webkit-user-select'] = 'none';\n\t            domStyle['user-select'] = 'none';\n\t            domStyle['-webkit-touch-callout'] = 'none';\n\t            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n\t        }\n\t\n\t        this.domBack = null;\n\t        this.ctxBack = null;\n\t\n\t        this.painter = painter;\n\t\n\t        this.config = null;\n\t\n\t        // Configs\n\t        /**\n\t         * 每次清空画布的颜色\n\t         * @type {string}\n\t         * @default 0\n\t         */\n\t        this.clearColor = 0;\n\t        /**\n\t         * 是否开启动态模糊\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        this.motionBlur = false;\n\t        /**\n\t         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n\t         * @type {number}\n\t         * @default 0.7\n\t         */\n\t        this.lastFrameAlpha = 0.7;\n\t\n\t        /**\n\t         * Layer dpr\n\t         * @type {number}\n\t         */\n\t        this.dpr = dpr;\n\t    };\n\t\n\t    Layer.prototype = {\n\t\n\t        constructor: Layer,\n\t\n\t        elCount: 0,\n\t\n\t        __dirty: true,\n\t\n\t        initContext: function () {\n\t            this.ctx = this.dom.getContext('2d');\n\t\n\t            var dpr = this.dpr;\n\t            if (dpr != 1) {\n\t                this.ctx.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        createBackBuffer: function () {\n\t            var dpr = this.dpr;\n\t\n\t            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n\t            this.ctxBack = this.domBack.getContext('2d');\n\t\n\t            if (dpr != 1) {\n\t                this.ctxBack.scale(dpr, dpr);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param  {number} width\n\t         * @param  {number} height\n\t         */\n\t        resize: function (width, height) {\n\t            var dpr = this.dpr;\n\t\n\t            var dom = this.dom;\n\t            var domStyle = dom.style;\n\t            var domBack = this.domBack;\n\t\n\t            domStyle.width = width + 'px';\n\t            domStyle.height = height + 'px';\n\t\n\t            dom.width = width * dpr;\n\t            dom.height = height * dpr;\n\t\n\t            if (dpr != 1) {\n\t                this.ctx.scale(dpr, dpr);\n\t            }\n\t\n\t            if (domBack) {\n\t                domBack.width = width * dpr;\n\t                domBack.height = height * dpr;\n\t\n\t                if (dpr != 1) {\n\t                    this.ctxBack.scale(dpr, dpr);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * 清空该层画布\n\t         * @param {boolean} clearAll Clear all with out motion blur\n\t         */\n\t        clear: function (clearAll) {\n\t            var dom = this.dom;\n\t            var ctx = this.ctx;\n\t            var width = dom.width;\n\t            var height = dom.height;\n\t\n\t            var haveClearColor = this.clearColor;\n\t            var haveMotionBLur = this.motionBlur && !clearAll;\n\t            var lastFrameAlpha = this.lastFrameAlpha;\n\t\n\t            var dpr = this.dpr;\n\t\n\t            if (haveMotionBLur) {\n\t                if (!this.domBack) {\n\t                    this.createBackBuffer();\n\t                }\n\t\n\t                this.ctxBack.globalCompositeOperation = 'copy';\n\t                this.ctxBack.drawImage(\n\t                    dom, 0, 0,\n\t                    width / dpr,\n\t                    height / dpr\n\t                );\n\t            }\n\t\n\t            ctx.clearRect(0, 0, width / dpr, height / dpr);\n\t            if (haveClearColor) {\n\t                ctx.save();\n\t                ctx.fillStyle = this.clearColor;\n\t                ctx.fillRect(0, 0, width / dpr, height / dpr);\n\t                ctx.restore();\n\t            }\n\t\n\t            if (haveMotionBLur) {\n\t                var domBack = this.domBack;\n\t                ctx.save();\n\t                ctx.globalAlpha = lastFrameAlpha;\n\t                ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);\n\t                ctx.restore();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = Layer;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Image element\n\t * @module zrender/graphic/Image\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(31);\n\t    var BoundingRect = __webpack_require__(26);\n\t    var zrUtil = __webpack_require__(9);\n\t    var roundRectHelper = __webpack_require__(35);\n\t\n\t    var LRU = __webpack_require__(36);\n\t    var globalImageCache = new LRU(50);\n\t    /**\n\t     * @alias zrender/graphic/Image\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var ZImage = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    ZImage.prototype = {\n\t\n\t        constructor: ZImage,\n\t\n\t        type: 'image',\n\t\n\t        brush: function (ctx) {\n\t            var style = this.style;\n\t            var src = style.image;\n\t            var image;\n\t            // style.image is a url string\n\t            if (typeof src === 'string') {\n\t                image = this._image;\n\t            }\n\t            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n\t            else {\n\t                image = src;\n\t            }\n\t            // FIXME Case create many images with src\n\t            if (!image && src) {\n\t                // Try get from global image cache\n\t                var cachedImgObj = globalImageCache.get(src);\n\t                if (!cachedImgObj) {\n\t                    // Create a new image\n\t                    image = new Image();\n\t                    image.onload = function () {\n\t                        image.onload = null;\n\t                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n\t                            cachedImgObj.pending[i].dirty();\n\t                        }\n\t                    };\n\t                    cachedImgObj = {\n\t                        image: image,\n\t                        pending: [this]\n\t                    };\n\t                    image.src = src;\n\t                    globalImageCache.put(src, cachedImgObj);\n\t                    this._image = image;\n\t                    return;\n\t                }\n\t                else {\n\t                    image = cachedImgObj.image;\n\t                    this._image = image;\n\t                    // Image is not complete finish, add to pending list\n\t                    if (!image.width || !image.height) {\n\t                        cachedImgObj.pending.push(this);\n\t                        return;\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (image) {\n\t                // 图片已经加载完成\n\t                // if (image.nodeName.toUpperCase() == 'IMG') {\n\t                //     if (!image.complete) {\n\t                //         return;\n\t                //     }\n\t                // }\n\t                // Else is canvas\n\t\n\t                var width = style.width || image.width;\n\t                var height = style.height || image.height;\n\t                var x = style.x || 0;\n\t                var y = style.y || 0;\n\t                // 图片加载失败\n\t                if (!image.width || !image.height) {\n\t                    return;\n\t                }\n\t\n\t                ctx.save();\n\t\n\t                style.bind(ctx);\n\t\n\t                // 设置transform\n\t                this.setTransform(ctx);\n\t\n\t                if (style.r) {\n\t                    // Border radius clipping\n\t                    // FIXME\n\t                    ctx.beginPath();\n\t                    roundRectHelper.buildPath(ctx, style);\n\t                    ctx.clip();\n\t                }\n\t\n\t                if (style.sWidth && style.sHeight) {\n\t                    var sx = style.sx || 0;\n\t                    var sy = style.sy || 0;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, style.sWidth, style.sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else if (style.sx && style.sy) {\n\t                    var sx = style.sx;\n\t                    var sy = style.sy;\n\t                    var sWidth = width - sx;\n\t                    var sHeight = height - sy;\n\t                    ctx.drawImage(\n\t                        image,\n\t                        sx, sy, sWidth, sHeight,\n\t                        x, y, width, height\n\t                    );\n\t                }\n\t                else {\n\t                    ctx.drawImage(image, x, y, width, height);\n\t                }\n\t\n\t                // 如果没设置宽和高的话自动根据图片宽高设置\n\t                if (style.width == null) {\n\t                    style.width = width;\n\t                }\n\t                if (style.height == null) {\n\t                    style.height = height;\n\t                }\n\t\n\t                // Draw rect text\n\t                if (style.text != null) {\n\t                    this.drawRectText(ctx, this.getBoundingRect());\n\t                }\n\t\n\t                ctx.restore();\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            var style = this.style;\n\t            if (! this._rect) {\n\t                this._rect = new BoundingRect(\n\t                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n\t                );\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(ZImage, Displayable);\n\t\n\t    module.exports = ZImage;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 可绘制的图形基类\n\t * Base class of all displayable graphic objects\n\t * @module zrender/graphic/Displayable\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(9);\n\t\n\t    var Style = __webpack_require__(32);\n\t\n\t    var Element = __webpack_require__(15);\n\t    var RectText = __webpack_require__(33);\n\t    // var Stateful = require('./mixin/Stateful');\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Displayable\n\t     * @extends module:zrender/Element\n\t     * @extends module:zrender/graphic/mixin/RectText\n\t     */\n\t    function Displayable(opts) {\n\t\n\t        opts = opts || {};\n\t\n\t        Element.call(this, opts);\n\t\n\t        // Extend properties\n\t        for (var name in opts) {\n\t            if (\n\t                opts.hasOwnProperty(name) &&\n\t                name !== 'style'\n\t            ) {\n\t                this[name] = opts[name];\n\t            }\n\t        }\n\t\n\t        /**\n\t         * @type {module:zrender/graphic/Style}\n\t         */\n\t        this.style = new Style(opts.style);\n\t\n\t        this._rect = null;\n\t        // Shapes for cascade clipping.\n\t        this.__clipPaths = [];\n\t\n\t        // FIXME Stateful must be mixined after style is setted\n\t        // Stateful.call(this, opts);\n\t    }\n\t\n\t    Displayable.prototype = {\n\t\n\t        constructor: Displayable,\n\t\n\t        type: 'displayable',\n\t\n\t        /**\n\t         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n\t         * Dirty flag. From which painter will determine if this displayable object needs brush\n\t         * @name module:zrender/graphic/Displayable#__dirty\n\t         * @type {boolean}\n\t         */\n\t        __dirty: true,\n\t\n\t        /**\n\t         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n\t         * If ignore drawing of the displayable object. Mouse event will still be triggered\n\t         * @name module:/zrender/graphic/Displayable#invisible\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        invisible: false,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z: 0,\n\t\n\t        /**\n\t         * @name module:/zrender/graphic/Displayable#z\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        z2: 0,\n\t\n\t        /**\n\t         * z层level，决定绘画在哪层canvas中\n\t         * @name module:/zrender/graphic/Displayable#zlevel\n\t         * @type {number}\n\t         * @default 0\n\t         */\n\t        zlevel: 0,\n\t\n\t        /**\n\t         * 是否可拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        draggable: false,\n\t\n\t        /**\n\t         * 是否正在拖拽\n\t         * @name module:/zrender/graphic/Displayable#draggable\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        dragging: false,\n\t\n\t        /**\n\t         * 是否相应鼠标事件\n\t         * @name module:/zrender/graphic/Displayable#silent\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        silent: false,\n\t\n\t        /**\n\t         * If enable culling\n\t         * @type {boolean}\n\t         * @default false\n\t         */\n\t        culling: false,\n\t\n\t        /**\n\t         * Mouse cursor when hovered\n\t         * @name module:/zrender/graphic/Displayable#cursor\n\t         * @type {string}\n\t         */\n\t        cursor: 'pointer',\n\t\n\t        /**\n\t         * If hover area is bounding rect\n\t         * @name module:/zrender/graphic/Displayable#rectHover\n\t         * @type {string}\n\t         */\n\t        rectHover: false,\n\t\n\t        beforeBrush: function (ctx) {},\n\t\n\t        afterBrush: function (ctx) {},\n\t\n\t        /**\n\t         * 图形绘制方法\n\t         * @param {Canvas2DRenderingContext} ctx\n\t         */\n\t        // Interface\n\t        brush: function (ctx) {},\n\t\n\t        /**\n\t         * 获取最小包围盒\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        // Interface\n\t        getBoundingRect: function () {},\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形上\n\t         * If displayable element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        contain: function (x, y) {\n\t            return this.rectContain(x, y);\n\t        },\n\t\n\t        /**\n\t         * @param  {Function} cb\n\t         * @param  {}   context\n\t         */\n\t        traverse: function (cb, context) {\n\t            cb.call(context, this);\n\t        },\n\t\n\t        /**\n\t         * 判断坐标 x, y 是否在图形的包围盒上\n\t         * If bounding rect of element contain coord x, y\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {boolean}\n\t         */\n\t        rectContain: function (x, y) {\n\t            var coord = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            return rect.contain(coord[0], coord[1]);\n\t        },\n\t\n\t        /**\n\t         * 标记图形元素为脏，并且在下一帧重绘\n\t         * Mark displayable element dirty and refresh next frame\n\t         */\n\t        dirty: function () {\n\t            this.__dirty = true;\n\t\n\t            this._rect = null;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t        },\n\t\n\t        /**\n\t         * 图形是否会触发事件\n\t         * If displayable object binded any event\n\t         * @return {boolean}\n\t         */\n\t        // TODO, 通过 bind 绑定的事件\n\t        // isSilent: function () {\n\t        //     return !(\n\t        //         this.hoverable || this.draggable\n\t        //         || this.onmousemove || this.onmouseover || this.onmouseout\n\t        //         || this.onmousedown || this.onmouseup || this.onclick\n\t        //         || this.ondragenter || this.ondragover || this.ondragleave\n\t        //         || this.ondrop\n\t        //     );\n\t        // },\n\t        /**\n\t         * Alias for animate('style')\n\t         * @param {boolean} loop\n\t         */\n\t        animateStyle: function (loop) {\n\t            return this.animate('style', loop);\n\t        },\n\t\n\t        attrKV: function (key, value) {\n\t            if (key !== 'style') {\n\t                Element.prototype.attrKV.call(this, key, value);\n\t            }\n\t            else {\n\t                this.style.set(value);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setStyle: function (key, value) {\n\t            this.style.set(key, value);\n\t            this.dirty();\n\t            return this;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Displayable, Element);\n\t\n\t    zrUtil.mixin(Displayable, RectText);\n\t    // zrUtil.mixin(Displayable, Stateful);\n\t\n\t    module.exports = Displayable;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @module zrender/graphic/Style\n\t */\n\t\n\t\n\t\n\t    var STYLE_LIST_COMMON = [\n\t        'lineCap', 'lineJoin', 'miterLimit',\n\t        'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'shadowColor'\n\t    ];\n\t\n\t    var Style = function (opts) {\n\t        this.extendFrom(opts);\n\t    };\n\t\n\t    Style.prototype = {\n\t\n\t        constructor: Style,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        fill: '#000000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        stroke: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        opacity: 1,\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         */\n\t        lineDash: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineDashOffset: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        shadowOffsetY: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        lineWidth: 1,\n\t\n\t        /**\n\t         * If stroke ignore scale\n\t         * @type {Boolean}\n\t         */\n\t        strokeNoScale: false,\n\t\n\t        // Bounding rect text configuration\n\t        // Not affected by element transform\n\t        /**\n\t         * @type {string}\n\t         */\n\t        text: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textFill: '#000',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textStroke: null,\n\t\n\t        /**\n\t         * 'inside', 'left', 'right', 'top', 'bottom'\n\t         * [x, y]\n\t         * @type {string|Array.<number>}\n\t         * @default 'inside'\n\t         */\n\t        textPosition: 'inside',\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textBaseline: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textAlign: null,\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        textVerticalAlign: null,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textDistance: 5,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowBlur: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetX: 0,\n\t\n\t        /**\n\t         * @type {number}\n\t         */\n\t        textShadowOffsetY: 0,\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         */\n\t        bind: function (ctx, el) {\n\t            var fill = this.fill;\n\t            var stroke = this.stroke;\n\t            for (var i = 0; i < STYLE_LIST_COMMON.length; i++) {\n\t                var styleName = STYLE_LIST_COMMON[i];\n\t\n\t                if (this[styleName] != null) {\n\t                    ctx[styleName] = this[styleName];\n\t                }\n\t            }\n\t            if (stroke != null) {\n\t                var lineWidth = this.lineWidth;\n\t                ctx.lineWidth = lineWidth / (\n\t                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n\t                );\n\t            }\n\t            if (fill != null) {\n\t                 // Use canvas gradient if has\n\t                ctx.fillStyle = fill.canvasGradient ? fill.canvasGradient : fill;\n\t            }\n\t            if (stroke != null) {\n\t                 // Use canvas gradient if has\n\t                ctx.strokeStyle = stroke.canvasGradient ? stroke.canvasGradient : stroke;\n\t            }\n\t            this.opacity != null && (ctx.globalAlpha = this.opacity);\n\t        },\n\t\n\t        /**\n\t         * Extend from other style\n\t         * @param {zrender/graphic/Style} otherStyle\n\t         * @param {boolean} overwrite\n\t         */\n\t        extendFrom: function (otherStyle, overwrite) {\n\t            if (otherStyle) {\n\t                var target = this;\n\t                for (var name in otherStyle) {\n\t                    if (otherStyle.hasOwnProperty(name)\n\t                        && (overwrite || ! target.hasOwnProperty(name))\n\t                    ) {\n\t                        target[name] = otherStyle[name];\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Batch setting style with a given object\n\t         * @param {Object|string} obj\n\t         * @param {*} [obj]\n\t         */\n\t        set: function (obj, value) {\n\t            if (typeof obj === 'string') {\n\t                this[obj] = value;\n\t            }\n\t            else {\n\t                this.extendFrom(obj, true);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Clone\n\t         * @return {zrender/graphic/Style} [description]\n\t         */\n\t        clone: function () {\n\t            var newStyle = new this.constructor();\n\t            newStyle.extendFrom(this, true);\n\t            return newStyle;\n\t        }\n\t    };\n\t\n\t    var styleProto = Style.prototype;\n\t    var name;\n\t    var i;\n\t    for (i = 0; i < STYLE_LIST_COMMON.length; i++) {\n\t        name = STYLE_LIST_COMMON[i];\n\t        if (!(name in styleProto)) {\n\t            styleProto[name] = null;\n\t        }\n\t    }\n\t\n\t    module.exports = Style;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Mixin for drawing text in a element bounding rect\n\t * @module zrender/mixin/RectText\n\t */\n\t\n\t\n\t\n\t    var textContain = __webpack_require__(34);\n\t    var BoundingRect = __webpack_require__(26);\n\t\n\t    var tmpRect = new BoundingRect();\n\t\n\t    var RectText = function () {};\n\t\n\t    function parsePercent(value, maxValue) {\n\t        if (typeof value === 'string') {\n\t            if (value.lastIndexOf('%') >= 0) {\n\t                return parseFloat(value) / 100 * maxValue;\n\t            }\n\t            return parseFloat(value);\n\t        }\n\t        return value;\n\t    }\n\t\n\t    function setTransform(ctx, m) {\n\t        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n\t    }\n\t\n\t    RectText.prototype = {\n\t\n\t        constructor: RectText,\n\t\n\t        /**\n\t         * Draw text in a rect with specified position.\n\t         * @param  {CanvasRenderingContext} ctx\n\t         * @param  {Object} rect Displayable rect\n\t         * @return {Object} textRect Alternative precalculated text bounding rect\n\t         */\n\t        drawRectText: function (ctx, rect, textRect) {\n\t            var style = this.style;\n\t            var text = style.text;\n\t            // Convert to string\n\t            text != null && (text += '');\n\t            if (!text) {\n\t                return;\n\t            }\n\t            var x;\n\t            var y;\n\t            var textPosition = style.textPosition;\n\t            var distance = style.textDistance;\n\t            var align = style.textAlign;\n\t            var font = style.textFont || style.font;\n\t            var baseline = style.textBaseline;\n\t            var verticalAlign = style.textVerticalAlign;\n\t\n\t            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\t\n\t            // Transform rect to view space\n\t            var transform = this.transform;\n\t            var invTransform = this.invTransform;\n\t            if (transform) {\n\t                tmpRect.copy(rect);\n\t                tmpRect.applyTransform(transform);\n\t                rect = tmpRect;\n\t                // Transform back\n\t                setTransform(ctx, invTransform);\n\t            }\n\t\n\t            // Text position represented by coord\n\t            if (textPosition instanceof Array) {\n\t                // Percent\n\t                x = rect.x + parsePercent(textPosition[0], rect.width);\n\t                y = rect.y + parsePercent(textPosition[1], rect.height);\n\t                align = align || 'left';\n\t                baseline = baseline || 'top';\n\t            }\n\t            else {\n\t                var res = textContain.adjustTextPositionOnRect(\n\t                    textPosition, rect, textRect, distance\n\t                );\n\t                x = res.x;\n\t                y = res.y;\n\t                // Default align and baseline when has textPosition\n\t                align = align || res.textAlign;\n\t                baseline = baseline || res.textBaseline;\n\t            }\n\t\n\t            ctx.textAlign = align;\n\t            if (verticalAlign) {\n\t                switch (verticalAlign) {\n\t                    case 'middle':\n\t                        y -= textRect.height / 2;\n\t                        break;\n\t                    case 'bottom':\n\t                        y -= textRect.height;\n\t                        break;\n\t                    // 'top'\n\t                }\n\t                // Ignore baseline\n\t                ctx.textBaseline = 'top';\n\t            }\n\t            else {\n\t                ctx.textBaseline = baseline;\n\t            }\n\t\n\t            var textFill = style.textFill;\n\t            var textStroke = style.textStroke;\n\t            textFill && (ctx.fillStyle = textFill);\n\t            textStroke && (ctx.strokeStyle = textStroke);\n\t            ctx.font = font;\n\t\n\t            // Text shadow\n\t            ctx.shadowColor = style.textShadowColor;\n\t            ctx.shadowBlur = style.textShadowBlur;\n\t            ctx.shadowOffsetX = style.textShadowOffsetX;\n\t            ctx.shadowOffsetY = style.textShadowOffsetY;\n\t\n\t            var textLines = text.split('\\n');\n\t            for (var i = 0; i < textLines.length; i++) {\n\t                textFill && ctx.fillText(textLines[i], x, y);\n\t                textStroke && ctx.strokeText(textLines[i], x, y);\n\t                y += textRect.lineHeight;\n\t            }\n\t\n\t            // Transform again\n\t            transform && setTransform(ctx, transform);\n\t        }\n\t    };\n\t\n\t    module.exports = RectText;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var textWidthCache = {};\n\t    var textWidthCacheCounter = 0;\n\t    var TEXT_CACHE_MAX = 5000;\n\t\n\t    var util = __webpack_require__(9);\n\t    var BoundingRect = __webpack_require__(26);\n\t\n\t    function getTextWidth(text, textFont) {\n\t        var key = text + ':' + textFont;\n\t        if (textWidthCache[key]) {\n\t            return textWidthCache[key];\n\t        }\n\t\n\t        var textLines = (text + '').split('\\n');\n\t        var width = 0;\n\t\n\t        for (var i = 0, l = textLines.length; i < l; i++) {\n\t            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n\t            width =  Math.max(textContain.measureText(textLines[i], textFont).width, width);\n\t        }\n\t\n\t        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n\t            textWidthCacheCounter = 0;\n\t            textWidthCache = {};\n\t        }\n\t        textWidthCacheCounter++;\n\t        textWidthCache[key] = width;\n\t\n\t        return width;\n\t    }\n\t\n\t    function getTextRect(text, textFont, textAlign, textBaseline) {\n\t        var textLineLen = ((text || '') + '').split('\\n').length;\n\t\n\t        var width = getTextWidth(text, textFont);\n\t        // FIXME 高度计算比较粗暴\n\t        var lineHeight = getTextWidth('国', textFont);\n\t        var height = textLineLen * lineHeight;\n\t\n\t        var rect = new BoundingRect(0, 0, width, height);\n\t        // Text has a special line height property\n\t        rect.lineHeight = lineHeight;\n\t\n\t        switch (textBaseline) {\n\t            case 'bottom':\n\t            case 'alphabetic':\n\t                rect.y -= lineHeight;\n\t                break;\n\t            case 'middle':\n\t                rect.y -= lineHeight / 2;\n\t                break;\n\t            // case 'hanging':\n\t            // case 'top':\n\t        }\n\t\n\t        // FIXME Right to left language\n\t        switch (textAlign) {\n\t            case 'end':\n\t            case 'right':\n\t                rect.x -= rect.width;\n\t                break;\n\t            case 'center':\n\t                rect.x -= rect.width / 2;\n\t                break;\n\t            // case 'start':\n\t            // case 'left':\n\t        }\n\t\n\t        return rect;\n\t    }\n\t\n\t    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\t\n\t        var x = rect.x;\n\t        var y = rect.y;\n\t\n\t        var height = rect.height;\n\t        var width = rect.width;\n\t\n\t        var textHeight = textRect.height;\n\t\n\t        var halfHeight = height / 2 - textHeight / 2;\n\t\n\t        var textAlign = 'left';\n\t\n\t        switch (textPosition) {\n\t            case 'left':\n\t                x -= distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'right':\n\t                x += distance + width;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'top':\n\t                x += width / 2;\n\t                y -= distance + textHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'bottom':\n\t                x += width / 2;\n\t                y += height + distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'inside':\n\t                x += width / 2;\n\t                y += halfHeight;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideLeft':\n\t                x += distance;\n\t                y += halfHeight;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideRight':\n\t                x += width - distance;\n\t                y += halfHeight;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideTop':\n\t                x += width / 2;\n\t                y += distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideBottom':\n\t                x += width / 2;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'center';\n\t                break;\n\t            case 'insideTopLeft':\n\t                x += distance;\n\t                y += distance;\n\t                textAlign = 'left';\n\t                break;\n\t            case 'insideTopRight':\n\t                x += width - distance;\n\t                y += distance;\n\t                textAlign = 'right';\n\t                break;\n\t            case 'insideBottomLeft':\n\t                x += distance;\n\t                y += height - textHeight - distance;\n\t                break;\n\t            case 'insideBottomRight':\n\t                x += width - distance;\n\t                y += height - textHeight - distance;\n\t                textAlign = 'right';\n\t                break;\n\t        }\n\t\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            textAlign: textAlign,\n\t            textBaseline: 'top'\n\t        };\n\t    }\n\t\n\t    /**\n\t     * Show ellipsis if overflow.\n\t     *\n\t     * @param  {string} text\n\t     * @param  {string} textFont\n\t     * @param  {string} containerWidth\n\t     * @param  {Object} [options]\n\t     * @param  {number} [options.ellipsis='...']\n\t     * @param  {number} [options.maxIterations=3]\n\t     * @param  {number} [options.minCharacters=3]\n\t     * @return {string}\n\t     */\n\t    function textEllipsis(text, textFont, containerWidth, options) {\n\t        if (!containerWidth) {\n\t            return '';\n\t        }\n\t\n\t        options = util.defaults({\n\t            ellipsis: '...',\n\t            minCharacters: 3,\n\t            maxIterations: 3,\n\t            cnCharWidth: getTextWidth('国', textFont),\n\t            // FIXME\n\t            // 未考虑非等宽字体\n\t            ascCharWidth: getTextWidth('a', textFont)\n\t        }, options, true);\n\t\n\t        containerWidth -= getTextWidth(options.ellipsis);\n\t\n\t        var textLines = (text + '').split('\\n');\n\t\n\t        for (var i = 0, len = textLines.length; i < len; i++) {\n\t            textLines[i] = textLineTruncate(\n\t                textLines[i], textFont, containerWidth, options\n\t            );\n\t        }\n\t\n\t        return textLines.join('\\n');\n\t    }\n\t\n\t    function textLineTruncate(text, textFont, containerWidth, options) {\n\t        // FIXME\n\t        // 粗糙得写的，尚未考虑性能和各种语言、字体的效果。\n\t        for (var i = 0;; i++) {\n\t            var lineWidth = getTextWidth(text, textFont);\n\t\n\t            if (lineWidth < containerWidth || i >= options.maxIterations) {\n\t                text += options.ellipsis;\n\t                break;\n\t            }\n\t\n\t            var subLength = i === 0\n\t                ? estimateLength(text, containerWidth, options)\n\t                : Math.floor(text.length * containerWidth / lineWidth);\n\t\n\t            if (subLength < options.minCharacters) {\n\t                text = '';\n\t                break;\n\t            }\n\t\n\t            text = text.substr(0, subLength);\n\t        }\n\t\n\t        return text;\n\t    }\n\t\n\t    function estimateLength(text, containerWidth, options) {\n\t        var width = 0;\n\t        var i = 0;\n\t        for (var len = text.length; i < len && width < containerWidth; i++) {\n\t            var charCode = text.charCodeAt(i);\n\t            width += (0 <= charCode && charCode <= 127)\n\t                ? options.ascCharWidth : options.cnCharWidth;\n\t        }\n\t        return i;\n\t    }\n\t\n\t    var textContain = {\n\t\n\t        getWidth: getTextWidth,\n\t\n\t        getBoundingRect: getTextRect,\n\t\n\t        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\t\n\t        ellipsis: textEllipsis,\n\t\n\t        measureText: function (text, textFont) {\n\t            var ctx = util.getContext();\n\t            ctx.font = textFont;\n\t            return ctx.measureText(text);\n\t        }\n\t    };\n\t\n\t    module.exports = textContain;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            var r = shape.r;\n\t            var r1;\n\t            var r2;\n\t            var r3;\n\t            var r4;\n\t\n\t            // Convert width and height to positive for better borderRadius\n\t            if (width < 0) {\n\t                x = x + width;\n\t                width = -width;\n\t            }\n\t            if (height < 0) {\n\t                y = y + height;\n\t                height = -height;\n\t            }\n\t\n\t            if (typeof r === 'number') {\n\t                r1 = r2 = r3 = r4 = r;\n\t            }\n\t            else if (r instanceof Array) {\n\t                if (r.length === 1) {\n\t                    r1 = r2 = r3 = r4 = r[0];\n\t                }\n\t                else if (r.length === 2) {\n\t                    r1 = r3 = r[0];\n\t                    r2 = r4 = r[1];\n\t                }\n\t                else if (r.length === 3) {\n\t                    r1 = r[0];\n\t                    r2 = r4 = r[1];\n\t                    r3 = r[2];\n\t                }\n\t                else {\n\t                    r1 = r[0];\n\t                    r2 = r[1];\n\t                    r3 = r[2];\n\t                    r4 = r[3];\n\t                }\n\t            }\n\t            else {\n\t                r1 = r2 = r3 = r4 = 0;\n\t            }\n\t\n\t            var total;\n\t            if (r1 + r2 > width) {\n\t                total = r1 + r2;\n\t                r1 *= width / total;\n\t                r2 *= width / total;\n\t            }\n\t            if (r3 + r4 > width) {\n\t                total = r3 + r4;\n\t                r3 *= width / total;\n\t                r4 *= width / total;\n\t            }\n\t            if (r2 + r3 > height) {\n\t                total = r2 + r3;\n\t                r2 *= height / total;\n\t                r3 *= height / total;\n\t            }\n\t            if (r1 + r4 > height) {\n\t                total = r1 + r4;\n\t                r1 *= height / total;\n\t                r4 *= height / total;\n\t            }\n\t            ctx.moveTo(x + r1, y);\n\t            ctx.lineTo(x + width - r2, y);\n\t            r2 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y, x + width, y + r2\n\t            );\n\t            ctx.lineTo(x + width, y + height - r3);\n\t            r3 !== 0 && ctx.quadraticCurveTo(\n\t                x + width, y + height, x + width - r3, y + height\n\t            );\n\t            ctx.lineTo(x + r4, y + height);\n\t            r4 !== 0 && ctx.quadraticCurveTo(\n\t                x, y + height, x, y + height - r4\n\t            );\n\t            ctx.lineTo(x, y + r1);\n\t            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t// Simple LRU cache use doubly linked list\n\t// @module zrender/core/LRU\n\t\n\t\n\t    /**\n\t     * Simple double linked list. Compared with array, it has O(1) remove operation.\n\t     * @constructor\n\t     */\n\t    var LinkedList = function() {\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.head = null;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.tail = null;\n\t\n\t        this._len = 0;\n\t    };\n\t\n\t    var linkedListProto = LinkedList.prototype;\n\t    /**\n\t     * Insert a new value at the tail\n\t     * @param  {} val\n\t     * @return {module:zrender/core/LRU~Entry}\n\t     */\n\t    linkedListProto.insert = function(val) {\n\t        var entry = new Entry(val);\n\t        this.insertEntry(entry);\n\t        return entry;\n\t    };\n\t\n\t    /**\n\t     * Insert an entry at the tail\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.insertEntry = function(entry) {\n\t        if (!this.head) {\n\t            this.head = this.tail = entry;\n\t        }\n\t        else {\n\t            this.tail.next = entry;\n\t            entry.prev = this.tail;\n\t            this.tail = entry;\n\t        }\n\t        this._len++;\n\t    };\n\t\n\t    /**\n\t     * Remove entry.\n\t     * @param  {module:zrender/core/LRU~Entry} entry\n\t     */\n\t    linkedListProto.remove = function(entry) {\n\t        var prev = entry.prev;\n\t        var next = entry.next;\n\t        if (prev) {\n\t            prev.next = next;\n\t        }\n\t        else {\n\t            // Is head\n\t            this.head = next;\n\t        }\n\t        if (next) {\n\t            next.prev = prev;\n\t        }\n\t        else {\n\t            // Is tail\n\t            this.tail = prev;\n\t        }\n\t        entry.next = entry.prev = null;\n\t        this._len--;\n\t    };\n\t\n\t    /**\n\t     * @return {number}\n\t     */\n\t    linkedListProto.len = function() {\n\t        return this._len;\n\t    };\n\t\n\t    /**\n\t     * @constructor\n\t     * @param {} val\n\t     */\n\t    var Entry = function(val) {\n\t        /**\n\t         * @type {}\n\t         */\n\t        this.value = val;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.next;\n\t\n\t        /**\n\t         * @type {module:zrender/core/LRU~Entry}\n\t         */\n\t        this.prev;\n\t    };\n\t\n\t    /**\n\t     * LRU Cache\n\t     * @constructor\n\t     * @alias module:zrender/core/LRU\n\t     */\n\t    var LRU = function(maxSize) {\n\t\n\t        this._list = new LinkedList();\n\t\n\t        this._map = {};\n\t\n\t        this._maxSize = maxSize || 10;\n\t    };\n\t\n\t    var LRUProto = LRU.prototype;\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @param  {} value\n\t     */\n\t    LRUProto.put = function(key, value) {\n\t        var list = this._list;\n\t        var map = this._map;\n\t        if (map[key] == null) {\n\t            var len = list.len();\n\t            if (len >= this._maxSize && len > 0) {\n\t                // Remove the least recently used\n\t                var leastUsedEntry = list.head;\n\t                list.remove(leastUsedEntry);\n\t                delete map[leastUsedEntry.key];\n\t            }\n\t\n\t            var entry = list.insert(value);\n\t            entry.key = key;\n\t            map[key] = entry;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param  {string} key\n\t     * @return {}\n\t     */\n\t    LRUProto.get = function(key) {\n\t        var entry = this._map[key];\n\t        var list = this._list;\n\t        if (entry != null) {\n\t            // Put the latest used entry in the tail\n\t            if (entry !== list.tail) {\n\t                list.remove(entry);\n\t                list.insertEntry(entry);\n\t            }\n\t\n\t            return entry.value;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Clear the cache\n\t     */\n\t    LRUProto.clear = function() {\n\t        this._list.clear();\n\t        this._map = {};\n\t    };\n\t\n\t    module.exports = LRU;\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO节点\r\n\t * 1.BO是一个矩形\r\n\t * 2.BO有名字\r\n\t * 3.BO有事件决策[]，双击事件决策弹出详情\r\n\t * 4.BO有外键属性[]\r\n\t * 5.BO有子BO\r\n\t * 6.当前BO特殊颜色显示\r\n\t * 7.双击BO弹出BO属性以及属性事件决策页面\r\n\t * @module fish-topo-bo/node/BoNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var BoName = __webpack_require__(39);\r\n\t    var EventDecision = __webpack_require__(69);\r\n\t    var Line = __webpack_require__(70);\r\n\t    var BoAttr = __webpack_require__(71);\r\n\t    var graphic = __webpack_require__(40);\r\n\t\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String BO主键,\r\n\t     *          name: String BO名字,\r\n\t     *          boEventArr: [] BO事件决策数组,\r\n\t     *          boAttrArr: [] BO属性数组\r\n\t     *          }} boData, bo数据对象\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number} 起始位置,\r\n\t     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n\t     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n\t     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n\t     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n\t     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n\t     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n\t     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n\t     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n\t     *          isCurrent: boolean 是否为当前BO\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BO(boData, opts) {\r\n\t\r\n\t        /**\r\n\t         * BO数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boData;\r\n\t\r\n\t        /**\r\n\t         * 初始坐标，用于最后画BO矩形\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._oriStartPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n\t         * @type {{x: number, y: number}}\r\n\t         * @private\r\n\t         */\r\n\t        this._nextStartPos = {\r\n\t            x: opts.startPos.x,\r\n\t            y: opts.startPos.y\r\n\t        };\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示属性事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\t\r\n\t        //TODO\r\n\t        if (this._displayAttrEvent) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n\t        } else if (this._displayAttrDataType) {\r\n\t            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n\t        }\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._boClickable = opts.boClickable || false;\r\n\t        this._boPopupOpts = opts.boPopupOpts;\r\n\t        this._boEventClickable = opts.boEventClickable || false;\r\n\t        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n\t        this._attrEventClickable = opts.attrEventClickable || false;\r\n\t        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * 是否是当前BO，当前BO特殊颜色显示\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._isCurrent = opts.isCurrent || false;\r\n\t\r\n\t\r\n\t        /**\r\n\t         * BO矩形高度，根据实际内容计算\r\n\t         * @type {number}\r\n\t         * @private\r\n\t         */\r\n\t        this._boShapeHeight = 0;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t        this._group.setCurrent = function (style) {\r\n\t            //Group最后一个是BO矩形\r\n\t            var _boShape = this.childAt(this.childCount() - 1);\r\n\t\r\n\t            if (style) {\r\n\t                fish.extend(_boShape.style, style);\r\n\t            } else {\r\n\t                //默认效果\r\n\t                _boShape.style.fill = '#66CC99';\r\n\t            }\r\n\t\r\n\t        };\r\n\t\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t\r\n\t    var boProto = BO.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取BO整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 获取数据\r\n\t     * @returns {Object}\r\n\t     */\r\n\t    boProto.getData = function () {\r\n\t        return this._data;\r\n\t    };\r\n\t\r\n\t    boProto.getLayout = function () {\r\n\t        return this._data.layout;\r\n\t    };\r\n\t\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 设置当前BO特殊演示显示\r\n\t     */\r\n\t    boProto.setCurrent = function () {\r\n\t        //BO矩形是最后一个图形\r\n\t        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO整体图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._render = function () {\r\n\t        //BO名字\r\n\t        this._createBoName();\r\n\t\r\n\t        //BO事件决策\r\n\t        this._createEventDecision();\r\n\t\r\n\t        //BO属性\r\n\t        this._createBoAttr();\r\n\t\r\n\t        //BO矩形\r\n\t        this._createBoShape();\r\n\t\r\n\t        //TODO\r\n\t        Const.BO_NODE_WIDTH = 180;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO名字文本\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoName = function () {\r\n\t        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            _boNameShape.clickable = this._boClickable;\r\n\t            _boNameShape._data = this._data;\r\n\t            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n\t            _boNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(_boNameShape);\r\n\t        this._calNextShapeStartPos(_boNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createEventDecision = function () {\r\n\t\r\n\t        //如果没有BO事件决策，则返回\r\n\t        if (!this._data.boEventArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boEventArr = this._data.boEventArr,\r\n\t            _boEventLen = _boEventArr.length,\r\n\t            _eventShape,\r\n\t            _eventOpts = {\r\n\t                startPos: this._nextStartPos,\r\n\t                clickable: this._boEventClickable,\r\n\t                popupOpts: this._boEventPopupOpts\r\n\t            };\r\n\t\r\n\t        for (var i = 0; i < _boEventLen; i++) {\r\n\t            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n\t            this._group.add(_eventShape.getShape());\r\n\t            this._calNextShapeStartPos(_eventShape.getShape());\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoAttr = function () {\r\n\t        //如果没有BO属性，则返回\r\n\t        if (!this._data.boAttrArr) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrArr = this._data.boAttrArr,\r\n\t            _boAttrLen = _boAttrArr.length,\r\n\t            _boAttrShape, _lineShape,\r\n\t            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\t\r\n\t        for (var i = 0; i < _boAttrLen; i++) {\r\n\t            if (i == 0) {\r\n\t                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n\t            }\r\n\t            else {\r\n\t                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n\t            }\r\n\t\r\n\t            this._group.add(_lineShape);\r\n\t\r\n\t            this._calNextShapeStartPos(_lineShape);\r\n\t\r\n\t            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n\t                {\r\n\t                    startPos: this._nextStartPos,\r\n\t                    displayDataType: this._displayAttrDataType,\r\n\t                    displayEventDecision: this._displayAttrEvent,\r\n\t                    eventClickable: this._attrEventClickable,\r\n\t                    eventPopupOpts: this._attrEventPopupOpts\r\n\t                }\r\n\t            );\r\n\t            this._group.add(_boAttrShape.getShape());\r\n\t            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n\t        }\r\n\t\r\n\t        if (this._displayAttrEvent) {\r\n\t            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n\t                this._nextStartPos.y - _attrEventStartPos.y\r\n\t            );\r\n\t            this._group.add(_lineShape);\r\n\t        }\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n\t     * @param curShape 当前图形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._calNextShapeStartPos = function (curShape) {\r\n\t        //下一图形起始位置\r\n\t        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\t\r\n\t        //BO矩形高度增加\r\n\t        this._boShapeHeight += curShape.getBoundingRect().height;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO矩形\r\n\t     * @private\r\n\t     */\r\n\t    boProto._createBoShape = function () {\r\n\t        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n\t                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n\t            shape = new graphic.Rect({\r\n\t                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\t\r\n\t                shape: {\r\n\t                    r: 5,\r\n\t                    width: Const.BO_NODE_WIDTH,\r\n\t                    height: height\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    brushType: 'both',\r\n\t                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 1,\r\n\t                    lineCape: 'round'\r\n\t                },\r\n\t\r\n\t                zlevel: -1\r\n\t            });\r\n\t\r\n\t        if (this._boClickable) {\r\n\t            shape._data = this._data;\r\n\t            shape._boPopupOpts = this._boPopupOpts;\r\n\t\r\n\t            shape.clickable = this._boClickable;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    boProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._boPopupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    module.exports = BO;\r\n\t\r\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    module.exports = {\r\n\t        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n\t        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n\t        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n\t        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\t\r\n\t        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n\t        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n\t        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\t\r\n\t        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n\t        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n\t        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\t\r\n\t        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n\t        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n\t        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n\t        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n\t        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n\t        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\t\r\n\t        LINE_DASH: 10,  //虚线\r\n\t        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n\t        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n\t        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n\t        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n\t        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n\t    };\r\n\t\r\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO名字\r\n\t * @module fish-topo-bo/node/BoName\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var graphic = __webpack_require__(40);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {String} text, BO名字\r\n\t     * @param {{x: number, y: number}} startPos, 起始位置\r\n\t     * @returns {zrender/graphic/Text}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoName(text, startPos) {\r\n\t        var x = startPos.x,\r\n\t            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\t\r\n\t            shape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: text,\r\n\t                    textFont: Const.BO_NAME_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n\t        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\t\r\n\t        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t    module.exports = BoName;\r\n\t\r\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\r\n\t\r\n\t    var zrUtil = __webpack_require__(9);\r\n\t\r\n\t    var pathTool = __webpack_require__(41);\r\n\t    var round = Math.round;\r\n\t    var Path = __webpack_require__(42);\r\n\t    var colorTool = __webpack_require__(23);\r\n\t    var matrix = __webpack_require__(17);\r\n\t    var vector = __webpack_require__(18);\r\n\t    var Gradient = __webpack_require__(10);\r\n\t\r\n\t    var graphic = {};\r\n\t    graphic.Util = zrUtil;\r\n\t    graphic.Group = __webpack_require__(14);\r\n\t\r\n\t    graphic.Image = __webpack_require__(30);\r\n\t\r\n\t    graphic.Text = __webpack_require__(54);\r\n\t\r\n\t    graphic.textContain = __webpack_require__(34);\r\n\t\r\n\t    graphic.Circle = __webpack_require__(55);\r\n\t\r\n\t    graphic.Sector = __webpack_require__(56);\r\n\t\r\n\t    graphic.Ring = __webpack_require__(57);\r\n\t\r\n\t    graphic.Polygon = __webpack_require__(58);\r\n\t\r\n\t    graphic.Polyline = __webpack_require__(62);\r\n\t\r\n\t    graphic.Rect = __webpack_require__(63);\r\n\t\r\n\t    graphic.Line = __webpack_require__(64);\r\n\t\r\n\t    graphic.BezierCurve = __webpack_require__(65);\r\n\t\r\n\t    graphic.Arc = __webpack_require__(66);\r\n\t\r\n\t    graphic.LinearGradient = __webpack_require__(67);\r\n\t\r\n\t    graphic.RadialGradient = __webpack_require__(68);\r\n\t\r\n\t    graphic.BoundingRect = __webpack_require__(26);\r\n\t\r\n\t    /**\r\n\t     * Extend shape with parameters\r\n\t     */\r\n\t    graphic.extendShape = function (opts) {\r\n\t        return Path.extend(opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Extend path\r\n\t     */\r\n\t    graphic.extendPath = function (pathData, opts) {\r\n\t        return pathTool.extendFromString(pathData, opts);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Create a path element from path data string\r\n\t     * @param {string} pathData\r\n\t     * @param {Object} opts\r\n\t     * @param {module:zrender/core/BoundingRect} rect\r\n\t     * @param {string} [layout=cover] 'center' or 'cover'\r\n\t     */\r\n\t    graphic.makePath = function (pathData, opts, rect, layout) {\r\n\t        var path = pathTool.createFromString(pathData, opts);\r\n\t        var boundingRect = path.getBoundingRect();\r\n\t        if (rect) {\r\n\t            var aspect = boundingRect.width / boundingRect.height;\r\n\t\r\n\t            if (layout === 'center') {\r\n\t                // Set rect to center, keep width / height ratio.\r\n\t                var width = rect.height * aspect;\r\n\t                var height;\r\n\t                if (width <= rect.width) {\r\n\t                    height = rect.height;\r\n\t                }\r\n\t                else {\r\n\t                    width = rect.width;\r\n\t                    height = width / aspect;\r\n\t                }\r\n\t                var cx = rect.x + rect.width / 2;\r\n\t                var cy = rect.y + rect.height / 2;\r\n\t\r\n\t                rect.x = cx - width / 2;\r\n\t                rect.y = cy - height / 2;\r\n\t                rect.width = width;\r\n\t                rect.height = height;\r\n\t            }\r\n\t\r\n\t            this.resizePath(path, rect);\r\n\t        }\r\n\t        return path;\r\n\t    };\r\n\t\r\n\t    graphic.mergePath = pathTool.mergePath,\r\n\t\r\n\t    /**\r\n\t     * Resize a path to fit the rect\r\n\t     * @param {module:zrender/graphic/Path} path\r\n\t     * @param {Object} rect\r\n\t     */\r\n\t    graphic.resizePath = function (path, rect) {\r\n\t        if (!path.applyTransform) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var pathRect = path.getBoundingRect();\r\n\t\r\n\t        var m = pathRect.calculateTransform(rect);\r\n\t\r\n\t        path.applyTransform(m);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize line for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x1]\r\n\t     * @param {number} [param.shape.y1]\r\n\t     * @param {number} [param.shape.x2]\r\n\t     * @param {number} [param.shape.y2]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeLine = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t\r\n\t        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n\t            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n\t        }\r\n\t        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n\t            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n\t        }\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize rect for canvas\r\n\t     *\r\n\t     * @param {Object} param\r\n\t     * @param {Object} [param.shape]\r\n\t     * @param {number} [param.shape.x]\r\n\t     * @param {number} [param.shape.y]\r\n\t     * @param {number} [param.shape.width]\r\n\t     * @param {number} [param.shape.height]\r\n\t     * @param {Object} [param.style]\r\n\t     * @param {number} [param.style.lineWidth]\r\n\t     * @return {Object} Modified param\r\n\t     */\r\n\t    graphic.subPixelOptimizeRect = function (param) {\r\n\t        var subPixelOptimize = graphic.subPixelOptimize;\r\n\t        var shape = param.shape;\r\n\t        var lineWidth = param.style.lineWidth;\r\n\t        var originX = shape.x;\r\n\t        var originY = shape.y;\r\n\t        var originWidth = shape.width;\r\n\t        var originHeight = shape.height;\r\n\t        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n\t        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n\t        shape.width = Math.max(\r\n\t            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n\t            originWidth === 0 ? 0 : 1\r\n\t        );\r\n\t        shape.height = Math.max(\r\n\t            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n\t            originHeight === 0 ? 0 : 1\r\n\t        );\r\n\t        return param;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Sub pixel optimize for canvas\r\n\t     *\r\n\t     * @param {number} position Coordinate, such as x, y\r\n\t     * @param {number} lineWidth Should be nonnegative integer.\r\n\t     * @param {boolean=} positiveOrNegative Default false (negative).\r\n\t     * @return {number} Optimized position.\r\n\t     */\r\n\t    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n\t        // Assure that (position + lineWidth / 2) is near integer edge,\r\n\t        // otherwise line will be fuzzy in canvas.\r\n\t        var doubledPosition = round(position * 2);\r\n\t        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n\t            ? doubledPosition / 2\r\n\t            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    function doSingleEnterHover(el) {\r\n\t        if (el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t        if (el.__hoverStlDirty) {\r\n\t            var stroke = el.style.stroke;\r\n\t            var fill = el.style.fill;\r\n\t\r\n\t            // Create hoverStyle on mouseover\r\n\t            var hoverStyle = el.__hoverStl;\r\n\t            var lift = colorTool.lift;\r\n\t            hoverStyle.fill = hoverStyle.fill\r\n\t                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n\t            hoverStyle.stroke = hoverStyle.stroke\r\n\t                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\t\r\n\t            var normalStyle = {};\r\n\t            for (var name in hoverStyle) {\r\n\t                if (hoverStyle.hasOwnProperty(name)) {\r\n\t                    normalStyle[name] = el.style[name];\r\n\t                }\r\n\t            }\r\n\t\r\n\t            el.__normalStl = normalStyle;\r\n\t\r\n\t            el.__hoverStlDirty = false;\r\n\t        }\r\n\t        el.setStyle(el.__hoverStl);\r\n\t        el.z2 += 1;\r\n\t\r\n\t        el.__isHover = true;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doSingleLeaveHover(el) {\r\n\t        if (!el.__isHover) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var normalStl = el.__normalStl;\r\n\t        normalStl && el.setStyle(normalStl);\r\n\t        el.z2 -= 1;\r\n\t\r\n\t        el.__isHover = false;\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function doEnterHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleEnterHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleEnterHover(el);\r\n\t    }\r\n\t    graphic.doEnterHover = doEnterHover;\r\n\t    function doLeaveHover(el) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    doSingleLeaveHover(child);\r\n\t                }\r\n\t            })\r\n\t            : doSingleLeaveHover(el);\r\n\t    }\r\n\t    graphic.doLeaveHover = doLeaveHover;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function setElementHoverStl(el, hoverStl) {\r\n\t        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n\t        // Often used when item group has a label element and it's hoverStyle is different\r\n\t        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n\t        el.__hoverStlDirty = true;\r\n\t    }\r\n\t    graphic.setElementHoverStl = setElementHoverStl;\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOver() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function onElementMouseOut() {\r\n\t        // Only if element is not in emphasis status\r\n\t        !this.__isEmphasis && doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function enterEmphasis() {\r\n\t        this.__isEmphasis = true;\r\n\t        doEnterHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * @inner\r\n\t     */\r\n\t    function leaveEmphasis() {\r\n\t        this.__isEmphasis = false;\r\n\t        doLeaveHover(this);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * Set hover style of element\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} [hoverStyle]\r\n\t     */\r\n\t    graphic.setHoverStyle = function (el, hoverStyle) {\r\n\t        el.type === 'group'\r\n\t            ? el.traverse(function (child) {\r\n\t                if (child.type !== 'group') {\r\n\t                    setElementHoverStl(child, hoverStyle);\r\n\t                }\r\n\t            })\r\n\t            : setElementHoverStl(el, hoverStyle);\r\n\t        // Remove previous bound handlers\r\n\t        el.on('mouseover', onElementMouseOver)\r\n\t          .on('mouseout', onElementMouseOut);\r\n\t\r\n\t        // Emphasis, normal can be triggered manually\r\n\t        el.on('emphasis', enterEmphasis)\r\n\t          .on('normal', leaveEmphasis);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Set text option in the style\r\n\t     * @param {Object} textStyle\r\n\t     * @param {module:echarts/model/Model} labelModel\r\n\t     * @param {string} color\r\n\t     */\r\n\t    graphic.setText = function (textStyle, labelModel, color) {\r\n\t        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n\t        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n\t        var textStyleModel = labelModel.getModel('textStyle');\r\n\t        zrUtil.extend(textStyle, {\r\n\t            textDistance: labelModel.getShallow('distance') || 5,\r\n\t            textFont: textStyleModel.getFont(),\r\n\t            textPosition: labelPosition,\r\n\t            textFill: textStyleModel.getTextColor() || labelColor\r\n\t        });\r\n\t    };\r\n\t\r\n\t    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n\t        var postfix = isUpdate ? 'Update' : '';\r\n\t        var duration = animatableModel\r\n\t            && animatableModel.getShallow('animationDuration' + postfix);\r\n\t        var animationEasing = animatableModel\r\n\t            && animatableModel.getShallow('animationEasing' + postfix);\r\n\t\r\n\t        animatableModel && animatableModel.getShallow('animation')\r\n\t            ? el.animateTo(props, duration, animationEasing, cb)\r\n\t            : (el.attr(props), cb && cb());\r\n\t    }\r\n\t    /**\r\n\t     * Update graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\t\r\n\t    /**\r\n\t     * Init graphic element properties with or without animation according to the configuration in series\r\n\t     * @param {module:zrender/Element} el\r\n\t     * @param {Object} props\r\n\t     * @param {module:echarts/model/Model} [animatableModel]\r\n\t     * @param {Function} cb\r\n\t     */\r\n\t    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\t\r\n\t    /**\r\n\t     * Get transform matrix of target (param target),\r\n\t     * in coordinate of its ancestor (param ancestor)\r\n\t     *\r\n\t     * @param {module:zrender/mixin/Transformable} target\r\n\t     * @param {module:zrender/mixin/Transformable} ancestor\r\n\t     */\r\n\t    graphic.getTransform = function (target, ancestor) {\r\n\t        var mat = matrix.identity([]);\r\n\t\r\n\t        while (target && target !== ancestor) {\r\n\t            matrix.mul(mat, target.getLocalTransform(), mat);\r\n\t            target = target.parent;\r\n\t        }\r\n\t\r\n\t        return mat;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * Apply transform to an vertex.\r\n\t     * @param {Array.<number>} vertex [x, y]\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {Array.<number>} [x, y]\r\n\t     */\r\n\t    graphic.applyTransform = function (vertex, transform, invert) {\r\n\t        if (invert) {\r\n\t            transform = matrix.invert([], transform);\r\n\t        }\r\n\t        return vector.applyTransform([], vertex, transform);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n\t     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n\t     * @param {boolean=} invert Whether use invert matrix.\r\n\t     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n\t     */\r\n\t    graphic.transformDirection = function (direction, transform, invert) {\r\n\t\r\n\t        // Pick a base, ensure that transform result will not be (0, 0).\r\n\t        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n\t        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n\t            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\t\r\n\t        var vertex = [\r\n\t            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n\t            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n\t        ];\r\n\t\r\n\t        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\t\r\n\t        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n\t            ? (vertex[0] > 0 ? 'right' : 'left')\r\n\t            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n\t    };\r\n\t\r\n\t    module.exports = graphic;\r\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var Path = __webpack_require__(42);\n\t    var PathProxy = __webpack_require__(43);\n\t    var transformPath = __webpack_require__(53);\n\t    var matrix = __webpack_require__(17);\n\t\n\t    // command chars\n\t    var cc = [\n\t        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n\t        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n\t    ];\n\t\n\t    var mathSqrt = Math.sqrt;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t    var PI = Math.PI;\n\t\n\t    var vMag = function(v) {\n\t        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n\t    };\n\t    var vRatio = function(u, v) {\n\t        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n\t    };\n\t    var vAngle = function(u, v) {\n\t        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n\t                * Math.acos(vRatio(u, v));\n\t    };\n\t\n\t    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n\t        var psi = psiDeg * (PI / 180.0);\n\t        var xp = mathCos(psi) * (x1 - x2) / 2.0\n\t                 + mathSin(psi) * (y1 - y2) / 2.0;\n\t        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n\t                 + mathCos(psi) * (y1 - y2) / 2.0;\n\t\n\t        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\t\n\t        if (lambda > 1) {\n\t            rx *= mathSqrt(lambda);\n\t            ry *= mathSqrt(lambda);\n\t        }\n\t\n\t        var f = (fa === fs ? -1 : 1)\n\t            * mathSqrt((((rx * rx) * (ry * ry))\n\t                    - ((rx * rx) * (yp * yp))\n\t                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n\t                    + (ry * ry) * (xp * xp))\n\t                ) || 0;\n\t\n\t        var cxp = f * rx * yp / ry;\n\t        var cyp = f * -ry * xp / rx;\n\t\n\t        var cx = (x1 + x2) / 2.0\n\t                 + mathCos(psi) * cxp\n\t                 - mathSin(psi) * cyp;\n\t        var cy = (y1 + y2) / 2.0\n\t                + mathSin(psi) * cxp\n\t                + mathCos(psi) * cyp;\n\t\n\t        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n\t        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n\t        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n\t        var dTheta = vAngle(u, v);\n\t\n\t        if (vRatio(u, v) <= -1) {\n\t            dTheta = PI;\n\t        }\n\t        if (vRatio(u, v) >= 1) {\n\t            dTheta = 0;\n\t        }\n\t        if (fs === 0 && dTheta > 0) {\n\t            dTheta = dTheta - 2 * PI;\n\t        }\n\t        if (fs === 1 && dTheta < 0) {\n\t            dTheta = dTheta + 2 * PI;\n\t        }\n\t\n\t        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n\t    }\n\t\n\t    function createPathProxyFromString(data) {\n\t        if (!data) {\n\t            return [];\n\t        }\n\t\n\t        // command string\n\t        var cs = data.replace(/-/g, ' -')\n\t            .replace(/  /g, ' ')\n\t            .replace(/ /g, ',')\n\t            .replace(/,,/g, ',');\n\t\n\t        var n;\n\t        // create pipes so that we can split the data\n\t        for (n = 0; n < cc.length; n++) {\n\t            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n\t        }\n\t\n\t        // create array\n\t        var arr = cs.split('|');\n\t        // init context point\n\t        var cpx = 0;\n\t        var cpy = 0;\n\t\n\t        var path = new PathProxy();\n\t        var CMD = PathProxy.CMD;\n\t\n\t        var prevCmd;\n\t        for (n = 1; n < arr.length; n++) {\n\t            var str = arr[n];\n\t            var c = str.charAt(0);\n\t            var off = 0;\n\t            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n\t            var cmd;\n\t\n\t            if (p.length > 0 && p[0] === '') {\n\t                p.shift();\n\t            }\n\t\n\t            for (var i = 0; i < p.length; i++) {\n\t                p[i] = parseFloat(p[i]);\n\t            }\n\t            while (off < p.length && !isNaN(p[off])) {\n\t                if (isNaN(p[0])) {\n\t                    break;\n\t                }\n\t                var ctlPtx;\n\t                var ctlPty;\n\t\n\t                var rx;\n\t                var ry;\n\t                var psi;\n\t                var fa;\n\t                var fs;\n\t\n\t                var x1 = cpx;\n\t                var y1 = cpy;\n\t\n\t                // convert l, H, h, V, and v to L\n\t                switch (c) {\n\t                    case 'l':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'L':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'm':\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'l';\n\t                        break;\n\t                    case 'M':\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.M;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        c = 'L';\n\t                        break;\n\t                    case 'h':\n\t                        cpx += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'H':\n\t                        cpx = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'v':\n\t                        cpy += p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'V':\n\t                        cpy = p[off++];\n\t                        cmd = CMD.L;\n\t                        path.addData(cmd, cpx, cpy);\n\t                        break;\n\t                    case 'C':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n\t                        );\n\t                        cpx = p[off - 2];\n\t                        cpy = p[off - 1];\n\t                        break;\n\t                    case 'c':\n\t                        cmd = CMD.C;\n\t                        path.addData(\n\t                            cmd,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy,\n\t                            p[off++] + cpx, p[off++] + cpy\n\t                        );\n\t                        cpx += p[off - 2];\n\t                        cpy += p[off - 1];\n\t                        break;\n\t                    case 'S':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 's':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.C) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cmd = CMD.C;\n\t                        x1 = cpx + p[off++];\n\t                        y1 = cpy + p[off++];\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'Q':\n\t                        x1 = p[off++];\n\t                        y1 = p[off++];\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'q':\n\t                        x1 = p[off++] + cpx;\n\t                        y1 = p[off++] + cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, x1, y1, cpx, cpy);\n\t                        break;\n\t                    case 'T':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 't':\n\t                        ctlPtx = cpx;\n\t                        ctlPty = cpy;\n\t                        var len = path.len();\n\t                        var pathData = path.data;\n\t                        if (prevCmd === CMD.Q) {\n\t                            ctlPtx += cpx - pathData[len - 4];\n\t                            ctlPty += cpy - pathData[len - 3];\n\t                        }\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.Q;\n\t                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n\t                        break;\n\t                    case 'A':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx = p[off++];\n\t                        cpy = p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                    case 'a':\n\t                        rx = p[off++];\n\t                        ry = p[off++];\n\t                        psi = p[off++];\n\t                        fa = p[off++];\n\t                        fs = p[off++];\n\t\n\t                        x1 = cpx, y1 = cpy;\n\t                        cpx += p[off++];\n\t                        cpy += p[off++];\n\t                        cmd = CMD.A;\n\t                        processArc(\n\t                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n\t                        );\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (c === 'z' || c === 'Z') {\n\t                cmd = CMD.Z;\n\t                path.addData(cmd);\n\t            }\n\t\n\t            prevCmd = cmd;\n\t        }\n\t\n\t        path.toStatic();\n\t\n\t        return path;\n\t    }\n\t\n\t    // TODO Optimize double memory cost problem\n\t    function createPathOptions(str, opts) {\n\t        var pathProxy = createPathProxyFromString(str);\n\t        var transform;\n\t        opts = opts || {};\n\t        opts.buildPath = function (path) {\n\t            path.setData(pathProxy.data);\n\t            transform && transformPath(path, transform);\n\t            // Svg and vml renderer don't have context\n\t            var ctx = path.getContext();\n\t            if (ctx) {\n\t                path.rebuildPath(ctx);\n\t            }\n\t        };\n\t\n\t        opts.applyTransform = function (m) {\n\t            if (!transform) {\n\t                transform = matrix.create();\n\t            }\n\t            matrix.mul(transform, m, transform);\n\t        };\n\t\n\t        return opts;\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Create a Path object from path string data\n\t         * http://www.w3.org/TR/SVG/paths.html#PathData\n\t         * @param  {Object} opts Other options\n\t         */\n\t        createFromString: function (str, opts) {\n\t            return new Path(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Create a Path class from path string data\n\t         * @param  {string} str\n\t         * @param  {Object} opts Other options\n\t         */\n\t        extendFromString: function (str, opts) {\n\t            return Path.extend(createPathOptions(str, opts));\n\t        },\n\t\n\t        /**\n\t         * Merge multiple paths\n\t         */\n\t        // TODO Apply transform\n\t        // TODO stroke dash\n\t        // TODO Optimize double memory cost problem\n\t        mergePath: function (pathEls, opts) {\n\t            var pathList = [];\n\t            var len = pathEls.length;\n\t            var pathEl;\n\t            var i;\n\t            for (i = 0; i < len; i++) {\n\t                pathEl = pathEls[i];\n\t                if (pathEl.__dirty) {\n\t                    pathEl.buildPath(pathEl.path, pathEl.shape);\n\t                }\n\t                pathList.push(pathEl.path);\n\t            }\n\t\n\t            var pathBundle = new Path(opts);\n\t            pathBundle.buildPath = function (path) {\n\t                path.appendPath(pathList);\n\t                // Svg and vml renderer don't have context\n\t                var ctx = path.getContext();\n\t                if (ctx) {\n\t                    path.rebuildPath(ctx);\n\t                }\n\t            };\n\t\n\t            return pathBundle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Path element\n\t * @module zrender/graphic/Path\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(31);\n\t    var zrUtil = __webpack_require__(9);\n\t    var PathProxy = __webpack_require__(43);\n\t    var pathContain = __webpack_require__(46);\n\t\n\t    var Gradient = __webpack_require__(10);\n\t\n\t    function pathHasFill(style) {\n\t        var fill = style.fill;\n\t        return fill != null && fill !== 'none';\n\t    }\n\t\n\t    function pathHasStroke(style) {\n\t        var stroke = style.stroke;\n\t        return stroke != null && stroke !== 'none' && style.lineWidth > 0;\n\t    }\n\t\n\t    var abs = Math.abs;\n\t\n\t    /**\n\t     * @alias module:zrender/graphic/Path\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    function Path(opts) {\n\t        Displayable.call(this, opts);\n\t\n\t        /**\n\t         * @type {module:zrender/core/PathProxy}\n\t         * @readOnly\n\t         */\n\t        this.path = new PathProxy();\n\t    }\n\t\n\t    Path.prototype = {\n\t\n\t        constructor: Path,\n\t\n\t        type: 'path',\n\t\n\t        __dirtyPath: true,\n\t\n\t        strokeContainThreshold: 5,\n\t\n\t        brush: function (ctx) {\n\t            ctx.save();\n\t\n\t            var style = this.style;\n\t            var path = this.path;\n\t            var hasStroke = pathHasStroke(style);\n\t            var hasFill = pathHasFill(style);\n\t\n\t            if (this.__dirtyPath) {\n\t                // Update gradient because bounding rect may changed\n\t                if (hasFill && (style.fill instanceof Gradient)) {\n\t                    style.fill.updateCanvasGradient(this, ctx);\n\t                }\n\t                if (hasStroke && (style.stroke instanceof Gradient)) {\n\t                    style.stroke.updateCanvasGradient(this, ctx);\n\t                }\n\t            }\n\t\n\t            style.bind(ctx, this);\n\t            this.setTransform(ctx);\n\t\n\t            var lineDash = style.lineDash;\n\t            var lineDashOffset = style.lineDashOffset;\n\t\n\t            var ctxLineDash = !!ctx.setLineDash;\n\t\n\t            // Proxy context\n\t            // Rebuild path in following 2 cases\n\t            // 1. Path is dirty\n\t            // 2. Path needs javascript implemented lineDash stroking.\n\t            //    In this case, lineDash information will not be saved in PathProxy\n\t            if (this.__dirtyPath || (\n\t                lineDash && !ctxLineDash && hasStroke\n\t            )) {\n\t                path = this.path.beginPath(ctx);\n\t\n\t                // Setting line dash before build path\n\t                if (lineDash && !ctxLineDash) {\n\t                    path.setLineDash(lineDash);\n\t                    path.setLineDashOffset(lineDashOffset);\n\t                }\n\t\n\t                this.buildPath(path, this.shape);\n\t\n\t                // Clear path dirty flag\n\t                this.__dirtyPath = false;\n\t            }\n\t            else {\n\t                // Replay path building\n\t                ctx.beginPath();\n\t                this.path.rebuildPath(ctx);\n\t            }\n\t\n\t            hasFill && path.fill(ctx);\n\t\n\t            if (lineDash && ctxLineDash) {\n\t                ctx.setLineDash(lineDash);\n\t                ctx.lineDashOffset = lineDashOffset;\n\t            }\n\t\n\t            hasStroke && path.stroke(ctx);\n\t\n\t            // Draw rect text\n\t            if (style.text != null) {\n\t                // var rect = this.getBoundingRect();\n\t                this.drawRectText(ctx, this.getBoundingRect());\n\t            }\n\t\n\t            ctx.restore();\n\t        },\n\t\n\t        buildPath: function (ctx, shapeCfg) {},\n\t\n\t        getBoundingRect: function () {\n\t            var rect = this._rect;\n\t            var style = this.style;\n\t            if (!rect) {\n\t                var path = this.path;\n\t                if (this.__dirtyPath) {\n\t                    path.beginPath();\n\t                    this.buildPath(path, this.shape);\n\t                }\n\t                rect = path.getBoundingRect();\n\t            }\n\t            /**\n\t             * Needs update rect with stroke lineWidth when\n\t             * 1. Element changes scale or lineWidth\n\t             * 2. First create rect\n\t             */\n\t            if (pathHasStroke(style) && (this.__dirty || !this._rect)) {\n\t                var rectWithStroke = this._rectWithStroke\n\t                    || (this._rectWithStroke = rect.clone());\n\t                rectWithStroke.copy(rect);\n\t                // FIXME Must after updateTransform\n\t                var w = style.lineWidth;\n\t                // PENDING, Min line width is needed when line is horizontal or vertical\n\t                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t\n\t                // Only add extra hover lineWidth when there are no fill\n\t                if (!pathHasFill(style)) {\n\t                    w = Math.max(w, this.strokeContainThreshold);\n\t                }\n\t                // Consider line width\n\t                // Line scale can't be 0;\n\t                if (lineScale > 1e-10) {\n\t                    rectWithStroke.width += w / lineScale;\n\t                    rectWithStroke.height += w / lineScale;\n\t                    rectWithStroke.x -= w / lineScale / 2;\n\t                    rectWithStroke.y -= w / lineScale / 2;\n\t                }\n\t                return rectWithStroke;\n\t            }\n\t            this._rect = rect;\n\t            return rect;\n\t        },\n\t\n\t        contain: function (x, y) {\n\t            var localPos = this.transformCoordToLocal(x, y);\n\t            var rect = this.getBoundingRect();\n\t            var style = this.style;\n\t            x = localPos[0];\n\t            y = localPos[1];\n\t\n\t            if (rect.contain(x, y)) {\n\t                var pathData = this.path.data;\n\t                if (pathHasStroke(style)) {\n\t                    var lineWidth = style.lineWidth;\n\t                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\t                    // Line scale can't be 0;\n\t                    if (lineScale > 1e-10) {\n\t                        // Only add extra hover lineWidth when there are no fill\n\t                        if (!pathHasFill(style)) {\n\t                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n\t                        }\n\t                        if (pathContain.containStroke(\n\t                            pathData, lineWidth / lineScale, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t                if (pathHasFill(style)) {\n\t                    return pathContain.contain(pathData, x, y);\n\t                }\n\t            }\n\t            return false;\n\t        },\n\t\n\t        /**\n\t         * @param  {boolean} dirtyPath\n\t         */\n\t        dirty: function (dirtyPath) {\n\t            if (arguments.length ===0) {\n\t                dirtyPath = true;\n\t            }\n\t            // Only mark dirty, not mark clean\n\t            if (dirtyPath) {\n\t                this.__dirtyPath = dirtyPath;\n\t                this._rect = null;\n\t            }\n\t\n\t            this.__dirty = true;\n\t\n\t            this.__zr && this.__zr.refresh();\n\t\n\t            // Used as a clipping path\n\t            if (this.__clipTarget) {\n\t                this.__clipTarget.dirty();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Alias for animate('shape')\n\t         * @param {boolean} loop\n\t         */\n\t        animateShape: function (loop) {\n\t            return this.animate('shape', loop);\n\t        },\n\t\n\t        // Overwrite attrKV\n\t        attrKV: function (key, value) {\n\t            // FIXME\n\t            if (key === 'shape') {\n\t                this.setShape(value);\n\t            }\n\t            else {\n\t                Displayable.prototype.attrKV.call(this, key, value);\n\t            }\n\t        },\n\t        /**\n\t         * @param {Object|string} key\n\t         * @param {*} value\n\t         */\n\t        setShape: function (key, value) {\n\t            var shape = this.shape;\n\t            // Path from string may not have shape\n\t            if (shape) {\n\t                if (zrUtil.isObject(key)) {\n\t                    for (var name in key) {\n\t                        shape[name] = key[name];\n\t                    }\n\t                }\n\t                else {\n\t                    shape[key] = value;\n\t                }\n\t                this.dirty(true);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        getLineScale: function () {\n\t            var m = this.transform;\n\t            // Get the line scale.\n\t            // Determinant of `m` means how much the area is enlarged by the\n\t            // transformation. So its square root can be used as a scale factor\n\t            // for width.\n\t            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n\t                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n\t                : 1;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * 扩展一个 Path element, 比如星形，圆等。\n\t     * Extend a path element\n\t     * @param {Object} props\n\t     * @param {string} props.type Path type\n\t     * @param {Function} props.init Initialize\n\t     * @param {Function} props.buildPath Overwrite buildPath method\n\t     * @param {Object} [props.style] Extended default style config\n\t     * @param {Object} [props.shape] Extended default shape config\n\t     */\n\t    Path.extend = function (defaults) {\n\t        var Sub = function (opts) {\n\t            Path.call(this, opts);\n\t\n\t            if (defaults.style) {\n\t                // Extend default style\n\t                this.style.extendFrom(defaults.style, false);\n\t            }\n\t\n\t            // Extend default shape\n\t            var defaultShape = defaults.shape;\n\t            if (defaultShape) {\n\t                this.shape = this.shape || {};\n\t                var thisShape = this.shape;\n\t                for (var name in defaultShape) {\n\t                    if (\n\t                        ! thisShape.hasOwnProperty(name)\n\t                        && defaultShape.hasOwnProperty(name)\n\t                    ) {\n\t                        thisShape[name] = defaultShape[name];\n\t                    }\n\t                }\n\t            }\n\t\n\t            defaults.init && defaults.init.call(this, opts);\n\t        };\n\t\n\t        zrUtil.inherits(Sub, Path);\n\t\n\t        // FIXME 不能 extend position, rotation 等引用对象\n\t        for (var name in defaults) {\n\t            // Extending prototype values and methods\n\t            if (name !== 'style' && name !== 'shape') {\n\t                Sub.prototype[name] = defaults[name];\n\t            }\n\t        }\n\t\n\t        return Sub;\n\t    };\n\t\n\t    zrUtil.inherits(Path, Displayable);\n\t\n\t    module.exports = Path;\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n\t * 可以用于 isInsidePath 判断以及获取boundingRect\n\t *\n\t * @module zrender/core/PathProxy\n\t * @author Yi Shen (http://www.github.com/pissang)\n\t */\n\t\n\t // TODO getTotalLength, getPointAtLength\n\t\n\t\n\t    var curve = __webpack_require__(44);\n\t    var vec2 = __webpack_require__(18);\n\t    var bbox = __webpack_require__(45);\n\t    var BoundingRect = __webpack_require__(26);\n\t\n\t    var CMD = {\n\t        M: 1,\n\t        L: 2,\n\t        C: 3,\n\t        Q: 4,\n\t        A: 5,\n\t        Z: 6,\n\t        // Rect\n\t        R: 7\n\t    };\n\t\n\t    var min = [];\n\t    var max = [];\n\t    var min2 = [];\n\t    var max2 = [];\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathCos = Math.cos;\n\t    var mathSin = Math.sin;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var hasTypedArray = typeof Float32Array != 'undefined';\n\t\n\t    /**\n\t     * @alias module:zrender/core/PathProxy\n\t     * @constructor\n\t     */\n\t    var PathProxy = function () {\n\t\n\t        /**\n\t         * Path data. Stored as flat array\n\t         * @type {Array.<Object>}\n\t         */\n\t        this.data = [];\n\t\n\t        this._len = 0;\n\t\n\t        this._ctx = null;\n\t\n\t        this._xi = 0;\n\t        this._yi = 0;\n\t\n\t        this._x0 = 0;\n\t        this._y0 = 0;\n\t    };\n\t\n\t    /**\n\t     * 快速计算Path包围盒（并不是最小包围盒）\n\t     * @return {Object}\n\t     */\n\t    PathProxy.prototype = {\n\t\n\t        constructor: PathProxy,\n\t\n\t        _lineDash: null,\n\t\n\t        _dashOffset: 0,\n\t\n\t        _dashIdx: 0,\n\t\n\t        _dashSum: 0,\n\t\n\t        getContext: function () {\n\t            return this._ctx;\n\t        },\n\t\n\t        /**\n\t         * @param  {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        beginPath: function (ctx) {\n\t            this._ctx = ctx;\n\t\n\t            ctx && ctx.beginPath();\n\t\n\t            // Reset\n\t            this._len = 0;\n\t\n\t            if (this._lineDash) {\n\t                this._lineDash = null;\n\t\n\t                this._dashOffset = 0;\n\t            }\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        moveTo: function (x, y) {\n\t            this.addData(CMD.M, x, y);\n\t            this._ctx && this._ctx.moveTo(x, y);\n\t\n\t            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n\t            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n\t            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n\t            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\t            this._x0 = x;\n\t            this._y0 = y;\n\t\n\t            this._xi = x;\n\t            this._yi = y;\n\t\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x\n\t         * @param  {number} y\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        lineTo: function (x, y) {\n\t            this.addData(CMD.L, x, y);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedLineTo(x, y)\n\t                    : this._ctx.lineTo(x, y);\n\t            }\n\t            this._xi = x;\n\t            this._yi = y;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @param  {number} x3\n\t         * @param  {number} y3\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n\t            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n\t                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n\t            }\n\t            this._xi = x3;\n\t            this._yi = y3;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} x1\n\t         * @param  {number} y1\n\t         * @param  {number} x2\n\t         * @param  {number} y2\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        quadraticCurveTo: function (x1, y1, x2, y2) {\n\t            this.addData(CMD.Q, x1, y1, x2, y2);\n\t            if (this._ctx) {\n\t                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n\t                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n\t            }\n\t            this._xi = x2;\n\t            this._yi = y2;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @param  {number} cx\n\t         * @param  {number} cy\n\t         * @param  {number} r\n\t         * @param  {number} startAngle\n\t         * @param  {number} endAngle\n\t         * @param  {boolean} anticlockwise\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n\t            this.addData(\n\t                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n\t            );\n\t            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\t\n\t            this._xi = mathCos(endAngle) * r + cx;\n\t            this._xi = mathSin(endAngle) * r + cx;\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        arcTo: function (x1, y1, x2, y2, radius) {\n\t            if (this._ctx) {\n\t                this._ctx.arcTo(x1, y1, x2, y2, radius);\n\t            }\n\t            return this;\n\t        },\n\t\n\t        // TODO\n\t        rect: function (x, y, w, h) {\n\t            this._ctx && this._ctx.rect(x, y, w, h);\n\t            this.addData(CMD.R, x, y, w, h);\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        closePath: function () {\n\t            this.addData(CMD.Z);\n\t\n\t            var ctx = this._ctx;\n\t            var x0 = this._x0;\n\t            var y0 = this._y0;\n\t            if (ctx) {\n\t                this._needsDash() && this._dashedLineTo(x0, y0);\n\t                ctx.closePath();\n\t            }\n\t\n\t            this._xi = x0;\n\t            this._yi = y0;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n\t         * stroke 同样\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        fill: function (ctx) {\n\t            ctx && ctx.fill();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * @param {CanvasRenderingContext2D} ctx\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        stroke: function (ctx) {\n\t            ctx && ctx.stroke();\n\t            this.toStatic();\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDash: function (lineDash) {\n\t            if (lineDash instanceof Array) {\n\t                this._lineDash = lineDash;\n\t\n\t                this._dashIdx = 0;\n\t\n\t                var lineDashSum = 0;\n\t                for (var i = 0; i < lineDash.length; i++) {\n\t                    lineDashSum += lineDash[i];\n\t                }\n\t                this._dashSum = lineDashSum;\n\t            }\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         * 必须在其它绘制命令前调用\n\t         * Must be invoked before all other path drawing methods\n\t         * @return {module:zrender/core/PathProxy}\n\t         */\n\t        setLineDashOffset: function (offset) {\n\t            this._dashOffset = offset;\n\t            return this;\n\t        },\n\t\n\t        /**\n\t         *\n\t         * @return {boolean}\n\t         */\n\t        len: function () {\n\t            return this._len;\n\t        },\n\t\n\t        /**\n\t         * 直接设置 Path 数据\n\t         */\n\t        setData: function (data) {\n\t\n\t            var len = data.length;\n\t\n\t            if (! (this.data && this.data.length == len) && hasTypedArray) {\n\t                this.data = new Float32Array(len);\n\t            }\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                this.data[i] = data[i];\n\t            }\n\t\n\t            this._len = len;\n\t        },\n\t\n\t        /**\n\t         * 添加子路径\n\t         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n\t         */\n\t        appendPath: function (path) {\n\t            if (!(path instanceof Array)) {\n\t                path = [path];\n\t            }\n\t            var len = path.length;\n\t            var appendSize = 0;\n\t            var offset = this._len;\n\t            for (var i = 0; i < len; i++) {\n\t                appendSize += path[i].len();\n\t            }\n\t            if (hasTypedArray && (this.data instanceof Float32Array)) {\n\t                this.data = new Float32Array(offset + appendSize);\n\t            }\n\t            for (var i = 0; i < len; i++) {\n\t                var appendPathData = path[i].data;\n\t                for (var k = 0; k < appendPathData.length; k++) {\n\t                    this.data[offset++] = appendPathData[k];\n\t                }\n\t            }\n\t            this._len = offset;\n\t        },\n\t\n\t        /**\n\t         * 填充 Path 数据。\n\t         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n\t         */\n\t        addData: function (cmd) {\n\t            var data = this.data;\n\t            if (this._len + arguments.length > data.length) {\n\t                // 因为之前的数组已经转换成静态的 Float32Array\n\t                // 所以不够用时需要扩展一个新的动态数组\n\t                this._expandData();\n\t                data = this.data;\n\t            }\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                data[this._len++] = arguments[i];\n\t            }\n\t\n\t            this._prevCmd = cmd;\n\t        },\n\t\n\t        _expandData: function () {\n\t            // Only if data is Float32Array\n\t            if (!(this.data instanceof Array)) {\n\t                var newData = [];\n\t                for (var i = 0; i < this._len; i++) {\n\t                    newData[i] = this.data[i];\n\t                }\n\t                this.data = newData;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * If needs js implemented dashed line\n\t         * @return {boolean}\n\t         * @private\n\t         */\n\t        _needsDash: function () {\n\t            return this._lineDash;\n\t        },\n\t\n\t        _dashedLineTo: function (x1, y1) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var dx = x1 - x0;\n\t            var dy = y1 - y0;\n\t            var dist = mathSqrt(dx * dx + dy * dy);\n\t            var x = x0;\n\t            var y = y0;\n\t            var dash;\n\t            var nDash = lineDash.length;\n\t            var idx;\n\t            dx /= dist;\n\t            dy /= dist;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            x -= offset * dx;\n\t            y -= offset * dy;\n\t\n\t            while ((dx >= 0 && x <= x1) || (dx < 0 && x > x1)) {\n\t                idx = this._dashIdx;\n\t                dash = lineDash[idx];\n\t                x += dx * dash;\n\t                y += dy * dash;\n\t                this._dashIdx = (idx + 1) % nDash;\n\t                // Skip positive offset\n\t                if ((dx > 0 && x < x0) || (dx < 0 && x > x0)) {\n\t                    continue;\n\t                }\n\t                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n\t                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n\t                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n\t                );\n\t            }\n\t            // Offset for next lineTo\n\t            dx = x - x1;\n\t            dy = y - y1;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        // Not accurate dashed line to\n\t        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n\t            var dashSum = this._dashSum;\n\t            var offset = this._dashOffset;\n\t            var lineDash = this._lineDash;\n\t            var ctx = this._ctx;\n\t\n\t            var x0 = this._xi;\n\t            var y0 = this._yi;\n\t            var t;\n\t            var dx;\n\t            var dy;\n\t            var cubicAt = curve.cubicAt;\n\t            var bezierLen = 0;\n\t            var idx = this._dashIdx;\n\t            var nDash = lineDash.length;\n\t\n\t            var x;\n\t            var y;\n\t\n\t            var tmpLen = 0;\n\t\n\t            if (offset < 0) {\n\t                // Convert to positive offset\n\t                offset = dashSum + offset;\n\t            }\n\t            offset %= dashSum;\n\t            // Bezier approx length\n\t            for (t = 0; t < 1; t += 0.1) {\n\t                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n\t                    - cubicAt(x0, x1, x2, x3, t);\n\t                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n\t                    - cubicAt(y0, y1, y2, y3, t);\n\t                bezierLen += mathSqrt(dx * dx + dy * dy);\n\t            }\n\t\n\t            // Find idx after add offset\n\t            for (; idx < nDash; idx++) {\n\t                tmpLen += lineDash[idx];\n\t                if (tmpLen > offset) {\n\t                    break;\n\t                }\n\t            }\n\t            t = (tmpLen - offset) / bezierLen;\n\t\n\t            while (t <= 1) {\n\t\n\t                x = cubicAt(x0, x1, x2, x3, t);\n\t                y = cubicAt(y0, y1, y2, y3, t);\n\t\n\t                // Use line to approximate dashed bezier\n\t                // Bad result if dash is long\n\t                idx % 2 ? ctx.moveTo(x, y)\n\t                    : ctx.lineTo(x, y);\n\t\n\t                t += lineDash[idx] / bezierLen;\n\t\n\t                idx = (idx + 1) % nDash;\n\t            }\n\t\n\t            // Finish the last segment and calculate the new offset\n\t            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n\t            dx = x3 - x;\n\t            dy = y3 - y;\n\t            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n\t        },\n\t\n\t        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n\t            // Convert quadratic to cubic using degree elevation\n\t            var x3 = x2;\n\t            var y3 = y2;\n\t            x2 = (x2 + 2 * x1) / 3;\n\t            y2 = (y2 + 2 * y1) / 3;\n\t            x1 = (this._xi + 2 * x1) / 3;\n\t            y1 = (this._yi + 2 * y1) / 3;\n\t\n\t            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n\t        },\n\t\n\t        /**\n\t         * 转成静态的 Float32Array 减少堆内存占用\n\t         * Convert dynamic array to static Float32Array\n\t         */\n\t        toStatic: function () {\n\t            var data = this.data;\n\t            if (data instanceof Array) {\n\t                data.length = this._len;\n\t                if (hasTypedArray) {\n\t                    this.data = new Float32Array(data);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @return {module:zrender/core/BoundingRect}\n\t         */\n\t        getBoundingRect: function () {\n\t            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n\t            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\t\n\t            var data = this.data;\n\t            var xi = 0;\n\t            var yi = 0;\n\t            var x0 = 0;\n\t            var y0 = 0;\n\t\n\t            for (var i = 0; i < data.length;) {\n\t                var cmd = data[i++];\n\t\n\t                if (i == 1) {\n\t                    // 如果第一个命令是 L, C, Q\n\t                    // 则 previous point 同绘制命令的第一个 point\n\t                    //\n\t                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                    xi = data[i];\n\t                    yi = data[i + 1];\n\t\n\t                    x0 = xi;\n\t                    y0 = yi;\n\t                }\n\t\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                        // 在 closePath 的时候使用\n\t                        x0 = data[i++];\n\t                        y0 = data[i++];\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        min2[0] = x0;\n\t                        min2[1] = y0;\n\t                        max2[0] = x0;\n\t                        max2[1] = y0;\n\t                        break;\n\t                    case CMD.L:\n\t                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.C:\n\t                        bbox.fromCubic(\n\t                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.Q:\n\t                        bbox.fromQuadratic(\n\t                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n\t                            min2, max2\n\t                        );\n\t                        xi = data[i++];\n\t                        yi = data[i++];\n\t                        break;\n\t                    case CMD.A:\n\t                        // TODO Arc 判断的开销比较大\n\t                        var cx = data[i++];\n\t                        var cy = data[i++];\n\t                        var rx = data[i++];\n\t                        var ry = data[i++];\n\t                        var startAngle = data[i++];\n\t                        var endAngle = data[i++] + startAngle;\n\t                        // TODO Arc 旋转\n\t                        var psi = data[i++];\n\t                        var anticlockwise = 1 - data[i++];\n\t\n\t                        if (i == 1) {\n\t                            // 直接使用 arc 命令\n\t                            // 第一个命令起点还未定义\n\t                            x0 = mathCos(startAngle) * rx + cx;\n\t                            y0 = mathSin(startAngle) * ry + cy;\n\t                        }\n\t\n\t                        bbox.fromArc(\n\t                            cx, cy, rx, ry, startAngle, endAngle,\n\t                            anticlockwise, min2, max2\n\t                        );\n\t\n\t                        xi = mathCos(endAngle) * rx + cx;\n\t                        yi = mathSin(endAngle) * ry + cy;\n\t                        break;\n\t                    case CMD.R:\n\t                        x0 = xi = data[i++];\n\t                        y0 = yi = data[i++];\n\t                        var width = data[i++];\n\t                        var height = data[i++];\n\t                        // Use fromLine\n\t                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n\t                        break;\n\t                    case CMD.Z:\n\t                        xi = x0;\n\t                        yi = y0;\n\t                        break;\n\t                }\n\t\n\t                // Union\n\t                vec2.min(min, min, min2);\n\t                vec2.max(max, max, max2);\n\t            }\n\t\n\t            // No data\n\t            if (i === 0) {\n\t                min[0] = min[1] = max[0] = max[1] = 0;\n\t            }\n\t\n\t            return new BoundingRect(\n\t                min[0], min[1], max[0] - min[0], max[1] - min[1]\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Rebuild path from current data\n\t         * Rebuild path will not consider javascript implemented line dash.\n\t         * @param {CanvasRenderingContext} ctx\n\t         */\n\t        rebuildPath: function (ctx) {\n\t            var d = this.data;\n\t            for (var i = 0; i < this._len;) {\n\t                var cmd = d[i++];\n\t                switch (cmd) {\n\t                    case CMD.M:\n\t                        ctx.moveTo(d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.L:\n\t                        ctx.lineTo(d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.C:\n\t                        ctx.bezierCurveTo(\n\t                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n\t                        );\n\t                        break;\n\t                    case CMD.Q:\n\t                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.A:\n\t                        var cx = d[i++];\n\t                        var cy = d[i++];\n\t                        var rx = d[i++];\n\t                        var ry = d[i++];\n\t                        var theta = d[i++];\n\t                        var dTheta = d[i++];\n\t                        var psi = d[i++];\n\t                        var fs = d[i++];\n\t                        var r = (rx > ry) ? rx : ry;\n\t                        var scaleX = (rx > ry) ? 1 : rx / ry;\n\t                        var scaleY = (rx > ry) ? ry / rx : 1;\n\t                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n\t                        if (isEllipse) {\n\t                            ctx.translate(cx, cy);\n\t                            ctx.rotate(psi);\n\t                            ctx.scale(scaleX, scaleY);\n\t                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);\n\t                            ctx.scale(1 / scaleX, 1 / scaleY);\n\t                            ctx.rotate(-psi);\n\t                            ctx.translate(-cx, -cy);\n\t                        }\n\t                        else {\n\t                            ctx.arc(cx, cy, r, theta, theta + dTheta, 1 - fs);\n\t                        }\n\t                        break;\n\t                    case CMD.R:\n\t                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n\t                        break;\n\t                    case CMD.Z:\n\t                        ctx.closePath();\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    PathProxy.CMD = CMD;\n\t\n\t    module.exports = PathProxy;\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 曲线辅助模块\n\t * @module zrender/core/curve\n\t * @author pissang(https://www.github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(18);\n\t    var v2Create = vec2.create;\n\t    var v2DistSquare = vec2.distSquare;\n\t    var mathPow = Math.pow;\n\t    var mathSqrt = Math.sqrt;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    var THREE_SQRT = mathSqrt(3);\n\t    var ONE_THIRD = 1 / 3;\n\t\n\t    // 临时变量\n\t    var _v0 = v2Create();\n\t    var _v1 = v2Create();\n\t    var _v2 = v2Create();\n\t    // var _v3 = vec2.create();\n\t\n\t    function isAroundZero(val) {\n\t        return val > -EPSILON && val < EPSILON;\n\t    }\n\t    function isNotAroundZero(val) {\n\t        return val > EPSILON || val < -EPSILON;\n\t    }\n\t    /**\n\t     * 计算三次贝塞尔值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return onet * onet * (onet * p0 + 3 * t * p1)\n\t             + t * t * (t * p3 + 3 * onet * p2);\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔导数值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n\t        var onet = 1 - t;\n\t        return 3 * (\n\t            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n\t            + (p3 - p2) * t * t\n\t        );\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程根，使用盛金公式\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} val\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n\t        // Evaluate roots of cubic functions\n\t        var a = p3 + 3 * (p1 - p2) - p0;\n\t        var b = 3 * (p2 - p1 * 2 + p0);\n\t        var c = 3 * (p1  - p0);\n\t        var d = p0 - val;\n\t\n\t        var A = b * b - 3 * a * c;\n\t        var B = b * c - 9 * a * d;\n\t        var C = c * c - 3 * b * d;\n\t\n\t        var n = 0;\n\t\n\t        if (isAroundZero(A) && isAroundZero(B)) {\n\t            if (isAroundZero(b)) {\n\t                roots[0] = 0;\n\t            }\n\t            else {\n\t                var t1 = -c / b;  //t1, t2, t3, b is not zero\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = B * B - 4 * A * C;\n\t\n\t            if (isAroundZero(disc)) {\n\t                var K = B / A;\n\t                var t1 = -b / a + K;  // t1, a is not zero\n\t                var t2 = -K / 2;  // t2, t3\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n\t                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\t                if (Y1 < 0) {\n\t                    Y1 = -mathPow(-Y1, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y1 = mathPow(Y1, ONE_THIRD);\n\t                }\n\t                if (Y2 < 0) {\n\t                    Y2 = -mathPow(-Y2, ONE_THIRD);\n\t                }\n\t                else {\n\t                    Y2 = mathPow(Y2, ONE_THIRD);\n\t                }\n\t                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else {\n\t                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n\t                var theta = Math.acos(T) / 3;\n\t                var ASqrt = mathSqrt(A);\n\t                var tmp = Math.cos(theta);\n\t\n\t                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n\t                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t                if (t3 >= 0 && t3 <= 1) {\n\t                    roots[n++] = t3;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算三次贝塞尔方程极限值的位置\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {Array.<number>} extrema\n\t     * @return {number} 有效数目\n\t     */\n\t    function cubicExtrema(p0, p1, p2, p3, extrema) {\n\t        var b = 6 * p2 - 12 * p1 + 6 * p0;\n\t        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n\t        var c = 3 * p1 - 3 * p0;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <=1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                extrema[0] = -b / (2 * a);\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    extrema[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    extrema[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 细分三次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} p3\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p23 = (p3 - p2) * t + p2;\n\t\n\t        var p012 = (p12 - p01) * t + p01;\n\t        var p123 = (p23 - p12) * t + p12;\n\t\n\t        var p0123 = (p123 - p012) * t + p012;\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t        out[3] = p0123;\n\t        // Seg1\n\t        out[4] = p0123;\n\t        out[5] = p123;\n\t        out[6] = p23;\n\t        out[7] = p3;\n\t    }\n\t\n\t    /**\n\t     * 投射点到三次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} [out] 投射点\n\t     * @return {number}\n\t     */\n\t    function cubicProjectPoint(\n\t        x0, y0, x1, y1, x2, y2, x3, y3,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t        var prev;\n\t        var next;\n\t        var d1;\n\t        var d2;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n\t            d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON) {\n\t                break;\n\t            }\n\t            prev = t - interval;\n\t            next = t + interval;\n\t            // t - interval\n\t            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n\t            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\t\n\t            d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n\t                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n\t                d2 = v2DistSquare(_v2, _v0);\n\t\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = cubicAt(x0, x1, x2, x3, t);\n\t            out[1] = cubicAt(y0, y1, y2, y3, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticAt(p0, p1, p2, t) {\n\t        var onet = 1 - t;\n\t        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔导数值\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @return {number}\n\t     */\n\t    function quadraticDerivativeAt(p0, p1, p2, t) {\n\t        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n\t    }\n\t\n\t    /**\n\t     * 计算二次方贝塞尔方程根\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} roots\n\t     * @return {number} 有效根数目\n\t     */\n\t    function quadraticRootAt(p0, p1, p2, val, roots) {\n\t        var a = p0 - 2 * p1 + p2;\n\t        var b = 2 * (p1 - p0);\n\t        var c = p0 - val;\n\t\n\t        var n = 0;\n\t        if (isAroundZero(a)) {\n\t            if (isNotAroundZero(b)) {\n\t                var t1 = -c / b;\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t        }\n\t        else {\n\t            var disc = b * b - 4 * a * c;\n\t            if (isAroundZero(disc)) {\n\t                var t1 = -b / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t            }\n\t            else if (disc > 0) {\n\t                var discSqrt = mathSqrt(disc);\n\t                var t1 = (-b + discSqrt) / (2 * a);\n\t                var t2 = (-b - discSqrt) / (2 * a);\n\t                if (t1 >= 0 && t1 <= 1) {\n\t                    roots[n++] = t1;\n\t                }\n\t                if (t2 >= 0 && t2 <= 1) {\n\t                    roots[n++] = t2;\n\t                }\n\t            }\n\t        }\n\t        return n;\n\t    }\n\t\n\t    /**\n\t     * 计算二次贝塞尔方程极限值\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @return {number}\n\t     */\n\t    function quadraticExtremum(p0, p1, p2) {\n\t        var divider = p0 + p2 - 2 * p1;\n\t        if (divider === 0) {\n\t            // p1 is center of p0 and p2\n\t            return 0.5;\n\t        }\n\t        else {\n\t            return (p0 - p1) / divider;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * 细分二次贝塞尔曲线\n\t     * @memberOf module:zrender/core/curve\n\t     * @param  {number} p0\n\t     * @param  {number} p1\n\t     * @param  {number} p2\n\t     * @param  {number} t\n\t     * @param  {Array.<number>} out\n\t     */\n\t    function quadraticSubdivide(p0, p1, p2, t, out) {\n\t        var p01 = (p1 - p0) * t + p0;\n\t        var p12 = (p2 - p1) * t + p1;\n\t        var p012 = (p12 - p01) * t + p01;\n\t\n\t        // Seg0\n\t        out[0] = p0;\n\t        out[1] = p01;\n\t        out[2] = p012;\n\t\n\t        // Seg1\n\t        out[3] = p012;\n\t        out[4] = p12;\n\t        out[5] = p2;\n\t    }\n\t\n\t    /**\n\t     * 投射点到二次贝塞尔曲线上，返回投射距离。\n\t     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {Array.<number>} out 投射点\n\t     * @return {number}\n\t     */\n\t    function quadraticProjectPoint(\n\t        x0, y0, x1, y1, x2, y2,\n\t        x, y, out\n\t    ) {\n\t        // http://pomax.github.io/bezierinfo/#projections\n\t        var t;\n\t        var interval = 0.005;\n\t        var d = Infinity;\n\t\n\t        _v0[0] = x;\n\t        _v0[1] = y;\n\t\n\t        // 先粗略估计一下可能的最小距离的 t 值\n\t        // PENDING\n\t        for (var _t = 0; _t < 1; _t += 0.05) {\n\t            _v1[0] = quadraticAt(x0, x1, x2, _t);\n\t            _v1[1] = quadraticAt(y0, y1, y2, _t);\n\t            var d1 = v2DistSquare(_v0, _v1);\n\t            if (d1 < d) {\n\t                t = _t;\n\t                d = d1;\n\t            }\n\t        }\n\t        d = Infinity;\n\t\n\t        // At most 32 iteration\n\t        for (var i = 0; i < 32; i++) {\n\t            if (interval < EPSILON) {\n\t                break;\n\t            }\n\t            var prev = t - interval;\n\t            var next = t + interval;\n\t            // t - interval\n\t            _v1[0] = quadraticAt(x0, x1, x2, prev);\n\t            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\t\n\t            var d1 = v2DistSquare(_v1, _v0);\n\t\n\t            if (prev >= 0 && d1 < d) {\n\t                t = prev;\n\t                d = d1;\n\t            }\n\t            else {\n\t                // t + interval\n\t                _v2[0] = quadraticAt(x0, x1, x2, next);\n\t                _v2[1] = quadraticAt(y0, y1, y2, next);\n\t                var d2 = v2DistSquare(_v2, _v0);\n\t                if (next <= 1 && d2 < d) {\n\t                    t = next;\n\t                    d = d2;\n\t                }\n\t                else {\n\t                    interval *= 0.5;\n\t                }\n\t            }\n\t        }\n\t        // t\n\t        if (out) {\n\t            out[0] = quadraticAt(x0, x1, x2, t);\n\t            out[1] = quadraticAt(y0, y1, y2, t);\n\t        }\n\t        // console.log(interval, i);\n\t        return mathSqrt(d);\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        cubicAt: cubicAt,\n\t\n\t        cubicDerivativeAt: cubicDerivativeAt,\n\t\n\t        cubicRootAt: cubicRootAt,\n\t\n\t        cubicExtrema: cubicExtrema,\n\t\n\t        cubicSubdivide: cubicSubdivide,\n\t\n\t        cubicProjectPoint: cubicProjectPoint,\n\t\n\t        quadraticAt: quadraticAt,\n\t\n\t        quadraticDerivativeAt: quadraticDerivativeAt,\n\t\n\t        quadraticRootAt: quadraticRootAt,\n\t\n\t        quadraticExtremum: quadraticExtremum,\n\t\n\t        quadraticSubdivide: quadraticSubdivide,\n\t\n\t        quadraticProjectPoint: quadraticProjectPoint\n\t    };\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @author Yi Shen(https://github.com/pissang)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(18);\n\t    var curve = __webpack_require__(44);\n\t\n\t    var bbox = {};\n\t    var mathMin = Math.min;\n\t    var mathMax = Math.max;\n\t    var mathSin = Math.sin;\n\t    var mathCos = Math.cos;\n\t\n\t    var start = vec2.create();\n\t    var end = vec2.create();\n\t    var extremity = vec2.create();\n\t\n\t    var PI2 = Math.PI * 2;\n\t    /**\n\t     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n\t     * @module zrender/core/bbox\n\t     * @param {Array<Object>} points 顶点数组\n\t     * @param {number} min\n\t     * @param {number} max\n\t     */\n\t    bbox.fromPoints = function(points, min, max) {\n\t        if (points.length === 0) {\n\t            return;\n\t        }\n\t        var p = points[0];\n\t        var left = p[0];\n\t        var right = p[0];\n\t        var top = p[1];\n\t        var bottom = p[1];\n\t        var i;\n\t\n\t        for (i = 1; i < points.length; i++) {\n\t            p = points[i];\n\t            left = mathMin(left, p[0]);\n\t            right = mathMax(right, p[0]);\n\t            top = mathMin(top, p[1]);\n\t            bottom = mathMax(bottom, p[1]);\n\t        }\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n\t        min[0] = mathMin(x0, x1);\n\t        min[1] = mathMin(y0, y1);\n\t        max[0] = mathMax(x0, x1);\n\t        max[1] = mathMax(y0, y1);\n\t    };\n\t\n\t    /**\n\t     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {number} x3\n\t     * @param {number} y3\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromCubic = function(\n\t        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n\t    ) {\n\t        var xDim = [];\n\t        var yDim = [];\n\t        var cubicExtrema = curve.cubicExtrema;\n\t        var cubicAt = curve.cubicAt;\n\t        var left, right, top, bottom;\n\t        var i;\n\t        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\t\n\t        for (i = 0; i < n; i++) {\n\t            xDim[i] = cubicAt(x0, x1, x2, x3, xDim[i]);\n\t        }\n\t        n = cubicExtrema(y0, y1, y2, y3, yDim);\n\t        for (i = 0; i < n; i++) {\n\t            yDim[i] = cubicAt(y0, y1, y2, y3, yDim[i]);\n\t        }\n\t\n\t        xDim.push(x0, x3);\n\t        yDim.push(y0, y3);\n\t\n\t        left = mathMin.apply(null, xDim);\n\t        right = mathMax.apply(null, xDim);\n\t        top = mathMin.apply(null, yDim);\n\t        bottom = mathMax.apply(null, yDim);\n\t\n\t        min[0] = left;\n\t        min[1] = top;\n\t        max[0] = right;\n\t        max[1] = bottom;\n\t    };\n\t\n\t    /**\n\t     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x0\n\t     * @param {number} y0\n\t     * @param {number} x1\n\t     * @param {number} y1\n\t     * @param {number} x2\n\t     * @param {number} y2\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n\t        var quadraticExtremum = curve.quadraticExtremum;\n\t        var quadraticAt = curve.quadraticAt;\n\t        // Find extremities, where derivative in x dim or y dim is zero\n\t        var tx =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n\t            );\n\t        var ty =\n\t            mathMax(\n\t                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n\t            );\n\t\n\t        var x = quadraticAt(x0, x1, x2, tx);\n\t        var y = quadraticAt(y0, y1, y2, ty);\n\t\n\t        min[0] = mathMin(x0, x2, x);\n\t        min[1] = mathMin(y0, y2, y);\n\t        max[0] = mathMax(x0, x2, x);\n\t        max[1] = mathMax(y0, y2, y);\n\t    };\n\t\n\t    /**\n\t     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n\t     * @method\n\t     * @memberOf module:zrender/core/bbox\n\t     * @param {number} x\n\t     * @param {number} y\n\t     * @param {number} rx\n\t     * @param {number} ry\n\t     * @param {number} startAngle\n\t     * @param {number} endAngle\n\t     * @param {number} anticlockwise\n\t     * @param {Array.<number>} min\n\t     * @param {Array.<number>} max\n\t     */\n\t    bbox.fromArc = function (\n\t        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n\t    ) {\n\t        var vec2Min = vec2.min;\n\t        var vec2Max = vec2.max;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t\n\t\n\t        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n\t            // Is a circle\n\t            min[0] = x - rx;\n\t            min[1] = y - ry;\n\t            max[0] = x + rx;\n\t            max[1] = y + ry;\n\t            return;\n\t        }\n\t\n\t        start[0] = mathCos(startAngle) * rx + x;\n\t        start[1] = mathSin(startAngle) * ry + y;\n\t\n\t        end[0] = mathCos(endAngle) * rx + x;\n\t        end[1] = mathSin(endAngle) * ry + y;\n\t\n\t        vec2Min(min, start, end);\n\t        vec2Max(max, start, end);\n\t\n\t        // Thresh to [0, Math.PI * 2]\n\t        startAngle = startAngle % (PI2);\n\t        if (startAngle < 0) {\n\t            startAngle = startAngle + PI2;\n\t        }\n\t        endAngle = endAngle % (PI2);\n\t        if (endAngle < 0) {\n\t            endAngle = endAngle + PI2;\n\t        }\n\t\n\t        if (startAngle > endAngle && !anticlockwise) {\n\t            endAngle += PI2;\n\t        }\n\t        else if (startAngle < endAngle && anticlockwise) {\n\t            startAngle += PI2;\n\t        }\n\t        if (anticlockwise) {\n\t            var tmp = endAngle;\n\t            endAngle = startAngle;\n\t            startAngle = tmp;\n\t        }\n\t\n\t        // var number = 0;\n\t        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\t        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n\t            if (angle > startAngle) {\n\t                extremity[0] = mathCos(angle) * rx + x;\n\t                extremity[1] = mathSin(angle) * ry + y;\n\t\n\t                vec2Min(min, extremity, min);\n\t                vec2Max(max, extremity, max);\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = bbox;\n\t\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var CMD = __webpack_require__(43).CMD;\n\t    var line = __webpack_require__(47);\n\t    var cubic = __webpack_require__(48);\n\t    var quadratic = __webpack_require__(49);\n\t    var arc = __webpack_require__(50);\n\t    var normalizeRadian = __webpack_require__(51).normalizeRadian;\n\t    var curve = __webpack_require__(44);\n\t\n\t    var windingLine = __webpack_require__(52);\n\t\n\t    var containStroke = line.containStroke;\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var EPSILON = 1e-4;\n\t\n\t    function isAroundEqual(a, b) {\n\t        return Math.abs(a - b) < EPSILON;\n\t    }\n\t\n\t    // 临时数组\n\t    var roots = [-1, -1, -1];\n\t    var extrema = [-1, -1];\n\t\n\t    function swapExtrema() {\n\t        var tmp = extrema[0];\n\t        extrema[0] = extrema[1];\n\t        extrema[1] = tmp;\n\t    }\n\t\n\t    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2 && y > y3)\n\t            || (y < y0 && y < y1 && y < y2 && y < y3)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var w = 0;\n\t            var nExtrema = -1;\n\t            var y0_, y1_;\n\t            for (var i = 0; i < nRoots; i++) {\n\t                var t = roots[i];\n\t                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\t                if (x_ < x) { // Quick reject\n\t                    continue;\n\t                }\n\t                if (nExtrema < 0) {\n\t                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\t                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n\t                        swapExtrema();\n\t                    }\n\t                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\t                    if (nExtrema > 1) {\n\t                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n\t                    }\n\t                }\n\t                if (nExtrema == 2) {\n\t                    // 分成三段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? 1 : -1;\n\t                    }\n\t                    else if (t < extrema[1]) {\n\t                        w += y1_ < y0_ ? 1 : -1;\n\t                    }\n\t                    else {\n\t                        w += y3 < y1_ ? 1 : -1;\n\t                    }\n\t                }\n\t                else {\n\t                    // 分成两段单调函数\n\t                    if (t < extrema[0]) {\n\t                        w += y0_ < y0 ? 1 : -1;\n\t                    }\n\t                    else {\n\t                        w += y3 < y0_ ? 1 : -1;\n\t                    }\n\t                }\n\t            }\n\t            return w;\n\t        }\n\t    }\n\t\n\t    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n\t        // Quick reject\n\t        if (\n\t            (y > y0 && y > y1 && y > y2)\n\t            || (y < y0 && y < y1 && y < y2)\n\t        ) {\n\t            return 0;\n\t        }\n\t        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\t        if (nRoots === 0) {\n\t            return 0;\n\t        }\n\t        else {\n\t            var t = curve.quadraticExtremum(y0, y1, y2);\n\t            if (t >=0 && t <= 1) {\n\t                var w = 0;\n\t                var y_ = curve.quadraticAt(y0, y1, y2, t);\n\t                for (var i = 0; i < nRoots; i++) {\n\t                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\t                    if (x_ > x) {\n\t                        continue;\n\t                    }\n\t                    if (roots[i] < t) {\n\t                        w += y_ < y0 ? 1 : -1;\n\t                    }\n\t                    else {\n\t                        w += y2 < y_ ? 1 : -1;\n\t                    }\n\t                }\n\t                return w;\n\t            }\n\t            else {\n\t                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\t                if (x_ > x) {\n\t                    return 0;\n\t                }\n\t                return y2 < y0 ? 1 : -1;\n\t            }\n\t        }\n\t    }\n\t\n\t    // TODO\n\t    // Arc 旋转\n\t    function windingArc(\n\t        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n\t    ) {\n\t        y -= cy;\n\t        if (y > r || y < -r) {\n\t            return 0;\n\t        }\n\t        var tmp = Math.sqrt(r * r - y * y);\n\t        roots[0] = -tmp;\n\t        roots[1] = tmp;\n\t\n\t        var diff = Math.abs(startAngle - endAngle);\n\t        if (diff < 1e-4) {\n\t            return 0;\n\t        }\n\t        if (diff % PI2 < 1e-4) {\n\t            // Is a circle\n\t            startAngle = 0;\n\t            endAngle = PI2;\n\t            var dir = anticlockwise ? 1 : -1;\n\t            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n\t                return dir;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t\n\t        if (anticlockwise) {\n\t            var tmp = startAngle;\n\t            startAngle = normalizeRadian(endAngle);\n\t            endAngle = normalizeRadian(tmp);\n\t        }\n\t        else {\n\t            startAngle = normalizeRadian(startAngle);\n\t            endAngle = normalizeRadian(endAngle);\n\t        }\n\t        if (startAngle > endAngle) {\n\t            endAngle += PI2;\n\t        }\n\t\n\t        var w = 0;\n\t        for (var i = 0; i < 2; i++) {\n\t            var x_ = roots[i];\n\t            if (x_ + cx > x) {\n\t                var angle = Math.atan2(y, x_);\n\t                var dir = anticlockwise ? 1 : -1;\n\t                if (angle < 0) {\n\t                    angle = PI2 + angle;\n\t                }\n\t                if (\n\t                    (angle >= startAngle && angle <= endAngle)\n\t                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n\t                ) {\n\t                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n\t                        dir = -dir;\n\t                    }\n\t                    w += dir;\n\t                }\n\t            }\n\t        }\n\t        return w;\n\t    }\n\t\n\t    function containPath(data, lineWidth, isStroke, x, y) {\n\t        var w = 0;\n\t        var xi = 0;\n\t        var yi = 0;\n\t        var x0 = 0;\n\t        var y0 = 0;\n\t\n\t        for (var i = 0; i < data.length;) {\n\t            var cmd = data[i++];\n\t            // Begin a new subpath\n\t            if (cmd === CMD.M && i > 1) {\n\t                // Close previous subpath\n\t                if (!isStroke) {\n\t                    w += windingLine(xi, yi, x0, y0, x, y);\n\t                }\n\t                // 如果被任何一个 subpath 包含\n\t                if (w !== 0) {\n\t                    return true;\n\t                }\n\t            }\n\t\n\t            if (i == 1) {\n\t                // 如果第一个命令是 L, C, Q\n\t                // 则 previous point 同绘制命令的第一个 point\n\t                //\n\t                // 第一个命令为 Arc 的情况下会在后面特殊处理\n\t                xi = data[i];\n\t                yi = data[i + 1];\n\t\n\t                x0 = xi;\n\t                y0 = yi;\n\t            }\n\t\n\t            switch (cmd) {\n\t                case CMD.M:\n\t                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n\t                    // 在 closePath 的时候使用\n\t                    x0 = data[i++];\n\t                    y0 = data[i++];\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t                case CMD.L:\n\t                    if (isStroke) {\n\t                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n\t                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.C:\n\t                    if (isStroke) {\n\t                        if (cubic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingCubic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.Q:\n\t                    if (isStroke) {\n\t                        if (quadratic.containStroke(xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingQuadratic(\n\t                            xi, yi,\n\t                            data[i++], data[i++], data[i], data[i + 1],\n\t                            x, y\n\t                        ) || 0;\n\t                    }\n\t                    xi = data[i++];\n\t                    yi = data[i++];\n\t                    break;\n\t                case CMD.A:\n\t                    // TODO Arc 判断的开销比较大\n\t                    var cx = data[i++];\n\t                    var cy = data[i++];\n\t                    var rx = data[i++];\n\t                    var ry = data[i++];\n\t                    var theta = data[i++];\n\t                    var dTheta = data[i++];\n\t                    // TODO Arc 旋转\n\t                    var psi = data[i++];\n\t                    var anticlockwise = 1 - data[i++];\n\t                    var x1 = Math.cos(theta) * rx + cx;\n\t                    var y1 = Math.sin(theta) * ry + cy;\n\t                    // 不是直接使用 arc 命令\n\t                    if (i > 1) {\n\t                        w += windingLine(xi, yi, x1, y1, x, y);\n\t                    }\n\t                    else {\n\t                        // 第一个命令起点还未定义\n\t                        x0 = x1;\n\t                        y0 = y1;\n\t                    }\n\t                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\t                    var _x = (x - cx) * ry / rx + cx;\n\t                    if (isStroke) {\n\t                        if (arc.containStroke(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            lineWidth, _x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        w += windingArc(\n\t                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n\t                            _x, y\n\t                        );\n\t                    }\n\t                    xi = Math.cos(theta + dTheta) * rx + cx;\n\t                    yi = Math.sin(theta + dTheta) * ry + cy;\n\t                    break;\n\t                case CMD.R:\n\t                    x0 = xi = data[i++];\n\t                    y0 = yi = data[i++];\n\t                    var width = data[i++];\n\t                    var height = data[i++];\n\t                    var x1 = x0 + width;\n\t                    var y1 = y0 + height;\n\t                    if (isStroke) {\n\t                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n\t                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n\t                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n\t                          || containStroke(x0, y1, x1, y1, lineWidth, x, y)\n\t                        ) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // FIXME Clockwise ?\n\t                        w += windingLine(x1, y0, x1, y1, x, y);\n\t                        w += windingLine(x0, y1, x0, y0, x, y);\n\t                    }\n\t                    break;\n\t                case CMD.Z:\n\t                    if (isStroke) {\n\t                        if (containStroke(\n\t                            xi, yi, x0, y0, lineWidth, x, y\n\t                        )) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Close a subpath\n\t                        w += windingLine(xi, yi, x0, y0, x, y);\n\t                        // 如果被任何一个 subpath 包含\n\t                        if (w !== 0) {\n\t                            return true;\n\t                        }\n\t                    }\n\t                    xi = x0;\n\t                    yi = y0;\n\t                    break;\n\t            }\n\t        }\n\t        if (!isStroke && !isAroundEqual(yi, y0)) {\n\t            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n\t        }\n\t        return w !== 0;\n\t    }\n\t\n\t    module.exports = {\n\t        contain: function (pathData, x, y) {\n\t            return containPath(pathData, 0, false, x, y);\n\t        },\n\t\n\t        containStroke: function (pathData, lineWidth, x, y) {\n\t            return containPath(pathData, lineWidth, true, x, y);\n\t        }\n\t    };\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = {\n\t        /**\n\t         * 线段包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            var _a = 0;\n\t            var _b = x0;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l)\n\t                || (y < y0 - _l && y < y1 - _l)\n\t                || (x > x0 + _l && x > x1 + _l)\n\t                || (x < x0 - _l && x < x1 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t\n\t            if (x0 !== x1) {\n\t                _a = (y0 - y1) / (x0 - x1);\n\t                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n\t            }\n\t            else {\n\t                return Math.abs(x - x0) <= _l / 2;\n\t            }\n\t            var tmp = _a * x - y + _b;\n\t            var _s = tmp * tmp / (_a * _a + 1);\n\t            return _s <= _l / 2 * _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(44);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 三次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  x3\n\t         * @param  {number}  y3\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.cubicProjectPoint(\n\t                x0, y0, x1, y1, x2, y2, x3, y3,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var curve = __webpack_require__(44);\n\t\n\t    module.exports = {\n\t        /**\n\t         * 二次贝塞尔曲线描边包含判断\n\t         * @param  {number}  x0\n\t         * @param  {number}  y0\n\t         * @param  {number}  x1\n\t         * @param  {number}  y1\n\t         * @param  {number}  x2\n\t         * @param  {number}  y2\n\t         * @param  {number}  lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {boolean}\n\t         */\n\t        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t            // Quick reject\n\t            if (\n\t                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n\t                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n\t                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n\t                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n\t            ) {\n\t                return false;\n\t            }\n\t            var d = curve.quadraticProjectPoint(\n\t                x0, y0, x1, y1, x2, y2,\n\t                x, y, null\n\t            );\n\t            return d <= _l / 2;\n\t        }\n\t    };\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var normalizeRadian = __webpack_require__(51).normalizeRadian;\n\t    var PI2 = Math.PI * 2;\n\t\n\t    module.exports = {\n\t        /**\n\t         * 圆弧描边包含判断\n\t         * @param  {number}  cx\n\t         * @param  {number}  cy\n\t         * @param  {number}  r\n\t         * @param  {number}  startAngle\n\t         * @param  {number}  endAngle\n\t         * @param  {boolean}  anticlockwise\n\t         * @param  {number} lineWidth\n\t         * @param  {number}  x\n\t         * @param  {number}  y\n\t         * @return {Boolean}\n\t         */\n\t        containStroke: function (\n\t            cx, cy, r, startAngle, endAngle, anticlockwise,\n\t            lineWidth, x, y\n\t        ) {\n\t\n\t            if (lineWidth === 0) {\n\t                return false;\n\t            }\n\t            var _l = lineWidth;\n\t\n\t            x -= cx;\n\t            y -= cy;\n\t            var d = Math.sqrt(x * x + y * y);\n\t\n\t            if ((d - _l > r) || (d + _l < r)) {\n\t                return false;\n\t            }\n\t            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n\t                // Is a circle\n\t                return true;\n\t            }\n\t            if (anticlockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = normalizeRadian(endAngle);\n\t                endAngle = normalizeRadian(tmp);\n\t            } else {\n\t                startAngle = normalizeRadian(startAngle);\n\t                endAngle = normalizeRadian(endAngle);\n\t            }\n\t            if (startAngle > endAngle) {\n\t                endAngle += PI2;\n\t            }\n\t\n\t            var angle = Math.atan2(y, x);\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return (angle >= startAngle && angle <= endAngle)\n\t                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n\t        }\n\t    };\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\t\n\t\n\t    var PI2 = Math.PI * 2;\n\t    module.exports = {\n\t        normalizeRadian: function(angle) {\n\t            angle %= PI2;\n\t            if (angle < 0) {\n\t                angle += PI2;\n\t            }\n\t            return angle;\n\t        }\n\t    };\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n\t        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n\t            return 0;\n\t        }\n\t        if (y1 === y0) {\n\t            return 0;\n\t        }\n\t        var dir = y1 < y0 ? 1 : -1;\n\t        var t = (y - y0) / (y1 - y0);\n\t        var x_ = t * (x1 - x0) + x0;\n\t\n\t        return x_ > x ? dir : 0;\n\t    };\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var CMD = __webpack_require__(43).CMD;\n\t    var vec2 = __webpack_require__(18);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t\n\t    var points = [[], [], []];\n\t    var mathSqrt = Math.sqrt;\n\t    var mathAtan2 = Math.atan2;\n\t    function transformPath(path, m) {\n\t        var data = path.data;\n\t        var cmd;\n\t        var nPoint;\n\t        var i;\n\t        var j;\n\t        var k;\n\t        var p;\n\t\n\t        var M = CMD.M;\n\t        var C = CMD.C;\n\t        var L = CMD.L;\n\t        var R = CMD.R;\n\t        var A = CMD.A;\n\t        var Q = CMD.Q;\n\t\n\t        for (i = 0, j = 0; i < data.length;) {\n\t            cmd = data[i++];\n\t            j = i;\n\t            nPoint = 0;\n\t\n\t            switch (cmd) {\n\t                case M:\n\t                    nPoint = 1;\n\t                    break;\n\t                case L:\n\t                    nPoint = 1;\n\t                    break;\n\t                case C:\n\t                    nPoint = 3;\n\t                    break;\n\t                case Q:\n\t                    nPoint = 2;\n\t                    break;\n\t                case A:\n\t                    var x = m[4];\n\t                    var y = m[5];\n\t                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n\t                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n\t                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n\t                    // cx\n\t                    data[i++] += x;\n\t                    // cy\n\t                    data[i++] += y;\n\t                    // Scale rx and ry\n\t                    // FIXME Assume psi is 0 here\n\t                    data[i++] *= sx;\n\t                    data[i++] *= sy;\n\t\n\t                    // Start angle\n\t                    data[i++] += angle;\n\t                    // end angle\n\t                    data[i++] += angle;\n\t                    // FIXME psi\n\t                    i += 2;\n\t                    j = i;\n\t                    break;\n\t                case R:\n\t                    // x0, y0\n\t                    p[0] = data[i++];\n\t                    p[1] = data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t                    // x1, y1\n\t                    p[0] += data[i++];\n\t                    p[1] += data[i++];\n\t                    v2ApplyTransform(p, p, m);\n\t                    data[j++] = p[0];\n\t                    data[j++] = p[1];\n\t            }\n\t\n\t            for (k = 0; k < nPoint; k++) {\n\t                var p = points[k];\n\t                p[0] = data[i++];\n\t                p[1] = data[i++];\n\t\n\t                v2ApplyTransform(p, p, m);\n\t                // Write back\n\t                data[j++] = p[0];\n\t                data[j++] = p[1];\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = transformPath;\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Text element\n\t * @module zrender/graphic/Text\n\t *\n\t * TODO Wrapping\n\t */\n\t\n\t\n\t\n\t    var Displayable = __webpack_require__(31);\n\t    var zrUtil = __webpack_require__(9);\n\t    var textContain = __webpack_require__(34);\n\t\n\t    /**\n\t     * @alias zrender/graphic/Text\n\t     * @extends module:zrender/graphic/Displayable\n\t     * @constructor\n\t     * @param {Object} opts\n\t     */\n\t    var Text = function (opts) {\n\t        Displayable.call(this, opts);\n\t    };\n\t\n\t    Text.prototype = {\n\t\n\t        constructor: Text,\n\t\n\t        type: 'text',\n\t\n\t        brush: function (ctx) {\n\t            var style = this.style;\n\t            var x = style.x || 0;\n\t            var y = style.y || 0;\n\t            // Convert to string\n\t            var text = style.text;\n\t            var textFill = style.fill;\n\t            var textStroke = style.stroke;\n\t\n\t            // Convert to string\n\t            text != null && (text += '');\n\t\n\t            if (text) {\n\t                ctx.save();\n\t\n\t                this.style.bind(ctx);\n\t                this.setTransform(ctx);\n\t\n\t                textFill && (ctx.fillStyle = textFill);\n\t                textStroke && (ctx.strokeStyle = textStroke);\n\t\n\t                ctx.font = style.textFont || style.font;\n\t                ctx.textAlign = style.textAlign;\n\t\n\t                if (style.textVerticalAlign) {\n\t                    var rect = textContain.getBoundingRect(\n\t                        text, ctx.font, style.textAlign, 'top'\n\t                    );\n\t                    // Ignore textBaseline\n\t                    ctx.textBaseline = 'top';\n\t                    switch (style.textVerticalAlign) {\n\t                        case 'middle':\n\t                            y -= rect.height / 2;\n\t                            break;\n\t                        case 'bottom':\n\t                            y -= rect.height;\n\t                            break;\n\t                        // 'top'\n\t                    }\n\t                }\n\t                else {\n\t                    ctx.textBaseline = style.textBaseline;\n\t                }\n\t                var lineHeight = textContain.measureText('国', ctx.font).width;\n\t\n\t                var textLines = text.split('\\n');\n\t                for (var i = 0; i < textLines.length; i++) {\n\t                    textFill && ctx.fillText(textLines[i], x, y);\n\t                    textStroke && ctx.strokeText(textLines[i], x, y);\n\t                    y += lineHeight;\n\t                }\n\t\n\t                ctx.restore();\n\t            }\n\t        },\n\t\n\t        getBoundingRect: function () {\n\t            if (!this._rect) {\n\t                var style = this.style;\n\t                var rect = textContain.getBoundingRect(\n\t                    style.text + '', style.textFont || style.font, style.textAlign, style.textBaseline\n\t                );\n\t                rect.x += style.x || 0;\n\t                rect.y += style.y || 0;\n\t                this._rect = rect;\n\t            }\n\t            return this._rect;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Text, Displayable);\n\t\n\t    module.exports = Text;\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 圆形\n\t * @module zrender/shape/Circle\n\t */\n\t\n\t\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t        \n\t        type: 'circle',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0\n\t        },\n\t\n\t        buildPath : function (ctx, shape) {\n\t            // Better stroking in ShapeBundle\n\t            ctx.moveTo(shape.cx + shape.r, shape.cy);\n\t            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 扇形\n\t * @module zrender/graphic/shape/Sector\n\t */\n\t\n\t// FIXME clockwise seems wrong\n\t\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'sector',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r0: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r0 = Math.max(shape.r0 || 0, 0);\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\t\n\t            ctx.lineTo(unitX * r + x, unitY * r + y);\n\t\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t\n\t            ctx.lineTo(\n\t                Math.cos(endAngle) * r0 + x,\n\t                Math.sin(endAngle) * r0 + y\n\t            );\n\t\n\t            if (r0 !== 0) {\n\t                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n\t            }\n\t\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆环\n\t * @module zrender/graphic/shape/Ring\n\t */\n\t\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'ring',\n\t\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            r: 0,\n\t            r0: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var PI2 = Math.PI * 2;\n\t            ctx.moveTo(x + shape.r, y);\n\t            ctx.arc(x, y, shape.r, 0, PI2, false);\n\t            ctx.moveTo(x + shape.r0, y);\n\t            ctx.arc(x, y, shape.r0, 0, PI2, true);\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 多边形\n\t * @module zrender/shape/Polygon\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(59);\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t        \n\t        type: 'polygon',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, true);\n\t        }\n\t    });\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var smoothSpline = __webpack_require__(60);\n\t    var smoothBezier = __webpack_require__(61);\n\t\n\t    module.exports = {\n\t        buildPath: function (ctx, shape, closePath) {\n\t            var points = shape.points;\n\t            var smooth = shape.smooth;\n\t            if (points && points.length >= 2) {\n\t                if (smooth && smooth !== 'spline') {\n\t                    var controlPoints = smoothBezier(\n\t                        points, smooth, closePath, shape.smoothConstraint\n\t                    );\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    var len = points.length;\n\t                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n\t                        var cp1 = controlPoints[i * 2];\n\t                        var cp2 = controlPoints[i * 2 + 1];\n\t                        var p = points[(i + 1) % len];\n\t                        ctx.bezierCurveTo(\n\t                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n\t                        );\n\t                    }\n\t                }\n\t                else {\n\t                    if (smooth === 'spline') {\n\t                        points = smoothSpline(points, closePath);\n\t                    }\n\t\n\t                    ctx.moveTo(points[0][0], points[0][1]);\n\t                    for (var i = 1, l = points.length; i < l; i++) {\n\t                        ctx.lineTo(points[i][0], points[i][1]);\n\t                    }\n\t                }\n\t\n\t                closePath && ctx.closePath();\n\t            }\n\t        }\n\t    };\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Catmull-Rom spline 插值折线\n\t * @module zrender/shape/util/smoothSpline\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t    var vec2 = __webpack_require__(18);\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n\t        var v0 = (p2 - p0) * 0.5;\n\t        var v1 = (p3 - p1) * 0.5;\n\t        return (2 * (p1 - p2) + v0 + v1) * t3\n\t                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n\t                + v0 * t + p1;\n\t    }\n\t\n\t    /**\n\t     * @alias module:zrender/shape/util/smoothSpline\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {boolean} isLoop\n\t     * @return {Array}\n\t     */\n\t    module.exports = function (points, isLoop) {\n\t        var len = points.length;\n\t        var ret = [];\n\t\n\t        var distance = 0;\n\t        for (var i = 1; i < len; i++) {\n\t            distance += vec2.distance(points[i - 1], points[i]);\n\t        }\n\t\n\t        var segs = distance / 2;\n\t        segs = segs < len ? len : segs;\n\t        for (var i = 0; i < segs; i++) {\n\t            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n\t            var idx = Math.floor(pos);\n\t\n\t            var w = pos - idx;\n\t\n\t            var p0;\n\t            var p1 = points[idx % len];\n\t            var p2;\n\t            var p3;\n\t            if (!isLoop) {\n\t                p0 = points[idx === 0 ? idx : idx - 1];\n\t                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n\t                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n\t            }\n\t            else {\n\t                p0 = points[(idx - 1 + len) % len];\n\t                p2 = points[(idx + 1) % len];\n\t                p3 = points[(idx + 2) % len];\n\t            }\n\t\n\t            var w2 = w * w;\n\t            var w3 = w * w2;\n\t\n\t            ret.push([\n\t                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n\t                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n\t            ]);\n\t        }\n\t        return ret;\n\t    };\n\t\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 贝塞尔平滑曲线\n\t * @module zrender/shape/util/smoothBezier\n\t * @author pissang (https://www.github.com/pissang)\n\t *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n\t *         errorrik (errorrik@gmail.com)\n\t */\n\t\n\t\n\t    var vec2 = __webpack_require__(18);\n\t    var v2Min = vec2.min;\n\t    var v2Max = vec2.max;\n\t    var v2Scale = vec2.scale;\n\t    var v2Distance = vec2.distance;\n\t    var v2Add = vec2.add;\n\t\n\t    /**\n\t     * 贝塞尔平滑曲线\n\t     * @alias module:zrender/shape/util/smoothBezier\n\t     * @param {Array} points 线段顶点数组\n\t     * @param {number} smooth 平滑等级, 0-1\n\t     * @param {boolean} isLoop\n\t     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n\t     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n\t     *                           整个折线的包围盒做一个并集用来约束控制点。\n\t     * @param {Array} 计算出来的控制点数组\n\t     */\n\t    module.exports = function (points, smooth, isLoop, constraint) {\n\t        var cps = [];\n\t\n\t        var v = [];\n\t        var v1 = [];\n\t        var v2 = [];\n\t        var prevPoint;\n\t        var nextPoint;\n\t\n\t        var min, max;\n\t        if (constraint) {\n\t            min = [Infinity, Infinity];\n\t            max = [-Infinity, -Infinity];\n\t            for (var i = 0, len = points.length; i < len; i++) {\n\t                v2Min(min, min, points[i]);\n\t                v2Max(max, max, points[i]);\n\t            }\n\t            // 与指定的包围盒做并集\n\t            v2Min(min, min, constraint[0]);\n\t            v2Max(max, max, constraint[1]);\n\t        }\n\t\n\t        for (var i = 0, len = points.length; i < len; i++) {\n\t            var point = points[i];\n\t\n\t            if (isLoop) {\n\t                prevPoint = points[i ? i - 1 : len - 1];\n\t                nextPoint = points[(i + 1) % len];\n\t            }\n\t            else {\n\t                if (i === 0 || i === len - 1) {\n\t                    cps.push(vec2.clone(points[i]));\n\t                    continue;\n\t                }\n\t                else {\n\t                    prevPoint = points[i - 1];\n\t                    nextPoint = points[i + 1];\n\t                }\n\t            }\n\t\n\t            vec2.sub(v, nextPoint, prevPoint);\n\t\n\t            // use degree to scale the handle length\n\t            v2Scale(v, v, smooth);\n\t\n\t            var d0 = v2Distance(point, prevPoint);\n\t            var d1 = v2Distance(point, nextPoint);\n\t            var sum = d0 + d1;\n\t            if (sum !== 0) {\n\t                d0 /= sum;\n\t                d1 /= sum;\n\t            }\n\t\n\t            v2Scale(v1, v, -d0);\n\t            v2Scale(v2, v, d1);\n\t            var cp0 = v2Add([], point, v1);\n\t            var cp1 = v2Add([], point, v2);\n\t            if (constraint) {\n\t                v2Max(cp0, cp0, min);\n\t                v2Min(cp0, cp0, max);\n\t                v2Max(cp1, cp1, min);\n\t                v2Min(cp1, cp1, max);\n\t            }\n\t            cps.push(cp0);\n\t            cps.push(cp1);\n\t        }\n\t\n\t        if (isLoop) {\n\t            cps.push(cps.shift());\n\t        }\n\t\n\t        return cps;\n\t    };\n\t\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module zrender/graphic/shape/Polyline\n\t */\n\t\n\t\n\t    var polyHelper = __webpack_require__(59);\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t        \n\t        type: 'polyline',\n\t\n\t        shape: {\n\t            points: null,\n\t\n\t            smooth: false,\n\t\n\t            smoothConstraint: null\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            polyHelper.buildPath(ctx, shape, false);\n\t        }\n\t    });\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 矩形\n\t * @module zrender/graphic/shape/Rect\n\t */\n\t\n\t\n\t    var roundRectHelper = __webpack_require__(35);\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'rect',\n\t\n\t        shape: {\n\t            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n\t            // r缩写为1         相当于 [1, 1, 1, 1]\n\t            // r缩写为[1]       相当于 [1, 1, 1, 1]\n\t            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n\t            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n\t            r: 0,\n\t\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var width = shape.width;\n\t            var height = shape.height;\n\t            if (!shape.r) {\n\t                ctx.rect(x, y, width, height);\n\t            }\n\t            else {\n\t                roundRectHelper.buildPath(ctx, shape);\n\t            }\n\t            ctx.closePath();\n\t            return;\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 直线\n\t * @module zrender/graphic/shape/Line\n\t */\n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'line',\n\t\n\t        shape: {\n\t            // Start point\n\t            x1: 0,\n\t            y1: 0,\n\t            // End point\n\t            x2: 0,\n\t            y2: 0,\n\t\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var percent = shape.percent;\n\t\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (percent < 1) {\n\t                x2 = x1 * (1 - percent) + x2 * percent;\n\t                y2 = y1 * (1 - percent) + y2 * percent;\n\t            }\n\t            ctx.lineTo(x2, y2);\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            return [\n\t                shape.x1 * (1 - p) + shape.x2 * p,\n\t                shape.y1 * (1 - p) + shape.y2 * p\n\t            ];\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * 贝塞尔曲线\n\t * @module zrender/shape/BezierCurve\n\t */\n\t\n\t\n\t    var curveTool = __webpack_require__(44);\n\t    var quadraticSubdivide = curveTool.quadraticSubdivide;\n\t    var cubicSubdivide = curveTool.cubicSubdivide;\n\t    var quadraticAt = curveTool.quadraticAt;\n\t    var cubicAt = curveTool.cubicAt;\n\t\n\t    var out = [];\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'bezier-curve',\n\t\n\t        shape: {\n\t            x1: 0,\n\t            y1: 0,\n\t            x2: 0,\n\t            y2: 0,\n\t            cpx1: 0,\n\t            cpy1: 0,\n\t            // cpx2: 0,\n\t            // cpy2: 0\n\t\n\t            // Curve show percent, for animating\n\t            percent: 1\n\t        },\n\t\n\t        style: {\n\t            stroke: '#000',\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var x1 = shape.x1;\n\t            var y1 = shape.y1;\n\t            var x2 = shape.x2;\n\t            var y2 = shape.y2;\n\t            var cpx1 = shape.cpx1;\n\t            var cpy1 = shape.cpy1;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            var percent = shape.percent;\n\t            if (percent === 0) {\n\t                return;\n\t            }\n\t\n\t            ctx.moveTo(x1, y1);\n\t\n\t            if (cpx2 == null || cpy2 == null) {\n\t                if (percent < 1) {\n\t                    quadraticSubdivide(\n\t                        x1, cpx1, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    x2 = out[2];\n\t                    quadraticSubdivide(\n\t                        y1, cpy1, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    y2 = out[2];\n\t                }\n\t\n\t                ctx.quadraticCurveTo(\n\t                    cpx1, cpy1,\n\t                    x2, y2\n\t                );\n\t            }\n\t            else {\n\t                if (percent < 1) {\n\t                    cubicSubdivide(\n\t                        x1, cpx1, cpx2, x2, percent, out\n\t                    );\n\t                    cpx1 = out[1];\n\t                    cpx2 = out[2];\n\t                    x2 = out[3];\n\t                    cubicSubdivide(\n\t                        y1, cpy1, cpy2, y2, percent, out\n\t                    );\n\t                    cpy1 = out[1];\n\t                    cpy2 = out[2];\n\t                    y2 = out[3];\n\t                }\n\t                ctx.bezierCurveTo(\n\t                    cpx1, cpy1,\n\t                    cpx2, cpy2,\n\t                    x2, y2\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Get point at percent\n\t         * @param  {number} percent\n\t         * @return {Array.<number>}\n\t         */\n\t        pointAt: function (p) {\n\t            var shape = this.shape;\n\t            var cpx2 = shape.cpx2;\n\t            var cpy2 = shape.cpy2;\n\t            if (cpx2 === null || cpy2 === null) {\n\t                return [\n\t                    quadraticAt(shape.x1, shape.cpx1, shape.x2, p),\n\t                    quadraticAt(shape.y1, shape.cpy1, shape.y2, p)\n\t                ];\n\t            }\n\t            else {\n\t                return [\n\t                    cubicAt(shape.x1, shape.cpx1, shape.cpx1, shape.x2, p),\n\t                    cubicAt(shape.y1, shape.cpy1, shape.cpy1, shape.y2, p)\n\t                ];\n\t            }\n\t        }\n\t    });\n\t\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * 圆弧\n\t * @module zrender/graphic/shape/Arc\n\t */\n\t \n\t\n\t    module.exports = __webpack_require__(42).extend({\n\t\n\t        type: 'arc',\n\t\n\t        shape: {\n\t\n\t            cx: 0,\n\t\n\t            cy: 0,\n\t\n\t            r: 0,\n\t\n\t            startAngle: 0,\n\t\n\t            endAngle: Math.PI * 2,\n\t\n\t            clockwise: true\n\t        },\n\t\n\t        style: {\n\t\n\t            stroke: '#000',\n\t\n\t            fill: null\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t\n\t            var x = shape.cx;\n\t            var y = shape.cy;\n\t            var r = Math.max(shape.r, 0);\n\t            var startAngle = shape.startAngle;\n\t            var endAngle = shape.endAngle;\n\t            var clockwise = shape.clockwise;\n\t\n\t            var unitX = Math.cos(startAngle);\n\t            var unitY = Math.sin(startAngle);\n\t\n\t            ctx.moveTo(unitX * r + x, unitY * r + y);\n\t            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\t        }\n\t    });\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(9);\n\t\n\t    var Gradient = __webpack_require__(10);\n\t\n\t    /**\n\t     * x, y, x2, y2 are all percent from 0 to 1\n\t     * @param {number} [x=0]\n\t     * @param {number} [y=0]\n\t     * @param {number} [x2=1]\n\t     * @param {number} [y2=0]\n\t     * @param {Array.<Object>} colorStops\n\t     */\n\t    var LinearGradient = function (x, y, x2, y2, colorStops) {\n\t        this.x = x == null ? 0 : x;\n\t\n\t        this.y = y == null ? 0 : y;\n\t\n\t        this.x2 = x2 == null ? 1 : x2;\n\t\n\t        this.y2 = y2 == null ? 0 : y2;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    LinearGradient.prototype = {\n\t\n\t        constructor: LinearGradient,\n\t\n\t        type: 'linear',\n\t\n\t        updateCanvasGradient: function (shape, ctx) {\n\t            var rect = shape.getBoundingRect();\n\t            // var size =\n\t            var x = this.x * rect.width + rect.x;\n\t            var x2 = this.x2 * rect.width + rect.x;\n\t            var y = this.y * rect.height + rect.y;\n\t            var y2 = this.y2 * rect.height + rect.y;\n\t\n\t            var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\t\n\t            var colorStops = this.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t\n\t            this.canvasGradient = canvasGradient;\n\t        }\n\t\n\t    };\n\t\n\t    zrUtil.inherits(LinearGradient, Gradient);\n\t\n\t    module.exports = LinearGradient;\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(9);\n\t\n\t    var Gradient = __webpack_require__(10);\n\t\n\t    /**\n\t     * x, y, r are all percent from 0 to 1\n\t     * @param {number} [x=0.5]\n\t     * @param {number} [y=0.5]\n\t     * @param {number} [r=0.5]\n\t     * @param {Array.<Object>} [colorStops]\n\t     */\n\t    var RadialGradient = function (x, y, r, colorStops) {\n\t        this.x = x == null ? 0.5 : x;\n\t\n\t        this.y = y == null ? 0.5 : y;\n\t\n\t        this.r = r == null ? 0.5 : r;\n\t\n\t        Gradient.call(this, colorStops);\n\t    };\n\t\n\t    RadialGradient.prototype = {\n\t\n\t        constructor: RadialGradient,\n\t\n\t        type: 'radial',\n\t\n\t        updateCanvasGradient: function (shape, ctx) {\n\t            var rect = shape.getBoundingRect();\n\t\n\t            var width = rect.width;\n\t            var height = rect.height;\n\t            var min = Math.min(width, height);\n\t            // var max = Math.max(width, height);\n\t\n\t            var x = this.x * width + rect.x;\n\t            var y = this.y * height + rect.y;\n\t            var r = this.r * min;\n\t\n\t            var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\t\n\t            var colorStops = this.colorStops;\n\t            for (var i = 0; i < colorStops.length; i++) {\n\t                canvasGradient.addColorStop(\n\t                    colorStops[i].offset, colorStops[i].color\n\t                );\n\t            }\n\t\n\t            this.canvasGradient = canvasGradient;\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(RadialGradient, Gradient);\n\t\n\t    module.exports = RadialGradient;\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 事件决策多边形\r\n\t * @module fish-topo-bo/node/EventDecisionNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var graphic = __webpack_require__(40);\r\n\t\r\n\t    function EventDecisionNode(data, opts) {\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = data;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        this._type = opts.type || 'boEvent';\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._clickable = opts.clickable || false;\r\n\t        this._popupOpts = opts.popupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var eventProto = EventDecisionNode.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    eventProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成事件决策图形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._render = function () {\r\n\t        //多边形\r\n\t        this._createEventShape();\r\n\t        //文字\r\n\t        this._createEVentName();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策多边形\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEventShape = function () {\r\n\t\r\n\t        //多边形高度\r\n\t        var height = Const.BO_EVENT_HEIGHT,\r\n\t            x = this._startPos.x + 1,\r\n\t            y = this._startPos.y,\r\n\t            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\t\r\n\t            shape = new graphic.Polygon({\r\n\t                name: this._data.id,\r\n\t                shape: {\r\n\t                    points: [\r\n\t                        [x, y],\r\n\t                        [x + width - 10, y],\r\n\t                        [x + width, y + height / 2],\r\n\t                        [x + width - 10, y + height],\r\n\t                        [x, y + height]]\r\n\t                },\r\n\t\r\n\t                style: {\r\n\t                    fill: '#FFCCCC',\r\n\t                    stroke: '#000000',\r\n\t                    lineWidth: 0.75\r\n\t                }\r\n\t\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            shape.clickable = this._clickable;\r\n\t            shape._data = this._data;\r\n\t            shape._popupOpts = this._popupOpts;\r\n\t            shape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t\r\n\t        this._group.add(shape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 点击事件\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._click = function () {\r\n\t        var options = fish.extend(\r\n\t            {\r\n\t                viewOption: {\r\n\t                    DATA: this._data\r\n\t                },\r\n\t                width: 800,\r\n\t                height: 500\r\n\t            }, this._popupOpts);\r\n\t\r\n\t        fish.popupView(options);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 事件决策名称\r\n\t     * @private\r\n\t     */\r\n\t    eventProto._createEVentName = function () {\r\n\t        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            eventNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_EVENT_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        if (this._clickable) {\r\n\t            eventNameShape.clickable = this._clickable;\r\n\t            eventNameShape._data = this._data;\r\n\t            eventNameShape._popupOpts = this._popupOpts;\r\n\t            eventNameShape.onclick = this._click;\r\n\t        }\r\n\t\r\n\t        this._group.add(eventNameShape);\r\n\t    };\r\n\t\r\n\t    module.exports = EventDecisionNode;\r\n\t\r\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO矩形内部的横线，分为实线和虚线两种\r\n\t * @module fish-topo-bo/node/LineNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var graphic = __webpack_require__(40);\r\n\t    var util = __webpack_require__(9);\r\n\t    /**\r\n\t     * BO名字下面的实现\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\t\r\n\t        return _line(startPos, endPos);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性之间的虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrLine(startPos) {\r\n\t\r\n\t        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * BO属性与BO事件决策之间的垂直虚线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {int} attrHeight, 高度\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @constructor\r\n\t     */\r\n\t    function AttrEventLine(startPos, attrHeight) {\r\n\t        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n\t            style = {lineDash: [Const.LINE_DASH]};\r\n\t\r\n\t        return _line(startPos, endPos, style);\r\n\t    }\r\n\t\r\n\t    /**\r\n\t     * 画线\r\n\t     * @param {{x: *, y: *}} startPos, 开始坐标\r\n\t     * @param {{x: *, y: *}} endPos, 结束坐标\r\n\t     * @param {Object} style, 样式,可空\r\n\t     * @returns {zrender/graphic/shape/Line}\r\n\t     * @private\r\n\t     */\r\n\t    function _line(startPos, endPos, style) {\r\n\t\r\n\t        var _style = {\r\n\t            strokeColor: '#000000',\r\n\t            lineWidth: 0.5,\r\n\t            percent: 1\r\n\t        };\r\n\t\r\n\t        util.extend(_style, style);\r\n\t\r\n\t        var shape = new graphic.Line({\r\n\t            shape: {\r\n\t                // Start point\r\n\t                x1: startPos.x,\r\n\t                y1: startPos.y,\r\n\t\r\n\t                // End point\r\n\t                x2: endPos.x,\r\n\t                y2: endPos.y,\r\n\t\r\n\t                percent: 1\r\n\t            },\r\n\t\r\n\t            style: _style\r\n\t        });\r\n\t\r\n\t        return shape;\r\n\t    }\r\n\t\r\n\t\r\n\t    module.exports = {\r\n\t        BoLine: BoLine,\r\n\t        AttrLine: AttrLine,\r\n\t        AttrEventLine: AttrEventLine\r\n\t    };\r\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * BO属性\r\n\t * 1.BO属性名字\r\n\t * 2.BO属性数据类型\r\n\t * 3.BO属性事件决策\r\n\t * @module fish-topo-bo/node/BoAttrNode\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var EventDecision = __webpack_require__(69);\r\n\t    var graphic = __webpack_require__(40);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param {{\r\n\t     *          id: String bo属性标识,\r\n\t     *          code: String bo属性编码\r\n\t     *          keyValue: boolean 是否为主键,\r\n\t     *          dataType: String 属性数据类型,\r\n\t     *          boAttrEventArr:[] 属性事件决策数组\r\n\t     *          }} boAttrData BO属性数据对象,\r\n\t     * @param {{\r\n\t     *          startPos: {x: number, y: number}起始位置,\r\n\t     *          displayDataType: boolean 是否显示数据类型,\r\n\t     *          displayEventDecision: boolean 是否显示事件决策,\r\n\t     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n\t     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n\t     *          }} opts\r\n\t     * @constructor\r\n\t     */\r\n\t    function BoAttr(boAttrData, opts) {\r\n\t        /**\r\n\t         * BO属性数据\r\n\t         * @type {Object}\r\n\t         * @private\r\n\t         */\r\n\t        this._data = boAttrData;\r\n\t\r\n\t        /**\r\n\t         * 是否为主键\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._keyValue = boAttrData.keyValue || false;\r\n\t\r\n\t        /**\r\n\t         * 起始位置坐标\r\n\t         * @type {startPos}\r\n\t         * @private\r\n\t         */\r\n\t        this._startPos = opts.startPos;\r\n\t\r\n\t        /**\r\n\t         * 是否显示数据类型\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayDataType = opts.displayDataType || false;\r\n\t\r\n\t        /**\r\n\t         * 是否显示事件决策\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._displayEventDecision = opts.displayEventDecision || false;\r\n\t\r\n\t        /**\r\n\t         * 是否支持点击\r\n\t         * @type {boolean}\r\n\t         * @private\r\n\t         */\r\n\t        this._eventClickable = opts.eventClickable || false;\r\n\t        this._eventPopupOpts = opts.eventPopupOpts;\r\n\t\r\n\t        /**\r\n\t         * Group容器\r\n\t         * @type zrender/graphic/Group\r\n\t         * @private\r\n\t         */\r\n\t        this._group = new graphic.Group();\r\n\t        this._group.name = this._data.id;\r\n\t\r\n\t        //生成BO属性图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var boAttrProto = BoAttr.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {zrender/graphic/Group}\r\n\t     */\r\n\t    boAttrProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t\r\n\t    /**\r\n\t     * 生成BO属性图形\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._render = function () {\r\n\t        //属性名字\r\n\t        this._createText();\r\n\t\r\n\t        //属性数据类型\r\n\t        this._createDataType();\r\n\t\r\n\t        //属性事件决策\r\n\t        this._createEventDecision();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性名字\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createText = function () {\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n\t            y = this._startPos.y,\r\n\t\r\n\t            attrNameShape = new graphic.Text({\r\n\t                style: {\r\n\t                    text: this._data.name,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: 'left',  //靠左开始，便于计算位置\r\n\t                    textBaseline: 'top',\r\n\t                    //lineWidth: 1,\r\n\t                    fill: this._keyValue ? 'red' : 'black'\r\n\t                },\r\n\t\r\n\t                position: [x, y]\r\n\t            });\r\n\t\r\n\t        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n\t        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n\t        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n\t        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\t\r\n\t        //重新设置B起始水平坐标 = 减去偏移量\r\n\t        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n\t        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\t\r\n\t        this._group.add(attrNameShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性数据类型\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createDataType = function () {\r\n\t        if (!this._displayDataType) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n\t            y = this._startPos.y,\r\n\t            textAlign = 'right';\r\n\t\r\n\t        //如果还要显示事件决策，则宽度重新计算\r\n\t        if (this._displayEventDecision) {\r\n\t            textAlign = 'left';\r\n\t            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n\t        }\r\n\t\r\n\t        var _dataTypeShape = new graphic.Text({\r\n\t            style: {\r\n\t                text: this._data.dataType || '',\r\n\t                textFont: Const.BO_ATTR_FONT,\r\n\t                textAlign: textAlign,  //靠左开始，便于计算位置\r\n\t                textBaseline: 'top',\r\n\t                lineWidth: 1\r\n\t            },\r\n\t\r\n\t            position: [x, y]\r\n\t        });\r\n\t\r\n\t        this._group.add(_dataTypeShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 属性事件决策\r\n\t     * @private\r\n\t     */\r\n\t    boAttrProto._createEventDecision = function () {\r\n\t        if (!this._displayEventDecision) {\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n\t            _boAttrEventLen = _boAttrEventArr.length,\r\n\t            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n\t            _startPos = {\r\n\t                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n\t                y: this._startPos.y\r\n\t            };\r\n\t\r\n\t        //从右向左画，\r\n\t        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n\t            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n\t                startPos: _startPos,\r\n\t                type: 'boAttrEvent',\r\n\t                clickable: this._eventClickable,\r\n\t                popupOpts: this._eventPopupOpts\r\n\t            }).getShape());\r\n\t            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n\t        }\r\n\t        /*_startPos = {\r\n\t         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n\t         y: this._startPos.y};\r\n\t\r\n\t         for (var i = 0; i < _boAttrEventLen; i++) {\r\n\t         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n\t         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n\t         }*/\r\n\t\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = BoAttr;\r\n\t\r\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\r\n\t * 用来创建关联关系\r\n\t * 关联关系包括折线、箭头、关系文字说明\r\n\t * @module fish-topo-bo/node/Relation\r\n\t * Created by majianan on 16/5/19.\r\n\t */\r\n\t\r\n\t    var Const = __webpack_require__(38);\r\n\t    var graphic = __webpack_require__(40);\r\n\t\r\n\t    /**\r\n\t     *\r\n\t     * @param sourceShape, 开始图形\r\n\t     * @param targetShape, 目标图形\r\n\t     * @param {String} sourceText, 关系开始文字说明,可空\r\n\t     * @param {String} targetText, 关系结束文字说明,可空\r\n\t     * @constructor\r\n\t     */\r\n\t    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n\t        this._sourceText = sourceText;\r\n\t        this._targetText = targetText;\r\n\t\r\n\t        this._group = new graphic.Group();\r\n\t\r\n\t        //左侧开始位置\r\n\t        this._lStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //左侧结束位置\r\n\t        this._lEndPos = {\r\n\t            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧开始位置\r\n\t        this._rStartPos = {\r\n\t            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //右侧结束位置\r\n\t        this._rEndPos = {\r\n\t            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n\t            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n\t        };\r\n\t\r\n\t        //判断画线方向\r\n\t        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\t\r\n\t        //生成图形\r\n\t        this._render();\r\n\t    }\r\n\t\r\n\t    var relationProto = Relation.prototype;\r\n\t\r\n\t    /**\r\n\t     * 获取关系整体图形\r\n\t     * @returns {*}\r\n\t     */\r\n\t    relationProto.getShape = function () {\r\n\t        return this._group;\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系整体图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._render = function () {\r\n\t        //画线\r\n\t        this._createLine();\r\n\t\r\n\t        //箭头\r\n\t        this._createArrow();\r\n\t\r\n\t        //关系说明文字\r\n\t        this._createText();\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成关系折线\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createLine = function () {\r\n\t        var _linePoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //第一点\r\n\t            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t        }\r\n\t        else {\r\n\t            //第一点\r\n\t            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n\t            //第二点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n\t            //第三点\r\n\t            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n\t            //第四点\r\n\t            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t        }\r\n\t\r\n\t        var _lineShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _linePoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                //fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_lineShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成箭头图形\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createArrow = function () {\r\n\t        var _arrowPoints = [];\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            //右侧第一点\r\n\t            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t        else {\r\n\t            //左侧第一点\r\n\t            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n\t            //下面第二点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n\t            //上面第三点\r\n\t            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n\t        }\r\n\t\r\n\t        var _arrowShape = new graphic.Polyline({\r\n\t            shape: {\r\n\t                points: _arrowPoints\r\n\t            },\r\n\t\r\n\t            style: {\r\n\t                fill: 'blue',\r\n\t                stroke: 'blue'\r\n\t            }\r\n\t        });\r\n\t\r\n\t        this._group.add(_arrowShape);\r\n\t    };\r\n\t\r\n\t    /**\r\n\t     * 生成文字说明\r\n\t     * @private\r\n\t     */\r\n\t    relationProto._createText = function () {\r\n\t        var _sourceTextPos,\r\n\t            _targetTextPos,\r\n\t            _textAlign;\r\n\t\r\n\t        if (this._leftDirection) {\r\n\t            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'right';\r\n\t        }\r\n\t        else {\r\n\t            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n\t            _textAlign = 'left';\r\n\t        }\r\n\t\r\n\t        //开始文字\r\n\t        if (this._sourceText) {\r\n\t            var _srcTextShape = new graphic.Text({\r\n\t                position: _sourceTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._sourceText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_srcTextShape);\r\n\t        }\r\n\t\r\n\t        //结束文字\r\n\t        if (this._targetText) {\r\n\t            var _targetTextShape = new graphic.Text({\r\n\t                position: _targetTextPos,\r\n\t\r\n\t                style: {\r\n\t                    text: this._targetText,\r\n\t                    textFont: Const.BO_ATTR_FONT,\r\n\t                    textAlign: _textAlign,\r\n\t                    textBaseline: 'buttom',\r\n\t                    lineWidth: 1\r\n\t                }\r\n\t            });\r\n\t            this._group.add(_targetTextShape);\r\n\t        }\r\n\t\r\n\t    };\r\n\t\r\n\t    module.exports = Relation;\r\n\n\n/***/ }\n/******/ ])\n});\n;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 916e37e37ced298188d3\n **/","/**\r\n * Export fishTopo as CommonJS module\r\n */\r\nmodule.exports = require('./lib/fish-topo-bo/lib/FishTopoBo.js');\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.bo.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n *\r\n */\r\n\r\n    var zr = require('zrender/lib/zrender');\r\n    var util = require('zrender/lib/core/util');\r\n    var BoNode = require('./node/BoNode');\r\n    var Relation = require('./node/Relation');\r\n    var Const = require('./models/Const');\r\n    var graphic = require(\"../../fish-topo-core/lib/graphic.js\");\r\n    var eventTool = require('zrender/lib/core/event');\r\n\r\n    function FishTopoBo(dom, opts) {\r\n        /**\r\n         * 缩放\r\n         * @type {number}\r\n         */\r\n        this.nowZoom = 1;\r\n        this.canScale = true;\r\n\r\n        /**\r\n         * 初始化zrender\r\n         */\r\n        this._zr = zr.init(dom, {\r\n            renderer: opts.renderer || 'canvas',\r\n            devicePixelRatio: opts.devicePixelRatio\r\n        });\r\n    }\r\n\r\n    var fishTopoProto = FishTopoBo.prototype;\r\n\r\n    /**\r\n     * 初始化\r\n     */\r\n    fishTopoProto.init = function () {\r\n        this.group = new graphic.Group();\r\n        this.groupDrag(this.group);\r\n        this._zr.add(this.group);\r\n        this.zrScale();\r\n    };\r\n\r\n    /**\r\n     * 调整尺寸  在窗口大小发生改变时需要手工调用\r\n     */\r\n    fishTopoProto.resize = function () {\r\n        this._zr.resize();\r\n    };\r\n\r\n    /**\r\n     * 添加BO\r\n     * @param {Object} boData, bo数据\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupUrl: String 点击BO弹出页面地址\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupUrl: String 点击BO事件决策弹出页面地址\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupUrl: String 点击BO属性事件决策弹出页面地址\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          }} opts\r\n     * @returns {*}\r\n     */\r\n    fishTopoProto.addBo = function (boData, opts) {\r\n        //设置BO父子关系，便于后续整体移动\r\n        this._setParent(boData);\r\n\r\n        //layout BO的布局信息，x,y左上角起始坐标, level:层级\r\n        boData.layout = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y,\r\n            level: 1\r\n        };\r\n\r\n        //计算BO的X坐标\r\n        this._bfs(boData);\r\n\r\n        //按照起始坐标整体左移\r\n        this._moveRightByParent(boData, opts.startPos.x - boData.layout.x);\r\n\r\n        //画BO\r\n        var boNode = new BoNode(boData, opts);\r\n        this.group.add(boNode.getShape());\r\n\r\n        //创建子BO\r\n        this.addChildBo(boNode, opts);\r\n\r\n        return boNode;\r\n    };\r\n\r\n    /**\r\n     * 设置BO的父子关系\r\n     * @param {Object} boData BO数据\r\n     * @private\r\n     */\r\n    fishTopoProto._setParent = function (boData) {\r\n        if (boData.child) {\r\n            var childCnt = boData.child.length,\r\n                childBoArr = boData.child;\r\n            for (var i = 0; i < childCnt; i++) {\r\n                childBoArr[i].parent = boData;\r\n                if (childBoArr[i + 1]) {\r\n                    childBoArr[i].next = childBoArr[i + 1];\r\n                }\r\n                //设置最后子节点的next=下一个父节点的第一个子节点\r\n                else if (boData.next && boData.next.child) {\r\n                    childBoArr[i].next = boData.next.child[0];\r\n                }\r\n                this._setParent(childBoArr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Breadth-First-Search 计算X坐标\r\n     * 由于BO宽度定死，可以在画图之前计算每个BO的起始X坐标\r\n     * 每个BO的高度根据显示内容不固定，因此需要根据实际的父BO高度才能计算本身的起始Y坐标\r\n     * @param boData\r\n     * @private\r\n     */\r\n    fishTopoProto._bfs = function (boData) {\r\n        //用于保存每个level的最大坐标值\r\n        this._levelMaxPos = {};\r\n\r\n        this._queue = [];   //存放BO数据\r\n        this._queue.push(boData);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift();\r\n            //console.log('BO[' + tmp.name + '] {x: ' + tmp.layout.x + ', level: ' + tmp.layout.level + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //该level第一个节点\r\n            if (!this._levelMaxPos[tmp.layout.level]) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前就是最右侧的节点\r\n            else if (this._levelMaxPos[tmp.layout.level].x + Const.BO_NODE_WIDTH <= tmp.layout.x) {\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n            //当前节点与之前的节点有交叉，则需要连同父节点整体向右移动\r\n            else {\r\n                this._moveRightByChild(tmp, this._levelMaxPos[tmp.layout.level].x - tmp.layout.x + Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X)\r\n                this._levelMaxPos[tmp.layout.level] = {x: tmp.layout.x};\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.layout.level + ']=' + this._levelMaxPos[tmp.layout.level]);\r\n\r\n            //存在子节点，计算子节点坐标，同时添加到队列中，以便后续计算调整x坐标\r\n            if (tmp.child) {\r\n                var childCnt = tmp.child.length;\r\n\r\n                for (var i = 0; i < childCnt; i++) {\r\n\r\n                    tmp.child[i].layout = {\r\n                        x: tmp.layout.x - (Const.BO_NODE_WIDTH + Const.BO_NODE_OFFSET_X) * ((childCnt - 1) / 2 - i),\r\n                        level: tmp.layout.level + 1\r\n                    };\r\n\r\n                    this._queue.push(tmp.child[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 子节点右移时，同时下一个子节点，以及父节点都同时移动\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByChild = function (boData, width) {\r\n        if (boData) {\r\n\r\n            if (!boData.layout.moved) {\r\n\r\n                if (boData.layout.level == 1) {\r\n                    boData.layout.x += width / 2;\r\n                } else {\r\n                    boData.layout.x += width;\r\n                }\r\n\r\n                boData.layout.moved = true;\r\n            }\r\n            //当前节点的下一节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n            //当前节点的父节点整体右移\r\n            this._moveRightByChild(boData.parent, width);\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 前一个节点右移的时候，所有后面的节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByPrevious = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            boData.layout.moved = true;\r\n            //当前节点的所有后续节点整体右移\r\n            this._moveRightByPrevious(boData.next, width);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 父节点右移时，所有子节点整体右移\r\n     * @param boData\r\n     * @param width\r\n     * @private\r\n     */\r\n    fishTopoProto._moveRightByParent = function (boData, width) {\r\n        if (boData) {\r\n            boData.layout.x += width;\r\n            if (boData.child) {\r\n                for (var i = 0; i < boData.child.length; i++) {\r\n                    this._moveRightByParent(boData.child[i], width);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 添加子BO\r\n     * @param {BoNode} parentBoNode\r\n     * @param {Object} opts\r\n     * @private\r\n     */\r\n    fishTopoProto.addChildBo = function (parentBoNode, opts) {\r\n\r\n        this._queue = []; //需要根据BO节点的实际高度计算自己点的起始Y坐标，因此存放的是BoNode图形\r\n        this._queue.push(parentBoNode);\r\n\r\n        while (this._queue.length > 0) {\r\n            var tmp = this._queue.shift(),\r\n                boNodeHeight = tmp.getShape().getBoundingRect().height;\r\n            //console.log('Parent BO[' + tmp.getData().name + '] {y: ' + tmp.getLayout().y + ', level: ' + tmp.getLayout().level + ', boNodeHeight:' + boNodeHeight + '} ');\r\n            //console.log('    ***Before this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            //如果是该Level第一个节点，或者当低于原来的节点\r\n            if (!this._levelMaxPos[tmp.getLayout().level].y ||\r\n                this._levelMaxPos[tmp.getLayout().level].y < tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y) {\r\n                this._levelMaxPos[tmp.getLayout().level].y = tmp.getLayout().y + boNodeHeight + Const.BO_NODE_OFFSET_Y;\r\n            }\r\n\r\n            //console.log('    ***After this._levelMaxPos[' + tmp.getLayout().level + ']=' + this._levelMaxPos[tmp.getLayout().level]);\r\n\r\n            if (tmp.getData().child) {\r\n\r\n                var childBoArr = tmp.getData().child,\r\n                    childCnt = childBoArr.length,\r\n                    boNode,\r\n                    relationNode;\r\n\r\n                //该level所有子节点的起始Y坐标都相同\r\n                opts.startPos.y = this._levelMaxPos[tmp.getLayout().level].y;\r\n                for (var i = 0; i < childCnt; i++) {\r\n                    opts.startPos.x = childBoArr[i].layout.x;\r\n                    childBoArr[i].layout.y = opts.startPos.y;\r\n                    boNode = new BoNode(childBoArr[i], opts);\r\n                    //console.log('Child BO[' + boNode.getData().name + '] {y: ' + opts.startPos.y + ', level: ' + boNode.getLayout().level + '} ');\r\n\r\n                    this.group.add(boNode.getShape());\r\n                    this._queue.push(boNode);\r\n\r\n                    //BO关系\r\n                    if (childBoArr[i].relation) {\r\n                        var _relationLen = childBoArr[i].relation.length;\r\n                        for (var j = 0; j < _relationLen; j++) {\r\n                            var sourceId = childBoArr[i].relation[j].sourceId,\r\n                                targetId = childBoArr[i].relation[j].targetId,\r\n                                sourceText = childBoArr[i].relation[j].sourceText,\r\n                                targetText = childBoArr[i].relation[j].targetText;\r\n\r\n                            relationNode = new Relation(\r\n                                boNode.getShape().childOfName(sourceId),\r\n                                tmp.getShape().childOfName(targetId),\r\n                                sourceText,\r\n                                targetText\r\n                            );\r\n                            this.group.add(relationNode.getShape());\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 设置当前BO为特殊样式\r\n     * @param {String} boId, BO标识\r\n     * @param {Object} style, BO特殊样式,可空\r\n     */\r\n    fishTopoProto.setCurrentBo = function (boId, style) {\r\n        var length = this.group.childCount();\r\n        for (var i = 0; i < length; i++) {\r\n            if (this.group.childAt(i).name == boId) {\r\n                this.group.childAt(i).setCurrent(style);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 清空\r\n     */\r\n    fishTopoProto.clear = function () {\r\n        this._zr.clear();\r\n        this.group = new graphic.Group();\r\n        this._zr.add(this.group);\r\n    };\r\n\r\n    /**\r\n     * 缩放功能\r\n     * @param type\r\n     */\r\n    fishTopoProto.zrScale = function (type) {\r\n        var that = this;\r\n        if (type) {\r\n            if (type == \"narrowing\") {\r\n                var zoomDelta = 1 / 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n            if (type == \"enlarge\") {\r\n                var zoomDelta = 1.1;\r\n                zoom(zoomDelta, this._zr.getWidth() / 2, this._zr.getHeight() / 2);\r\n            }\r\n        } else {\r\n            that._zr.on('mousewheel', function (e) {\r\n                eventTool.stop(e.event);\r\n                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;\r\n                zoom(zoomDelta, e.offsetX, e.offsetY);\r\n            });\r\n        }\r\n        ;\r\n        function zoom(zoomDelta, zoomX, zoomY) {\r\n            if (that.canScale == false) {\r\n                return;\r\n            }\r\n            var target = that.group;\r\n            if (target) {\r\n                var pos = target.position;\r\n                var scale = target.scale;\r\n                var newZoom = that._zoom = that._zoom || 1;\r\n                newZoom *= zoomDelta;\r\n                var zoomScale = newZoom / that._zoom;\r\n                // if(newZoom>2.6||newZoom<0.38){\r\n                //     return;\r\n                // };\r\n                that._zoom = newZoom;\r\n\r\n                that.nowZoom = newZoom;\r\n                // Keep the mouse center when scaling\r\n                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);\r\n                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);\r\n                scale[0] *= zoomScale;\r\n                scale[1] *= zoomScale;\r\n                target.attr(\"position\", [pos[0], pos[1]]);\r\n                target.attr(\"scale\", [scale[0], scale[1]]);\r\n                //that.minimap.updateSelectionPosition(pos,zoomScale);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽Group\r\n     */\r\n    fishTopoProto.groupDrag = function () {\r\n        var that = this;\r\n        that._zr.on(\"mousedown\", function (e) {\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = that.group.position;\r\n            var groupPositionX = that.group.position[0];\r\n            var groupPositionY = that.group.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n\r\n            function moveDrag(e) {\r\n                var width = that.group.getBoundingRect().width * that.nowZoom;\r\n                var height = that.group.getBoundingRect().height * that.nowZoom;\r\n                var gx = that.group.getBoundingRect().x * that.nowZoom;\r\n                var gy = that.group.getBoundingRect().y * that.nowZoom;\r\n                var min = [10 - (width + gx), 10 - (height + gy)];\r\n                var max = [(that._zr.getWidth() - gx) - 10, (that._zr.getHeight() - gy) - 10];\r\n                var sX = (e.event.clientX - startX) * (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) * (that.nowZoom);\r\n                nowGroupPosition[0] = groupPositionX + (sX);\r\n                nowGroupPosition[1] = groupPositionY + (sY);\r\n                if (nowGroupPosition[0] > max[0] || nowGroupPosition[1] > max[1] || nowGroupPosition[0] < min[0] || nowGroupPosition[1] < min[1]) {\r\n                    return;\r\n                } else {\r\n                    that.group.attr(\"position\", nowGroupPosition);\r\n                }\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * 拖拽\r\n     * @param node\r\n     */\r\n    fishTopoProto.drag = function (node) {\r\n        var that = this;\r\n        node.on(\"mousedown\", function (e) {\r\n            if (this.isdraggable == false) {\r\n                return;\r\n            }\r\n            groupDragFunction(e);\r\n            e.cancelBubble = true;\r\n        });\r\n        function groupDragFunction(e) {\r\n            var startX = e.event.clientX;\r\n            var startY = e.event.clientY;\r\n            var moveFunction = function (e) {\r\n                moveDrag(e);\r\n            }\r\n            var nowGroupPosition = node.position;\r\n            var groupPositionX = node.position[0];\r\n            var groupPositionY = node.position[1];\r\n            var alarmPositionX, alarmPositionY;\r\n            if (node.alarm) {\r\n                var newAlarmPosition = node.alarm.position;\r\n                alarmPositionX = node.alarm.position[0];\r\n                alarmPositionY = node.alarm.position[1];\r\n            }\r\n            ;\r\n            function moveDrag(e) {\r\n                var sX = (e.event.clientX - startX) / (that.nowZoom);\r\n                var sY = (e.event.clientY - startY) / (that.nowZoom);\r\n                if (node.parent && node.parent instanceof GroupNode) {\r\n                    //放入node现有数值，用于重绘group\r\n                    var nodeMessage = {\r\n                        width: node.shape.width,\r\n                        height: node.shape.height,\r\n                        position: node.position,\r\n                        nodeXY: [node.shape.x, node.shape.y],\r\n                        movePosition: [groupPositionX, groupPositionY],\r\n                        moveX: sX,\r\n                        moveY: sY\r\n                    };\r\n                    var groupNode = node.parent;\r\n                    groupNode.reDraw(nodeMessage, node);\r\n                } else {\r\n                    nowGroupPosition[0] = groupPositionX + (sX);\r\n                    nowGroupPosition[1] = groupPositionY + (sY);\r\n                    node.attr(\"position\", nowGroupPosition);\r\n                    if (node.alarm) {\r\n                        var newAlarmPosition = [nowGroupPosition[0] + node.getBoundingRect().width - (node.alarm.getBoundingRect().width - 6), nowGroupPosition[1] - node.alarm.getBoundingRect().height - 3];\r\n                        node.alarm.attr(\"position\", newAlarmPosition);\r\n                    }\r\n                    ;\r\n                }\r\n                ConnectionManager.refreshLineByNode(node);\r\n            }\r\n\r\n            that._zr.on('mousemove', moveFunction);\r\n            var upFunction = function (e) {\r\n                endDrag(e);\r\n            }\r\n            //拖拽结束\r\n            function endDrag(e) {\r\n                that._zr.off('mousemove', moveFunction);\r\n                that._zr.off('mouseup', upFunction);\r\n                that._zr.off(\"globalout\", upFunction);\r\n                //布局重新计算\r\n                if (node.layout) {\r\n                    that.layoutNode(\"tree\", {\"node\": node});\r\n                }\r\n                if (that.forceLayoutOption) {\r\n                    var nodes = that.forceLayoutOption.allNodes;\r\n                    if (_.indexOf(nodes, node) != -1) {\r\n                        that.layoutNode(\"force\", this.forceLayoutOption);\r\n                    }\r\n                }\r\n                ;\r\n            }\r\n\r\n            that._zr.on('mouseup', upFunction);\r\n            that._zr.on(\"globalout\", upFunction);\r\n        }\r\n    };\r\n\r\n\r\n    // ---------对外暴露fishTopoBo------------------\r\n    var idBase = new Date() - 0;\r\n    var instances = {};\r\n    var DOM_ATTRIBUTE_KEY = '_fishTopoBo_instance_';\r\n    var fishTopoBo = {\r\n        /**\r\n         * @type {number}\r\n         */\r\n        version: '1.0.0',\r\n        dependencies: {\r\n            zrender: '3.0.4'\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @param {HTMLDomElement} dom\r\n     * @param {Object} opts\r\n     */\r\n    fishTopoBo.init = function (dom, opts) {\r\n        if (!dom) {\r\n            throw new Error('Initialize failed: invalid dom.');\r\n        }\r\n\r\n        opts = opts || {};\r\n        // Default value\r\n        util.defaults(opts,\r\n            {\r\n                type: \"bpmn\",\r\n                showGridLine: true,\r\n                devicePixelRatio: 1,\r\n                gridLineSpacing:10\r\n            }\r\n        );\r\n\r\n        var fishTopoBo = new FishTopoBo(dom, opts);\r\n        fishTopoBo.init();\r\n\r\n        fishTopoBo.id = 'ft_' + idBase++;\r\n        instances[fishTopoBo.id] = fishTopoBo;\r\n\r\n        dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, fishTopoBo.id);\r\n\r\n        return fishTopoBo;\r\n    };\r\n\r\n\r\n    /**\r\n     * @param  {HTMLDomElement} dom\r\n     * @return {fishTopo}\r\n     */\r\n    fishTopoBo.getInstanceByDom = function (dom) {\r\n        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);\r\n        return instances[key];\r\n    };\r\n\r\n    /**\r\n     * Dispose a fishTopo instance\r\n     * @param  {module:fishTopo|HTMLDomElement|string} fishTopo\r\n     */\r\n    fishTopoBo.dispose = function (chart) {\r\n        var topo;\r\n        if (zrUtil.isDom(chart)) {\r\n            topo = fishTopoBo.getInstanceByDom(chart);\r\n        }\r\n        else if (typeof chart === 'string') {\r\n            topo = instances[chart];\r\n        }\r\n        if ((topo instanceof fishTopoBo) && !topo.isDisposed()) {\r\n            topo.dispose();\r\n        }\r\n    };\r\n\r\n    module.exports = fishTopoBo;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/FishTopoBo.js\n ** module id = 2\n ** module chunks = 0\n **/","/*!\n * ZRender, a high performance 2d drawing library.\n *\n * Copyright (c) 2013, Baidu Inc.\n * All rights reserved.\n *\n * LICENSE\n * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n */\n// Global defines\n\n    var guid = require('./core/guid');\n    var env = require('./core/env');\n\n    var Handler = require('./Handler');\n    var Storage = require('./Storage');\n    var Animation = require('./animation/Animation');\n\n    var useVML = !env.canvasSupported;\n\n    var painterCtors = {\n        canvas: require('./Painter')\n    };\n\n    var instances = {};    // ZRender实例map索引\n\n    var zrender = {};\n    /**\n     * @type {string}\n     */\n    zrender.version = '3.0.4';\n\n    /**\n     * @param {HTMLElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     * @return {module:zrender/ZRender}\n     */\n    zrender.init = function(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    };\n\n    /**\n     * Dispose zrender instance\n     * @param {module:zrender/ZRender} zr\n     */\n    zrender.dispose = function (zr) {\n        if (zr) {\n            zr.dispose();\n        }\n        else {\n            for (var key in instances) {\n                instances[key].dispose();\n            }\n            instances = {};\n        }\n\n        return zrender;\n    };\n\n    /**\n     * 获取zrender实例\n     * @param {string} id ZRender对象索引\n     * @return {module:zrender/ZRender}\n     */\n    zrender.getInstance = function (id) {\n        return instances[id];\n    };\n\n    zrender.registerPainter = function (name, Ctor) {\n        painterCtors[name] = Ctor;\n    };\n\n    function delInstance(id) {\n        delete instances[id];\n    }\n\n    /**\n     * @module zrender/ZRender\n     */\n    /**\n     * @constructor\n     * @alias module:zrender/ZRender\n     * @param {string} id\n     * @param {HTMLDomElement} dom\n     * @param {Object} opts\n     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n     * @param {number} [opts.devicePixelRatio]\n     */\n    var ZRender = function(id, dom, opts) {\n\n        opts = opts || {};\n\n        /**\n         * @type {HTMLDomElement}\n         */\n        this.dom = dom;\n\n        /**\n         * @type {string}\n         */\n        this.id = id;\n\n        var self = this;\n        var storage = new Storage();\n\n        var rendererType = opts.renderer;\n        if (useVML) {\n            if (!painterCtors.vml) {\n                throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n            }\n            rendererType = 'vml';\n        }\n        else if (!rendererType || !painterCtors[rendererType]) {\n            rendererType = 'canvas';\n        }\n        var painter = new painterCtors[rendererType](dom, storage, opts);\n\n        this.storage = storage;\n        this.painter = painter;\n        if (!env.node) {\n            this.handler = new Handler(painter.getViewportRoot(), storage, painter);\n        }\n\n        /**\n         * @type {module:zrender/animation/Animation}\n         */\n        this.animation = new Animation({\n            stage: {\n                update: function () {\n                    if (self._needsRefresh) {\n                        self.refreshImmediately();\n                    }\n                }\n            }\n        });\n        this.animation.start();\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._needsRefresh;\n\n        // 修改 storage.delFromMap, 每次删除元素之前删除动画\n        // FIXME 有点ugly\n        var oldDelFromMap = storage.delFromMap;\n        var oldAddToMap = storage.addToMap;\n\n        storage.delFromMap = function (elId) {\n            var el = storage.get(elId);\n\n            oldDelFromMap.call(storage, elId);\n\n            el && el.removeSelfFromZr(self);\n        };\n\n        storage.addToMap = function (el) {\n            oldAddToMap.call(storage, el);\n\n            el.addSelfToZr(self);\n        };\n    };\n\n    ZRender.prototype = {\n\n        constructor: ZRender,\n        /**\n         * 获取实例唯一标识\n         * @return {string}\n         */\n        getId: function () {\n            return this.id;\n        },\n\n        /**\n         * 添加元素\n         * @param  {string|module:zrender/Element} el\n         */\n        add: function (el) {\n            this.storage.addRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 删除元素\n         * @param  {string|module:zrender/Element} el\n         */\n        remove: function (el) {\n            this.storage.delRoot(el);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 修改指定zlevel的绘制配置项\n         *\n         * @param {string} zLevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n        */\n        configLayer: function (zLevel, config) {\n            this.painter.configLayer(zLevel, config);\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 视图更新\n         */\n        refreshImmediately: function () {\n            // Clear needsRefresh ahead to avoid something wrong happens in refresh\n            // Or it will cause zrender refreshes again and again.\n            this._needsRefresh = false;\n            this.painter.refresh();\n            /**\n             * Avoid trigger zr.refresh in Element#beforeUpdate hook\n             */\n            this._needsRefresh = false;\n        },\n\n        /**\n         * 标记视图在浏览器下一帧需要绘制\n         */\n        refresh: function() {\n            this._needsRefresh = true;\n        },\n\n        /**\n         * 调整视图大小\n         */\n        resize: function() {\n            this.painter.resize();\n            this.handler && this.handler.resize();\n        },\n\n        /**\n         * 停止所有动画\n         */\n        clearAnimation: function () {\n            this.animation.clear();\n        },\n\n        /**\n         * 获取视图宽度\n         */\n        getWidth: function() {\n            return this.painter.getWidth();\n        },\n\n        /**\n         * 获取视图高度\n         */\n        getHeight: function() {\n            return this.painter.getHeight();\n        },\n\n        /**\n         * 图像导出\n         * @param {string} type\n         * @param {string} [backgroundColor='#fff'] 背景色\n         * @return {string} 图片的Base64 url\n         */\n        toDataURL: function(type, backgroundColor, args) {\n            return this.painter.toDataURL(type, backgroundColor, args);\n        },\n\n        /**\n         * 将常规shape转成image shape\n         * @param {module:zrender/graphic/Path} e\n         * @param {number} width\n         * @param {number} height\n         */\n        pathToImage: function(e, width, height) {\n            var id = guid();\n            return this.painter.pathToImage(id, e, width, height);\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} cursorStyle 例如 crosshair\n         */\n        setDefaultCursorStyle: function (cursorStyle) {\n            this.handler.setDefaultCursorStyle(cursorStyle);\n        },\n\n        /**\n         * 事件绑定\n         *\n         * @param {string} eventName 事件名称\n         * @param {Function} eventHandler 响应函数\n         * @param {Object} [context] 响应函数\n         */\n        on: function(eventName, eventHandler, context) {\n            this.handler && this.handler.on(eventName, eventHandler, context);\n        },\n\n        /**\n         * 事件解绑定，参数为空则解绑所有自定义事件\n         *\n         * @param {string} eventName 事件名称\n         * @param {Function} eventHandler 响应函数\n         */\n        off: function(eventName, eventHandler) {\n            this.handler && this.handler.off(eventName, eventHandler);\n        },\n\n        /**\n         * 事件触发\n         *\n         * @param {string} eventName 事件名称，resize，hover，drag，etc\n         * @param {event=} event event dom事件对象\n         */\n        trigger: function (eventName, event) {\n            this.handler && this.handler.trigger(eventName, event);\n        },\n\n\n        /**\n         * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用\n         */\n        clear: function () {\n            this.storage.delRoot();\n            this.painter.clear();\n        },\n\n        /**\n         * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用\n         */\n        dispose: function () {\n            this.animation.stop();\n\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler && this.handler.dispose();\n\n            this.animation =\n            this.storage =\n            this.painter =\n            this.handler = null;\n\n            delInstance(this.id);\n        }\n    };\n\n    module.exports = zrender;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/zrender.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\n\n\n        var idStart = 0x0907;\n\n        module.exports = function () {\n            return 'zr_' + (idStart++);\n        };\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/guid.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n    var env = {};\n    if (typeof navigator === 'undefined') {\n        // In node\n        env = {\n            browser: {},\n            os: {},\n            node: true,\n            // Assume canvas is supported\n            canvasSupported: true\n        };\n    }\n    else {\n        env = detect(navigator.userAgent);\n    }\n\n    module.exports = env;\n\n    // Zepto.js\n    // (c) 2010-2013 Thomas Fuchs\n    // Zepto.js may be freely distributed under the MIT license.\n\n    function detect(ua) {\n        var os = {};\n        var browser = {};\n        var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n        var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n        var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n        var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n        var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n        var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n        var touchpad = webos && ua.match(/TouchPad/);\n        var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n        var silk = ua.match(/Silk\\/([\\d._]+)/);\n        var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n        var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n        var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n        var playbook = ua.match(/PlayBook/);\n        var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            // IE 11 Trident/7.0; rv:11.0\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n        // Todo: clean this up with a better OS/browser seperation:\n        // - discern (more) between multiple browsers on android\n        // - decide if kindle fire in silk mode is android or not\n        // - Firefox on Android doesn't specify the Android version\n        // - possibly devide in os, device and browser hashes\n\n        if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n        if (android) os.android = true, os.version = android[2];\n        if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n        if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n        if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n        if (webos) os.webos = true, os.version = webos[2];\n        if (touchpad) os.touchpad = true;\n        if (blackberry) os.blackberry = true, os.version = blackberry[2];\n        if (bb10) os.bb10 = true, os.version = bb10[2];\n        if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n        if (playbook) browser.playbook = true;\n        if (kindle) os.kindle = true, os.version = kindle[1];\n        if (silk) browser.silk = true, browser.version = silk[1];\n        if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n        if (chrome) browser.chrome = true, browser.version = chrome[1];\n        if (firefox) browser.firefox = true, browser.version = firefox[1];\n        if (ie) browser.ie = true, browser.version = ie[1];\n        if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n        if (webview) browser.webview = true;\n        if (ie) browser.ie = true, browser.version = ie[1];\n        if (edge) browser.edge = true, browser.version = edge[1];\n\n        os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n            (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n        os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||\n            (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n            (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n        return {\n            browser: browser,\n            os: os,\n            node: false,\n            // 原生canvas支持，改极端点了\n            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n            canvasSupported : document.createElement('canvas').getContext ? true : false,\n            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>\n            // works on most browsers\n            // IE10/11 does not support touch event, and MS Edge supports them but not by\n            // default, so we dont check navigator.maxTouchPoints for them here.\n            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n            // <http://caniuse.com/#search=pointer%20event>.\n            pointerEventsSupported: 'onpointerdown' in window\n                // Firefox supports pointer but not by default,\n                // only MS browsers are reliable on pointer events currently.\n                && (browser.edge || (browser.ie && browser.version >= 10))\n        };\n    }\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/env.js\n ** module id = 5\n ** module chunks = 0\n **/","'use strict';\n/**\n * Handler控制模块\n * @module zrender/Handler\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (shenyi.914@gmail.com)\n */\n\n\n    var env = require('./core/env');\n    var eventTool = require('./core/event');\n    var util = require('./core/util');\n    var Draggable = require('./mixin/Draggable');\n    var GestureMgr = require('./core/GestureMgr');\n\n    var Eventful = require('./mixin/Eventful');\n\n    var mouseHandlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout'\n    ];\n    !usePointerEvent() && mouseHandlerNames.push(\n        'mouseup', 'mousedown', 'mousemove'\n    );\n\n    var touchHandlerNames = [\n        'touchstart', 'touchend', 'touchmove'\n    ];\n\n    var pointerHandlerNames = [\n        'pointerdown', 'pointerup', 'pointermove'\n    ];\n\n    var TOUCH_CLICK_DELAY = 300;\n\n    // touch指尖错觉的尝试偏移量配置\n    // var MOBILE_TOUCH_OFFSETS = [\n    //     { x: 10 },\n    //     { x: -20 },\n    //     { x: 10, y: 10 },\n    //     { y: -20 }\n    // ];\n\n    var addEventListener = eventTool.addEventListener;\n    var removeEventListener = eventTool.removeEventListener;\n    var normalizeEvent = eventTool.normalizeEvent;\n\n    function makeEventPacket(eveType, target, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: target,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta\n        };\n    }\n\n    var domHandlers = {\n        /**\n         * Mouse move handler\n         * @inner\n         * @param {Event} event\n         */\n        mousemove: function (event) {\n            event = normalizeEvent(this.root, event);\n\n            var x = event.zrX;\n            var y = event.zrY;\n\n            var hovered = this.findHover(x, y, null);\n            var lastHovered = this._hovered;\n\n            this._hovered = hovered;\n\n            this.root.style.cursor = hovered ? hovered.cursor : this._defaultCursorStyle;\n            // Mouse out on previous hovered element\n            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {\n                this._dispatchProxy(lastHovered, 'mouseout', event);\n            }\n\n            // Mouse moving on one element\n            this._dispatchProxy(hovered, 'mousemove', event);\n\n            // Mouse over on a new element\n            if (hovered && hovered !== lastHovered) {\n                this._dispatchProxy(hovered, 'mouseover', event);\n            }\n        },\n\n        /**\n         * Mouse out handler\n         * @inner\n         * @param {Event} event\n         */\n        mouseout: function (event) {\n            event = normalizeEvent(this.root, event);\n\n            var element = event.toElement || event.relatedTarget;\n            if (element != this.root) {\n                while (element && element.nodeType != 9) {\n                    // 忽略包含在root中的dom引起的mouseOut\n                    if (element === this.root) {\n                        return;\n                    }\n\n                    element = element.parentNode;\n                }\n            }\n\n            this._dispatchProxy(this._hovered, 'mouseout', event);\n\n            this.trigger('globalout', {\n                event: event\n            });\n        },\n\n        /**\n         * Touch开始响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchstart: function (event) {\n            // FIXME\n            // 移动端可能需要default行为，例如静态图表时。\n            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n            event = normalizeEvent(this.root, event);\n\n            this._lastTouchMoment = new Date();\n\n            processGesture(this, event, 'start');\n\n            // 平板补充一次findHover\n            // this._mobileFindFixed(event);\n            // Trigger mousemove and mousedown\n            domHandlers.mousemove.call(this, event);\n\n            domHandlers.mousedown.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch移动响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchmove: function (event) {\n            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n            event = normalizeEvent(this.root, event);\n\n            processGesture(this, event, 'change');\n\n            // Mouse move should always be triggered no matter whether\n            // there is gestrue event, because mouse move and pinch may\n            // be used at the same time.\n            domHandlers.mousemove.call(this, event);\n\n            setTouchTimer(this);\n        },\n\n        /**\n         * Touch结束响应函数\n         * @inner\n         * @param {Event} event\n         */\n        touchend: function (event) {\n            // eventTool.stop(event);// 阻止浏览器默认事件，重要\n            event = normalizeEvent(this.root, event);\n\n            processGesture(this, event, 'end');\n\n            domHandlers.mouseup.call(this, event);\n\n            // click event should always be triggered no matter whether\n            // there is gestrue event. System click can not be prevented.\n            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n                // this._mobileFindFixed(event);\n                domHandlers.click.call(this, event);\n            }\n\n            setTouchTimer(this);\n        }\n    };\n\n    // Common handlers\n    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick'], function (name) {\n        domHandlers[name] = function (event) {\n            event = normalizeEvent(this.root, event);\n            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n            var hovered = this.findHover(event.zrX, event.zrY, null);\n            this._dispatchProxy(hovered, name, event);\n        };\n    });\n\n    // Pointer event handlers\n    // util.each(['pointerdown', 'pointermove', 'pointerup'], function (name) {\n    //     domHandlers[name] = function (event) {\n    //         var mouseName = name.replace('pointer', 'mouse');\n    //         domHandlers[mouseName].call(this, event);\n    //     };\n    // });\n\n    function processGesture(zrHandler, event, stage) {\n        var gestureMgr = zrHandler._gestureMgr;\n\n        stage === 'start' && gestureMgr.clear();\n\n        var gestureInfo = gestureMgr.recognize(\n            event,\n            zrHandler.findHover(event.zrX, event.zrY, null)\n        );\n\n        stage === 'end' && gestureMgr.clear();\n\n        if (gestureInfo) {\n            // eventTool.stop(event);\n            var type = gestureInfo.type;\n            event.gestureEvent = type;\n\n            zrHandler._dispatchProxy(gestureInfo.target, type, gestureInfo.event);\n        }\n    }\n\n    /**\n     * 为控制类实例初始化dom 事件处理函数\n     *\n     * @inner\n     * @param {module:zrender/Handler} instance 控制类实例\n     */\n    function initDomHandler(instance) {\n        var handlerNames = touchHandlerNames.concat(pointerHandlerNames);\n        for (var i = 0; i < handlerNames.length; i++) {\n            var name = handlerNames[i];\n            instance._handlers[name] = util.bind(domHandlers[name], instance);\n        }\n\n        for (var i = 0; i < mouseHandlerNames.length; i++) {\n            var name = mouseHandlerNames[i];\n            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);\n        }\n\n        function makeMouseHandler(fn, instance) {\n            return function () {\n                if (instance._touching) {\n                    return;\n                }\n                return fn.apply(instance, arguments);\n            };\n        }\n    }\n\n    /**\n     * @alias module:zrender/Handler\n     * @constructor\n     * @extends module:zrender/mixin/Eventful\n     * @param {HTMLElement} root Main HTML element for painting.\n     * @param {module:zrender/Storage} storage Storage instance.\n     * @param {module:zrender/Painter} painter Painter instance.\n     */\n    var Handler = function(root, storage, painter) {\n        Eventful.call(this);\n\n        this.root = root;\n        this.storage = storage;\n        this.painter = painter;\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._hovered;\n\n        /**\n         * @private\n         * @type {Date}\n         */\n        this._lastTouchMoment;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastX;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._lastY;\n\n        /**\n         * @private\n         * @type {string}\n         */\n        this._defaultCursorStyle = 'default';\n\n        /**\n         * @private\n         * @type {module:zrender/core/GestureMgr}\n         */\n        this._gestureMgr = new GestureMgr();\n\n        /**\n         * @private\n         * @type {Array.<Function>}\n         */\n        this._handlers = [];\n\n        /**\n         * @private\n         * @type {boolean}\n         */\n        this._touching = false;\n\n        /**\n         * @private\n         * @type {number}\n         */\n        this._touchTimer;\n\n        initDomHandler(this);\n\n        if (usePointerEvent()) {\n            mountHandlers(pointerHandlerNames, this);\n        }\n        else if (useTouchEvent()) {\n            mountHandlers(touchHandlerNames, this);\n\n            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n            // addEventListener(root, 'mouseout', this._mouseoutHandler);\n        }\n\n        // Considering some devices that both enable touch and mouse event (like MS Surface\n        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n        // mouse event can not be handle in those devices.\n        mountHandlers(mouseHandlerNames, this);\n\n        Draggable.call(this);\n\n        function mountHandlers(handlerNames, instance) {\n            util.each(handlerNames, function (name) {\n                addEventListener(root, eventNameFix(name), instance._handlers[name]);\n            }, instance);\n        }\n    };\n\n    Handler.prototype = {\n\n        constructor: Handler,\n\n        /**\n         * Resize\n         */\n        resize: function (event) {\n            this._hovered = null;\n        },\n\n        /**\n         * Dispatch event\n         * @param {string} eventName\n         * @param {event=} eventArgs\n         */\n        dispatch: function (eventName, eventArgs) {\n            var handler = this._handlers[eventName];\n            handler && handler.call(this, eventArgs);\n        },\n\n        /**\n         * Dispose\n         */\n        dispose: function () {\n            var root = this.root;\n\n            var handlerNames = mouseHandlerNames.concat(touchHandlerNames);\n\n            for (var i = 0; i < handlerNames.length; i++) {\n                var name = handlerNames[i];\n                removeEventListener(root, eventNameFix(name), this._handlers[name]);\n            }\n\n            this.root =\n            this.storage =\n            this.painter = null;\n        },\n\n        /**\n         * 设置默认的cursor style\n         * @param {string} cursorStyle 例如 crosshair\n         */\n        setDefaultCursorStyle: function (cursorStyle) {\n            this._defaultCursorStyle = cursorStyle;\n        },\n\n        /**\n         * 事件分发代理\n         *\n         * @private\n         * @param {Object} targetEl 目标图形元素\n         * @param {string} eventName 事件名称\n         * @param {Object} event 事件对象\n         */\n        _dispatchProxy: function (targetEl, eventName, event) {\n            var eventHandler = 'on' + eventName;\n            var eventPacket = makeEventPacket(eventName, targetEl, event);\n\n            var el = targetEl;\n\n            while (el) {\n                el[eventHandler]\n                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n\n                el.trigger(eventName, eventPacket);\n\n                el = el.parent;\n\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n\n            if (!eventPacket.cancelBubble) {\n                // 冒泡到顶级 zrender 对象\n                this.trigger(eventName, eventPacket);\n                // 分发事件到用户自定义层\n                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n                this.painter && this.painter.eachOtherLayer(function (layer) {\n                    if (typeof(layer[eventHandler]) == 'function') {\n                        layer[eventHandler].call(layer, eventPacket);\n                    }\n                    if (layer.trigger) {\n                        layer.trigger(eventName, eventPacket);\n                    }\n                });\n            }\n        },\n\n        /**\n         * @private\n         * @param {number} x\n         * @param {number} y\n         * @param {module:zrender/graphic/Displayable} exclude\n         * @method\n         */\n        findHover: function(x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            for (var i = list.length - 1; i >= 0 ; i--) {\n                if (!list[i].silent\n                 && list[i] !== exclude\n                 // getDisplayList may include ignored item in VML mode\n                 && !list[i].ignore\n                 && isHover(list[i], x, y)) {\n                    return list[i];\n                }\n            }\n        }\n    };\n\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var p = displayable.parent;\n            while (p) {\n                if (p.clipPath && !p.clipPath.contain(x, y))  {\n                    // Clipped by parents\n                    return false;\n                }\n                p = p.parent;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Prevent mouse event from being dispatched after Touch Events action\n     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n     * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n     * Result: Blocking Mouse Events for 700ms.\n     */\n    function setTouchTimer(instance) {\n        instance._touching = true;\n        clearTimeout(instance._touchTimer);\n        instance._touchTimer = setTimeout(function () {\n            instance._touching = false;\n        }, 700);\n    }\n\n    /**\n     * Althought MS Surface support screen touch, IE10/11 do not support\n     * touch event and MS Edge supported them but not by default (but chrome\n     * and firefox do). Thus we use Pointer event on MS browsers to handle touch.\n     */\n    function usePointerEvent() {\n        // TODO\n        // pointermove event dont trigger when using finger.\n        // We may figger it out latter.\n        return false;\n        // return env.pointerEventsSupported\n            // In no-touch device we dont use pointer evnets but just\n            // use mouse event for avoiding problems.\n            // && window.navigator.maxTouchPoints;\n    }\n\n    function useTouchEvent() {\n        return env.touchEventsSupported;\n    }\n\n    function eventNameFix(name) {\n        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;\n    }\n\n    util.mixin(Handler, Eventful);\n    util.mixin(Handler, Draggable);\n\n    module.exports = Handler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Handler.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n/**\n * 事件辅助类\n * @module zrender/core/event\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n\n    var Eventful = require('../mixin/Eventful');\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n\n    function getBoundingClientRect(el) {\n        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect\n        return el.getBoundingClientRect ? el.getBoundingClientRect() : { left: 0, top: 0};\n    }\n    /**\n     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标\n     */\n    function normalizeEvent(el, e) {\n\n        e = e || window.event;\n\n        if (e.zrX != null) {\n            return e;\n        }\n\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n        if (!isTouch) {\n            var box = getBoundingClientRect(el);\n            e.zrX = e.clientX - box.left;\n            e.zrY = e.clientY - box.top;\n            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType != 'touchend'\n                            ? e.targetTouches[0]\n                            : e.changedTouches[0];\n            if (touch) {\n                var rBounding = getBoundingClientRect(el);\n                // touch事件坐标是全屏的~\n                e.zrX = touch.clientX - rBounding.left;\n                e.zrY = touch.clientY - rBounding.top;\n            }\n        }\n\n        return e;\n    }\n\n    function addEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n\n    function removeEventListener(el, name, handler) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n\n    /**\n     * 停止冒泡和阻止默认行为\n     * @memberOf module:zrender/core/event\n     * @method\n     * @param {Event} e : event对象\n     */\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n\n    module.exports = {\n        normalizeEvent: normalizeEvent,\n        addEventListener: addEventListener,\n        removeEventListener: removeEventListener,\n\n        stop: stop,\n        // 做向上兼容\n        Dispatcher: Eventful\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/event.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * 事件扩展\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n\n\n    var arrySlice = Array.prototype.slice;\n    var zrUtil = require('../core/util');\n    var indexOf = zrUtil.indexOf;\n\n    /**\n     * 事件分发器\n     * @alias module:zrender/mixin/Eventful\n     * @constructor\n     */\n    var Eventful = function () {\n        this._$handlers = {};\n    };\n\n    Eventful.prototype = {\n\n        constructor: Eventful,\n\n        /**\n         * 单次触发绑定，trigger后销毁\n         *\n         * @param {string} event 事件名\n         * @param {Function} handler 响应函数\n         * @param {Object} context\n         */\n        one: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            if (indexOf(_h[event], event) >= 0) {\n                return this;\n            }\n\n            _h[event].push({\n                h: handler,\n                one: true,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 绑定事件\n         * @param {string} event 事件名\n         * @param {Function} handler 事件处理函数\n         * @param {Object} [context]\n         */\n        on: function (event, handler, context) {\n            var _h = this._$handlers;\n\n            if (!handler || !event) {\n                return this;\n            }\n\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n\n            _h[event].push({\n                h: handler,\n                one: false,\n                ctx: context || this\n            });\n\n            return this;\n        },\n\n        /**\n         * 是否绑定了事件\n         * @param  {string}  event\n         * @return {boolean}\n         */\n        isSilent: function (event) {\n            var _h = this._$handlers;\n            return _h[event] && _h[event].length;\n        },\n\n        /**\n         * 解绑事件\n         * @param {string} event 事件名\n         * @param {Function} [handler] 事件处理函数\n         */\n        off: function (event, handler) {\n            var _h = this._$handlers;\n\n            if (!event) {\n                this._$handlers = {};\n                return this;\n            }\n\n            if (handler) {\n                if (_h[event]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[event].length; i < l; i++) {\n                        if (_h[event][i]['h'] != handler) {\n                            newList.push(_h[event][i]);\n                        }\n                    }\n                    _h[event] = newList;\n                }\n\n                if (_h[event] && _h[event].length === 0) {\n                    delete _h[event];\n                }\n            }\n            else {\n                delete _h[event];\n            }\n\n            return this;\n        },\n\n        /**\n         * 事件分发\n         *\n         * @param {string} type 事件类型\n         */\n        trigger: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 3) {\n                    args = arrySlice.call(args, 1);\n                }\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(_h[i]['ctx']);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(_h[i]['ctx'], args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 带有context的事件分发, 最后一个参数是事件回调的context\n         * @param {string} type 事件类型\n         */\n        triggerWithContext: function (type) {\n            if (this._$handlers[type]) {\n                var args = arguments;\n                var argLen = args.length;\n\n                if (argLen > 4) {\n                    args = arrySlice.call(args, 1, args.length - 1);\n                }\n                var ctx = args[args.length - 1];\n\n                var _h = this._$handlers[type];\n                var len = _h.length;\n                for (var i = 0; i < len;) {\n                    // Optimize advise from backbone\n                    switch (argLen) {\n                        case 1:\n                            _h[i]['h'].call(ctx);\n                            break;\n                        case 2:\n                            _h[i]['h'].call(ctx, args[1]);\n                            break;\n                        case 3:\n                            _h[i]['h'].call(ctx, args[1], args[2]);\n                            break;\n                        default:\n                            // have more than 2 given arguments\n                            _h[i]['h'].apply(ctx, args);\n                            break;\n                    }\n\n                    if (_h[i]['one']) {\n                        _h.splice(i, 1);\n                        len--;\n                    }\n                    else {\n                        i++;\n                    }\n                }\n            }\n\n            return this;\n        }\n    };\n\n    // 对象可以通过 onxxxx 绑定事件\n    /**\n     * @event module:zrender/mixin/Eventful#onclick\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseout\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousemove\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousewheel\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmousedown\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#onmouseup\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragstart\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragend\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragenter\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragleave\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondragover\n     * @type {Function}\n     * @default null\n     */\n    /**\n     * @event module:zrender/mixin/Eventful#ondrop\n     * @type {Function}\n     * @default null\n     */\n\n    module.exports = Eventful;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Eventful.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n */\n\n    var Gradient = require('../graphic/Gradient');\n    // 用于处理merge时无法遍历Date等对象的问题\n    var BUILTIN_OBJECT = {\n        '[object Function]': 1,\n        '[object RegExp]': 1,\n        '[object Date]': 1,\n        '[object Error]': 1,\n        '[object CanvasGradient]': 1\n    };\n\n    var objToString = Object.prototype.toString;\n\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var nativeReduce = arrayProto.reduce;\n\n    /**\n     * @param {*} source\n     * @return {*} 拷贝后的新对象\n     */\n    function clone(source) {\n        if (typeof source == 'object' && source !== null) {\n            var result = source;\n            if (source instanceof Array) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n            else if (\n                !isBuildInObject(source)\n                // 是否为 dom 对象\n                && !isDom(source)\n            ) {\n                result = {};\n                for (var key in source) {\n                    if (source.hasOwnProperty(key)) {\n                        result[key] = clone(source[key]);\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        return source;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolean} [overwrite=false]\n     */\n    function merge(target, source, overwrite) {\n        // We should escapse that source is string\n        // and enter for ... in ...\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuildInObject(sourceProp)\n                    && !isBuildInObject(targetProp)\n                ) {\n                    // 如果需要递归覆盖，就递归调用merge\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n                    // NOTE，在 target[key] 不存在的时候也是直接覆盖\n                    target[key] = clone(source[key], true);\n                }\n            }\n        }\n\n        return target;\n    }\n\n    /**\n     * @param {Array} targetAndSources The first item is target, and the rests are source.\n     * @param {boolean} [overwrite=false]\n     * @return {*} target\n     */\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     */\n    function extend(target, source) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    /**\n     * @param {*} target\n     * @param {*} source\n     * @param {boolen} [overlay=false]\n     */\n    function defaults(target, source, overlay) {\n        for (var key in source) {\n            if (source.hasOwnProperty(key)\n                && (overlay ? source[key] != null : target[key] == null)\n            ) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n\n    function createCanvas() {\n        return document.createElement('canvas');\n    }\n    // FIXME\n    var _ctx;\n    function getContext() {\n        if (!_ctx) {\n            // Use util.createCanvas instead of createCanvas\n            // because createCanvas may be overwritten in different environment\n            _ctx = util.createCanvas().getContext('2d');\n        }\n        return _ctx;\n    }\n\n    /**\n     * 查询数组中元素的index\n     */\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * 构造类继承关系\n     *\n     * @param {Function} clazz 源类\n     * @param {Function} baseClazz 基类\n     */\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() {}\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n\n        for (var prop in clazzPrototype) {\n            clazz.prototype[prop] = clazzPrototype[prop];\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n\n    /**\n     * @param {Object|Function} target\n     * @param {Object|Function} sorce\n     * @param {boolean} overlay\n     */\n    function mixin(target, source, overlay) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n\n        defaults(target, source, overlay);\n    }\n\n    /**\n     * @param {Array|TypedArray} data\n     */\n    function isArrayLike(data) {\n        if (! data) {\n            return;\n        }\n        if (typeof data == 'string') {\n            return false;\n        }\n        return typeof data.length == 'number';\n    }\n\n    /**\n     * 数组或对象遍历\n     * @memberOf module:zrender/tool/util\n     * @param {Object|Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     */\n    function each(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.forEach && obj.forEach === nativeForEach) {\n            obj.forEach(cb, context);\n        }\n        else if (obj.length === +obj.length) {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                cb.call(context, obj[i], i, obj);\n            }\n        }\n        else {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    cb.call(context, obj[key], key, obj);\n                }\n            }\n        }\n    }\n\n    /**\n     * 数组映射\n     * @memberOf module:zrender/tool/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function map(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.map && obj.map === nativeMap) {\n            return obj.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                result.push(cb.call(context, obj[i], i, obj));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {Object} [memo]\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function reduce(obj, cb, memo, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.reduce && obj.reduce === nativeReduce) {\n            return obj.reduce(cb, memo, context);\n        }\n        else {\n            for (var i = 0, len = obj.length; i < len; i++) {\n                memo = cb.call(context, memo, obj[i], i, obj);\n            }\n            return memo;\n        }\n    }\n\n    /**\n     * 数组过滤\n     * @memberOf module:zrender/tool/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function filter(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        if (obj.filter && obj.filter === nativeFilter) {\n            return obj.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = obj.length; i < len; i++) {\n                if (cb.call(context, obj[i], i, obj)) {\n                    result.push(obj[i]);\n                }\n            }\n            return result;\n        }\n    }\n\n    /**\n     * 数组项查找\n     * @memberOf module:zrender/tool/util\n     * @param {Array} obj\n     * @param {Function} cb\n     * @param {*} [context]\n     * @return {Array}\n     */\n    function find(obj, cb, context) {\n        if (!(obj && cb)) {\n            return;\n        }\n        for (var i = 0, len = obj.length; i < len; i++) {\n            if (cb.call(context, obj[i], i, obj)) {\n                return obj[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {Function} func\n     * @param {*} context\n     * @return {Function}\n     */\n    function bind(func, context) {\n        var args = nativeSlice.call(arguments, 2);\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {Function} func\n     * @param {...}\n     * @return {Function}\n     */\n    function curry(func) {\n        var args = nativeSlice.call(arguments, 1);\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isArray(value) {\n        return objToString.call(value) === '[object Array]';\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isString(value) {\n        return objToString.call(value) === '[object String]';\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isObject(value) {\n        // Avoid a V8 JIT bug in Chrome 19-20.\n        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n        var type = typeof value;\n        return type === 'function' || (!!value && type == 'object');\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isBuildInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)]\n            || (value instanceof Gradient);\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {*} value\n     * @return {boolean}\n     */\n    function isDom(value) {\n        return value && value.nodeType === 1\n               && typeof(value.nodeName) == 'string';\n    }\n\n    /**\n     * If value1 is not null, then return value1, otherwise judget rest of values.\n     * @param  {*...} values\n     * @return {*} Final value\n     */\n    function retrieve(values) {\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            if (arguments[i] != null) {\n                return arguments[i];\n            }\n        }\n    }\n\n    /**\n     * @memberOf module:zrender/tool/util\n     * @param {Array} arr\n     * @param {number} startIndex\n     * @param {number} endIndex\n     * @return {Array}\n     */\n    function slice() {\n        return Function.call.apply(nativeSlice, arguments);\n    }\n\n    /**\n     * @param {boolean} condition\n     * @param {string} message\n     */\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n\n    var util = {\n        inherits: inherits,\n        mixin: mixin,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        getContext: getContext,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        slice: slice,\n        find: find,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        isBuildInObject: isBuildInObject,\n        isDom: isDom,\n        retrieve: retrieve,\n        assert: assert,\n        noop: function () {}\n    };\n    module.exports = util;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/util.js\n ** module id = 9\n ** module chunks = 0\n **/","\n\n    /**\n     * @param {Array.<Object>} colorStops\n     */\n    var Gradient = function (colorStops) {\n\n        this.colorStops = colorStops || [];\n    };\n\n    Gradient.prototype = {\n\n        constructor: Gradient,\n\n        addColorStop: function (offset, color) {\n            this.colorStops.push({\n\n                offset: offset,\n\n                color: color\n            });\n        }\n    };\n\n    module.exports = Gradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Gradient.js\n ** module id = 10\n ** module chunks = 0\n **/","// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\n\n    function Draggable() {\n\n        this.on('mousedown', this._dragStart, this);\n        this.on('mousemove', this._drag, this);\n        this.on('mouseup', this._dragEnd, this);\n        this.on('globalout', this._dragEnd, this);\n        // this._dropTarget = null;\n        // this._draggingTarget = null;\n\n        // this._x = 0;\n        // this._y = 0;\n    }\n\n    Draggable.prototype = {\n\n        constructor: Draggable,\n\n        _dragStart: function (e) {\n            var draggingTarget = e.target;\n            if (draggingTarget && draggingTarget.draggable) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n\n                this._dispatchProxy(draggingTarget, 'dragstart', e.event);\n            }\n        },\n\n        _drag: function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n\n                var x = e.offsetX;\n                var y = e.offsetY;\n\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n\n                draggingTarget.drift(dx, dy, e);\n                this._dispatchProxy(draggingTarget, 'drag', e.event);\n\n                var dropTarget = this.findHover(x, y, draggingTarget);\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this._dispatchProxy(lastDropTarget, 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this._dispatchProxy(dropTarget, 'dragenter', e.event);\n                    }\n                }\n            }\n        },\n\n        _dragEnd: function (e) {\n            var draggingTarget = this._draggingTarget;\n\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n\n            this._dispatchProxy(draggingTarget, 'dragend', e.event);\n\n            if (this._dropTarget) {\n                this._dispatchProxy(this._dropTarget, 'drop', e.event);\n            }\n\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        }\n\n    };\n\n    module.exports = Draggable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Draggable.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n/**\n * Only implements needed gestures for mobile.\n */\n\n\n    var GestureMgr = function () {\n\n        /**\n         * @private\n         * @type {Array.<Object>}\n         */\n        this._track = [];\n    };\n\n    GestureMgr.prototype = {\n\n        constructor: GestureMgr,\n\n        recognize: function (event, target) {\n            this._doTrack(event, target);\n            return this._recognize(event);\n        },\n\n        clear: function () {\n            this._track.length = 0;\n            return this;\n        },\n\n        _doTrack: function (event, target) {\n            var touches = event.touches;\n\n            if (!touches) {\n                return;\n            }\n\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                trackItem.points.push([touch.clientX, touch.clientY]);\n                trackItem.touches.push(touch);\n            }\n\n            this._track.push(trackItem);\n        },\n\n        _recognize: function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        }\n    };\n\n    function dist(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n\n    var recognizers = {\n\n        pinch: function (track, event) {\n            var trackLen = track.length;\n\n            if (!trackLen) {\n                return;\n            }\n\n            var pinchEnd = (track[trackLen - 1] || {}).points;\n            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1\n            ) {\n                var pinchScale = dist(pinchEnd) / dist(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n\n                event.pinchScale = pinchScale;\n\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n\n                return {\n                    type: 'pinch',\n                    target: track[0].target,\n                    event: event\n                };\n            }\n        }\n\n        // Only pinch currently.\n    };\n\n    module.exports = GestureMgr;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/GestureMgr.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n/**\n * Storage内容仓库模块\n * @module zrender/Storage\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n * @author errorrik (errorrik@gmail.com)\n * @author pissang (https://github.com/pissang/)\n */\n\n\n    var util = require('./core/util');\n\n    var Group = require('./container/Group');\n\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                if (a.z2 === b.z2) {\n                    return a.__renderidx - b.__renderidx;\n                }\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    /**\n     * 内容仓库 (M)\n     * @alias module:zrender/Storage\n     * @constructor\n     */\n    var Storage = function () {\n        // 所有常规形状，id索引的map\n        this._elements = {};\n\n        this._roots = [];\n\n        this._displayList = [];\n\n        this._displayListLen = 0;\n    };\n\n    Storage.prototype = {\n\n        constructor: Storage,\n\n        /**\n         * 返回所有图形的绘制队列\n         * @param {boolean} [update=false] 是否在返回前更新该数组\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n         *\n         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n         * @return {Array.<module:zrender/graphic/Displayable>}\n         */\n        getDisplayList: function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            if (update) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return this._displayList;\n        },\n\n        /**\n         * 更新图形的绘制队列。\n         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n         */\n        updateDisplayList: function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n\n            for (var i = 0, len = displayList.length; i < len; i++) {\n                displayList[i].__renderidx = i;\n            }\n\n            displayList.sort(shapeCompareFunc);\n        },\n\n        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n\n            el.beforeUpdate();\n\n            el.update();\n\n            el.afterUpdate();\n\n            var clipPath = el.clipPath;\n            if (clipPath) {\n                // clipPath 的变换是基于 group 的变换\n                clipPath.parent = el;\n                clipPath.updateTransform();\n\n                // FIXME 效率影响\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                    clipPaths.push(clipPath);\n                }\n                else {\n                    clipPaths = [clipPath];\n                }\n            }\n\n            if (el.type == 'group') {\n                var children = el._children;\n\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n\n                    // Force to mark as dirty if group is dirty\n                    // FIXME __dirtyPath ?\n                    child.__dirty = el.__dirty || child.__dirty;\n\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n\n                // Mark group clean here\n                el.__dirty = false;\n\n            }\n            else {\n                el.__clipPaths = clipPaths;\n\n                this._displayList[this._displayListLen++] = el;\n            }\n        },\n\n        /**\n         * 添加图形(Shape)或者组(Group)到根节点\n         * @param {module:zrender/Element} el\n         */\n        addRoot: function (el) {\n            // Element has been added\n            if (this._elements[el.id]) {\n                return;\n            }\n\n            if (el instanceof Group) {\n                el.addChildrenToStorage(this);\n            }\n\n            this.addToMap(el);\n            this._roots.push(el);\n        },\n\n        /**\n         * 删除指定的图形(Shape)或者组(Group)\n         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage\n         */\n        delRoot: function (elId) {\n            if (elId == null) {\n                // 不指定elId清空\n                for (var i = 0; i < this._roots.length; i++) {\n                    var root = this._roots[i];\n                    if (root instanceof Group) {\n                        root.delChildrenFromStorage(this);\n                    }\n                }\n\n                this._elements = {};\n                this._roots = [];\n                this._displayList = [];\n                this._displayListLen = 0;\n\n                return;\n            }\n\n            if (elId instanceof Array) {\n                for (var i = 0, l = elId.length; i < l; i++) {\n                    this.delRoot(elId[i]);\n                }\n                return;\n            }\n\n            var el;\n            if (typeof(elId) == 'string') {\n                el = this._elements[elId];\n            }\n            else {\n                el = elId;\n            }\n\n            var idx = util.indexOf(this._roots, el);\n            if (idx >= 0) {\n                this.delFromMap(el.id);\n                this._roots.splice(idx, 1);\n                if (el instanceof Group) {\n                    el.delChildrenFromStorage(this);\n                }\n            }\n        },\n\n        addToMap: function (el) {\n            if (el instanceof Group) {\n                el.__storage = this;\n            }\n            el.dirty();\n\n            this._elements[el.id] = el;\n\n            return this;\n        },\n\n        get: function (elId) {\n            return this._elements[elId];\n        },\n\n        delFromMap: function (elId) {\n            var elements = this._elements;\n            var el = elements[elId];\n            if (el) {\n                delete elements[elId];\n                if (el instanceof Group) {\n                    el.__storage = null;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * 清空并且释放Storage\n         */\n        dispose: function () {\n            this._elements =\n            this._renderList =\n            this._roots = null;\n        }\n    };\n\n    module.exports = Storage;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Storage.js\n ** module id = 13\n ** module chunks = 0\n **/","/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/lib/container/Group');\n *     var Circle = require('zrender/lib/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n\n    var zrUtil = require('../core/util');\n    var Element = require('../Element');\n    var BoundingRect = require('../core/BoundingRect');\n\n    /**\n     * @alias module:zrender/graphic/Group\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @extends module:zrender/mixin/Eventful\n     */\n    var Group = function (opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        for (var key in opts) {\n            this[key] = opts[key];\n        }\n\n        this._children = [];\n\n        this.__storage = null;\n\n        this.__dirty = true;\n    };\n\n    Group.prototype = {\n\n        constructor: Group,\n\n        /**\n         * @type {string}\n         */\n        type: 'group',\n\n        /**\n         * @return {Array.<module:zrender/Element>}\n         */\n        children: function () {\n            return this._children.slice();\n        },\n\n        /**\n         * 获取指定 index 的儿子节点\n         * @param  {number} idx\n         * @return {module:zrender/Element}\n         */\n        childAt: function (idx) {\n            return this._children[idx];\n        },\n\n        /**\n         * 获取指定名字的儿子节点\n         * @param  {string} name\n         * @return {module:zrender/Element}\n         */\n        childOfName: function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n             }\n        },\n\n        /**\n         * @return {number}\n         */\n        childCount: function () {\n            return this._children.length;\n        },\n\n        /**\n         * 添加子节点到最后\n         * @param {module:zrender/Element} child\n         */\n        add: function (child) {\n            if (child && child !== this && child.parent !== this) {\n\n                this._children.push(child);\n\n                this._doAdd(child);\n            }\n\n            return this;\n        },\n\n        /**\n         * 添加子节点在 nextSibling 之前\n         * @param {module:zrender/Element} child\n         * @param {module:zrender/Element} nextSibling\n         */\n        addBefore: function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n\n            return this;\n        },\n\n        _doAdd: function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n\n            child.parent = this;\n\n            var storage = this.__storage;\n            var zr = this.__zr;\n            if (storage && storage !== child.__storage) {\n\n                storage.addToMap(child);\n\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n        },\n\n        /**\n         * 移除子节点\n         * @param {module:zrender/Element} child\n         */\n        remove: function (child) {\n            var zr = this.__zr;\n            var storage = this.__storage;\n            var children = this._children;\n\n            var idx = zrUtil.indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n\n            child.parent = null;\n\n            if (storage) {\n\n                storage.delFromMap(child.id);\n\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n\n            zr && zr.refresh();\n\n            return this;\n        },\n\n        /**\n         * 移除所有子节点\n         */\n        removeAll: function () {\n            var children = this._children;\n            var storage = this.__storage;\n            var child;\n            var i;\n            for (i = 0; i < children.length; i++) {\n                child = children[i];\n                if (storage) {\n                    storage.delFromMap(child.id);\n                    if (child instanceof Group) {\n                        child.delChildrenFromStorage(storage);\n                    }\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n\n            return this;\n        },\n\n        /**\n         * 遍历所有子节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        eachChild: function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        },\n\n        /**\n         * 深度优先遍历所有子孙节点\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                cb.call(context, child);\n\n                if (child.type === 'group') {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        },\n\n        addChildrenToStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.addToMap(child);\n                if (child instanceof Group) {\n                    child.addChildrenToStorage(storage);\n                }\n            }\n        },\n\n        delChildrenFromStorage: function (storage) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                storage.delFromMap(child.id);\n                if (child instanceof Group) {\n                    child.delChildrenFromStorage(storage);\n                }\n            }\n        },\n\n        dirty: function () {\n            this.__dirty = true;\n            this.__zr && this.__zr.refresh();\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function (includeChildren) {\n            // TODO Caching\n            // TODO Transform\n            var rect = null;\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    tmpRect.copy(childRect);\n                    tmpRect.applyTransform(transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        }\n    };\n\n    zrUtil.inherits(Group, Element);\n\n    module.exports = Group;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/container/Group.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/Element\n */\n\n\n    var guid = require('./core/guid');\n    var Eventful = require('./mixin/Eventful');\n    var Transformable = require('./mixin/Transformable');\n    var Animatable = require('./mixin/Animatable');\n    var zrUtil = require('./core/util');\n\n    /**\n     * @alias module:zrender/Element\n     * @constructor\n     * @extends {module:zrender/mixin/Animatable}\n     * @extends {module:zrender/mixin/Transformable}\n     * @extends {module:zrender/mixin/Eventful}\n     */\n    var Element = function (opts) {\n\n        Transformable.call(this, opts);\n        Eventful.call(this, opts);\n        Animatable.call(this, opts);\n\n        /**\n         * 画布元素ID\n         * @type {string}\n         */\n        this.id = opts.id || guid();\n    };\n\n    Element.prototype = {\n\n        /**\n         * 元素类型\n         * Element type\n         * @type {string}\n         */\n        type: 'element',\n\n        /**\n         * 元素名字\n         * Element name\n         * @type {string}\n         */\n        name: '',\n\n        /**\n         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n         * ZRender instance will be assigned when element is associated with zrender\n         * @name module:/zrender/Element#__zr\n         * @type {module:zrender/ZRender}\n         */\n        __zr: null,\n\n        /**\n         * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n         * If ignore drawing and events of the element object\n         * @name module:/zrender/Element#ignore\n         * @type {boolean}\n         * @default false\n         */\n        ignore: false,\n\n        /**\n         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n         * 该路径会继承被裁减对象的变换\n         * @type {module:zrender/graphic/Path}\n         * @see http://www.w3.org/TR/2dcontext/#clipping-region\n         * @readOnly\n         */\n        clipPath: null,\n\n        /**\n         * Drift element\n         * @param  {number} dx dx on the global space\n         * @param  {number} dy dy on the global space\n         */\n        drift: function (dx, dy) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n\n            this.decomposeTransform();\n            this.dirty();\n        },\n\n        /**\n         * Hook before update\n         */\n        beforeUpdate: function () {},\n        /**\n         * Hook after update\n         */\n        afterUpdate: function () {},\n        /**\n         * Update each frame\n         */\n        update: function () {\n            this.updateTransform();\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {},\n\n        /**\n         * @protected\n         */\n        attrKV: function (key, value) {\n            if (key === 'position' || key === 'scale' || key === 'origin') {\n                // Copy the array\n                if (value) {\n                    var target = this[key];\n                    if (!target) {\n                        target = this[key] = [];\n                    }\n                    target[0] = value[0];\n                    target[1] = value[1];\n                }\n            }\n            else {\n                this[key] = value;\n            }\n        },\n\n        /**\n         * Hide the element\n         */\n        hide: function () {\n            this.ignore = true;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * Show the element\n         */\n        show: function () {\n            this.ignore = false;\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * @param {string|Object} key\n         * @param {*} value\n         */\n        attr: function (key, value) {\n            if (typeof key === 'string') {\n                this.attrKV(key, value);\n            }\n            else if (zrUtil.isObject(key)) {\n                for (var name in key) {\n                    if (key.hasOwnProperty(name)) {\n                        this.attrKV(name, key[name]);\n                    }\n                }\n            }\n            this.dirty();\n\n            return this;\n        },\n\n        /**\n         * @param {module:zrender/graphic/Path} clipPath\n         */\n        setClipPath: function (clipPath) {\n            var zr = this.__zr;\n            if (zr) {\n                clipPath.addSelfToZr(zr);\n            }\n\n            // Remove previous clip path\n            if (this.clipPath && this.clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n\n            this.clipPath = clipPath;\n            clipPath.__zr = zr;\n            clipPath.__clipTarget = this;\n\n            this.dirty();\n        },\n\n        /**\n         */\n        removeClipPath: function () {\n            var clipPath = this.clipPath;\n            if (clipPath) {\n                if (clipPath.__zr) {\n                    clipPath.removeSelfFromZr(clipPath.__zr);\n                }\n\n                clipPath.__zr = null;\n                clipPath.__clipTarget = null;\n                this.clipPath = null;\n\n                this.dirty();\n            }\n        },\n\n        /**\n         * Add self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        addSelfToZr: function (zr) {\n            this.__zr = zr;\n            // 添加动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.addSelfToZr(zr);\n            }\n        },\n\n        /**\n         * Remove self from zrender instance.\n         * Not recursively because it will be invoked when element added to storage.\n         * @param {module:zrender/ZRender} zr\n         */\n        removeSelfFromZr: function (zr) {\n            this.__zr = null;\n            // 移除动画\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n\n            if (this.clipPath) {\n                this.clipPath.removeSelfFromZr(zr);\n            }\n        }\n    };\n\n    zrUtil.mixin(Element, Animatable);\n    zrUtil.mixin(Element, Transformable);\n    zrUtil.mixin(Element, Eventful);\n\n    module.exports = Element;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Element.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\n\n\n    var matrix = require('../core/matrix');\n    var vector = require('../core/vector');\n    var mIdentity = matrix.identity;\n\n    var EPSILON = 5e-5;\n\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n\n    /**\n     * @alias module:zrender/mixin/Transformable\n     * @constructor\n     */\n    var Transformable = function (opts) {\n        opts = opts || {};\n        // If there are no given position, rotation, scale\n        if (!opts.position) {\n            /**\n             * 平移\n             * @type {Array.<number>}\n             * @default [0, 0]\n             */\n            this.position = [0, 0];\n        }\n        if (opts.rotation == null) {\n            /**\n             * 旋转\n             * @type {Array.<number>}\n             * @default 0\n             */\n            this.rotation = 0;\n        }\n        if (!opts.scale) {\n            /**\n             * 缩放\n             * @type {Array.<number>}\n             * @default [1, 1]\n             */\n            this.scale = [1, 1];\n        }\n        /**\n         * 旋转和缩放的原点\n         * @type {Array.<number>}\n         * @default null\n         */\n        this.origin = this.origin || null;\n    };\n\n    var transformableProto = Transformable.prototype;\n    transformableProto.transform = null;\n\n    /**\n     * 判断是否需要有坐标变换\n     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n     */\n    transformableProto.needLocalTransform = function () {\n        return isNotAroundZero(this.rotation)\n            || isNotAroundZero(this.position[0])\n            || isNotAroundZero(this.position[1])\n            || isNotAroundZero(this.scale[0] - 1)\n            || isNotAroundZero(this.scale[1] - 1);\n    };\n\n    transformableProto.updateTransform = function () {\n        var parent = this.parent;\n        var parentHasTransform = parent && parent.transform;\n        var needLocalTransform = this.needLocalTransform();\n\n        var m = this.transform;\n        if (!(needLocalTransform || parentHasTransform)) {\n            m && mIdentity(m);\n            return;\n        }\n\n        m = m || matrix.create();\n\n        if (needLocalTransform) {\n            this.getLocalTransform(m);\n        }\n        else {\n            mIdentity(m);\n        }\n\n        // 应用父节点变换\n        if (parentHasTransform) {\n            if (needLocalTransform) {\n                matrix.mul(m, parent.transform, m);\n            }\n            else {\n                matrix.copy(m, parent.transform);\n            }\n        }\n        // 保存这个变换矩阵\n        this.transform = m;\n\n        this.invTransform = this.invTransform || matrix.create();\n        matrix.invert(this.invTransform, m);\n    };\n\n    transformableProto.getLocalTransform = function (m) {\n        m = m || [];\n        mIdentity(m);\n\n        var origin = this.origin;\n\n        var scale = this.scale;\n        var rotation = this.rotation;\n        var position = this.position;\n        if (origin) {\n            // Translate to origin\n            m[4] -= origin[0];\n            m[5] -= origin[1];\n        }\n        matrix.scale(m, m, scale);\n        if (rotation) {\n            matrix.rotate(m, m, rotation);\n        }\n        if (origin) {\n            // Translate back from origin\n            m[4] += origin[0];\n            m[5] += origin[1];\n        }\n\n        m[4] += position[0];\n        m[5] += position[1];\n\n        return m;\n    };\n    /**\n     * 将自己的transform应用到context上\n     * @param {Context2D} ctx\n     */\n    transformableProto.setTransform = function (ctx) {\n        var m = this.transform;\n        if (m) {\n            ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n        }\n    };\n\n    var tmpTransform = [];\n\n    /**\n     * 分解`transform`矩阵到`position`, `rotation`, `scale`\n     */\n    transformableProto.decomposeTransform = function () {\n        if (!this.transform) {\n            return;\n        }\n        var parent = this.parent;\n        var m = this.transform;\n        if (parent && parent.transform) {\n            // Get local transform and decompose them to position, scale, rotation\n            matrix.mul(tmpTransform, parent.invTransform, m);\n            m = tmpTransform;\n        }\n        var sx = m[0] * m[0] + m[1] * m[1];\n        var sy = m[2] * m[2] + m[3] * m[3];\n        var position = this.position;\n        var scale = this.scale;\n        if (isNotAroundZero(sx - 1)) {\n            sx = Math.sqrt(sx);\n        }\n        if (isNotAroundZero(sy - 1)) {\n            sy = Math.sqrt(sy);\n        }\n        if (m[0] < 0) {\n            sx = -sx;\n        }\n        if (m[3] < 0) {\n            sy = -sy;\n        }\n        position[0] = m[4];\n        position[1] = m[5];\n        scale[0] = sx;\n        scale[1] = sy;\n        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n    };\n\n    /**\n     * 变换坐标位置到 shape 的局部坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToLocal = function (x, y) {\n        var v2 = [x, y];\n        var invTransform = this.invTransform;\n        if (invTransform) {\n            vector.applyTransform(v2, v2, invTransform);\n        }\n        return v2;\n    };\n\n    /**\n     * 变换局部坐标位置到全局坐标空间\n     * @method\n     * @param {number} x\n     * @param {number} y\n     * @return {Array.<number>}\n     */\n    transformableProto.transformCoordToGlobal = function (x, y) {\n        var v2 = [x, y];\n        var transform = this.transform;\n        if (transform) {\n            vector.applyTransform(v2, v2, transform);\n        }\n        return v2;\n    };\n\n    module.exports = Transformable;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Transformable.js\n ** module id = 16\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n    /**\n     * 3x2矩阵操作类\n     * @exports zrender/tool/matrix\n     */\n    var matrix = {\n        /**\n         * 创建一个单位矩阵\n         * @return {Float32Array|Array.<number>}\n         */\n        create : function() {\n            var out = new ArrayCtor(6);\n            matrix.identity(out);\n\n            return out;\n        },\n        /**\n         * 设置矩阵为单位矩阵\n         * @param {Float32Array|Array.<number>} out\n         */\n        identity : function(out) {\n            out[0] = 1;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            out[4] = 0;\n            out[5] = 0;\n            return out;\n        },\n        /**\n         * 复制矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m\n         */\n        copy: function(out, m) {\n            out[0] = m[0];\n            out[1] = m[1];\n            out[2] = m[2];\n            out[3] = m[3];\n            out[4] = m[4];\n            out[5] = m[5];\n            return out;\n        },\n        /**\n         * 矩阵相乘\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} m1\n         * @param {Float32Array|Array.<number>} m2\n         */\n        mul : function (out, m1, m2) {\n            // Consider matrix.mul(m, m2, m);\n            // where out is the same as m2.\n            // So use temp variable to escape error.\n            var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n            var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n            var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n            var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n            out[0] = out0;\n            out[1] = out1;\n            out[2] = out2;\n            out[3] = out3;\n            out[4] = out4;\n            out[5] = out5;\n            return out;\n        },\n        /**\n         * 平移变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        translate : function(out, a, v) {\n            out[0] = a[0];\n            out[1] = a[1];\n            out[2] = a[2];\n            out[3] = a[3];\n            out[4] = a[4] + v[0];\n            out[5] = a[5] + v[1];\n            return out;\n        },\n        /**\n         * 旋转变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {number} rad\n         */\n        rotate : function(out, a, rad) {\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n            var st = Math.sin(rad);\n            var ct = Math.cos(rad);\n\n            out[0] = aa * ct + ab * st;\n            out[1] = -aa * st + ab * ct;\n            out[2] = ac * ct + ad * st;\n            out[3] = -ac * st + ct * ad;\n            out[4] = ct * atx + st * aty;\n            out[5] = ct * aty - st * atx;\n            return out;\n        },\n        /**\n         * 缩放变换\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         * @param {Float32Array|Array.<number>} v\n         */\n        scale : function(out, a, v) {\n            var vx = v[0];\n            var vy = v[1];\n            out[0] = a[0] * vx;\n            out[1] = a[1] * vy;\n            out[2] = a[2] * vx;\n            out[3] = a[3] * vy;\n            out[4] = a[4] * vx;\n            out[5] = a[5] * vy;\n            return out;\n        },\n        /**\n         * 求逆矩阵\n         * @param {Float32Array|Array.<number>} out\n         * @param {Float32Array|Array.<number>} a\n         */\n        invert : function(out, a) {\n\n            var aa = a[0];\n            var ac = a[2];\n            var atx = a[4];\n            var ab = a[1];\n            var ad = a[3];\n            var aty = a[5];\n\n            var det = aa * ad - ab * ac;\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = ad * det;\n            out[1] = -ab * det;\n            out[2] = -ac * det;\n            out[3] = aa * det;\n            out[4] = (ac * aty - ad * atx) * det;\n            out[5] = (ab * atx - aa * aty) * det;\n            return out;\n        }\n    };\n\n    module.exports = matrix;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/matrix.js\n ** module id = 17\n ** module chunks = 0\n **/","\n    var ArrayCtor = typeof Float32Array === 'undefined'\n        ? Array\n        : Float32Array;\n\n    /**\n     * @typedef {Float32Array|Array.<number>} Vector2\n     */\n    /**\n     * 二维向量类\n     * @exports zrender/tool/vector\n     */\n    var vector = {\n        /**\n         * 创建一个向量\n         * @param {number} [x=0]\n         * @param {number} [y=0]\n         * @return {Vector2}\n         */\n        create: function (x, y) {\n            var out = new ArrayCtor(2);\n            out[0] = x || 0;\n            out[1] = y || 0;\n            return out;\n        },\n\n        /**\n         * 复制向量数据\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        copy: function (out, v) {\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 克隆一个向量\n         * @param {Vector2} v\n         * @return {Vector2}\n         */\n        clone: function (v) {\n            var out = new ArrayCtor(2);\n            out[0] = v[0];\n            out[1] = v[1];\n            return out;\n        },\n\n        /**\n         * 设置向量的两个项\n         * @param {Vector2} out\n         * @param {number} a\n         * @param {number} b\n         * @return {Vector2} 结果\n         */\n        set: function (out, a, b) {\n            out[0] = a;\n            out[1] = b;\n            return out;\n        },\n\n        /**\n         * 向量相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        add: function (out, v1, v2) {\n            out[0] = v1[0] + v2[0];\n            out[1] = v1[1] + v2[1];\n            return out;\n        },\n\n        /**\n         * 向量缩放后相加\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} a\n         */\n        scaleAndAdd: function (out, v1, v2, a) {\n            out[0] = v1[0] + v2[0] * a;\n            out[1] = v1[1] + v2[1] * a;\n            return out;\n        },\n\n        /**\n         * 向量相减\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        sub: function (out, v1, v2) {\n            out[0] = v1[0] - v2[0];\n            out[1] = v1[1] - v2[1];\n            return out;\n        },\n\n        /**\n         * 向量长度\n         * @param {Vector2} v\n         * @return {number}\n         */\n        len: function (v) {\n            return Math.sqrt(this.lenSquare(v));\n        },\n\n        /**\n         * 向量长度平方\n         * @param {Vector2} v\n         * @return {number}\n         */\n        lenSquare: function (v) {\n            return v[0] * v[0] + v[1] * v[1];\n        },\n\n        /**\n         * 向量乘法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        mul: function (out, v1, v2) {\n            out[0] = v1[0] * v2[0];\n            out[1] = v1[1] * v2[1];\n            return out;\n        },\n\n        /**\n         * 向量除法\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         */\n        div: function (out, v1, v2) {\n            out[0] = v1[0] / v2[0];\n            out[1] = v1[1] / v2[1];\n            return out;\n        },\n\n        /**\n         * 向量点乘\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        dot: function (v1, v2) {\n            return v1[0] * v2[0] + v1[1] * v2[1];\n        },\n\n        /**\n         * 向量缩放\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {number} s\n         */\n        scale: function (out, v, s) {\n            out[0] = v[0] * s;\n            out[1] = v[1] * s;\n            return out;\n        },\n\n        /**\n         * 向量归一化\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        normalize: function (out, v) {\n            var d = vector.len(v);\n            if (d === 0) {\n                out[0] = 0;\n                out[1] = 0;\n            }\n            else {\n                out[0] = v[0] / d;\n                out[1] = v[1] / d;\n            }\n            return out;\n        },\n\n        /**\n         * 计算向量间距离\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distance: function (v1, v2) {\n            return Math.sqrt(\n                (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1])\n            );\n        },\n\n        /**\n         * 向量距离平方\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @return {number}\n         */\n        distanceSquare: function (v1, v2) {\n            return (v1[0] - v2[0]) * (v1[0] - v2[0])\n                + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n        },\n\n        /**\n         * 求负向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         */\n        negate: function (out, v) {\n            out[0] = -v[0];\n            out[1] = -v[1];\n            return out;\n        },\n\n        /**\n         * 插值两个点\n         * @param {Vector2} out\n         * @param {Vector2} v1\n         * @param {Vector2} v2\n         * @param {number} t\n         */\n        lerp: function (out, v1, v2, t) {\n            out[0] = v1[0] + t * (v2[0] - v1[0]);\n            out[1] = v1[1] + t * (v2[1] - v1[1]);\n            return out;\n        },\n\n        /**\n         * 矩阵左乘向量\n         * @param {Vector2} out\n         * @param {Vector2} v\n         * @param {Vector2} m\n         */\n        applyTransform: function (out, v, m) {\n            var x = v[0];\n            var y = v[1];\n            out[0] = m[0] * x + m[2] * y + m[4];\n            out[1] = m[1] * x + m[3] * y + m[5];\n            return out;\n        },\n        /**\n         * 求两个向量最小值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        min: function (out, v1, v2) {\n            out[0] = Math.min(v1[0], v2[0]);\n            out[1] = Math.min(v1[1], v2[1]);\n            return out;\n        },\n        /**\n         * 求两个向量最大值\n         * @param  {Vector2} out\n         * @param  {Vector2} v1\n         * @param  {Vector2} v2\n         */\n        max: function (out, v1, v2) {\n            out[0] = Math.max(v1[0], v2[0]);\n            out[1] = Math.max(v1[1], v2[1]);\n            return out;\n        }\n    };\n\n    vector.length = vector.len;\n    vector.lengthSquare = vector.lenSquare;\n    vector.dist = vector.distance;\n    vector.distSquare = vector.distanceSquare;\n\n    module.exports = vector;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/vector.js\n ** module id = 18\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module zrender/mixin/Animatable\n */\n\n\n    var Animator = require('../animation/Animator');\n    var util = require('../core/util');\n    var isString = util.isString;\n    var isFunction = util.isFunction;\n    var isObject = util.isObject;\n    var log = require('../core/log');\n\n    /**\n     * @alias modue:zrender/mixin/Animatable\n     * @constructor\n     */\n    var Animatable = function () {\n\n        /**\n         * @type {Array.<module:zrender/animation/Animator>}\n         * @readOnly\n         */\n        this.animators = [];\n    };\n\n    Animatable.prototype = {\n\n        constructor: Animatable,\n\n        /**\n         * 动画\n         *\n         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性\n         * @param {boolean} [loop] 动画是否循环\n         * @return {module:zrender/animation/Animator}\n         * @example:\n         *     el.animate('style', false)\n         *         .when(1000, {x: 10} )\n         *         .done(function(){ // Animation done })\n         *         .start()\n         */\n        animate: function (path, loop) {\n            var target;\n            var animatingShape = false;\n            var el = this;\n            var zr = this.__zr;\n            if (path) {\n                var pathSplitted = path.split('.');\n                var prop = el;\n                // If animating shape\n                animatingShape = pathSplitted[0] === 'shape';\n                for (var i = 0, l = pathSplitted.length; i < l; i++) {\n                    if (!prop) {\n                        continue;\n                    }\n                    prop = prop[pathSplitted[i]];\n                }\n                if (prop) {\n                    target = prop;\n                }\n            }\n            else {\n                target = el;\n            }\n\n            if (!target) {\n                log(\n                    'Property \"'\n                    + path\n                    + '\" is not existed in element '\n                    + el.id\n                );\n                return;\n            }\n\n            var animators = el.animators;\n\n            var animator = new Animator(target, loop);\n\n            animator.during(function (target) {\n                el.dirty(animatingShape);\n            })\n            .done(function () {\n                // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n                animators.splice(util.indexOf(animators, animator), 1);\n            });\n\n            animators.push(animator);\n\n            // If animate after added to the zrender\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n\n            return animator;\n        },\n\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stopAnimation: function (forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            for (var i = 0; i < len; i++) {\n                animators[i].stop(forwardToLast);\n            }\n            animators.length = 0;\n\n            return this;\n        },\n\n        /**\n         * @param {Object} target\n         * @param {number} [time=500] Time in ms\n         * @param {string} [easing='linear']\n         * @param {number} [delay=0]\n         * @param {Function} [callback]\n         *\n         * @example\n         *  // Animate position\n         *  el.animateTo({\n         *      position: [10, 10]\n         *  }, function () { // done })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n         *  el.animateTo({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100, 'cubicOut', function () { // done })\n         */\n         // TODO Return animation key\n        animateTo: function (target, time, delay, easing, callback) {\n            // animateTo(target, time, easing, callback);\n            if (isString(delay)) {\n                callback = easing;\n                easing = delay;\n                delay = 0;\n            }\n            // animateTo(target, time, delay, callback);\n            else if (isFunction(easing)) {\n                callback = easing;\n                easing = 'linear';\n                delay = 0;\n            }\n            // animateTo(target, time, callback);\n            else if (isFunction(delay)) {\n                callback = delay;\n                delay = 0;\n            }\n            // animateTo(target, callback)\n            else if (isFunction(time)) {\n                callback = time;\n                time = 500;\n            }\n            // animateTo(target)\n            else if (!time) {\n                time = 500;\n            }\n            // Stop all previous animations\n            this.stopAnimation();\n            this._animateToShallow('', this, target, time, delay, easing, callback);\n\n            // Animators may be removed immediately after start\n            // if there is nothing to animate\n            var animators = this.animators.slice();\n            var count = animators.length;\n            function done() {\n                count--;\n                if (!count) {\n                    callback && callback();\n                }\n            }\n\n            // No animators. This should be checked before animators[i].start(),\n            // because 'done' may be executed immediately if no need to animate.\n            if (!count) {\n                callback && callback();\n            }\n            // Start after all animators created\n            // Incase any animator is done immediately when all animation properties are not changed\n            for (var i = 0; i < animators.length; i++) {\n                animators[i]\n                    .done(done)\n                    .start(easing);\n            }\n        },\n\n        /**\n         * @private\n         * @param {string} path=''\n         * @param {Object} source=this\n         * @param {Object} target\n         * @param {number} [time=500]\n         * @param {number} [delay=0]\n         *\n         * @example\n         *  // Animate position\n         *  el._animateToShallow({\n         *      position: [10, 10]\n         *  })\n         *\n         *  // Animate shape, style and position in 100ms, delayed 100ms\n         *  el._animateToShallow({\n         *      shape: {\n         *          width: 500\n         *      },\n         *      style: {\n         *          fill: 'red'\n         *      }\n         *      position: [10, 10]\n         *  }, 100, 100)\n         */\n        _animateToShallow: function (path, source, target, time, delay) {\n            var objShallow = {};\n            var propertyCount = 0;\n            for (var name in target) {\n                if (source[name] != null) {\n                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {\n                        this._animateToShallow(\n                            path ? path + '.' + name : name,\n                            source[name],\n                            target[name],\n                            time,\n                            delay\n                        );\n                    }\n                    else {\n                        objShallow[name] = target[name];\n                        propertyCount++;\n                    }\n                }\n                else if (target[name] != null) {\n                    // Attr directly if not has property\n                    // FIXME, if some property not needed for element ?\n                    if (!path) {\n                        this.attr(name, target[name]);\n                    }\n                    else {  // Shape or style\n                        var props = {};\n                        props[path] = {};\n                        props[path][name] = target[name];\n                        this.attr(props);\n                    }\n                }\n            }\n\n            if (propertyCount > 0) {\n                this.animate(path, false)\n                    .when(time == null ? 500 : time, objShallow)\n                    .delay(delay || 0);\n            }\n\n            return this;\n        }\n    };\n\n    module.exports = Animatable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/mixin/Animatable.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * @module echarts/animation/Animator\n */\n\n\n    var Clip = require('./Clip');\n    var color = require('../tool/color');\n    var util = require('../core/util');\n    var isArrayLike = util.isArrayLike;\n\n    var arraySlice = Array.prototype.slice;\n\n    function defaultGetter(target, key) {\n        return target[key];\n    }\n\n    function defaultSetter(target, key, value) {\n        target[key] = value;\n    }\n\n    /**\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} percent\n     * @return {number}\n     */\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n\n    /**\n     * @param  {string} p0\n     * @param  {string} p1\n     * @param  {number} percent\n     * @return {string}\n     */\n    function interpolateString(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n\n    /**\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {number} percent\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function interpolateArray(p0, p1, percent, out, arrDim) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = interpolateNumber(p0[i], p1[i], percent);\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = interpolateNumber(\n                        p0[i][j], p1[i][j], percent\n                    );\n                }\n            }\n        }\n    }\n\n    function fillArr(arr0, arr1, arrDim) {\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len === arr1Len) {\n            return;\n        }\n        // FIXME Not work for TypedArray\n        var isPreviousLarger = arr0Len > arr1Len;\n        if (isPreviousLarger) {\n            // Cut the previous\n            arr0.length = arr1Len;\n        }\n        else {\n            // Fill the previous\n            for (var i = arr0Len; i < arr1Len; i++) {\n                arr0.push(\n                    arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])\n                );\n            }\n        }\n    }\n\n    /**\n     * @param  {Array} arr0\n     * @param  {Array} arr1\n     * @param  {number} arrDim\n     * @return {boolean}\n     */\n    function isArraySame(arr0, arr1, arrDim) {\n        if (arr0 === arr1) {\n            return true;\n        }\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        if (arrDim === 1) {\n            for (var i = 0; i < len; i++) {\n                if (arr0[i] !== arr1[i]) {\n                    return false;\n                }\n            }\n        }\n        else {\n            var len2 = arr0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    if (arr0[i][j] !== arr1[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Catmull Rom interpolate array\n     * @param  {Array} p0\n     * @param  {Array} p1\n     * @param  {Array} p2\n     * @param  {Array} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @param  {Array} out\n     * @param  {number} arrDim\n     */\n    function catmullRomInterpolateArray(\n        p0, p1, p2, p3, t, t2, t3, out, arrDim\n    ) {\n        var len = p0.length;\n        if (arrDim == 1) {\n            for (var i = 0; i < len; i++) {\n                out[i] = catmullRomInterpolate(\n                    p0[i], p1[i], p2[i], p3[i], t, t2, t3\n                );\n            }\n        }\n        else {\n            var len2 = p0[0].length;\n            for (var i = 0; i < len; i++) {\n                for (var j = 0; j < len2; j++) {\n                    out[i][j] = catmullRomInterpolate(\n                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],\n                        t, t2, t3\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Catmull Rom interpolate number\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {number} t2\n     * @param  {number} t3\n     * @return {number}\n     */\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n\n            return arraySlice.call(value);\n        }\n\n        return value;\n    }\n\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n\n    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {\n        var getter = animator._getter;\n        var setter = animator._setter;\n        var useSpline = easing === 'spline';\n\n        var trackLen = keyframes.length;\n        if (!trackLen) {\n            return;\n        }\n        // Guess data type\n        var firstVal = keyframes[0].value;\n        var isValueArray = isArrayLike(firstVal);\n        var isValueColor = false;\n        var isValueString = false;\n\n        // For vertices morphing\n        var arrDim = (\n                isValueArray\n                && isArrayLike(firstVal[0])\n            )\n            ? 2 : 1;\n        var trackMaxTime;\n        // Sort keyframe as ascending\n        keyframes.sort(function(a, b) {\n            return a.time - b.time;\n        });\n\n        trackMaxTime = keyframes[trackLen - 1].time;\n        // Percents of each keyframe\n        var kfPercents = [];\n        // Value of each keyframe\n        var kfValues = [];\n        var prevValue = keyframes[0].value;\n        var isAllValueEqual = true;\n        for (var i = 0; i < trackLen; i++) {\n            kfPercents.push(keyframes[i].time / trackMaxTime);\n            // Assume value is a color when it is a string\n            var value = keyframes[i].value;\n\n            // Check if value is equal, deep check if value is array\n            if (!((isValueArray && isArraySame(value, prevValue, arrDim))\n                || (!isValueArray && value === prevValue))) {\n                isAllValueEqual = false;\n            }\n            prevValue = value;\n\n            // Try converting a string to a color array\n            if (typeof value == 'string') {\n                var colorArray = color.parse(value);\n                if (colorArray) {\n                    value = colorArray;\n                    isValueColor = true;\n                }\n                else {\n                    isValueString = true;\n                }\n            }\n            kfValues.push(value);\n        }\n        if (isAllValueEqual) {\n            return;\n        }\n\n        if (isValueArray) {\n            var lastValue = kfValues[trackLen - 1];\n            // Polyfill array\n            for (var i = 0; i < trackLen - 1; i++) {\n                fillArr(kfValues[i], lastValue, arrDim);\n            }\n            fillArr(getter(animator._target, propName), lastValue, arrDim);\n        }\n\n        // Cache the key of last frame to speed up when\n        // animation playback is sequency\n        var lastFrame = 0;\n        var lastFramePercent = 0;\n        var start;\n        var w;\n        var p0;\n        var p1;\n        var p2;\n        var p3;\n\n        if (isValueColor) {\n            var rgba = [0, 0, 0, 0];\n        }\n\n        var onframe = function (target, percent) {\n            // Find the range keyframes\n            // kf1-----kf2---------current--------kf3\n            // find kf2 and kf3 and do interpolation\n            var frame;\n            if (percent < lastFramePercent) {\n                // Start from next key\n                start = Math.min(lastFrame + 1, trackLen - 1);\n                for (frame = start; frame >= 0; frame--) {\n                    if (kfPercents[frame] <= percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame, trackLen - 2);\n            }\n            else {\n                for (frame = lastFrame; frame < trackLen; frame++) {\n                    if (kfPercents[frame] > percent) {\n                        break;\n                    }\n                }\n                frame = Math.min(frame - 1, trackLen - 2);\n            }\n            lastFrame = frame;\n            lastFramePercent = percent;\n\n            var range = (kfPercents[frame + 1] - kfPercents[frame]);\n            if (range === 0) {\n                return;\n            }\n            else {\n                w = (percent - kfPercents[frame]) / range;\n            }\n            if (useSpline) {\n                p1 = kfValues[frame];\n                p0 = kfValues[frame === 0 ? frame : frame - 1];\n                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n                if (isValueArray) {\n                    catmullRomInterpolateArray(\n                        p0, p1, p2, p3, w, w * w, w * w * w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        value = catmullRomInterpolateArray(\n                            p0, p1, p2, p3, w, w * w, w * w * w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(p1, p2, w);\n                    }\n                    else {\n                        value = catmullRomInterpolate(\n                            p0, p1, p2, p3, w, w * w, w * w * w\n                        );\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n            else {\n                if (isValueArray) {\n                    interpolateArray(\n                        kfValues[frame], kfValues[frame + 1], w,\n                        getter(target, propName),\n                        arrDim\n                    );\n                }\n                else {\n                    var value;\n                    if (isValueColor) {\n                        interpolateArray(\n                            kfValues[frame], kfValues[frame + 1], w,\n                            rgba, 1\n                        );\n                        value = rgba2String(rgba);\n                    }\n                    else if (isValueString) {\n                        // String is step(0.5)\n                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    else {\n                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n                    }\n                    setter(\n                        target,\n                        propName,\n                        value\n                    );\n                }\n            }\n        };\n\n        var clip = new Clip({\n            target: animator._target,\n            life: trackMaxTime,\n            loop: animator._loop,\n            delay: animator._delay,\n            onframe: onframe,\n            ondestroy: oneTrackDone\n        });\n\n        if (easing && easing !== 'spline') {\n            clip.easing = easing;\n        }\n\n        return clip;\n    }\n\n    /**\n     * @alias module:zrender/animation/Animator\n     * @constructor\n     * @param {Object} target\n     * @param {boolean} loop\n     * @param {Function} getter\n     * @param {Function} setter\n     */\n    var Animator = function(target, loop, getter, setter) {\n        this._tracks = {};\n        this._target = target;\n\n        this._loop = loop || false;\n\n        this._getter = getter || defaultGetter;\n        this._setter = setter || defaultSetter;\n\n        this._clipCount = 0;\n\n        this._delay = 0;\n\n        this._doneList = [];\n\n        this._onframeList = [];\n\n        this._clipList = [];\n    };\n\n    Animator.prototype = {\n        /**\n         * 设置动画关键帧\n         * @param  {number} time 关键帧时间，单位是ms\n         * @param  {Object} props 关键帧的属性值，key-value表示\n         * @return {module:zrender/animation/Animator}\n         */\n        when: function(time /* ms */, props) {\n            var tracks = this._tracks;\n            for (var propName in props) {\n                if (!tracks[propName]) {\n                    tracks[propName] = [];\n                    // Invalid value\n                    var value = this._getter(this._target, propName);\n                    if (value == null) {\n                        // zrLog('Invalid property ' + propName);\n                        continue;\n                    }\n                    // If time is 0\n                    //  Then props is given initialize value\n                    // Else\n                    //  Initialize value from current prop value\n                    if (time !== 0) {\n                        tracks[propName].push({\n                            time: 0,\n                            value: cloneValue(value)\n                        });\n                    }\n                }\n                tracks[propName].push({\n                    time: time,\n                    value: props[propName]\n                });\n            }\n            return this;\n        },\n        /**\n         * 添加动画每一帧的回调函数\n         * @param  {Function} callback\n         * @return {module:zrender/animation/Animator}\n         */\n        during: function (callback) {\n            this._onframeList.push(callback);\n            return this;\n        },\n\n        _doneCallback: function () {\n            // Clear all tracks\n            this._tracks = {};\n            // Clear all clips\n            this._clipList.length = 0;\n\n            var doneList = this._doneList;\n            var len = doneList.length;\n            for (var i = 0; i < len; i++) {\n                doneList[i].call(this);\n            }\n        },\n        /**\n         * 开始执行动画\n         * @param  {string|Function} easing\n         *         动画缓动函数，详见{@link module:zrender/animation/easing}\n         * @return {module:zrender/animation/Animator}\n         */\n        start: function (easing) {\n\n            var self = this;\n            var clipCount = 0;\n\n            var oneTrackDone = function() {\n                clipCount--;\n                if (!clipCount) {\n                    self._doneCallback();\n                }\n            };\n\n            var lastClip;\n            for (var propName in this._tracks) {\n                var clip = createTrackClip(\n                    this, easing, oneTrackDone,\n                    this._tracks[propName], propName\n                );\n                if (clip) {\n                    this._clipList.push(clip);\n                    clipCount++;\n\n                    // If start after added to animation\n                    if (this.animation) {\n                        this.animation.addClip(clip);\n                    }\n\n                    lastClip = clip;\n                }\n            }\n\n            // Add during callback on the last clip\n            if (lastClip) {\n                var oldOnFrame = lastClip.onframe;\n                lastClip.onframe = function (target, percent) {\n                    oldOnFrame(target, percent);\n\n                    for (var i = 0; i < self._onframeList.length; i++) {\n                        self._onframeList[i](target, percent);\n                    }\n                };\n            }\n\n            if (!clipCount) {\n                this._doneCallback();\n            }\n            return this;\n        },\n        /**\n         * 停止动画\n         * @param {boolean} forwardToLast If move to last frame before stop\n         */\n        stop: function (forwardToLast) {\n            var clipList = this._clipList;\n            var animation = this.animation;\n            for (var i = 0; i < clipList.length; i++) {\n                var clip = clipList[i];\n                if (forwardToLast) {\n                    // Move to last frame before stop\n                    clip.onframe(this._target, 1);\n                }\n                animation && animation.removeClip(clip);\n            }\n            clipList.length = 0;\n        },\n        /**\n         * 设置动画延迟开始的时间\n         * @param  {number} time 单位ms\n         * @return {module:zrender/animation/Animator}\n         */\n        delay: function (time) {\n            this._delay = time;\n            return this;\n        },\n        /**\n         * 添加动画结束的回调\n         * @param  {Function} cb\n         * @return {module:zrender/animation/Animator}\n         */\n        done: function(cb) {\n            if (cb) {\n                this._doneList.push(cb);\n            }\n            return this;\n        },\n\n        /**\n         * @return {Array.<module:zrender/animation/Clip>}\n         */\n        getClips: function () {\n            return this._clipList;\n        }\n    };\n\n    module.exports = Animator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animator.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\n\n\n    var easingFuncs = require('./easing');\n\n    function Clip(options) {\n\n        this._target = options.target;\n\n        // 生命周期\n        this._life = options.life || 1000;\n        // 延时\n        this._delay = options.delay || 0;\n        // 开始时间\n        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n        this._initialized = false;\n\n        // 是否循环\n        this.loop = options.loop == null ? false : options.loop;\n\n        this.gap = options.gap || 0;\n\n        this.easing = options.easing || 'Linear';\n\n        this.onframe = options.onframe;\n        this.ondestroy = options.ondestroy;\n        this.onrestart = options.onrestart;\n    }\n\n    Clip.prototype = {\n\n        constructor: Clip,\n\n        step: function (time) {\n            // Set startTime on first step, or _startTime may has milleseconds different between clips\n            // PENDING\n            if (!this._initialized) {\n                this._startTime = new Date().getTime() + this._delay;\n                this._initialized = true;\n            }\n\n            var percent = (time - this._startTime) / this._life;\n\n            // 还没开始\n            if (percent < 0) {\n                return;\n            }\n\n            percent = Math.min(percent, 1);\n\n            var easing = this.easing;\n            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n\n            this.fire('frame', schedule);\n\n            // 结束\n            if (percent == 1) {\n                if (this.loop) {\n                    this.restart();\n                    // 重新开始周期\n                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n                    return 'restart';\n                }\n\n                // 动画完成将这个控制器标识为待删除\n                // 在Animation.update中进行批量删除\n                this._needsRemove = true;\n                return 'destroy';\n            }\n\n            return null;\n        },\n\n        restart: function() {\n            var time = new Date().getTime();\n            var remainder = (time - this._startTime) % this._life;\n            this._startTime = new Date().getTime() - remainder + this.gap;\n\n            this._needsRemove = false;\n        },\n\n        fire: function(eventType, arg) {\n            eventType = 'on' + eventType;\n            if (this[eventType]) {\n                this[eventType](this._target, arg);\n            }\n        }\n    };\n\n    module.exports = Clip;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Clip.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\n\n    var easing = {\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        linear: function (k) {\n            return k;\n        },\n\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n\n        // 三次方的缓动（t^3）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n\n        // 四次方的缓动（t^4）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n\n        // 五次方的缓动（t^5）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n\n        // 正弦曲线的缓动（sin(t)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n\n        // 指数曲线的缓动（2^t）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n\n        // 圆形曲线的缓动（sqrt(1-t^2)）\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n\n        // 创建类似于弹簧在停止前来回振荡的动画\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1)) *\n                        Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k) *\n                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1; s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n\n        },\n\n        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n\n        // 创建弹跳效果\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        /**\n        * @param {number} k\n        * @return {number}\n        */\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    module.exports = easing;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/easing.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * @module zrender/tool/color\n */\n\n\n    var kCSSColorTable = {\n        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],\n        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],\n        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],\n        'beige': [245,245,220,1], 'bisque': [255,228,196,1],\n        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],\n        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],\n        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],\n        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],\n        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],\n        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],\n        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],\n        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],\n        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],\n        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],\n        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],\n        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],\n        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],\n        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],\n        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],\n        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],\n        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],\n        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],\n        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],\n        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],\n        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],\n        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],\n        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],\n        'gray': [128,128,128,1], 'green': [0,128,0,1],\n        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],\n        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],\n        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],\n        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],\n        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],\n        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],\n        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],\n        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],\n        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],\n        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],\n        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],\n        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],\n        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],\n        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],\n        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],\n        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],\n        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],\n        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],\n        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],\n        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],\n        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],\n        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],\n        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],\n        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],\n        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],\n        'orange': [255,165,0,1], 'orangered': [255,69,0,1],\n        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],\n        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],\n        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],\n        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],\n        'pink': [255,192,203,1], 'plum': [221,160,221,1],\n        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],\n        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],\n        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],\n        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],\n        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],\n        'sienna': [160,82,45,1], 'silver': [192,192,192,1],\n        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],\n        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],\n        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],\n        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],\n        'teal': [0,128,128,1], 'thistle': [216,191,216,1],\n        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],\n        'violet': [238,130,238,1], 'wheat': [245,222,179,1],\n        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],\n        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]\n    };\n\n    function clampCssByte(i) {  // Clamp to integer 0 .. 255.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n\n    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.\n        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n\n    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n\n    function parseCssInt(str) {  // int or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n\n    function parseCssFloat(str) {  // float or percentage.\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2/3 - h) * 6;\n        }\n        return m1;\n    }\n\n    function lerp(a, b, p) {\n        return a + (b - a) * p;\n    }\n\n    /**\n     * @param {string} colorStr\n     * @return {Array.<number>}\n     * @memberOf module:zrender/util/color\n     */\n    function parse(colorStr) {\n        if (!colorStr) {\n            return;\n        }\n        // colorStr may be not string\n        colorStr = colorStr + '';\n        // Remove all whitespace, not compliant, but should just be more accepting.\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n\n        // Color keywords (and transparent) lookup.\n        if (str in kCSSColorTable) {\n            return kCSSColorTable[str].slice();  // dup.\n        }\n\n        // #abc and #abc123 syntax.\n        if (str.charAt(0) === '#') {\n            if (str.length === 4) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n                    (iv & 0xf0) | ((iv & 0xf0) >> 4),\n                    (iv & 0xf) | ((iv & 0xf) << 4),\n                    1\n                ];\n            }\n            else if (str.length === 7) {\n                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    return;  // Covers NaN.\n                }\n                return [\n                    (iv & 0xff0000) >> 16,\n                    (iv & 0xff00) >> 8,\n                    iv & 0xff,\n                    1\n                ];\n            }\n\n            return;\n        }\n        var op = str.indexOf('('), ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === str.length) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;  // To allow case fallthrough.\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    alpha = parseCssFloat(params.pop()); // jshint ignore:line\n                // Fall through.\n                case 'rgb':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return [\n                        parseCssInt(params[0]),\n                        parseCssInt(params[1]),\n                        parseCssInt(params[2]),\n                        alpha\n                    ];\n                case 'hsla':\n                    if (params.length !== 4) {\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    return hsla2rgba(params);\n                case 'hsl':\n                    if (params.length !== 3) {\n                        return;\n                    }\n                    return hsla2rgba(params);\n                default:\n                    return;\n            }\n        }\n\n        return;\n    }\n\n    /**\n     * @param {Array.<number>} hsla\n     * @return {Array.<number>} rgba\n     */\n    function hsla2rgba(hsla) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n\n        var rgba = [\n            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h) * 255),\n            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)\n        ];\n\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n\n        return rgba;\n    }\n\n    /**\n     * @param {Array.<number>} rgba\n     * @return {Array.<number>} hsla\n     */\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n\n        // RGB from 0 to 255\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n\n        var vMin = Math.min(R, G, B); // Min. value of RGB\n        var vMax = Math.max(R, G, B); // Max. value of RGB\n        var delta = vMax - vMin; // Delta RGB value\n\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        // HSL results from 0 to 1\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n\n            if (H < 0) {\n                H += 1;\n            }\n\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n\n        var hsla = [H * 360, S, L];\n\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n\n        return hsla;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number} level\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @return {string}\n     * @memberOf module:zrender/util/color\n     */\n    function toHex(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n\n    /**\n     * Map value to color. Faster than mapToColor methods because color is represented by rgba array\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<Array.<number>>} colors List of rgba color array\n     * @param {Array.<number>} [out] Mapped gba color array\n     * @return {Array.<number>}\n     */\n    function fastMapToColor(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n        out = out || [0, 0, 0, 0];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    /**\n     * @param {number} normalizedValue A float between 0 and 1.\n     * @param {Array.<string>} colors Color list.\n     * @param {boolean=} fullOutput Default false.\n     * @return {(string|Object)} Result color. If fullOutput,\n     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n     * @memberOf module:zrender/util/color\n     */\n    function mapToColor(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)\n        ) {\n            return;\n        }\n\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n\n        var color = stringify(\n            [\n                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),\n                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),\n                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),\n                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))\n            ],\n            'rgba'\n        );\n\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n\n    /**\n     * @param {Array<number>} interval  Array length === 2,\n     *                                  each item is normalized value ([0, 1]).\n     * @param {Array.<string>} colors Color list.\n     * @return {Array.<Object>} colors corresponding to the interval,\n     *                          each item is {color: 'xxx', offset: ...}\n     *                          where offset is between 0 and 1.\n     * @memberOf module:zrender/util/color\n     */\n    function mapIntervalToColor(interval, colors) {\n        if (interval.length !== 2 || interval[1] < interval[0]) {\n            return;\n        }\n\n        var info0 = mapToColor(interval[0], colors, true);\n        var info1 = mapToColor(interval[1], colors, true);\n\n        var result = [{color: info0.color, offset: 0}];\n\n        var during = info1.value - info0.value;\n        var start = Math.max(info0.value, info0.rightIndex);\n        var end = Math.min(info1.value, info1.leftIndex);\n\n        for (var i = start; during > 0 && i <= end; i++) {\n            result.push({\n                color: colors[i],\n                offset: (i - info0.value) / during\n            });\n        }\n        result.push({color: info1.color, offset: 1});\n\n        return result;\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} h 0 ~ 360, ignore when null.\n     * @param {number=} s 0 ~ 1, ignore when null.\n     * @param {number=} l 0 ~ 1, ignore when null.\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyHSL(color, h, s, l) {\n        color = parse(color);\n\n        if (color) {\n            color = rgba2hsla(color);\n            h != null && (color[0] = clampCssAngle(h));\n            s != null && (color[1] = parseCssFloat(s));\n            l != null && (color[2] = parseCssFloat(l));\n\n            return stringify(hsla2rgba(color), 'rgba');\n        }\n    }\n\n    /**\n     * @param {string} color\n     * @param {number=} alpha 0 ~ 1\n     * @return {string} Color string in rgba format.\n     * @memberOf module:zrender/util/color\n     */\n    function modifyAlpha(color, alpha) {\n        color = parse(color);\n\n        if (color && alpha != null) {\n            color[3] = clampCssFloat(alpha);\n            return stringify(color, 'rgba');\n        }\n    }\n\n    /**\n     * @param {Array.<string>} colors Color list.\n     * @param {string} type 'rgba', 'hsva', ...\n     * @return {string} Result color.\n     */\n    function stringify(arrColor, type) {\n        if (type === 'rgb' || type === 'hsv' || type === 'hsl') {\n            arrColor = arrColor.slice(0, 3);\n        }\n        return type + '(' + arrColor.join(',') + ')';\n    }\n\n    module.exports = {\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastMapToColor: fastMapToColor,\n        mapToColor: mapToColor,\n        mapIntervalToColor: mapIntervalToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify\n    };\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/color.js\n ** module id = 23\n ** module chunks = 0\n **/","\n        var config = require('../config');\n\n        /**\n         * @exports zrender/tool/log\n         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n         */\n        module.exports = function() {\n            if (config.debugMode === 0) {\n                return;\n            }\n            else if (config.debugMode == 1) {\n                for (var k in arguments) {\n                    throw new Error(arguments[k]);\n                }\n            }\n            else if (config.debugMode > 1) {\n                for (var k in arguments) {\n                    console.log(arguments[k]);\n                }\n            }\n        };\n\n        /* for debug\n        return function(mes) {\n            document.getElementById('wrong-message').innerHTML =\n                mes + ' ' + (new Date() - 0)\n                + '<br/>' \n                + document.getElementById('wrong-message').innerHTML;\n        };\n        */\n    \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/log.js\n ** module id = 24\n ** module chunks = 0\n **/","\n    var dpr = 1;\n    // If in browser environment\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio || 1, 1);\n    }\n    /**\n     * config默认配置项\n     * @exports zrender/config\n     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n     */\n    var config = {\n        /**\n         * debug日志选项：catchBrushException为true下有效\n         * 0 : 不生成debug数据，发布用\n         * 1 : 异常抛出，调试用\n         * 2 : 控制台输出，调试用\n         */\n        debugMode: 0,\n\n        // retina 屏幕优化\n        devicePixelRatio: dpr\n    };\n    module.exports = config;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/config.js\n ** module id = 25\n ** module chunks = 0\n **/","'use strict';\n/**\n * @module echarts/core/BoundingRect\n */\n\n\n    var vec2 = require('./vector');\n    var matrix = require('./matrix');\n\n    var v2ApplyTransform = vec2.applyTransform;\n    var mathMin = Math.min;\n    var mathAbs = Math.abs;\n    var mathMax = Math.max;\n    /**\n     * @alias module:echarts/core/BoundingRect\n     */\n    function BoundingRect(x, y, width, height) {\n        /**\n         * @type {number}\n         */\n        this.x = x;\n        /**\n         * @type {number}\n         */\n        this.y = y;\n        /**\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * @type {number}\n         */\n        this.height = height;\n    }\n\n    BoundingRect.prototype = {\n\n        constructor: BoundingRect,\n\n        /**\n         * @param {module:echarts/core/BoundingRect} other\n         */\n        union: function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n\n            this.width = mathMax(\n                    other.x + other.width,\n                    this.x + this.width\n                ) - x;\n            this.height = mathMax(\n                    other.y + other.height,\n                    this.y + this.height\n                ) - y;\n            this.x = x;\n            this.y = y;\n        },\n\n        /**\n         * @param {Array.<number>} m\n         * @methods\n         */\n        applyTransform: (function () {\n            var min = [];\n            var max = [];\n            return function (m) {\n                // In case usage like this\n                // el.getBoundingRect().applyTransform(el.transform)\n                // And element has no transform\n                if (!m) {\n                    return;\n                }\n                min[0] = this.x;\n                min[1] = this.y;\n                max[0] = this.x + this.width;\n                max[1] = this.y + this.height;\n\n                v2ApplyTransform(min, min, m);\n                v2ApplyTransform(max, max, m);\n\n                this.x = mathMin(min[0], max[0]);\n                this.y = mathMin(min[1], max[1]);\n                this.width = mathAbs(max[0] - min[0]);\n                this.height = mathAbs(max[1] - min[1]);\n            };\n        })(),\n\n        /**\n         * Calculate matrix of transforming from self to target rect\n         * @param  {module:zrender/core/BoundingRect} b\n         * @return {Array.<number>}\n         */\n        calculateTransform: function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n\n            var m = matrix.create();\n\n            // 矩阵右乘\n            matrix.translate(m, m, [-a.x, -a.y]);\n            matrix.scale(m, m, [sx, sy]);\n            matrix.translate(m, m, [b.x, b.y]);\n\n            return m;\n        },\n\n        /**\n         * @param {(module:echarts/core/BoundingRect|Object)} b\n         * @return {boolean}\n         */\n        intersect: function (b) {\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n\n            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        },\n\n        contain: function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        },\n\n        /**\n         * @return {module:echarts/core/BoundingRect}\n         */\n        clone: function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        },\n\n        /**\n         * Copy from another rect\n         */\n        copy: function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            this.width = other.width;\n            this.height = other.height;\n        }\n    };\n\n    module.exports = BoundingRect;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/BoundingRect.js\n ** module id = 26\n ** module chunks = 0\n **/","'use strict';\n/**\n * 动画主类, 调度和管理所有动画控制器\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n\n    var util = require('../core/util');\n    var Dispatcher = require('../core/event').Dispatcher;\n\n    var requestAnimationFrame = (typeof window !== 'undefined' &&\n                                    (window.requestAnimationFrame\n                                    || window.msRequestAnimationFrame\n                                    || window.mozRequestAnimationFrame\n                                    || window.webkitRequestAnimationFrame))\n                                || function (func) {\n                                    setTimeout(func, 16);\n                                };\n\n    var Animator = require('./Animator');\n    /**\n     * @typedef {Object} IZRenderStage\n     * @property {Function} update\n     */\n\n    /**\n     * @alias module:zrender/animation/Animation\n     * @constructor\n     * @param {Object} [options]\n     * @param {Function} [options.onframe]\n     * @param {IZRenderStage} [options.stage]\n     * @example\n     *     var animation = new Animation();\n     *     var obj = {\n     *         x: 100,\n     *         y: 100\n     *     };\n     *     animation.animate(node.position)\n     *         .when(1000, {\n     *             x: 500,\n     *             y: 500\n     *         })\n     *         .when(2000, {\n     *             x: 100,\n     *             y: 100\n     *         })\n     *         .start('spline');\n     */\n    var Animation = function (options) {\n\n        options = options || {};\n\n        this.stage = options.stage || {};\n\n        this.onframe = options.onframe || function() {};\n\n        // private properties\n        this._clips = [];\n\n        this._running = false;\n\n        this._time = 0;\n\n        Dispatcher.call(this);\n    };\n\n    Animation.prototype = {\n\n        constructor: Animation,\n        /**\n         * 添加 clip\n         * @param {module:zrender/animation/Clip} clip\n         */\n        addClip: function (clip) {\n            this._clips.push(clip);\n        },\n        /**\n         * 添加 animator\n         * @param {module:zrender/animation/Animator} animator\n         */\n        addAnimator: function (animator) {\n            animator.animation = this;\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.addClip(clips[i]);\n            }\n        },\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Clip} clip\n         */\n        removeClip: function(clip) {\n            var idx = util.indexOf(this._clips, clip);\n            if (idx >= 0) {\n                this._clips.splice(idx, 1);\n            }\n        },\n\n        /**\n         * 删除动画片段\n         * @param {module:zrender/animation/Animator} animator\n         */\n        removeAnimator: function (animator) {\n            var clips = animator.getClips();\n            for (var i = 0; i < clips.length; i++) {\n                this.removeClip(clips[i]);\n            }\n            animator.animation = null;\n        },\n\n        _update: function() {\n\n            var time = new Date().getTime();\n            var delta = time - this._time;\n            var clips = this._clips;\n            var len = clips.length;\n\n            var deferredEvents = [];\n            var deferredClips = [];\n            for (var i = 0; i < len; i++) {\n                var clip = clips[i];\n                var e = clip.step(time);\n                // Throw out the events need to be called after\n                // stage.update, like destroy\n                if (e) {\n                    deferredEvents.push(e);\n                    deferredClips.push(clip);\n                }\n            }\n\n            // Remove the finished clip\n            for (var i = 0; i < len;) {\n                if (clips[i]._needsRemove) {\n                    clips[i] = clips[len - 1];\n                    clips.pop();\n                    len--;\n                }\n                else {\n                    i++;\n                }\n            }\n\n            len = deferredEvents.length;\n            for (var i = 0; i < len; i++) {\n                deferredClips[i].fire(deferredEvents[i]);\n            }\n\n            this._time = time;\n\n            this.onframe(delta);\n\n            this.trigger('frame', delta);\n\n            if (this.stage.update) {\n                this.stage.update();\n            }\n        },\n        /**\n         * 开始运行动画\n         */\n        start: function () {\n            var self = this;\n\n            this._running = true;\n\n            function step() {\n                if (self._running) {\n\n                    requestAnimationFrame(step);\n\n                    self._update();\n                }\n            }\n\n            this._time = new Date().getTime();\n            requestAnimationFrame(step);\n        },\n        /**\n         * 停止运行动画\n         */\n        stop: function () {\n            this._running = false;\n        },\n        /**\n         * 清除所有动画片段\n         */\n        clear: function () {\n            this._clips = [];\n        },\n        /**\n         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画\n         * @param  {Object} target\n         * @param  {Object} options\n         * @param  {boolean} [options.loop=false] 是否循环播放动画\n         * @param  {Function} [options.getter=null]\n         *         如果指定getter函数，会通过getter函数取属性值\n         * @param  {Function} [options.setter=null]\n         *         如果指定setter函数，会通过setter函数设置属性值\n         * @return {module:zrender/animation/Animation~Animator}\n         */\n        animate: function (target, options) {\n            options = options || {};\n            var animator = new Animator(\n                target,\n                options.loop,\n                options.getter,\n                options.setter\n            );\n\n            return animator;\n        }\n    };\n\n    util.mixin(Animation, Dispatcher);\n\n    module.exports = Animation;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/animation/Animation.js\n ** module id = 27\n ** module chunks = 0\n **/","'use strict';\n/**\n * Default canvas painter\n * @module zrender/Painter\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\n \n\n    var config = require('./config');\n    var util = require('./core/util');\n    var log = require('./core/log');\n    var BoundingRect = require('./core/BoundingRect');\n\n    var Layer = require('./Layer');\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n\n        if (layer.isBuildin) {\n            return true;\n        }\n\n        if (typeof(layer.resize) !== 'function'\n            || typeof(layer.refresh) !== 'function'\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function preProcessLayer(layer) {\n        layer.__unusedCount++;\n    }\n\n    function postProcessLayer(layer) {\n        layer.__dirty = false;\n        if (layer.__unusedCount == 1) {\n            layer.clear();\n        }\n    }\n\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n    }\n\n    function doClip(clipPaths, ctx) {\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            var m;\n            if (clipPath.transform) {\n                m = clipPath.transform;\n                ctx.transform(\n                    m[0], m[1],\n                    m[2], m[3],\n                    m[4], m[5]\n                );\n            }\n            var path = clipPath.path;\n            path.beginPath(ctx);\n            clipPath.buildPath(path, clipPath.shape);\n            ctx.clip();\n            // Transform back\n            if (clipPath.transform) {\n                m = clipPath.invTransform;\n                ctx.transform(\n                    m[0], m[1],\n                    m[2], m[3],\n                    m[4], m[5]\n                );\n            }\n        }\n    }\n\n    /**\n     * @alias module:zrender/Painter\n     * @constructor\n     * @param {HTMLElement} root 绘图容器\n     * @param {module:zrender/Storage} storage\n     * @param {Ojbect} opts\n     */\n    var Painter = function (root, storage, opts) {\n        var singleCanvas = !root.nodeName // In node ?\n            || root.nodeName.toUpperCase() === 'CANVAS';\n\n        opts = opts || {};\n\n        /**\n         * @type {number}\n         */\n        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._singleCanvas = singleCanvas;\n        /**\n         * 绘图容器\n         * @type {HTMLElement}\n         */\n        this.root = root;\n\n        var rootStyle = root.style;\n\n        // In node environment using node-canvas\n        if (rootStyle) {\n            rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n            rootStyle['-webkit-user-select'] = 'none';\n            rootStyle['user-select'] = 'none';\n            rootStyle['-webkit-touch-callout'] = 'none';\n\n            root.innerHTML = '';\n        }\n\n        /**\n         * @type {module:zrender/Storage}\n         */\n        this.storage = storage;\n\n        if (!singleCanvas) {\n            var width = this._getWidth();\n            var height = this._getHeight();\n            this._width = width;\n            this._height = height;\n\n            var domRoot = document.createElement('div');\n            this._domRoot = domRoot;\n            var domRootStyle = domRoot.style;\n\n            // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domRootStyle.position = 'relative';\n            domRootStyle.overflow = 'hidden';\n            domRootStyle.width = this._width + 'px';\n            domRootStyle.height = this._height + 'px';\n            root.appendChild(domRoot);\n\n            /**\n             * @type {Object.<key, module:zrender/Layer>}\n             * @private\n             */\n            this._layers = {};\n            /**\n             * @type {Array.<number>}\n             * @private\n             */\n            this._zlevelList = [];\n        }\n        else {\n            // Use canvas width and height directly\n            var width = root.width;\n            var height = root.height;\n            this._width = width;\n            this._height = height;\n\n            // Create layer if only one given canvas\n            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height\n            var mainLayer = new Layer(root, this, 1);\n            mainLayer.initContext();\n            // FIXME Use canvas width and height\n            // mainLayer.resize(width, height);\n            this._layers = {\n                0: mainLayer\n            };\n            this._zlevelList = [0];\n        }\n\n        this._layerConfig = {};\n\n        this.pathToImage = this._createPathToImage();\n    };\n\n    Painter.prototype = {\n\n        constructor: Painter,\n\n        /**\n         * If painter use a single canvas\n         * @return {boolean}\n         */\n        isSingleCanvas: function () {\n            return this._singleCanvas;\n        },\n        /**\n         * @return {HTMLDivElement}\n         */\n        getViewportRoot: function () {\n            return this._singleCanvas ? this._layers[0].dom : this._domRoot;\n        },\n\n        /**\n         * 刷新\n         * @param {boolean} [paintAll=false] 强制绘制所有displayable\n         */\n        refresh: function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var zlevelList = this._zlevelList;\n\n            this._paintList(list, paintAll);\n\n            // Paint custum layers\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.isBuildin && layer.refresh) {\n                    layer.refresh();\n                }\n            }\n\n            return this;\n        },\n\n        _paintList: function (list, paintAll) {\n\n            if (paintAll == null) {\n                paintAll = false;\n            }\n\n            this._updateLayerStatus(list);\n\n            var currentLayer;\n            var currentZLevel;\n            var ctx;\n\n            var viewWidth = this._width;\n            var viewHeight = this._height;\n\n            this.eachBuildinLayer(preProcessLayer);\n\n            // var invTransform = [];\n            var prevElClipPaths = null;\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var elZLevel = this._singleCanvas ? 0 : el.zlevel;\n                // Change draw layer\n                if (currentZLevel !== elZLevel) {\n                    // Only 0 zlevel if only has one canvas\n                    currentZLevel = elZLevel;\n                    currentLayer = this.getLayer(currentZLevel);\n\n                    if (!currentLayer.isBuildin) {\n                        log(\n                            'ZLevel ' + currentZLevel\n                            + ' has been used by unkown layer ' + currentLayer.id\n                        );\n                    }\n\n                    ctx = currentLayer.ctx;\n\n                    // Reset the count\n                    currentLayer.__unusedCount = 0;\n\n                    if (currentLayer.__dirty || paintAll) {\n                        currentLayer.clear();\n                    }\n                }\n\n                if (\n                    (currentLayer.__dirty || paintAll)\n                    // Ignore invisible element\n                    && !el.invisible\n                    // Ignore transparent element\n                    && el.style.opacity !== 0\n                    // Ignore scale 0 element, in some environment like node-canvas\n                    // Draw a scale 0 element can cause all following draw wrong\n                    && el.scale[0] && el.scale[1]\n                    // Ignore culled element\n                    && !(el.culling && isDisplayableCulled(el, viewWidth, viewHeight))\n                ) {\n                    var clipPaths = el.__clipPaths;\n\n                    // Optimize when clipping on group with several elements\n                    if (isClipPathChanged(clipPaths, prevElClipPaths)) {\n                        // If has previous clipping state, restore from it\n                        if (prevElClipPaths) {\n                            ctx.restore();\n                        }\n                        // New clipping state\n                        if (clipPaths) {\n                            ctx.save();\n                            doClip(clipPaths, ctx);\n                        }\n                        prevElClipPaths = clipPaths;\n                    }\n                    // TODO Use events ?\n                    el.beforeBrush && el.beforeBrush(ctx);\n                    el.brush(ctx, false);\n                    el.afterBrush && el.afterBrush(ctx);\n                }\n\n                el.__dirty = false;\n            }\n\n            // If still has clipping state\n            if (prevElClipPaths) {\n                ctx.restore();\n            }\n\n            this.eachBuildinLayer(postProcessLayer);\n        },\n\n        /**\n         * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n         * @param {number} zlevel\n         * @return {module:zrender/Layer}\n         */\n        getLayer: function (zlevel) {\n            if (this._singleCanvas) {\n                return this._layers[0];\n            }\n\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                // Create a new layer\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.isBuildin = true;\n\n                if (this._layerConfig[zlevel]) {\n                    util.merge(layer, this._layerConfig[zlevel], true);\n                }\n\n                this.insertLayer(zlevel, layer);\n\n                // Context is created after dom inserted to document\n                // Or excanvas will get 0px clientWidth and clientHeight\n                layer.initContext();\n            }\n\n            return layer;\n        },\n\n        insertLayer: function (zlevel, layer) {\n\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var prevLayer = null;\n            var i = -1;\n            var domRoot = this._domRoot;\n\n            if (layersMap[zlevel]) {\n                log('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            // Check if is a valid layer\n            if (!isLayerValid(layer)) {\n                log('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (\n                        zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel\n                    ) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n\n            if (prevLayer) {\n                var prevDom = prevLayer.dom;\n                if (prevDom.nextSibling) {\n                    domRoot.insertBefore(\n                        layer.dom,\n                        prevDom.nextSibling\n                    );\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n            else {\n                if (domRoot.firstChild) {\n                    domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                }\n                else {\n                    domRoot.appendChild(layer.dom);\n                }\n            }\n\n            layersMap[zlevel] = layer;\n        },\n\n        // Iterate each layer\n        eachLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        },\n\n        // Iterate each buildin layer\n        eachBuildinLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        // Iterate each other layer except buildin layer\n        eachOtherLayer: function (cb, context) {\n            var zlevelList = this._zlevelList;\n            var layer;\n            var z;\n            var i;\n            for (i = 0; i < zlevelList.length; i++) {\n                z = zlevelList[i];\n                layer = this._layers[z];\n                if (! layer.isBuildin) {\n                    cb.call(context, layer, z);\n                }\n            }\n        },\n\n        /**\n         * 获取所有已创建的层\n         * @param {Array.<module:zrender/Layer>} [prevLayer]\n         */\n        getLayers: function () {\n            return this._layers;\n        },\n\n        _updateLayerStatus: function (list) {\n\n            var layers = this._layers;\n\n            var elCounts = {};\n\n            this.eachBuildinLayer(function (layer, z) {\n                elCounts[z] = layer.elCount;\n                layer.elCount = 0;\n            });\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                var el = list[i];\n                var zlevel = this._singleCanvas ? 0 : el.zlevel;\n                var layer = layers[zlevel];\n                if (layer) {\n                    layer.elCount++;\n                    // 已经被标记为需要刷新\n                    if (layer.__dirty) {\n                        continue;\n                    }\n                    layer.__dirty = el.__dirty;\n                }\n            }\n\n            // 层中的元素数量有发生变化\n            this.eachBuildinLayer(function (layer, z) {\n                if (elCounts[z] !== layer.elCount) {\n                    layer.__dirty = true;\n                }\n            });\n        },\n\n        /**\n         * 清除hover层外所有内容\n         */\n        clear: function () {\n            this.eachBuildinLayer(this._clearLayer);\n            return this;\n        },\n\n        _clearLayer: function (layer) {\n            layer.clear();\n        },\n\n        /**\n         * 修改指定zlevel的绘制参数\n         *\n         * @param {string} zlevel\n         * @param {Object} config 配置对象\n         * @param {string} [config.clearColor=0] 每次清空画布的颜色\n         * @param {string} [config.motionBlur=false] 是否开启动态模糊\n         * @param {number} [config.lastFrameAlpha=0.7]\n         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         */\n        configLayer: function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    util.merge(layerConfig[zlevel], config, true);\n                }\n\n                var layer = this._layers[zlevel];\n\n                if (layer) {\n                    util.merge(layer, layerConfig[zlevel], true);\n                }\n            }\n        },\n\n        /**\n         * 删除指定层\n         * @param {number} zlevel 层所在的zlevel\n         */\n        delLayer: function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n\n            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n        },\n\n        /**\n         * 区域大小变化后重绘\n         */\n        resize: function (width, height) {\n            var domRoot = this._domRoot;\n            // FIXME Why ?\n            domRoot.style.display = 'none';\n\n            width = width || this._getWidth();\n            height = height || this._getHeight();\n\n            domRoot.style.display = '';\n\n            // 优化没有实际改变的resize\n            if (this._width != width || height != this._height) {\n                domRoot.style.width = width + 'px';\n                domRoot.style.height = height + 'px';\n\n                for (var id in this._layers) {\n                    this._layers[id].resize(width, height);\n                }\n\n                this.refresh(true);\n            }\n\n            this._width = width;\n            this._height = height;\n\n            return this;\n        },\n\n        /**\n         * 清除单独的一个层\n         * @param {number} zlevel\n         */\n        clearLayer: function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        },\n\n        /**\n         * 释放\n         */\n        dispose: function () {\n            this.root.innerHTML = '';\n\n            this.root =\n            this.storage =\n\n            this._domRoot =\n            this._layers = null;\n        },\n\n        /**\n         * Get canvas which has all thing rendered\n         * @param {Object} opts\n         * @param {string} [opts.backgroundColor]\n         */\n        getRenderedCanvas: function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas) {\n                return this._layers[0].dom;\n            }\n\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            imageLayer.initContext();\n\n            var ctx = imageLayer.ctx;\n            imageLayer.clearColor = opts.backgroundColor;\n            imageLayer.clear();\n\n            var displayList = this.storage.getDisplayList(true);\n\n            for (var i = 0; i < displayList.length; i++) {\n                var el = displayList[i];\n                if (!el.invisible) {\n                    el.beforeBrush && el.beforeBrush(ctx);\n                    // TODO Check image cross origin\n                    el.brush(ctx, false);\n                    el.afterBrush && el.afterBrush(ctx);\n                }\n            }\n\n            return imageLayer.dom;\n        },\n        /**\n         * 获取绘图区域宽度\n         */\n        getWidth: function () {\n            return this._width;\n        },\n\n        /**\n         * 获取绘图区域高度\n         */\n        getHeight: function () {\n            return this._height;\n        },\n\n        _getWidth: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            // FIXME Better way to get the width and height when element has not been append to the document\n            return ((root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width))\n                    - (parseInt10(stl.paddingLeft) || 0)\n                    - (parseInt10(stl.paddingRight) || 0)) | 0;\n        },\n\n        _getHeight: function () {\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n\n            return ((root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height))\n                    - (parseInt10(stl.paddingTop) || 0)\n                    - (parseInt10(stl.paddingBottom) || 0)) | 0;\n        },\n\n        _pathToImage: function (id, path, width, height, dpr) {\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n\n            ctx.clearRect(0, 0, width * dpr, height * dpr);\n\n            var pathTransform = {\n                position: path.position,\n                rotation: path.rotation,\n                scale: path.scale\n            };\n            path.position = [0, 0, 0];\n            path.rotation = 0;\n            path.scale = [1, 1];\n            if (path) {\n                path.brush(ctx);\n            }\n\n            var ImageShape = require('./graphic/Image');\n            var imgShape = new ImageShape({\n                id: id,\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n\n            if (pathTransform.position != null) {\n                imgShape.position = path.position = pathTransform.position;\n            }\n\n            if (pathTransform.rotation != null) {\n                imgShape.rotation = path.rotation = pathTransform.rotation;\n            }\n\n            if (pathTransform.scale != null) {\n                imgShape.scale = path.scale = pathTransform.scale;\n            }\n\n            return imgShape;\n        },\n\n        _createPathToImage: function () {\n            var me = this;\n\n            return function (id, e, width, height) {\n                return me._pathToImage(\n                    id, e, width, height, me.dpr\n                );\n            };\n        }\n    };\n\n    module.exports = Painter;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Painter.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var util = require('./core/util');\n    var config = require('./config');\n\n    function returnFalse() {\n        return false;\n    }\n\n    /**\n     * 创建dom\n     *\n     * @inner\n     * @param {string} id dom id 待用\n     * @param {string} type dom type，such as canvas, div etc.\n     * @param {Painter} painter painter instance\n     * @param {number} number\n     */\n    function createDom(id, type, painter, dpr) {\n        var newDom = document.createElement(type);\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n\n        var newDomStyle = newDom.style;\n        // 没append呢，请原谅我这样写，清晰~\n        newDomStyle.position = 'absolute';\n        newDomStyle.left = 0;\n        newDomStyle.top = 0;\n        newDomStyle.width = width + 'px';\n        newDomStyle.height = height + 'px';\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n\n        // id不作为索引用，避免可能造成的重名，定义为私有属性\n        newDom.setAttribute('data-zr-dom-id', id);\n        return newDom;\n    }\n\n    /**\n     * @alias module:zrender/Layer\n     * @constructor\n     * @extends module:zrender/mixin/Transformable\n     * @param {string} id\n     * @param {module:zrender/Painter} painter\n     * @param {number} [dpr]\n     */\n    var Layer = function(id, painter, dpr) {\n        var dom;\n        dpr = dpr || config.devicePixelRatio;\n        if (typeof id === 'string') {\n            dom = createDom(id, 'canvas', painter, dpr);\n        }\n        // Not using isDom because in node it will return false\n        else if (util.isObject(id)) {\n            dom = id;\n            id = dom.id;\n        }\n        this.id = id;\n        this.dom = dom;\n\n        var domStyle = dom.style;\n        if (domStyle) { // Not in node\n            dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n            domStyle['-webkit-user-select'] = 'none';\n            domStyle['user-select'] = 'none';\n            domStyle['-webkit-touch-callout'] = 'none';\n            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n        }\n\n        this.domBack = null;\n        this.ctxBack = null;\n\n        this.painter = painter;\n\n        this.config = null;\n\n        // Configs\n        /**\n         * 每次清空画布的颜色\n         * @type {string}\n         * @default 0\n         */\n        this.clearColor = 0;\n        /**\n         * 是否开启动态模糊\n         * @type {boolean}\n         * @default false\n         */\n        this.motionBlur = false;\n        /**\n         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n         * @type {number}\n         * @default 0.7\n         */\n        this.lastFrameAlpha = 0.7;\n\n        /**\n         * Layer dpr\n         * @type {number}\n         */\n        this.dpr = dpr;\n    };\n\n    Layer.prototype = {\n\n        constructor: Layer,\n\n        elCount: 0,\n\n        __dirty: true,\n\n        initContext: function () {\n            this.ctx = this.dom.getContext('2d');\n\n            var dpr = this.dpr;\n            if (dpr != 1) {\n                this.ctx.scale(dpr, dpr);\n            }\n        },\n\n        createBackBuffer: function () {\n            var dpr = this.dpr;\n\n            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n\n            if (dpr != 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        },\n\n        /**\n         * @param  {number} width\n         * @param  {number} height\n         */\n        resize: function (width, height) {\n            var dpr = this.dpr;\n\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n\n            domStyle.width = width + 'px';\n            domStyle.height = height + 'px';\n\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n\n            if (dpr != 1) {\n                this.ctx.scale(dpr, dpr);\n            }\n\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n\n                if (dpr != 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        },\n\n        /**\n         * 清空该层画布\n         * @param {boolean} clearAll Clear all with out motion blur\n         */\n        clear: function (clearAll) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n\n            var haveClearColor = this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n\n            var dpr = this.dpr;\n\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(\n                    dom, 0, 0,\n                    width / dpr,\n                    height / dpr\n                );\n            }\n\n            ctx.clearRect(0, 0, width / dpr, height / dpr);\n            if (haveClearColor) {\n                ctx.save();\n                ctx.fillStyle = this.clearColor;\n                ctx.fillRect(0, 0, width / dpr, height / dpr);\n                ctx.restore();\n            }\n\n            if (haveMotionBLur) {\n                var domBack = this.domBack;\n                ctx.save();\n                ctx.globalAlpha = lastFrameAlpha;\n                ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);\n                ctx.restore();\n            }\n        }\n    };\n\n    module.exports = Layer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/Layer.js\n ** module id = 29\n ** module chunks = 0\n **/","/**\n * Image element\n * @module zrender/graphic/Image\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var BoundingRect = require('../core/BoundingRect');\n    var zrUtil = require('../core/util');\n    var roundRectHelper = require('./helper/roundRect');\n\n    var LRU = require('../core/LRU');\n    var globalImageCache = new LRU(50);\n    /**\n     * @alias zrender/graphic/Image\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var ZImage = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    ZImage.prototype = {\n\n        constructor: ZImage,\n\n        type: 'image',\n\n        brush: function (ctx) {\n            var style = this.style;\n            var src = style.image;\n            var image;\n            // style.image is a url string\n            if (typeof src === 'string') {\n                image = this._image;\n            }\n            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas\n            else {\n                image = src;\n            }\n            // FIXME Case create many images with src\n            if (!image && src) {\n                // Try get from global image cache\n                var cachedImgObj = globalImageCache.get(src);\n                if (!cachedImgObj) {\n                    // Create a new image\n                    image = new Image();\n                    image.onload = function () {\n                        image.onload = null;\n                        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n                            cachedImgObj.pending[i].dirty();\n                        }\n                    };\n                    cachedImgObj = {\n                        image: image,\n                        pending: [this]\n                    };\n                    image.src = src;\n                    globalImageCache.put(src, cachedImgObj);\n                    this._image = image;\n                    return;\n                }\n                else {\n                    image = cachedImgObj.image;\n                    this._image = image;\n                    // Image is not complete finish, add to pending list\n                    if (!image.width || !image.height) {\n                        cachedImgObj.pending.push(this);\n                        return;\n                    }\n                }\n            }\n\n            if (image) {\n                // 图片已经加载完成\n                // if (image.nodeName.toUpperCase() == 'IMG') {\n                //     if (!image.complete) {\n                //         return;\n                //     }\n                // }\n                // Else is canvas\n\n                var width = style.width || image.width;\n                var height = style.height || image.height;\n                var x = style.x || 0;\n                var y = style.y || 0;\n                // 图片加载失败\n                if (!image.width || !image.height) {\n                    return;\n                }\n\n                ctx.save();\n\n                style.bind(ctx);\n\n                // 设置transform\n                this.setTransform(ctx);\n\n                if (style.r) {\n                    // Border radius clipping\n                    // FIXME\n                    ctx.beginPath();\n                    roundRectHelper.buildPath(ctx, style);\n                    ctx.clip();\n                }\n\n                if (style.sWidth && style.sHeight) {\n                    var sx = style.sx || 0;\n                    var sy = style.sy || 0;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, style.sWidth, style.sHeight,\n                        x, y, width, height\n                    );\n                }\n                else if (style.sx && style.sy) {\n                    var sx = style.sx;\n                    var sy = style.sy;\n                    var sWidth = width - sx;\n                    var sHeight = height - sy;\n                    ctx.drawImage(\n                        image,\n                        sx, sy, sWidth, sHeight,\n                        x, y, width, height\n                    );\n                }\n                else {\n                    ctx.drawImage(image, x, y, width, height);\n                }\n\n                // 如果没设置宽和高的话自动根据图片宽高设置\n                if (style.width == null) {\n                    style.width = width;\n                }\n                if (style.height == null) {\n                    style.height = height;\n                }\n\n                // Draw rect text\n                if (style.text != null) {\n                    this.drawRectText(ctx, this.getBoundingRect());\n                }\n\n                ctx.restore();\n            }\n        },\n\n        getBoundingRect: function () {\n            var style = this.style;\n            if (! this._rect) {\n                this._rect = new BoundingRect(\n                    style.x || 0, style.y || 0, style.width || 0, style.height || 0\n                );\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(ZImage, Displayable);\n\n    module.exports = ZImage;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Image.js\n ** module id = 30\n ** module chunks = 0\n **/","/**\n * 可绘制的图形基类\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n\n\n    var zrUtil = require('../core/util');\n\n    var Style = require('./Style');\n\n    var Element = require('../Element');\n    var RectText = require('./mixin/RectText');\n    // var Stateful = require('./mixin/Stateful');\n\n    /**\n     * @alias module:zrender/graphic/Displayable\n     * @extends module:zrender/Element\n     * @extends module:zrender/graphic/mixin/RectText\n     */\n    function Displayable(opts) {\n\n        opts = opts || {};\n\n        Element.call(this, opts);\n\n        // Extend properties\n        for (var name in opts) {\n            if (\n                opts.hasOwnProperty(name) &&\n                name !== 'style'\n            ) {\n                this[name] = opts[name];\n            }\n        }\n\n        /**\n         * @type {module:zrender/graphic/Style}\n         */\n        this.style = new Style(opts.style);\n\n        this._rect = null;\n        // Shapes for cascade clipping.\n        this.__clipPaths = [];\n\n        // FIXME Stateful must be mixined after style is setted\n        // Stateful.call(this, opts);\n    }\n\n    Displayable.prototype = {\n\n        constructor: Displayable,\n\n        type: 'displayable',\n\n        /**\n         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制\n         * Dirty flag. From which painter will determine if this displayable object needs brush\n         * @name module:zrender/graphic/Displayable#__dirty\n         * @type {boolean}\n         */\n        __dirty: true,\n\n        /**\n         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件\n         * If ignore drawing of the displayable object. Mouse event will still be triggered\n         * @name module:/zrender/graphic/Displayable#invisible\n         * @type {boolean}\n         * @default false\n         */\n        invisible: false,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z: 0,\n\n        /**\n         * @name module:/zrender/graphic/Displayable#z\n         * @type {number}\n         * @default 0\n         */\n        z2: 0,\n\n        /**\n         * z层level，决定绘画在哪层canvas中\n         * @name module:/zrender/graphic/Displayable#zlevel\n         * @type {number}\n         * @default 0\n         */\n        zlevel: 0,\n\n        /**\n         * 是否可拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        draggable: false,\n\n        /**\n         * 是否正在拖拽\n         * @name module:/zrender/graphic/Displayable#draggable\n         * @type {boolean}\n         * @default false\n         */\n        dragging: false,\n\n        /**\n         * 是否相应鼠标事件\n         * @name module:/zrender/graphic/Displayable#silent\n         * @type {boolean}\n         * @default false\n         */\n        silent: false,\n\n        /**\n         * If enable culling\n         * @type {boolean}\n         * @default false\n         */\n        culling: false,\n\n        /**\n         * Mouse cursor when hovered\n         * @name module:/zrender/graphic/Displayable#cursor\n         * @type {string}\n         */\n        cursor: 'pointer',\n\n        /**\n         * If hover area is bounding rect\n         * @name module:/zrender/graphic/Displayable#rectHover\n         * @type {string}\n         */\n        rectHover: false,\n\n        beforeBrush: function (ctx) {},\n\n        afterBrush: function (ctx) {},\n\n        /**\n         * 图形绘制方法\n         * @param {Canvas2DRenderingContext} ctx\n         */\n        // Interface\n        brush: function (ctx) {},\n\n        /**\n         * 获取最小包围盒\n         * @return {module:zrender/core/BoundingRect}\n         */\n        // Interface\n        getBoundingRect: function () {},\n\n        /**\n         * 判断坐标 x, y 是否在图形上\n         * If displayable element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        contain: function (x, y) {\n            return this.rectContain(x, y);\n        },\n\n        /**\n         * @param  {Function} cb\n         * @param  {}   context\n         */\n        traverse: function (cb, context) {\n            cb.call(context, this);\n        },\n\n        /**\n         * 判断坐标 x, y 是否在图形的包围盒上\n         * If bounding rect of element contain coord x, y\n         * @param  {number} x\n         * @param  {number} y\n         * @return {boolean}\n         */\n        rectContain: function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        },\n\n        /**\n         * 标记图形元素为脏，并且在下一帧重绘\n         * Mark displayable element dirty and refresh next frame\n         */\n        dirty: function () {\n            this.__dirty = true;\n\n            this._rect = null;\n\n            this.__zr && this.__zr.refresh();\n        },\n\n        /**\n         * 图形是否会触发事件\n         * If displayable object binded any event\n         * @return {boolean}\n         */\n        // TODO, 通过 bind 绑定的事件\n        // isSilent: function () {\n        //     return !(\n        //         this.hoverable || this.draggable\n        //         || this.onmousemove || this.onmouseover || this.onmouseout\n        //         || this.onmousedown || this.onmouseup || this.onclick\n        //         || this.ondragenter || this.ondragover || this.ondragleave\n        //         || this.ondrop\n        //     );\n        // },\n        /**\n         * Alias for animate('style')\n         * @param {boolean} loop\n         */\n        animateStyle: function (loop) {\n            return this.animate('style', loop);\n        },\n\n        attrKV: function (key, value) {\n            if (key !== 'style') {\n                Element.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                this.style.set(value);\n            }\n        },\n\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setStyle: function (key, value) {\n            this.style.set(key, value);\n            this.dirty();\n            return this;\n        }\n    };\n\n    zrUtil.inherits(Displayable, Element);\n\n    zrUtil.mixin(Displayable, RectText);\n    // zrUtil.mixin(Displayable, Stateful);\n\n    module.exports = Displayable;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Displayable.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/Style\n */\n\n\n\n    var STYLE_LIST_COMMON = [\n        'lineCap', 'lineJoin', 'miterLimit',\n        'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'shadowColor'\n    ];\n\n    var Style = function (opts) {\n        this.extendFrom(opts);\n    };\n\n    Style.prototype = {\n\n        constructor: Style,\n\n        /**\n         * @type {string}\n         */\n        fill: '#000000',\n\n        /**\n         * @type {string}\n         */\n        stroke: null,\n\n        /**\n         * @type {number}\n         */\n        opacity: 1,\n\n        /**\n         * @type {Array.<number>}\n         */\n        lineDash: null,\n\n        /**\n         * @type {number}\n         */\n        lineDashOffset: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        shadowOffsetY: 0,\n\n        /**\n         * @type {number}\n         */\n        lineWidth: 1,\n\n        /**\n         * If stroke ignore scale\n         * @type {Boolean}\n         */\n        strokeNoScale: false,\n\n        // Bounding rect text configuration\n        // Not affected by element transform\n        /**\n         * @type {string}\n         */\n        text: null,\n\n        /**\n         * @type {string}\n         */\n        textFill: '#000',\n\n        /**\n         * @type {string}\n         */\n        textStroke: null,\n\n        /**\n         * 'inside', 'left', 'right', 'top', 'bottom'\n         * [x, y]\n         * @type {string|Array.<number>}\n         * @default 'inside'\n         */\n        textPosition: 'inside',\n\n        /**\n         * @type {string}\n         */\n        textBaseline: null,\n\n        /**\n         * @type {string}\n         */\n        textAlign: null,\n\n        /**\n         * @type {string}\n         */\n        textVerticalAlign: null,\n\n        /**\n         * @type {number}\n         */\n        textDistance: 5,\n\n        /**\n         * @type {number}\n         */\n        textShadowBlur: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetX: 0,\n\n        /**\n         * @type {number}\n         */\n        textShadowOffsetY: 0,\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         */\n        bind: function (ctx, el) {\n            var fill = this.fill;\n            var stroke = this.stroke;\n            for (var i = 0; i < STYLE_LIST_COMMON.length; i++) {\n                var styleName = STYLE_LIST_COMMON[i];\n\n                if (this[styleName] != null) {\n                    ctx[styleName] = this[styleName];\n                }\n            }\n            if (stroke != null) {\n                var lineWidth = this.lineWidth;\n                ctx.lineWidth = lineWidth / (\n                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1\n                );\n            }\n            if (fill != null) {\n                 // Use canvas gradient if has\n                ctx.fillStyle = fill.canvasGradient ? fill.canvasGradient : fill;\n            }\n            if (stroke != null) {\n                 // Use canvas gradient if has\n                ctx.strokeStyle = stroke.canvasGradient ? stroke.canvasGradient : stroke;\n            }\n            this.opacity != null && (ctx.globalAlpha = this.opacity);\n        },\n\n        /**\n         * Extend from other style\n         * @param {zrender/graphic/Style} otherStyle\n         * @param {boolean} overwrite\n         */\n        extendFrom: function (otherStyle, overwrite) {\n            if (otherStyle) {\n                var target = this;\n                for (var name in otherStyle) {\n                    if (otherStyle.hasOwnProperty(name)\n                        && (overwrite || ! target.hasOwnProperty(name))\n                    ) {\n                        target[name] = otherStyle[name];\n                    }\n                }\n            }\n        },\n\n        /**\n         * Batch setting style with a given object\n         * @param {Object|string} obj\n         * @param {*} [obj]\n         */\n        set: function (obj, value) {\n            if (typeof obj === 'string') {\n                this[obj] = value;\n            }\n            else {\n                this.extendFrom(obj, true);\n            }\n        },\n\n        /**\n         * Clone\n         * @return {zrender/graphic/Style} [description]\n         */\n        clone: function () {\n            var newStyle = new this.constructor();\n            newStyle.extendFrom(this, true);\n            return newStyle;\n        }\n    };\n\n    var styleProto = Style.prototype;\n    var name;\n    var i;\n    for (i = 0; i < STYLE_LIST_COMMON.length; i++) {\n        name = STYLE_LIST_COMMON[i];\n        if (!(name in styleProto)) {\n            styleProto[name] = null;\n        }\n    }\n\n    module.exports = Style;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Style.js\n ** module id = 32\n ** module chunks = 0\n **/","/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\n\n\n\n    var textContain = require('../../contain/text');\n    var BoundingRect = require('../../core/BoundingRect');\n\n    var tmpRect = new BoundingRect();\n\n    var RectText = function () {};\n\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    function setTransform(ctx, m) {\n        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n    }\n\n    RectText.prototype = {\n\n        constructor: RectText,\n\n        /**\n         * Draw text in a rect with specified position.\n         * @param  {CanvasRenderingContext} ctx\n         * @param  {Object} rect Displayable rect\n         * @return {Object} textRect Alternative precalculated text bounding rect\n         */\n        drawRectText: function (ctx, rect, textRect) {\n            var style = this.style;\n            var text = style.text;\n            // Convert to string\n            text != null && (text += '');\n            if (!text) {\n                return;\n            }\n            var x;\n            var y;\n            var textPosition = style.textPosition;\n            var distance = style.textDistance;\n            var align = style.textAlign;\n            var font = style.textFont || style.font;\n            var baseline = style.textBaseline;\n            var verticalAlign = style.textVerticalAlign;\n\n            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);\n\n            // Transform rect to view space\n            var transform = this.transform;\n            var invTransform = this.invTransform;\n            if (transform) {\n                tmpRect.copy(rect);\n                tmpRect.applyTransform(transform);\n                rect = tmpRect;\n                // Transform back\n                setTransform(ctx, invTransform);\n            }\n\n            // Text position represented by coord\n            if (textPosition instanceof Array) {\n                // Percent\n                x = rect.x + parsePercent(textPosition[0], rect.width);\n                y = rect.y + parsePercent(textPosition[1], rect.height);\n                align = align || 'left';\n                baseline = baseline || 'top';\n            }\n            else {\n                var res = textContain.adjustTextPositionOnRect(\n                    textPosition, rect, textRect, distance\n                );\n                x = res.x;\n                y = res.y;\n                // Default align and baseline when has textPosition\n                align = align || res.textAlign;\n                baseline = baseline || res.textBaseline;\n            }\n\n            ctx.textAlign = align;\n            if (verticalAlign) {\n                switch (verticalAlign) {\n                    case 'middle':\n                        y -= textRect.height / 2;\n                        break;\n                    case 'bottom':\n                        y -= textRect.height;\n                        break;\n                    // 'top'\n                }\n                // Ignore baseline\n                ctx.textBaseline = 'top';\n            }\n            else {\n                ctx.textBaseline = baseline;\n            }\n\n            var textFill = style.textFill;\n            var textStroke = style.textStroke;\n            textFill && (ctx.fillStyle = textFill);\n            textStroke && (ctx.strokeStyle = textStroke);\n            ctx.font = font;\n\n            // Text shadow\n            ctx.shadowColor = style.textShadowColor;\n            ctx.shadowBlur = style.textShadowBlur;\n            ctx.shadowOffsetX = style.textShadowOffsetX;\n            ctx.shadowOffsetY = style.textShadowOffsetY;\n\n            var textLines = text.split('\\n');\n            for (var i = 0; i < textLines.length; i++) {\n                textFill && ctx.fillText(textLines[i], x, y);\n                textStroke && ctx.strokeText(textLines[i], x, y);\n                y += textRect.lineHeight;\n            }\n\n            // Transform again\n            transform && setTransform(ctx, transform);\n        }\n    };\n\n    module.exports = RectText;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/mixin/RectText.js\n ** module id = 33\n ** module chunks = 0\n **/","\n\n    var textWidthCache = {};\n    var textWidthCacheCounter = 0;\n    var TEXT_CACHE_MAX = 5000;\n\n    var util = require('../core/util');\n    var BoundingRect = require('../core/BoundingRect');\n\n    function getTextWidth(text, textFont) {\n        var key = text + ':' + textFont;\n        if (textWidthCache[key]) {\n            return textWidthCache[key];\n        }\n\n        var textLines = (text + '').split('\\n');\n        var width = 0;\n\n        for (var i = 0, l = textLines.length; i < l; i++) {\n            // measureText 可以被覆盖以兼容不支持 Canvas 的环境\n            width =  Math.max(textContain.measureText(textLines[i], textFont).width, width);\n        }\n\n        if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n            textWidthCacheCounter = 0;\n            textWidthCache = {};\n        }\n        textWidthCacheCounter++;\n        textWidthCache[key] = width;\n\n        return width;\n    }\n\n    function getTextRect(text, textFont, textAlign, textBaseline) {\n        var textLineLen = ((text || '') + '').split('\\n').length;\n\n        var width = getTextWidth(text, textFont);\n        // FIXME 高度计算比较粗暴\n        var lineHeight = getTextWidth('国', textFont);\n        var height = textLineLen * lineHeight;\n\n        var rect = new BoundingRect(0, 0, width, height);\n        // Text has a special line height property\n        rect.lineHeight = lineHeight;\n\n        switch (textBaseline) {\n            case 'bottom':\n            case 'alphabetic':\n                rect.y -= lineHeight;\n                break;\n            case 'middle':\n                rect.y -= lineHeight / 2;\n                break;\n            // case 'hanging':\n            // case 'top':\n        }\n\n        // FIXME Right to left language\n        switch (textAlign) {\n            case 'end':\n            case 'right':\n                rect.x -= rect.width;\n                break;\n            case 'center':\n                rect.x -= rect.width / 2;\n                break;\n            // case 'start':\n            // case 'left':\n        }\n\n        return rect;\n    }\n\n    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {\n\n        var x = rect.x;\n        var y = rect.y;\n\n        var height = rect.height;\n        var width = rect.width;\n\n        var textHeight = textRect.height;\n\n        var halfHeight = height / 2 - textHeight / 2;\n\n        var textAlign = 'left';\n\n        switch (textPosition) {\n            case 'left':\n                x -= distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'right':\n                x += distance + width;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'top':\n                x += width / 2;\n                y -= distance + textHeight;\n                textAlign = 'center';\n                break;\n            case 'bottom':\n                x += width / 2;\n                y += height + distance;\n                textAlign = 'center';\n                break;\n            case 'inside':\n                x += width / 2;\n                y += halfHeight;\n                textAlign = 'center';\n                break;\n            case 'insideLeft':\n                x += distance;\n                y += halfHeight;\n                textAlign = 'left';\n                break;\n            case 'insideRight':\n                x += width - distance;\n                y += halfHeight;\n                textAlign = 'right';\n                break;\n            case 'insideTop':\n                x += width / 2;\n                y += distance;\n                textAlign = 'center';\n                break;\n            case 'insideBottom':\n                x += width / 2;\n                y += height - textHeight - distance;\n                textAlign = 'center';\n                break;\n            case 'insideTopLeft':\n                x += distance;\n                y += distance;\n                textAlign = 'left';\n                break;\n            case 'insideTopRight':\n                x += width - distance;\n                y += distance;\n                textAlign = 'right';\n                break;\n            case 'insideBottomLeft':\n                x += distance;\n                y += height - textHeight - distance;\n                break;\n            case 'insideBottomRight':\n                x += width - distance;\n                y += height - textHeight - distance;\n                textAlign = 'right';\n                break;\n        }\n\n        return {\n            x: x,\n            y: y,\n            textAlign: textAlign,\n            textBaseline: 'top'\n        };\n    }\n\n    /**\n     * Show ellipsis if overflow.\n     *\n     * @param  {string} text\n     * @param  {string} textFont\n     * @param  {string} containerWidth\n     * @param  {Object} [options]\n     * @param  {number} [options.ellipsis='...']\n     * @param  {number} [options.maxIterations=3]\n     * @param  {number} [options.minCharacters=3]\n     * @return {string}\n     */\n    function textEllipsis(text, textFont, containerWidth, options) {\n        if (!containerWidth) {\n            return '';\n        }\n\n        options = util.defaults({\n            ellipsis: '...',\n            minCharacters: 3,\n            maxIterations: 3,\n            cnCharWidth: getTextWidth('国', textFont),\n            // FIXME\n            // 未考虑非等宽字体\n            ascCharWidth: getTextWidth('a', textFont)\n        }, options, true);\n\n        containerWidth -= getTextWidth(options.ellipsis);\n\n        var textLines = (text + '').split('\\n');\n\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            textLines[i] = textLineTruncate(\n                textLines[i], textFont, containerWidth, options\n            );\n        }\n\n        return textLines.join('\\n');\n    }\n\n    function textLineTruncate(text, textFont, containerWidth, options) {\n        // FIXME\n        // 粗糙得写的，尚未考虑性能和各种语言、字体的效果。\n        for (var i = 0;; i++) {\n            var lineWidth = getTextWidth(text, textFont);\n\n            if (lineWidth < containerWidth || i >= options.maxIterations) {\n                text += options.ellipsis;\n                break;\n            }\n\n            var subLength = i === 0\n                ? estimateLength(text, containerWidth, options)\n                : Math.floor(text.length * containerWidth / lineWidth);\n\n            if (subLength < options.minCharacters) {\n                text = '';\n                break;\n            }\n\n            text = text.substr(0, subLength);\n        }\n\n        return text;\n    }\n\n    function estimateLength(text, containerWidth, options) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < containerWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127)\n                ? options.ascCharWidth : options.cnCharWidth;\n        }\n        return i;\n    }\n\n    var textContain = {\n\n        getWidth: getTextWidth,\n\n        getBoundingRect: getTextRect,\n\n        adjustTextPositionOnRect: adjustTextPositionOnRect,\n\n        ellipsis: textEllipsis,\n\n        measureText: function (text, textFont) {\n            var ctx = util.getContext();\n            ctx.font = textFont;\n            return ctx.measureText(text);\n        }\n    };\n\n    module.exports = textContain;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/text.js\n ** module id = 34\n ** module chunks = 0\n **/","\n\n    module.exports = {\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            var r = shape.r;\n            var r1;\n            var r2;\n            var r3;\n            var r4;\n\n            // Convert width and height to positive for better borderRadius\n            if (width < 0) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0) {\n                y = y + height;\n                height = -height;\n            }\n\n            if (typeof r === 'number') {\n                r1 = r2 = r3 = r4 = r;\n            }\n            else if (r instanceof Array) {\n                if (r.length === 1) {\n                    r1 = r2 = r3 = r4 = r[0];\n                }\n                else if (r.length === 2) {\n                    r1 = r3 = r[0];\n                    r2 = r4 = r[1];\n                }\n                else if (r.length === 3) {\n                    r1 = r[0];\n                    r2 = r4 = r[1];\n                    r3 = r[2];\n                }\n                else {\n                    r1 = r[0];\n                    r2 = r[1];\n                    r3 = r[2];\n                    r4 = r[3];\n                }\n            }\n            else {\n                r1 = r2 = r3 = r4 = 0;\n            }\n\n            var total;\n            if (r1 + r2 > width) {\n                total = r1 + r2;\n                r1 *= width / total;\n                r2 *= width / total;\n            }\n            if (r3 + r4 > width) {\n                total = r3 + r4;\n                r3 *= width / total;\n                r4 *= width / total;\n            }\n            if (r2 + r3 > height) {\n                total = r2 + r3;\n                r2 *= height / total;\n                r3 *= height / total;\n            }\n            if (r1 + r4 > height) {\n                total = r1 + r4;\n                r1 *= height / total;\n                r4 *= height / total;\n            }\n            ctx.moveTo(x + r1, y);\n            ctx.lineTo(x + width - r2, y);\n            r2 !== 0 && ctx.quadraticCurveTo(\n                x + width, y, x + width, y + r2\n            );\n            ctx.lineTo(x + width, y + height - r3);\n            r3 !== 0 && ctx.quadraticCurveTo(\n                x + width, y + height, x + width - r3, y + height\n            );\n            ctx.lineTo(x + r4, y + height);\n            r4 !== 0 && ctx.quadraticCurveTo(\n                x, y + height, x, y + height - r4\n            );\n            ctx.lineTo(x, y + r1);\n            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/roundRect.js\n ** module id = 35\n ** module chunks = 0\n **/","// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n\n    /**\n     * Simple double linked list. Compared with array, it has O(1) remove operation.\n     * @constructor\n     */\n    var LinkedList = function() {\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.head = null;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.tail = null;\n\n        this._len = 0;\n    };\n\n    var linkedListProto = LinkedList.prototype;\n    /**\n     * Insert a new value at the tail\n     * @param  {} val\n     * @return {module:zrender/core/LRU~Entry}\n     */\n    linkedListProto.insert = function(val) {\n        var entry = new Entry(val);\n        this.insertEntry(entry);\n        return entry;\n    };\n\n    /**\n     * Insert an entry at the tail\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.insertEntry = function(entry) {\n        if (!this.head) {\n            this.head = this.tail = entry;\n        }\n        else {\n            this.tail.next = entry;\n            entry.prev = this.tail;\n            this.tail = entry;\n        }\n        this._len++;\n    };\n\n    /**\n     * Remove entry.\n     * @param  {module:zrender/core/LRU~Entry} entry\n     */\n    linkedListProto.remove = function(entry) {\n        var prev = entry.prev;\n        var next = entry.next;\n        if (prev) {\n            prev.next = next;\n        }\n        else {\n            // Is head\n            this.head = next;\n        }\n        if (next) {\n            next.prev = prev;\n        }\n        else {\n            // Is tail\n            this.tail = prev;\n        }\n        entry.next = entry.prev = null;\n        this._len--;\n    };\n\n    /**\n     * @return {number}\n     */\n    linkedListProto.len = function() {\n        return this._len;\n    };\n\n    /**\n     * @constructor\n     * @param {} val\n     */\n    var Entry = function(val) {\n        /**\n         * @type {}\n         */\n        this.value = val;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.next;\n\n        /**\n         * @type {module:zrender/core/LRU~Entry}\n         */\n        this.prev;\n    };\n\n    /**\n     * LRU Cache\n     * @constructor\n     * @alias module:zrender/core/LRU\n     */\n    var LRU = function(maxSize) {\n\n        this._list = new LinkedList();\n\n        this._map = {};\n\n        this._maxSize = maxSize || 10;\n    };\n\n    var LRUProto = LRU.prototype;\n\n    /**\n     * @param  {string} key\n     * @param  {} value\n     */\n    LRUProto.put = function(key, value) {\n        var list = this._list;\n        var map = this._map;\n        if (map[key] == null) {\n            var len = list.len();\n            if (len >= this._maxSize && len > 0) {\n                // Remove the least recently used\n                var leastUsedEntry = list.head;\n                list.remove(leastUsedEntry);\n                delete map[leastUsedEntry.key];\n            }\n\n            var entry = list.insert(value);\n            entry.key = key;\n            map[key] = entry;\n        }\n    };\n\n    /**\n     * @param  {string} key\n     * @return {}\n     */\n    LRUProto.get = function(key) {\n        var entry = this._map[key];\n        var list = this._list;\n        if (entry != null) {\n            // Put the latest used entry in the tail\n            if (entry !== list.tail) {\n                list.remove(entry);\n                list.insertEntry(entry);\n            }\n\n            return entry.value;\n        }\n    };\n\n    /**\n     * Clear the cache\n     */\n    LRUProto.clear = function() {\n        this._list.clear();\n        this._map = {};\n    };\n\n    module.exports = LRU;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/LRU.js\n ** module id = 36\n ** module chunks = 0\n **/","/**\r\n * BO节点\r\n * 1.BO是一个矩形\r\n * 2.BO有名字\r\n * 3.BO有事件决策[]，双击事件决策弹出详情\r\n * 4.BO有外键属性[]\r\n * 5.BO有子BO\r\n * 6.当前BO特殊颜色显示\r\n * 7.双击BO弹出BO属性以及属性事件决策页面\r\n * @module fish-topo-bo/node/BoNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var BoName = require('../node/BoName');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var Line = require('../node/LineNode');\r\n    var BoAttr = require('../node/BoAttrNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String BO主键,\r\n     *          name: String BO名字,\r\n     *          boEventArr: [] BO事件决策数组,\r\n     *          boAttrArr: [] BO属性数组\r\n     *          }} boData, bo数据对象\r\n     * @param {{\r\n     *          startPos: {x: number, y: number} 起始位置,\r\n     *          displayAttrDataType: boolean 是否显示属性数据类型,\r\n     *          displayAttrEvent: boolean 是否显示属性事件决策,\r\n     *          boClickable: boolean BO是否支持点击事件, 可空 默认false\r\n     *          boPopupOpts: Object BO弹出页面参数，url,width,height等\r\n     *          boEventClickable: boolean BO事件决策是否支持点击事件, 可空 默认false\r\n     *          boEventPopupOpts: Object BO事件决策弹出页面参数，url,width,height等\r\n     *          attrEventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false\r\n     *          attrEventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等\r\n     *          isCurrent: boolean 是否为当前BO\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BO(boData, opts) {\r\n\r\n        /**\r\n         * BO数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boData;\r\n\r\n        /**\r\n         * 初始坐标，用于最后画BO矩形\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._oriStartPos = opts.startPos;\r\n\r\n        /**\r\n         * 每个控件的起始参照坐标，每个控件画完之后都会重新计算\r\n         * @type {{x: number, y: number}}\r\n         * @private\r\n         */\r\n        this._nextStartPos = {\r\n            x: opts.startPos.x,\r\n            y: opts.startPos.y\r\n        };\r\n\r\n        /**\r\n         * 是否显示属性数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrDataType = opts.displayAttrDataType || false;\r\n\r\n        /**\r\n         * 是否显示属性事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayAttrEvent = opts.displayAttrEvent || false;\r\n\r\n        //TODO\r\n        if (this._displayAttrEvent) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 3;\r\n        } else if (this._displayAttrDataType) {\r\n            Const.BO_NODE_WIDTH = Const.BO_NODE_WIDTH * 1.5;\r\n        }\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._boClickable = opts.boClickable || false;\r\n        this._boPopupOpts = opts.boPopupOpts;\r\n        this._boEventClickable = opts.boEventClickable || false;\r\n        this._boEventPopupOpts = opts.boEventPopupOpts;\r\n        this._attrEventClickable = opts.attrEventClickable || false;\r\n        this._attrEventPopupOpts = opts.attrEventPopupOpts;\r\n\r\n        /**\r\n         * 是否是当前BO，当前BO特殊颜色显示\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._isCurrent = opts.isCurrent || false;\r\n\r\n\r\n        /**\r\n         * BO矩形高度，根据实际内容计算\r\n         * @type {number}\r\n         * @private\r\n         */\r\n        this._boShapeHeight = 0;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n        this._group.setCurrent = function (style) {\r\n            //Group最后一个是BO矩形\r\n            var _boShape = this.childAt(this.childCount() - 1);\r\n\r\n            if (style) {\r\n                fish.extend(_boShape.style, style);\r\n            } else {\r\n                //默认效果\r\n                _boShape.style.fill = '#66CC99';\r\n            }\r\n\r\n        };\r\n\r\n        this._render();\r\n    }\r\n\r\n\r\n    var boProto = BO.prototype;\r\n\r\n    /**\r\n     * 获取BO整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 获取数据\r\n     * @returns {Object}\r\n     */\r\n    boProto.getData = function () {\r\n        return this._data;\r\n    };\r\n\r\n    boProto.getLayout = function () {\r\n        return this._data.layout;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * 设置当前BO特殊演示显示\r\n     */\r\n    boProto.setCurrent = function () {\r\n        //BO矩形是最后一个图形\r\n        this.childAt(this.childCount - 1).style.fill = '#66CC99'\r\n    };\r\n\r\n    /**\r\n     * 生成BO整体图形\r\n     * @private\r\n     */\r\n    boProto._render = function () {\r\n        //BO名字\r\n        this._createBoName();\r\n\r\n        //BO事件决策\r\n        this._createEventDecision();\r\n\r\n        //BO属性\r\n        this._createBoAttr();\r\n\r\n        //BO矩形\r\n        this._createBoShape();\r\n\r\n        //TODO\r\n        Const.BO_NODE_WIDTH = 180;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO名字文本\r\n     * @private\r\n     */\r\n    boProto._createBoName = function () {\r\n        var _boNameShape = BoName(this._data.name, this._nextStartPos);\r\n\r\n        if (this._boClickable) {\r\n            _boNameShape.clickable = this._boClickable;\r\n            _boNameShape._data = this._data;\r\n            _boNameShape._boPopupOpts = this._boPopupOpts;\r\n            _boNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(_boNameShape);\r\n        this._calNextShapeStartPos(_boNameShape);\r\n    };\r\n\r\n    /**\r\n     * 生成BO事件决策\r\n     * @private\r\n     */\r\n    boProto._createEventDecision = function () {\r\n\r\n        //如果没有BO事件决策，则返回\r\n        if (!this._data.boEventArr) {\r\n            return;\r\n        }\r\n\r\n        var _boEventArr = this._data.boEventArr,\r\n            _boEventLen = _boEventArr.length,\r\n            _eventShape,\r\n            _eventOpts = {\r\n                startPos: this._nextStartPos,\r\n                clickable: this._boEventClickable,\r\n                popupOpts: this._boEventPopupOpts\r\n            };\r\n\r\n        for (var i = 0; i < _boEventLen; i++) {\r\n            _eventShape = new EventDecision(_boEventArr[i], _eventOpts);\r\n            this._group.add(_eventShape.getShape());\r\n            this._calNextShapeStartPos(_eventShape.getShape());\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * 生成BO属性\r\n     * @private\r\n     */\r\n    boProto._createBoAttr = function () {\r\n        //如果没有BO属性，则返回\r\n        if (!this._data.boAttrArr) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrArr = this._data.boAttrArr,\r\n            _boAttrLen = _boAttrArr.length,\r\n            _boAttrShape, _lineShape,\r\n            _attrEventStartPos = {x: this._nextStartPos.x + Const.BO_NODE_WIDTH / 2, y: this._nextStartPos.y};\r\n\r\n        for (var i = 0; i < _boAttrLen; i++) {\r\n            if (i == 0) {\r\n                _lineShape = Line.BoLine(this._nextStartPos); //实线\r\n            }\r\n            else {\r\n                _lineShape = Line.AttrLine(this._nextStartPos);//虚线\r\n            }\r\n\r\n            this._group.add(_lineShape);\r\n\r\n            this._calNextShapeStartPos(_lineShape);\r\n\r\n            _boAttrShape = new BoAttr(_boAttrArr[i],\r\n                {\r\n                    startPos: this._nextStartPos,\r\n                    displayDataType: this._displayAttrDataType,\r\n                    displayEventDecision: this._displayAttrEvent,\r\n                    eventClickable: this._attrEventClickable,\r\n                    eventPopupOpts: this._attrEventPopupOpts\r\n                }\r\n            );\r\n            this._group.add(_boAttrShape.getShape());\r\n            this._calNextShapeStartPos(_boAttrShape.getShape())\r\n        }\r\n\r\n        if (this._displayAttrEvent) {\r\n            _lineShape = Line.AttrEventLine(_attrEventStartPos,\r\n                this._nextStartPos.y - _attrEventStartPos.y\r\n            );\r\n            this._group.add(_lineShape);\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * 计算下一个图形的开始位置，以及BO矩形的高度\r\n     * @param curShape 当前图形\r\n     * @private\r\n     */\r\n    boProto._calNextShapeStartPos = function (curShape) {\r\n        //下一图形起始位置\r\n        this._nextStartPos.y += curShape.getBoundingRect().height;\r\n\r\n        //BO矩形高度增加\r\n        this._boShapeHeight += curShape.getBoundingRect().height;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO矩形\r\n     * @private\r\n     */\r\n    boProto._createBoShape = function () {\r\n        var height = this._boShapeHeight > Const.BO_NODE_DEFAULT_HEIGHT ?\r\n                this._boShapeHeight : Const.BO_NODE_DEFAULT_HEIGHT,\r\n            shape = new graphic.Rect({\r\n                position: [this._oriStartPos.x, this._oriStartPos.y],\r\n\r\n                shape: {\r\n                    r: 5,\r\n                    width: Const.BO_NODE_WIDTH,\r\n                    height: height\r\n                },\r\n\r\n                style: {\r\n                    brushType: 'both',\r\n                    fill: this._isCurrent ? '#66CC99' : 'white',\r\n                    stroke: '#000000',\r\n                    lineWidth: 1,\r\n                    lineCape: 'round'\r\n                },\r\n\r\n                zlevel: -1\r\n            });\r\n\r\n        if (this._boClickable) {\r\n            shape._data = this._data;\r\n            shape._boPopupOpts = this._boPopupOpts;\r\n\r\n            shape.clickable = this._boClickable;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    boProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._boPopupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    module.exports = BO;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoNode.js\n ** module id = 37\n ** module chunks = 0\n **/","/**\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    module.exports = {\r\n        BO_NODE_WIDTH: 180,    //BO矩形宽度\r\n        BO_NODE_DEFAULT_HEIGHT: 60,\t//BO矩形默认高度，即只有BO名字的情况\r\n        BO_NODE_OFFSET_X: 90, //BO矩形的水平偏移量=矩形宽度的一般\r\n        BO_NODE_OFFSET_Y: 50, //BO矩形的垂直偏移量\r\n\r\n        BO_NAME_FONT: 'bold 18px Arial', //'normal 16px verdana',    //BO名字文本样式,\r\n        BO_NAME_PADDING_TOP: 10,   //BO名字与矩形上边框的距离\r\n        BO_NAME_PADDING_BOTTOM: 15,   //BO名字与下一个控件（事件决策或者横线）的距离\r\n\r\n        BO_EVENT_HEIGHT: 20,   //BO事件决策多边形高度\r\n        BO_EVENT_WIDTH: 140,   //BO事件决策多边形宽度\r\n        BO_EVENT_FONT: 'normal 14px Arial',  //BO事件决策名字文本样式\r\n\r\n        BO_ATTR_FONT: 'normal 14px Arial',   //BO属性名字文本样式\r\n        BO_ATTR_PADDING_TOP: 5,   //BO属性名字与矩形上边框的距离\r\n        BO_ATTR_PADDING_BOTTOM: 5,   //BO属性名字与下一个控件（事件决策或者横线）的距离\r\n        BO_ATTR_PADDING_LEFT: 5,   //BO属性名字与矩形左边框的距离\r\n        BO_ATTR_DATA_TYPE_PADDING_RIGHT: 5, //BO属性数据类型与矩形右边框的距离\r\n        BO_ATTR_EVENT_WIDTH: 135,   //BO属性事件决策多边形宽度\r\n\r\n        LINE_DASH: 10,  //虚线\r\n        RELATION_OFFSET: 40,   //关联关系的初始偏移量，即第一段折线宽度\r\n        RELATION_ARROW_WIDTH: 10,  //关联关系三角箭头水平宽度\r\n        RELATION_ARROW_HEIGHT: 5,  //关联关系三角箭头垂直高度的一半\r\n        RELATION_TEXT_OFFSET_X: 10, //关联关系文字说明水平偏移量\r\n        RELATION_TEXT_OFFSET_Y: 5 //关联关系文字说明垂直偏移量\r\n    };\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/models/Const.js\n ** module id = 38\n ** module chunks = 0\n **/","/**\r\n * BO名字\r\n * @module fish-topo-bo/node/BoName\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {String} text, BO名字\r\n     * @param {{x: number, y: number}} startPos, 起始位置\r\n     * @returns {zrender/graphic/Text}\r\n     * @constructor\r\n     */\r\n    function BoName(text, startPos) {\r\n        var x = startPos.x,\r\n            y = startPos.y + Const.BO_NAME_PADDING_TOP, //文字到矩形上边框的距离 padding-top=10\r\n\r\n            shape = new graphic.Text({\r\n                style: {\r\n                    text: text,\r\n                    textFont: Const.BO_NAME_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //文字居中显示，重新计算文本水平起始位置 = 矩形水平起始位置 + (BO矩形宽度 - 文本宽度)/2\r\n        shape.position[0] += (Const.BO_NODE_WIDTH - shape.getBoundingRect().width) / 2;\r\n\r\n        //重新设置BO名字图形高度 = 文本高度 + padding-top + padding-bottom\r\n        shape.getBoundingRect().height += Const.BO_NAME_PADDING_TOP + Const.BO_NAME_PADDING_BOTTOM;\r\n\r\n        return shape;\r\n    }\r\n\r\n    module.exports = BoName;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoName.js\n ** module id = 39\n ** module chunks = 0\n **/","'use strict';\n\r\n\r\n    var zrUtil = require('zrender/lib/core/util');\r\n\r\n    var pathTool = require('zrender/lib/tool/path');\r\n    var round = Math.round;\r\n    var Path = require('zrender/lib/graphic/Path');\r\n    var colorTool = require('zrender/lib/tool/color');\r\n    var matrix = require('zrender/lib/core/matrix');\r\n    var vector = require('zrender/lib/core/vector');\r\n    var Gradient = require('zrender/lib/graphic/Gradient');\r\n\r\n    var graphic = {};\r\n    graphic.Util = zrUtil;\r\n    graphic.Group = require('zrender/lib/container/Group');\r\n\r\n    graphic.Image = require('zrender/lib/graphic/Image');\r\n\r\n    graphic.Text = require('zrender/lib/graphic/Text');\r\n\r\n    graphic.textContain = require('zrender/lib/contain/text');\r\n\r\n    graphic.Circle = require('zrender/lib/graphic/shape/Circle');\r\n\r\n    graphic.Sector = require('zrender/lib/graphic/shape/Sector');\r\n\r\n    graphic.Ring = require('zrender/lib/graphic/shape/Ring');\r\n\r\n    graphic.Polygon = require('zrender/lib/graphic/shape/Polygon');\r\n\r\n    graphic.Polyline = require('zrender/lib/graphic/shape/Polyline');\r\n\r\n    graphic.Rect = require('zrender/lib/graphic/shape/Rect');\r\n\r\n    graphic.Line = require('zrender/lib/graphic/shape/Line');\r\n\r\n    graphic.BezierCurve = require('zrender/lib/graphic/shape/BezierCurve');\r\n\r\n    graphic.Arc = require('zrender/lib/graphic/shape/Arc');\r\n\r\n    graphic.LinearGradient = require('zrender/lib/graphic/LinearGradient');\r\n\r\n    graphic.RadialGradient = require('zrender/lib/graphic/RadialGradient');\r\n\r\n    graphic.BoundingRect = require('zrender/lib/core/BoundingRect');\r\n\r\n    /**\r\n     * Extend shape with parameters\r\n     */\r\n    graphic.extendShape = function (opts) {\r\n        return Path.extend(opts);\r\n    };\r\n\r\n    /**\r\n     * Extend path\r\n     */\r\n    graphic.extendPath = function (pathData, opts) {\r\n        return pathTool.extendFromString(pathData, opts);\r\n    };\r\n\r\n    /**\r\n     * Create a path element from path data string\r\n     * @param {string} pathData\r\n     * @param {Object} opts\r\n     * @param {module:zrender/core/BoundingRect} rect\r\n     * @param {string} [layout=cover] 'center' or 'cover'\r\n     */\r\n    graphic.makePath = function (pathData, opts, rect, layout) {\r\n        var path = pathTool.createFromString(pathData, opts);\r\n        var boundingRect = path.getBoundingRect();\r\n        if (rect) {\r\n            var aspect = boundingRect.width / boundingRect.height;\r\n\r\n            if (layout === 'center') {\r\n                // Set rect to center, keep width / height ratio.\r\n                var width = rect.height * aspect;\r\n                var height;\r\n                if (width <= rect.width) {\r\n                    height = rect.height;\r\n                }\r\n                else {\r\n                    width = rect.width;\r\n                    height = width / aspect;\r\n                }\r\n                var cx = rect.x + rect.width / 2;\r\n                var cy = rect.y + rect.height / 2;\r\n\r\n                rect.x = cx - width / 2;\r\n                rect.y = cy - height / 2;\r\n                rect.width = width;\r\n                rect.height = height;\r\n            }\r\n\r\n            this.resizePath(path, rect);\r\n        }\r\n        return path;\r\n    };\r\n\r\n    graphic.mergePath = pathTool.mergePath,\r\n\r\n    /**\r\n     * Resize a path to fit the rect\r\n     * @param {module:zrender/graphic/Path} path\r\n     * @param {Object} rect\r\n     */\r\n    graphic.resizePath = function (path, rect) {\r\n        if (!path.applyTransform) {\r\n            return;\r\n        }\r\n\r\n        var pathRect = path.getBoundingRect();\r\n\r\n        var m = pathRect.calculateTransform(rect);\r\n\r\n        path.applyTransform(m);\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize line for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x1]\r\n     * @param {number} [param.shape.y1]\r\n     * @param {number} [param.shape.x2]\r\n     * @param {number} [param.shape.y2]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeLine = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n\r\n        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {\r\n            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);\r\n        }\r\n        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {\r\n            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);\r\n        }\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize rect for canvas\r\n     *\r\n     * @param {Object} param\r\n     * @param {Object} [param.shape]\r\n     * @param {number} [param.shape.x]\r\n     * @param {number} [param.shape.y]\r\n     * @param {number} [param.shape.width]\r\n     * @param {number} [param.shape.height]\r\n     * @param {Object} [param.style]\r\n     * @param {number} [param.style.lineWidth]\r\n     * @return {Object} Modified param\r\n     */\r\n    graphic.subPixelOptimizeRect = function (param) {\r\n        var subPixelOptimize = graphic.subPixelOptimize;\r\n        var shape = param.shape;\r\n        var lineWidth = param.style.lineWidth;\r\n        var originX = shape.x;\r\n        var originY = shape.y;\r\n        var originWidth = shape.width;\r\n        var originHeight = shape.height;\r\n        shape.x = subPixelOptimize(shape.x, lineWidth, true);\r\n        shape.y = subPixelOptimize(shape.y, lineWidth, true);\r\n        shape.width = Math.max(\r\n            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,\r\n            originWidth === 0 ? 0 : 1\r\n        );\r\n        shape.height = Math.max(\r\n            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,\r\n            originHeight === 0 ? 0 : 1\r\n        );\r\n        return param;\r\n    };\r\n\r\n    /**\r\n     * Sub pixel optimize for canvas\r\n     *\r\n     * @param {number} position Coordinate, such as x, y\r\n     * @param {number} lineWidth Should be nonnegative integer.\r\n     * @param {boolean=} positiveOrNegative Default false (negative).\r\n     * @return {number} Optimized position.\r\n     */\r\n    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {\r\n        // Assure that (position + lineWidth / 2) is near integer edge,\r\n        // otherwise line will be fuzzy in canvas.\r\n        var doubledPosition = round(position * 2);\r\n        return (doubledPosition + round(lineWidth)) % 2 === 0\r\n            ? doubledPosition / 2\r\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function doSingleEnterHover(el) {\r\n        if (el.__isHover) {\r\n            return;\r\n        }\r\n        if (el.__hoverStlDirty) {\r\n            var stroke = el.style.stroke;\r\n            var fill = el.style.fill;\r\n\r\n            // Create hoverStyle on mouseover\r\n            var hoverStyle = el.__hoverStl;\r\n            var lift = colorTool.lift;\r\n            hoverStyle.fill = hoverStyle.fill\r\n                || (fill && (fill instanceof Gradient ? fill : lift(fill, -0.1)));\r\n            hoverStyle.stroke = hoverStyle.stroke\r\n                || (stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1)));\r\n\r\n            var normalStyle = {};\r\n            for (var name in hoverStyle) {\r\n                if (hoverStyle.hasOwnProperty(name)) {\r\n                    normalStyle[name] = el.style[name];\r\n                }\r\n            }\r\n\r\n            el.__normalStl = normalStyle;\r\n\r\n            el.__hoverStlDirty = false;\r\n        }\r\n        el.setStyle(el.__hoverStl);\r\n        el.z2 += 1;\r\n\r\n        el.__isHover = true;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doSingleLeaveHover(el) {\r\n        if (!el.__isHover) {\r\n            return;\r\n        }\r\n\r\n        var normalStl = el.__normalStl;\r\n        normalStl && el.setStyle(normalStl);\r\n        el.z2 -= 1;\r\n\r\n        el.__isHover = false;\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function doEnterHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleEnterHover(child);\r\n                }\r\n            })\r\n            : doSingleEnterHover(el);\r\n    }\r\n    graphic.doEnterHover = doEnterHover;\r\n    function doLeaveHover(el) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    doSingleLeaveHover(child);\r\n                }\r\n            })\r\n            : doSingleLeaveHover(el);\r\n    }\r\n    graphic.doLeaveHover = doLeaveHover;\r\n    /**\r\n     * @inner\r\n     */\r\n    function setElementHoverStl(el, hoverStl) {\r\n        // If element has sepcified hoverStyle, then use it instead of given hoverStyle\r\n        // Often used when item group has a label element and it's hoverStyle is different\r\n        el.__hoverStl = el.hoverStyle || hoverStl || {};\r\n        el.__hoverStlDirty = true;\r\n    }\r\n    graphic.setElementHoverStl = setElementHoverStl;\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOver() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function onElementMouseOut() {\r\n        // Only if element is not in emphasis status\r\n        !this.__isEmphasis && doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function enterEmphasis() {\r\n        this.__isEmphasis = true;\r\n        doEnterHover(this);\r\n    }\r\n\r\n    /**\r\n     * @inner\r\n     */\r\n    function leaveEmphasis() {\r\n        this.__isEmphasis = false;\r\n        doLeaveHover(this);\r\n    }\r\n\r\n    /**\r\n     * Set hover style of element\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} [hoverStyle]\r\n     */\r\n    graphic.setHoverStyle = function (el, hoverStyle) {\r\n        el.type === 'group'\r\n            ? el.traverse(function (child) {\r\n                if (child.type !== 'group') {\r\n                    setElementHoverStl(child, hoverStyle);\r\n                }\r\n            })\r\n            : setElementHoverStl(el, hoverStyle);\r\n        // Remove previous bound handlers\r\n        el.on('mouseover', onElementMouseOver)\r\n          .on('mouseout', onElementMouseOut);\r\n\r\n        // Emphasis, normal can be triggered manually\r\n        el.on('emphasis', enterEmphasis)\r\n          .on('normal', leaveEmphasis);\r\n    };\r\n\r\n    /**\r\n     * Set text option in the style\r\n     * @param {Object} textStyle\r\n     * @param {module:echarts/model/Model} labelModel\r\n     * @param {string} color\r\n     */\r\n    graphic.setText = function (textStyle, labelModel, color) {\r\n        var labelPosition = labelModel.getShallow('position') || 'inside';\r\n        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;\r\n        var textStyleModel = labelModel.getModel('textStyle');\r\n        zrUtil.extend(textStyle, {\r\n            textDistance: labelModel.getShallow('distance') || 5,\r\n            textFont: textStyleModel.getFont(),\r\n            textPosition: labelPosition,\r\n            textFill: textStyleModel.getTextColor() || labelColor\r\n        });\r\n    };\r\n\r\n    function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {\r\n        var postfix = isUpdate ? 'Update' : '';\r\n        var duration = animatableModel\r\n            && animatableModel.getShallow('animationDuration' + postfix);\r\n        var animationEasing = animatableModel\r\n            && animatableModel.getShallow('animationEasing' + postfix);\r\n\r\n        animatableModel && animatableModel.getShallow('animation')\r\n            ? el.animateTo(props, duration, animationEasing, cb)\r\n            : (el.attr(props), cb && cb());\r\n    }\r\n    /**\r\n     * Update graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.updateProps = zrUtil.curry(animateOrSetProps, true);\r\n\r\n    /**\r\n     * Init graphic element properties with or without animation according to the configuration in series\r\n     * @param {module:zrender/Element} el\r\n     * @param {Object} props\r\n     * @param {module:echarts/model/Model} [animatableModel]\r\n     * @param {Function} cb\r\n     */\r\n    graphic.initProps = zrUtil.curry(animateOrSetProps, false);\r\n\r\n    /**\r\n     * Get transform matrix of target (param target),\r\n     * in coordinate of its ancestor (param ancestor)\r\n     *\r\n     * @param {module:zrender/mixin/Transformable} target\r\n     * @param {module:zrender/mixin/Transformable} ancestor\r\n     */\r\n    graphic.getTransform = function (target, ancestor) {\r\n        var mat = matrix.identity([]);\r\n\r\n        while (target && target !== ancestor) {\r\n            matrix.mul(mat, target.getLocalTransform(), mat);\r\n            target = target.parent;\r\n        }\r\n\r\n        return mat;\r\n    };\r\n\r\n    /**\r\n     * Apply transform to an vertex.\r\n     * @param {Array.<number>} vertex [x, y]\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {Array.<number>} [x, y]\r\n     */\r\n    graphic.applyTransform = function (vertex, transform, invert) {\r\n        if (invert) {\r\n            transform = matrix.invert([], transform);\r\n        }\r\n        return vector.applyTransform([], vertex, transform);\r\n    };\r\n\r\n    /**\r\n     * @param {string} direction 'left' 'right' 'top' 'bottom'\r\n     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]\r\n     * @param {boolean=} invert Whether use invert matrix.\r\n     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'\r\n     */\r\n    graphic.transformDirection = function (direction, transform, invert) {\r\n\r\n        // Pick a base, ensure that transform result will not be (0, 0).\r\n        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[0]);\r\n        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)\r\n            ? 1 : Math.abs(2 * transform[4] / transform[2]);\r\n\r\n        var vertex = [\r\n            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,\r\n            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0\r\n        ];\r\n\r\n        vertex = graphic.applyTransform(vertex, transform, invert);\r\n\r\n        return Math.abs(vertex[0]) > Math.abs(vertex[1])\r\n            ? (vertex[0] > 0 ? 'right' : 'left')\r\n            : (vertex[1] > 0 ? 'bottom' : 'top');\r\n    };\r\n\r\n    module.exports = graphic;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-core/lib/graphic.js\n ** module id = 40\n ** module chunks = 0\n **/","\n\n    var Path = require('../graphic/Path');\n    var PathProxy = require('../core/PathProxy');\n    var transformPath = require('./transformPath');\n    var matrix = require('../core/matrix');\n\n    // command chars\n    var cc = [\n        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n    ];\n\n    var mathSqrt = Math.sqrt;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI = Math.PI;\n\n    var vMag = function(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    };\n    var vRatio = function(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    };\n    var vAngle = function(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n                * Math.acos(vRatio(u, v));\n    };\n\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI / 180.0);\n        var xp = mathCos(psi) * (x1 - x2) / 2.0\n                 + mathSin(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0\n                 + mathCos(psi) * (y1 - y2) / 2.0;\n\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n\n        if (lambda > 1) {\n            rx *= mathSqrt(lambda);\n            ry *= mathSqrt(lambda);\n        }\n\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt((((rx * rx) * (ry * ry))\n                    - ((rx * rx) * (yp * yp))\n                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                    + (ry * ry) * (xp * xp))\n                ) || 0;\n\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n\n        var cx = (x1 + x2) / 2.0\n                 + mathCos(psi) * cxp\n                 - mathSin(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n                + mathSin(psi) * cxp\n                + mathCos(psi) * cyp;\n\n        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);\n        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];\n        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];\n        var dTheta = vAngle(u, v);\n\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (fs === 0 && dTheta > 0) {\n            dTheta = dTheta - 2 * PI;\n        }\n        if (fs === 1 && dTheta < 0) {\n            dTheta = dTheta + 2 * PI;\n        }\n\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n\n    function createPathProxyFromString(data) {\n        if (!data) {\n            return [];\n        }\n\n        // command string\n        var cs = data.replace(/-/g, ' -')\n            .replace(/  /g, ' ')\n            .replace(/ /g, ',')\n            .replace(/,,/g, ',');\n\n        var n;\n        // create pipes so that we can split the data\n        for (n = 0; n < cc.length; n++) {\n            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n        }\n\n        // create array\n        var arr = cs.split('|');\n        // init context point\n        var cpx = 0;\n        var cpy = 0;\n\n        var path = new PathProxy();\n        var CMD = PathProxy.CMD;\n\n        var prevCmd;\n        for (n = 1; n < arr.length; n++) {\n            var str = arr[n];\n            var c = str.charAt(0);\n            var off = 0;\n            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');\n            var cmd;\n\n            if (p.length > 0 && p[0] === '') {\n                p.shift();\n            }\n\n            for (var i = 0; i < p.length; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            while (off < p.length && !isNaN(p[off])) {\n                if (isNaN(p[0])) {\n                    break;\n                }\n                var ctlPtx;\n                var ctlPty;\n\n                var rx;\n                var ry;\n                var psi;\n                var fa;\n                var fs;\n\n                var x1 = cpx;\n                var y1 = cpy;\n\n                // convert l, H, h, V, and v to L\n                switch (c) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        c = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]\n                        );\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(\n                            cmd,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy,\n                            p[off++] + cpx, p[off++] + cpy\n                        );\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        var len = path.len();\n                        var pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(\n                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path\n                        );\n                        break;\n                }\n            }\n\n            if (c === 'z' || c === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n            }\n\n            prevCmd = cmd;\n        }\n\n        path.toStatic();\n\n        return path;\n    }\n\n    // TODO Optimize double memory cost problem\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var transform;\n        opts = opts || {};\n        opts.buildPath = function (path) {\n            path.setData(pathProxy.data);\n            transform && transformPath(path, transform);\n            // Svg and vml renderer don't have context\n            var ctx = path.getContext();\n            if (ctx) {\n                path.rebuildPath(ctx);\n            }\n        };\n\n        opts.applyTransform = function (m) {\n            if (!transform) {\n                transform = matrix.create();\n            }\n            matrix.mul(transform, m, transform);\n        };\n\n        return opts;\n    }\n\n    module.exports = {\n        /**\n         * Create a Path object from path string data\n         * http://www.w3.org/TR/SVG/paths.html#PathData\n         * @param  {Object} opts Other options\n         */\n        createFromString: function (str, opts) {\n            return new Path(createPathOptions(str, opts));\n        },\n\n        /**\n         * Create a Path class from path string data\n         * @param  {string} str\n         * @param  {Object} opts Other options\n         */\n        extendFromString: function (str, opts) {\n            return Path.extend(createPathOptions(str, opts));\n        },\n\n        /**\n         * Merge multiple paths\n         */\n        // TODO Apply transform\n        // TODO stroke dash\n        // TODO Optimize double memory cost problem\n        mergePath: function (pathEls, opts) {\n            var pathList = [];\n            var len = pathEls.length;\n            var pathEl;\n            var i;\n            for (i = 0; i < len; i++) {\n                pathEl = pathEls[i];\n                if (pathEl.__dirty) {\n                    pathEl.buildPath(pathEl.path, pathEl.shape);\n                }\n                pathList.push(pathEl.path);\n            }\n\n            var pathBundle = new Path(opts);\n            pathBundle.buildPath = function (path) {\n                path.appendPath(pathList);\n                // Svg and vml renderer don't have context\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx);\n                }\n            };\n\n            return pathBundle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/path.js\n ** module id = 41\n ** module chunks = 0\n **/","/**\n * Path element\n * @module zrender/graphic/Path\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var PathProxy = require('../core/PathProxy');\n    var pathContain = require('../contain/path');\n\n    var Gradient = require('./Gradient');\n\n    function pathHasFill(style) {\n        var fill = style.fill;\n        return fill != null && fill !== 'none';\n    }\n\n    function pathHasStroke(style) {\n        var stroke = style.stroke;\n        return stroke != null && stroke !== 'none' && style.lineWidth > 0;\n    }\n\n    var abs = Math.abs;\n\n    /**\n     * @alias module:zrender/graphic/Path\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    function Path(opts) {\n        Displayable.call(this, opts);\n\n        /**\n         * @type {module:zrender/core/PathProxy}\n         * @readOnly\n         */\n        this.path = new PathProxy();\n    }\n\n    Path.prototype = {\n\n        constructor: Path,\n\n        type: 'path',\n\n        __dirtyPath: true,\n\n        strokeContainThreshold: 5,\n\n        brush: function (ctx) {\n            ctx.save();\n\n            var style = this.style;\n            var path = this.path;\n            var hasStroke = pathHasStroke(style);\n            var hasFill = pathHasFill(style);\n\n            if (this.__dirtyPath) {\n                // Update gradient because bounding rect may changed\n                if (hasFill && (style.fill instanceof Gradient)) {\n                    style.fill.updateCanvasGradient(this, ctx);\n                }\n                if (hasStroke && (style.stroke instanceof Gradient)) {\n                    style.stroke.updateCanvasGradient(this, ctx);\n                }\n            }\n\n            style.bind(ctx, this);\n            this.setTransform(ctx);\n\n            var lineDash = style.lineDash;\n            var lineDashOffset = style.lineDashOffset;\n\n            var ctxLineDash = !!ctx.setLineDash;\n\n            // Proxy context\n            // Rebuild path in following 2 cases\n            // 1. Path is dirty\n            // 2. Path needs javascript implemented lineDash stroking.\n            //    In this case, lineDash information will not be saved in PathProxy\n            if (this.__dirtyPath || (\n                lineDash && !ctxLineDash && hasStroke\n            )) {\n                path = this.path.beginPath(ctx);\n\n                // Setting line dash before build path\n                if (lineDash && !ctxLineDash) {\n                    path.setLineDash(lineDash);\n                    path.setLineDashOffset(lineDashOffset);\n                }\n\n                this.buildPath(path, this.shape);\n\n                // Clear path dirty flag\n                this.__dirtyPath = false;\n            }\n            else {\n                // Replay path building\n                ctx.beginPath();\n                this.path.rebuildPath(ctx);\n            }\n\n            hasFill && path.fill(ctx);\n\n            if (lineDash && ctxLineDash) {\n                ctx.setLineDash(lineDash);\n                ctx.lineDashOffset = lineDashOffset;\n            }\n\n            hasStroke && path.stroke(ctx);\n\n            // Draw rect text\n            if (style.text != null) {\n                // var rect = this.getBoundingRect();\n                this.drawRectText(ctx, this.getBoundingRect());\n            }\n\n            ctx.restore();\n        },\n\n        buildPath: function (ctx, shapeCfg) {},\n\n        getBoundingRect: function () {\n            var rect = this._rect;\n            var style = this.style;\n            if (!rect) {\n                var path = this.path;\n                if (this.__dirtyPath) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape);\n                }\n                rect = path.getBoundingRect();\n            }\n            /**\n             * Needs update rect with stroke lineWidth when\n             * 1. Element changes scale or lineWidth\n             * 2. First create rect\n             */\n            if (pathHasStroke(style) && (this.__dirty || !this._rect)) {\n                var rectWithStroke = this._rectWithStroke\n                    || (this._rectWithStroke = rect.clone());\n                rectWithStroke.copy(rect);\n                // FIXME Must after updateTransform\n                var w = style.lineWidth;\n                // PENDING, Min line width is needed when line is horizontal or vertical\n                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n\n                // Only add extra hover lineWidth when there are no fill\n                if (!pathHasFill(style)) {\n                    w = Math.max(w, this.strokeContainThreshold);\n                }\n                // Consider line width\n                // Line scale can't be 0;\n                if (lineScale > 1e-10) {\n                    rectWithStroke.width += w / lineScale;\n                    rectWithStroke.height += w / lineScale;\n                    rectWithStroke.x -= w / lineScale / 2;\n                    rectWithStroke.y -= w / lineScale / 2;\n                }\n                return rectWithStroke;\n            }\n            this._rect = rect;\n            return rect;\n        },\n\n        contain: function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n\n            if (rect.contain(x, y)) {\n                var pathData = this.path.data;\n                if (pathHasStroke(style)) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    // Line scale can't be 0;\n                    if (lineScale > 1e-10) {\n                        // Only add extra hover lineWidth when there are no fill\n                        if (!pathHasFill(style)) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (pathContain.containStroke(\n                            pathData, lineWidth / lineScale, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                }\n                if (pathHasFill(style)) {\n                    return pathContain.contain(pathData, x, y);\n                }\n            }\n            return false;\n        },\n\n        /**\n         * @param  {boolean} dirtyPath\n         */\n        dirty: function (dirtyPath) {\n            if (arguments.length ===0) {\n                dirtyPath = true;\n            }\n            // Only mark dirty, not mark clean\n            if (dirtyPath) {\n                this.__dirtyPath = dirtyPath;\n                this._rect = null;\n            }\n\n            this.__dirty = true;\n\n            this.__zr && this.__zr.refresh();\n\n            // Used as a clipping path\n            if (this.__clipTarget) {\n                this.__clipTarget.dirty();\n            }\n        },\n\n        /**\n         * Alias for animate('shape')\n         * @param {boolean} loop\n         */\n        animateShape: function (loop) {\n            return this.animate('shape', loop);\n        },\n\n        // Overwrite attrKV\n        attrKV: function (key, value) {\n            // FIXME\n            if (key === 'shape') {\n                this.setShape(value);\n            }\n            else {\n                Displayable.prototype.attrKV.call(this, key, value);\n            }\n        },\n        /**\n         * @param {Object|string} key\n         * @param {*} value\n         */\n        setShape: function (key, value) {\n            var shape = this.shape;\n            // Path from string may not have shape\n            if (shape) {\n                if (zrUtil.isObject(key)) {\n                    for (var name in key) {\n                        shape[name] = key[name];\n                    }\n                }\n                else {\n                    shape[key] = value;\n                }\n                this.dirty(true);\n            }\n            return this;\n        },\n\n        getLineScale: function () {\n            var m = this.transform;\n            // Get the line scale.\n            // Determinant of `m` means how much the area is enlarged by the\n            // transformation. So its square root can be used as a scale factor\n            // for width.\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        }\n    };\n\n    /**\n     * 扩展一个 Path element, 比如星形，圆等。\n     * Extend a path element\n     * @param {Object} props\n     * @param {string} props.type Path type\n     * @param {Function} props.init Initialize\n     * @param {Function} props.buildPath Overwrite buildPath method\n     * @param {Object} [props.style] Extended default style config\n     * @param {Object} [props.shape] Extended default shape config\n     */\n    Path.extend = function (defaults) {\n        var Sub = function (opts) {\n            Path.call(this, opts);\n\n            if (defaults.style) {\n                // Extend default style\n                this.style.extendFrom(defaults.style, false);\n            }\n\n            // Extend default shape\n            var defaultShape = defaults.shape;\n            if (defaultShape) {\n                this.shape = this.shape || {};\n                var thisShape = this.shape;\n                for (var name in defaultShape) {\n                    if (\n                        ! thisShape.hasOwnProperty(name)\n                        && defaultShape.hasOwnProperty(name)\n                    ) {\n                        thisShape[name] = defaultShape[name];\n                    }\n                }\n            }\n\n            defaults.init && defaults.init.call(this, opts);\n        };\n\n        zrUtil.inherits(Sub, Path);\n\n        // FIXME 不能 extend position, rotation 等引用对象\n        for (var name in defaults) {\n            // Extending prototype values and methods\n            if (name !== 'style' && name !== 'shape') {\n                Sub.prototype[name] = defaults[name];\n            }\n        }\n\n        return Sub;\n    };\n\n    zrUtil.inherits(Path, Displayable);\n\n    module.exports = Path;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Path.js\n ** module id = 42\n ** module chunks = 0\n **/","'use strict';\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n\n // TODO getTotalLength, getPointAtLength\n\n\n    var curve = require('./curve');\n    var vec2 = require('./vector');\n    var bbox = require('./bbox');\n    var BoundingRect = require('./BoundingRect');\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        // Rect\n        R: 7\n    };\n\n    var min = [];\n    var max = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathCos = Math.cos;\n    var mathSin = Math.sin;\n    var mathSqrt = Math.sqrt;\n\n    var hasTypedArray = typeof Float32Array != 'undefined';\n\n    /**\n     * @alias module:zrender/core/PathProxy\n     * @constructor\n     */\n    var PathProxy = function () {\n\n        /**\n         * Path data. Stored as flat array\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        this._len = 0;\n\n        this._ctx = null;\n\n        this._xi = 0;\n        this._yi = 0;\n\n        this._x0 = 0;\n        this._y0 = 0;\n    };\n\n    /**\n     * 快速计算Path包围盒（并不是最小包围盒）\n     * @return {Object}\n     */\n    PathProxy.prototype = {\n\n        constructor: PathProxy,\n\n        _lineDash: null,\n\n        _dashOffset: 0,\n\n        _dashIdx: 0,\n\n        _dashSum: 0,\n\n        getContext: function () {\n            return this._ctx;\n        },\n\n        /**\n         * @param  {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        beginPath: function (ctx) {\n            this._ctx = ctx;\n\n            ctx && ctx.beginPath();\n\n            // Reset\n            this._len = 0;\n\n            if (this._lineDash) {\n                this._lineDash = null;\n\n                this._dashOffset = 0;\n            }\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        moveTo: function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n\n            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n            this._x0 = x;\n            this._y0 = y;\n\n            this._xi = x;\n            this._yi = y;\n\n            return this;\n        },\n\n        /**\n         * @param  {number} x\n         * @param  {number} y\n         * @return {module:zrender/core/PathProxy}\n         */\n        lineTo: function (x, y) {\n            this.addData(CMD.L, x, y);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            this._xi = x;\n            this._yi = y;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @param  {number} x3\n         * @param  {number} y3\n         * @return {module:zrender/core/PathProxy}\n         */\n        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        },\n\n        /**\n         * @param  {number} x1\n         * @param  {number} y1\n         * @param  {number} x2\n         * @param  {number} y2\n         * @return {module:zrender/core/PathProxy}\n         */\n        quadraticCurveTo: function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        },\n\n        /**\n         * @param  {number} cx\n         * @param  {number} cy\n         * @param  {number} r\n         * @param  {number} startAngle\n         * @param  {number} endAngle\n         * @param  {boolean} anticlockwise\n         * @return {module:zrender/core/PathProxy}\n         */\n        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.addData(\n                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1\n            );\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n\n            this._xi = mathCos(endAngle) * r + cx;\n            this._xi = mathSin(endAngle) * r + cx;\n            return this;\n        },\n\n        // TODO\n        arcTo: function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        },\n\n        // TODO\n        rect: function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        },\n\n        /**\n         * @return {module:zrender/core/PathProxy}\n         */\n        closePath: function () {\n            this.addData(CMD.Z);\n\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash() && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        },\n\n        /**\n         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n         * stroke 同样\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        fill: function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        },\n\n        /**\n         * @param {CanvasRenderingContext2D} ctx\n         * @return {module:zrender/core/PathProxy}\n         */\n        stroke: function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDash: function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n\n                this._dashIdx = 0;\n\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n            }\n            return this;\n        },\n\n        /**\n         * 必须在其它绘制命令前调用\n         * Must be invoked before all other path drawing methods\n         * @return {module:zrender/core/PathProxy}\n         */\n        setLineDashOffset: function (offset) {\n            this._dashOffset = offset;\n            return this;\n        },\n\n        /**\n         *\n         * @return {boolean}\n         */\n        len: function () {\n            return this._len;\n        },\n\n        /**\n         * 直接设置 Path 数据\n         */\n        setData: function (data) {\n\n            var len = data.length;\n\n            if (! (this.data && this.data.length == len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n\n            this._len = len;\n        },\n\n        /**\n         * 添加子路径\n         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n         */\n        appendPath: function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        },\n\n        /**\n         * 填充 Path 数据。\n         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n         */\n        addData: function (cmd) {\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                // 因为之前的数组已经转换成静态的 Float32Array\n                // 所以不够用时需要扩展一个新的动态数组\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n\n            this._prevCmd = cmd;\n        },\n\n        _expandData: function () {\n            // Only if data is Float32Array\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        },\n\n        /**\n         * If needs js implemented dashed line\n         * @return {boolean}\n         * @private\n         */\n        _needsDash: function () {\n            return this._lineDash;\n        },\n\n        _dashedLineTo: function (x1, y1) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var dash;\n            var nDash = lineDash.length;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n\n            while ((dx >= 0 && x <= x1) || (dx < 0 && x > x1)) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                // Skip positive offset\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](\n                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),\n                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)\n                );\n            }\n            // Offset for next lineTo\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        // Not accurate dashed line to\n        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var t;\n            var dx;\n            var dy;\n            var cubicAt = curve.cubicAt;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n\n            var x;\n            var y;\n\n            var tmpLen = 0;\n\n            if (offset < 0) {\n                // Convert to positive offset\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            // Bezier approx length\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt(dx * dx + dy * dy);\n            }\n\n            // Find idx after add offset\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n\n            while (t <= 1) {\n\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n\n                // Use line to approximate dashed bezier\n                // Bad result if dash is long\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n\n                t += lineDash[idx] / bezierLen;\n\n                idx = (idx + 1) % nDash;\n            }\n\n            // Finish the last segment and calculate the new offset\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n        },\n\n        _dashedQuadraticTo: function (x1, y1, x2, y2) {\n            // Convert quadratic to cubic using degree elevation\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        },\n\n        /**\n         * 转成静态的 Float32Array 减少堆内存占用\n         * Convert dynamic array to static Float32Array\n         */\n        toStatic: function () {\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        },\n\n        /**\n         * @return {module:zrender/core/BoundingRect}\n         */\n        getBoundingRect: function () {\n            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n\n            for (var i = 0; i < data.length;) {\n                var cmd = data[i++];\n\n                if (i == 1) {\n                    // 如果第一个命令是 L, C, Q\n                    // 则 previous point 同绘制命令的第一个 point\n                    //\n                    // 第一个命令为 Arc 的情况下会在后面特殊处理\n                    xi = data[i];\n                    yi = data[i + 1];\n\n                    x0 = xi;\n                    y0 = yi;\n                }\n\n                switch (cmd) {\n                    case CMD.M:\n                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                        // 在 closePath 的时候使用\n                        x0 = data[i++];\n                        y0 = data[i++];\n                        xi = x0;\n                        yi = y0;\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        bbox.fromCubic(\n                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        bbox.fromQuadratic(\n                            xi, yi, data[i++], data[i++], data[i], data[i + 1],\n                            min2, max2\n                        );\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        // TODO Arc 判断的开销比较大\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        // TODO Arc 旋转\n                        var psi = data[i++];\n                        var anticlockwise = 1 - data[i++];\n\n                        if (i == 1) {\n                            // 直接使用 arc 命令\n                            // 第一个命令起点还未定义\n                            x0 = mathCos(startAngle) * rx + cx;\n                            y0 = mathSin(startAngle) * ry + cy;\n                        }\n\n                        bbox.fromArc(\n                            cx, cy, rx, ry, startAngle, endAngle,\n                            anticlockwise, min2, max2\n                        );\n\n                        xi = mathCos(endAngle) * rx + cx;\n                        yi = mathSin(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        // Use fromLine\n                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n\n                // Union\n                vec2.min(min, min, min2);\n                vec2.max(max, max, max2);\n            }\n\n            // No data\n            if (i === 0) {\n                min[0] = min[1] = max[0] = max[1] = 0;\n            }\n\n            return new BoundingRect(\n                min[0], min[1], max[0] - min[0], max[1] - min[1]\n            );\n        },\n\n        /**\n         * Rebuild path from current data\n         * Rebuild path will not consider javascript implemented line dash.\n         * @param {CanvasRenderingContext} ctx\n         */\n        rebuildPath: function (ctx) {\n            var d = this.data;\n            for (var i = 0; i < this._len;) {\n                var cmd = d[i++];\n                switch (cmd) {\n                    case CMD.M:\n                        ctx.moveTo(d[i++], d[i++]);\n                        break;\n                    case CMD.L:\n                        ctx.lineTo(d[i++], d[i++]);\n                        break;\n                    case CMD.C:\n                        ctx.bezierCurveTo(\n                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]\n                        );\n                        break;\n                    case CMD.Q:\n                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var theta = d[i++];\n                        var dTheta = d[i++];\n                        var psi = d[i++];\n                        var fs = d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var scaleX = (rx > ry) ? 1 : rx / ry;\n                        var scaleY = (rx > ry) ? ry / rx : 1;\n                        var isEllipse = Math.abs(rx - ry) > 1e-3;\n                        if (isEllipse) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, theta, theta + dTheta, 1 - fs);\n                        }\n                        break;\n                    case CMD.R:\n                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n                        break;\n                    case CMD.Z:\n                        ctx.closePath();\n                }\n            }\n        }\n    };\n\n    PathProxy.CMD = CMD;\n\n    module.exports = PathProxy;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/PathProxy.js\n ** module id = 43\n ** module chunks = 0\n **/","'use strict';\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var v2Create = vec2.create;\n    var v2DistSquare = vec2.distSquare;\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n\n    var EPSILON = 1e-4;\n\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n\n    // 临时变量\n    var _v0 = v2Create();\n    var _v1 = v2Create();\n    var _v2 = v2Create();\n    // var _v3 = vec2.create();\n\n    function isAroundZero(val) {\n        return val > -EPSILON && val < EPSILON;\n    }\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    /**\n     * 计算三次贝塞尔值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n             + t * t * (t * p3 + 3 * onet * p2);\n    }\n\n    /**\n     * 计算三次贝塞尔导数值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @return {number}\n     */\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (\n            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t\n        );\n    }\n\n    /**\n     * 计算三次贝塞尔方程根，使用盛金公式\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} val\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        // Evaluate roots of cubic functions\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1  - p0);\n        var d = p0 - val;\n\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n\n        var n = 0;\n\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;  //t1, t2, t3, b is not zero\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;  // t1, a is not zero\n                var t2 = -K / 2;  // t2, t3\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算三次贝塞尔方程极限值的位置\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {Array.<number>} extrema\n     * @return {number} 有效数目\n     */\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <=1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 细分三次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} p3\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n\n        var p0123 = (p123 - p012) * t + p012;\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        // Seg1\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n\n    /**\n     * 投射点到三次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} [out] 投射点\n     * @return {number}\n     */\n    function cubicProjectPoint(\n        x0, y0, x1, y1, x2, y2, x3, y3,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            // t - interval\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n\n            d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = v2DistSquare(_v2, _v0);\n\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    /**\n     * 计算二次方贝塞尔值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n\n    /**\n     * 计算二次方贝塞尔导数值\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @return {number}\n     */\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n\n    /**\n     * 计算二次方贝塞尔方程根\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} roots\n     * @return {number} 有效根数目\n     */\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n\n    /**\n     * 计算二次贝塞尔方程极限值\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @return {number}\n     */\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            // p1 is center of p0 and p2\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n\n    /**\n     * 细分二次贝塞尔曲线\n     * @memberOf module:zrender/core/curve\n     * @param  {number} p0\n     * @param  {number} p1\n     * @param  {number} p2\n     * @param  {number} t\n     * @param  {Array.<number>} out\n     */\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n\n        // Seg0\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n\n        // Seg1\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n\n    /**\n     * 投射点到二次贝塞尔曲线上，返回投射距离。\n     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x\n     * @param {number} y\n     * @param {Array.<number>} out 投射点\n     * @return {number}\n     */\n    function quadraticProjectPoint(\n        x0, y0, x1, y1, x2, y2,\n        x, y, out\n    ) {\n        // http://pomax.github.io/bezierinfo/#projections\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n\n        _v0[0] = x;\n        _v0[1] = y;\n\n        // 先粗略估计一下可能的最小距离的 t 值\n        // PENDING\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = v2DistSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n\n        // At most 32 iteration\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            // t - interval\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n\n            var d1 = v2DistSquare(_v1, _v0);\n\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                // t + interval\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = v2DistSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        // t\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        // console.log(interval, i);\n        return mathSqrt(d);\n    }\n\n    module.exports = {\n\n        cubicAt: cubicAt,\n\n        cubicDerivativeAt: cubicDerivativeAt,\n\n        cubicRootAt: cubicRootAt,\n\n        cubicExtrema: cubicExtrema,\n\n        cubicSubdivide: cubicSubdivide,\n\n        cubicProjectPoint: cubicProjectPoint,\n\n        quadraticAt: quadraticAt,\n\n        quadraticDerivativeAt: quadraticDerivativeAt,\n\n        quadraticRootAt: quadraticRootAt,\n\n        quadraticExtremum: quadraticExtremum,\n\n        quadraticSubdivide: quadraticSubdivide,\n\n        quadraticProjectPoint: quadraticProjectPoint\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/curve.js\n ** module id = 44\n ** module chunks = 0\n **/","/**\n * @author Yi Shen(https://github.com/pissang)\n */\n\n\n    var vec2 = require('./vector');\n    var curve = require('./curve');\n\n    var bbox = {};\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n\n    var start = vec2.create();\n    var end = vec2.create();\n    var extremity = vec2.create();\n\n    var PI2 = Math.PI * 2;\n    /**\n     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n     * @module zrender/core/bbox\n     * @param {Array<Object>} points 顶点数组\n     * @param {number} min\n     * @param {number} max\n     */\n    bbox.fromPoints = function(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        var i;\n\n        for (i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin(left, p[0]);\n            right = mathMax(right, p[0]);\n            top = mathMin(top, p[1]);\n            bottom = mathMax(bottom, p[1]);\n        }\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromLine = function (x0, y0, x1, y1, min, max) {\n        min[0] = mathMin(x0, x1);\n        min[1] = mathMin(y0, y1);\n        max[0] = mathMax(x0, x1);\n        max[1] = mathMax(y0, y1);\n    };\n\n    /**\n     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {number} x3\n     * @param {number} y3\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromCubic = function(\n        x0, y0, x1, y1, x2, y2, x3, y3, min, max\n    ) {\n        var xDim = [];\n        var yDim = [];\n        var cubicExtrema = curve.cubicExtrema;\n        var cubicAt = curve.cubicAt;\n        var left, right, top, bottom;\n        var i;\n        var n = cubicExtrema(x0, x1, x2, x3, xDim);\n\n        for (i = 0; i < n; i++) {\n            xDim[i] = cubicAt(x0, x1, x2, x3, xDim[i]);\n        }\n        n = cubicExtrema(y0, y1, y2, y3, yDim);\n        for (i = 0; i < n; i++) {\n            yDim[i] = cubicAt(y0, y1, y2, y3, yDim[i]);\n        }\n\n        xDim.push(x0, x3);\n        yDim.push(y0, y3);\n\n        left = mathMin.apply(null, xDim);\n        right = mathMax.apply(null, xDim);\n        top = mathMin.apply(null, yDim);\n        bottom = mathMax.apply(null, yDim);\n\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    };\n\n    /**\n     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x0\n     * @param {number} y0\n     * @param {number} x1\n     * @param {number} y1\n     * @param {number} x2\n     * @param {number} y2\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum = curve.quadraticExtremum;\n        var quadraticAt = curve.quadraticAt;\n        // Find extremities, where derivative in x dim or y dim is zero\n        var tx =\n            mathMax(\n                mathMin(quadraticExtremum(x0, x1, x2), 1), 0\n            );\n        var ty =\n            mathMax(\n                mathMin(quadraticExtremum(y0, y1, y2), 1), 0\n            );\n\n        var x = quadraticAt(x0, x1, x2, tx);\n        var y = quadraticAt(y0, y1, y2, ty);\n\n        min[0] = mathMin(x0, x2, x);\n        min[1] = mathMin(y0, y2, y);\n        max[0] = mathMax(x0, x2, x);\n        max[1] = mathMax(y0, y2, y);\n    };\n\n    /**\n     * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n     * @method\n     * @memberOf module:zrender/core/bbox\n     * @param {number} x\n     * @param {number} y\n     * @param {number} rx\n     * @param {number} ry\n     * @param {number} startAngle\n     * @param {number} endAngle\n     * @param {number} anticlockwise\n     * @param {Array.<number>} min\n     * @param {Array.<number>} max\n     */\n    bbox.fromArc = function (\n        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max\n    ) {\n        var vec2Min = vec2.min;\n        var vec2Max = vec2.max;\n\n        var diff = Math.abs(startAngle - endAngle);\n\n\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            // Is a circle\n            min[0] = x - rx;\n            min[1] = y - ry;\n            max[0] = x + rx;\n            max[1] = y + ry;\n            return;\n        }\n\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n\n        vec2Min(min, start, end);\n        vec2Max(max, start, end);\n\n        // Thresh to [0, Math.PI * 2]\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n\n        // var number = 0;\n        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n\n                vec2Min(min, extremity, min);\n                vec2Max(max, extremity, max);\n            }\n        }\n    };\n\n    module.exports = bbox;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/core/bbox.js\n ** module id = 45\n ** module chunks = 0\n **/","'use strict';\n\n\n    var CMD = require('../core/PathProxy').CMD;\n    var line = require('./line');\n    var cubic = require('./cubic');\n    var quadratic = require('./quadratic');\n    var arc = require('./arc');\n    var normalizeRadian = require('./util').normalizeRadian;\n    var curve = require('../core/curve');\n\n    var windingLine = require('./windingLine');\n\n    var containStroke = line.containStroke;\n\n    var PI2 = Math.PI * 2;\n\n    var EPSILON = 1e-4;\n\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON;\n    }\n\n    // 临时数组\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_, y1_;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) { // Quick reject\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema == 2) {\n                    // 分成三段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? 1 : -1;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? 1 : -1;\n                    }\n                    else {\n                        w += y3 < y1_ ? 1 : -1;\n                    }\n                }\n                else {\n                    // 分成两段单调函数\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? 1 : -1;\n                    }\n                    else {\n                        w += y3 < y0_ ? 1 : -1;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        // Quick reject\n        if (\n            (y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)\n        ) {\n            return 0;\n        }\n        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = curve.quadraticExtremum(y0, y1, y2);\n            if (t >=0 && t <= 1) {\n                var w = 0;\n                var y_ = curve.quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ > x) {\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? 1 : -1;\n                    }\n                    else {\n                        w += y2 < y_ ? 1 : -1;\n                    }\n                }\n                return w;\n            }\n            else {\n                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ > x) {\n                    return 0;\n                }\n                return y2 < y0 ? 1 : -1;\n            }\n        }\n    }\n\n    // TODO\n    // Arc 旋转\n    function windingArc(\n        cx, cy, r, startAngle, endAngle, anticlockwise, x, y\n    ) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff < 1e-4) {\n            return 0;\n        }\n        if (diff % PI2 < 1e-4) {\n            // Is a circle\n            startAngle = 0;\n            endAngle = PI2;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            } else {\n                return 0;\n            }\n        }\n\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2;\n        }\n\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2 + angle;\n                }\n                if (\n                    (angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)\n                ) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n\n    function containPath(data, lineWidth, isStroke, x, y) {\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n\n        for (var i = 0; i < data.length;) {\n            var cmd = data[i++];\n            // Begin a new subpath\n            if (cmd === CMD.M && i > 1) {\n                // Close previous subpath\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n                // 如果被任何一个 subpath 包含\n                if (w !== 0) {\n                    return true;\n                }\n            }\n\n            if (i == 1) {\n                // 如果第一个命令是 L, C, Q\n                // 则 previous point 同绘制命令的第一个 point\n                //\n                // 第一个命令为 Arc 的情况下会在后面特殊处理\n                xi = data[i];\n                yi = data[i + 1];\n\n                x0 = xi;\n                y0 = yi;\n            }\n\n            switch (cmd) {\n                case CMD.M:\n                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n                    // 在 closePath 的时候使用\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.C:\n                    if (isStroke) {\n                        if (cubic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(\n                            xi, yi,\n                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.Q:\n                    if (isStroke) {\n                        if (quadratic.containStroke(xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(\n                            xi, yi,\n                            data[i++], data[i++], data[i], data[i + 1],\n                            x, y\n                        ) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD.A:\n                    // TODO Arc 判断的开销比较大\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    // TODO Arc 旋转\n                    var psi = data[i++];\n                    var anticlockwise = 1 - data[i++];\n                    var x1 = Math.cos(theta) * rx + cx;\n                    var y1 = Math.sin(theta) * ry + cy;\n                    // 不是直接使用 arc 命令\n                    if (i > 1) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        // 第一个命令起点还未定义\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (arc.containStroke(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            lineWidth, _x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(\n                            cx, cy, ry, theta, theta + dTheta, anticlockwise,\n                            _x, y\n                        );\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    var x1 = x0 + width;\n                    var y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                          || containStroke(x0, y1, x1, y1, lineWidth, x, y)\n                        ) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // FIXME Clockwise ?\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD.Z:\n                    if (isStroke) {\n                        if (containStroke(\n                            xi, yi, x0, y0, lineWidth, x, y\n                        )) {\n                            return true;\n                        }\n                    }\n                    else {\n                        // Close a subpath\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                        // 如果被任何一个 subpath 包含\n                        if (w !== 0) {\n                            return true;\n                        }\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n\n    module.exports = {\n        contain: function (pathData, x, y) {\n            return containPath(pathData, 0, false, x, y);\n        },\n\n        containStroke: function (pathData, lineWidth, x, y) {\n            return containPath(pathData, lineWidth, true, x, y);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/path.js\n ** module id = 46\n ** module chunks = 0\n **/","\n    module.exports = {\n        /**\n         * 线段包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            var _a = 0;\n            var _b = x0;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l)\n                || (y < y0 - _l && y < y1 - _l)\n                || (x > x0 + _l && x > x1 + _l)\n                || (x < x0 - _l && x < x1 - _l)\n            ) {\n                return false;\n            }\n\n            if (x0 !== x1) {\n                _a = (y0 - y1) / (x0 - x1);\n                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;\n            }\n            else {\n                return Math.abs(x - x0) <= _l / 2;\n            }\n            var tmp = _a * x - y + _b;\n            var _s = tmp * tmp / (_a * _a + 1);\n            return _s <= _l / 2 * _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/line.js\n ** module id = 47\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 三次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  x3\n         * @param  {number}  y3\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.cubicProjectPoint(\n                x0, y0, x1, y1, x2, y2, x3, y3,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/cubic.js\n ** module id = 48\n ** module chunks = 0\n **/","\n\n    var curve = require('../core/curve');\n\n    module.exports = {\n        /**\n         * 二次贝塞尔曲线描边包含判断\n         * @param  {number}  x0\n         * @param  {number}  y0\n         * @param  {number}  x1\n         * @param  {number}  y1\n         * @param  {number}  x2\n         * @param  {number}  y2\n         * @param  {number}  lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {boolean}\n         */\n        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n            // Quick reject\n            if (\n                (y > y0 + _l && y > y1 + _l && y > y2 + _l)\n                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)\n            ) {\n                return false;\n            }\n            var d = curve.quadraticProjectPoint(\n                x0, y0, x1, y1, x2, y2,\n                x, y, null\n            );\n            return d <= _l / 2;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/quadratic.js\n ** module id = 49\n ** module chunks = 0\n **/","\n\n    var normalizeRadian = require('./util').normalizeRadian;\n    var PI2 = Math.PI * 2;\n\n    module.exports = {\n        /**\n         * 圆弧描边包含判断\n         * @param  {number}  cx\n         * @param  {number}  cy\n         * @param  {number}  r\n         * @param  {number}  startAngle\n         * @param  {number}  endAngle\n         * @param  {boolean}  anticlockwise\n         * @param  {number} lineWidth\n         * @param  {number}  x\n         * @param  {number}  y\n         * @return {Boolean}\n         */\n        containStroke: function (\n            cx, cy, r, startAngle, endAngle, anticlockwise,\n            lineWidth, x, y\n        ) {\n\n            if (lineWidth === 0) {\n                return false;\n            }\n            var _l = lineWidth;\n\n            x -= cx;\n            y -= cy;\n            var d = Math.sqrt(x * x + y * y);\n\n            if ((d - _l > r) || (d + _l < r)) {\n                return false;\n            }\n            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n                // Is a circle\n                return true;\n            }\n            if (anticlockwise) {\n                var tmp = startAngle;\n                startAngle = normalizeRadian(endAngle);\n                endAngle = normalizeRadian(tmp);\n            } else {\n                startAngle = normalizeRadian(startAngle);\n                endAngle = normalizeRadian(endAngle);\n            }\n            if (startAngle > endAngle) {\n                endAngle += PI2;\n            }\n\n            var angle = Math.atan2(y, x);\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return (angle >= startAngle && angle <= endAngle)\n                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/arc.js\n ** module id = 50\n ** module chunks = 0\n **/","\n\n    var PI2 = Math.PI * 2;\n    module.exports = {\n        normalizeRadian: function(angle) {\n            angle %= PI2;\n            if (angle < 0) {\n                angle += PI2;\n            }\n            return angle;\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/util.js\n ** module id = 51\n ** module chunks = 0\n **/","\n    module.exports = function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        if (y1 === y0) {\n            return 0;\n        }\n        var dir = y1 < y0 ? 1 : -1;\n        var t = (y - y0) / (y1 - y0);\n        var x_ = t * (x1 - x0) + x0;\n\n        return x_ > x ? dir : 0;\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/contain/windingLine.js\n ** module id = 52\n ** module chunks = 0\n **/","\n\n    var CMD = require('../core/PathProxy').CMD;\n    var vec2 = require('../core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n\n    var points = [[], [], []];\n    var mathSqrt = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n\n        var M = CMD.M;\n        var C = CMD.C;\n        var L = CMD.L;\n        var R = CMD.R;\n        var A = CMD.A;\n        var Q = CMD.Q;\n\n        for (i = 0, j = 0; i < data.length;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    // cx\n                    data[i++] += x;\n                    // cy\n                    data[i++] += y;\n                    // Scale rx and ry\n                    // FIXME Assume psi is 0 here\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n\n                    // Start angle\n                    data[i++] += angle;\n                    // end angle\n                    data[i++] += angle;\n                    // FIXME psi\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    // x0, y0\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    // x1, y1\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    v2ApplyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n\n            for (k = 0; k < nPoint; k++) {\n                var p = points[k];\n                p[0] = data[i++];\n                p[1] = data[i++];\n\n                v2ApplyTransform(p, p, m);\n                // Write back\n                data[j++] = p[0];\n                data[j++] = p[1];\n            }\n        }\n    }\n\n    module.exports = transformPath;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/tool/transformPath.js\n ** module id = 53\n ** module chunks = 0\n **/","/**\n * Text element\n * @module zrender/graphic/Text\n *\n * TODO Wrapping\n */\n\n\n\n    var Displayable = require('./Displayable');\n    var zrUtil = require('../core/util');\n    var textContain = require('../contain/text');\n\n    /**\n     * @alias zrender/graphic/Text\n     * @extends module:zrender/graphic/Displayable\n     * @constructor\n     * @param {Object} opts\n     */\n    var Text = function (opts) {\n        Displayable.call(this, opts);\n    };\n\n    Text.prototype = {\n\n        constructor: Text,\n\n        type: 'text',\n\n        brush: function (ctx) {\n            var style = this.style;\n            var x = style.x || 0;\n            var y = style.y || 0;\n            // Convert to string\n            var text = style.text;\n            var textFill = style.fill;\n            var textStroke = style.stroke;\n\n            // Convert to string\n            text != null && (text += '');\n\n            if (text) {\n                ctx.save();\n\n                this.style.bind(ctx);\n                this.setTransform(ctx);\n\n                textFill && (ctx.fillStyle = textFill);\n                textStroke && (ctx.strokeStyle = textStroke);\n\n                ctx.font = style.textFont || style.font;\n                ctx.textAlign = style.textAlign;\n\n                if (style.textVerticalAlign) {\n                    var rect = textContain.getBoundingRect(\n                        text, ctx.font, style.textAlign, 'top'\n                    );\n                    // Ignore textBaseline\n                    ctx.textBaseline = 'top';\n                    switch (style.textVerticalAlign) {\n                        case 'middle':\n                            y -= rect.height / 2;\n                            break;\n                        case 'bottom':\n                            y -= rect.height;\n                            break;\n                        // 'top'\n                    }\n                }\n                else {\n                    ctx.textBaseline = style.textBaseline;\n                }\n                var lineHeight = textContain.measureText('国', ctx.font).width;\n\n                var textLines = text.split('\\n');\n                for (var i = 0; i < textLines.length; i++) {\n                    textFill && ctx.fillText(textLines[i], x, y);\n                    textStroke && ctx.strokeText(textLines[i], x, y);\n                    y += lineHeight;\n                }\n\n                ctx.restore();\n            }\n        },\n\n        getBoundingRect: function () {\n            if (!this._rect) {\n                var style = this.style;\n                var rect = textContain.getBoundingRect(\n                    style.text + '', style.textFont || style.font, style.textAlign, style.textBaseline\n                );\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                this._rect = rect;\n            }\n            return this._rect;\n        }\n    };\n\n    zrUtil.inherits(Text, Displayable);\n\n    module.exports = Text;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/Text.js\n ** module id = 54\n ** module chunks = 0\n **/","'use strict';\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\n\n\n\n    module.exports = require('../Path').extend({\n        \n        type: 'circle',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0\n        },\n\n        buildPath : function (ctx, shape) {\n            // Better stroking in ShapeBundle\n            ctx.moveTo(shape.cx + shape.r, shape.cy);\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Circle.js\n ** module id = 55\n ** module chunks = 0\n **/","/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\n\n// FIXME clockwise seems wrong\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'sector',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r0: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r0 = Math.max(shape.r0 || 0, 0);\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n\n            ctx.lineTo(unitX * r + x, unitY * r + y);\n\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n\n            ctx.lineTo(\n                Math.cos(endAngle) * r0 + x,\n                Math.sin(endAngle) * r0 + y\n            );\n\n            if (r0 !== 0) {\n                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n            }\n\n            ctx.closePath();\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Sector.js\n ** module id = 56\n ** module chunks = 0\n **/","/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\n\n\n    module.exports = require('../Path').extend({\n\n        type: 'ring',\n\n        shape: {\n            cx: 0,\n            cy: 0,\n            r: 0,\n            r0: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Ring.js\n ** module id = 57\n ** module chunks = 0\n **/","/**\n * 多边形\n * @module zrender/shape/Polygon\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polygon',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, true);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polygon.js\n ** module id = 58\n ** module chunks = 0\n **/","\n\n    var smoothSpline = require('./smoothSpline');\n    var smoothBezier = require('./smoothBezier');\n\n    module.exports = {\n        buildPath: function (ctx, shape, closePath) {\n            var points = shape.points;\n            var smooth = shape.smooth;\n            if (points && points.length >= 2) {\n                if (smooth && smooth !== 'spline') {\n                    var controlPoints = smoothBezier(\n                        points, smooth, closePath, shape.smoothConstraint\n                    );\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    var len = points.length;\n                    for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                        var cp1 = controlPoints[i * 2];\n                        var cp2 = controlPoints[i * 2 + 1];\n                        var p = points[(i + 1) % len];\n                        ctx.bezierCurveTo(\n                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]\n                        );\n                    }\n                }\n                else {\n                    if (smooth === 'spline') {\n                        points = smoothSpline(points, closePath);\n                    }\n\n                    ctx.moveTo(points[0][0], points[0][1]);\n                    for (var i = 1, l = points.length; i < l; i++) {\n                        ctx.lineTo(points[i][0], points[i][1]);\n                    }\n                }\n\n                closePath && ctx.closePath();\n            }\n        }\n    };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/poly.js\n ** module id = 59\n ** module chunks = 0\n **/","/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n    var vec2 = require('../../core/vector');\n\n    /**\n     * @inner\n     */\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n                + v0 * t + p1;\n    }\n\n    /**\n     * @alias module:zrender/shape/util/smoothSpline\n     * @param {Array} points 线段顶点数组\n     * @param {boolean} isLoop\n     * @return {Array}\n     */\n    module.exports = function (points, isLoop) {\n        var len = points.length;\n        var ret = [];\n\n        var distance = 0;\n        for (var i = 1; i < len; i++) {\n            distance += vec2.distance(points[i - 1], points[i]);\n        }\n\n        var segs = distance / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n\n            var w = pos - idx;\n\n            var p0;\n            var p1 = points[idx % len];\n            var p2;\n            var p3;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n\n            var w2 = w * w;\n            var w3 = w * w2;\n\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothSpline.js\n ** module id = 60\n ** module chunks = 0\n **/","/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n\n    var vec2 = require('../../core/vector');\n    var v2Min = vec2.min;\n    var v2Max = vec2.max;\n    var v2Scale = vec2.scale;\n    var v2Distance = vec2.distance;\n    var v2Add = vec2.add;\n\n    /**\n     * 贝塞尔平滑曲线\n     * @alias module:zrender/shape/util/smoothBezier\n     * @param {Array} points 线段顶点数组\n     * @param {number} smooth 平滑等级, 0-1\n     * @param {boolean} isLoop\n     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n     *                           整个折线的包围盒做一个并集用来约束控制点。\n     * @param {Array} 计算出来的控制点数组\n     */\n    module.exports = function (points, smooth, isLoop, constraint) {\n        var cps = [];\n\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n\n        var min, max;\n        if (constraint) {\n            min = [Infinity, Infinity];\n            max = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                v2Min(min, min, points[i]);\n                v2Max(max, max, points[i]);\n            }\n            // 与指定的包围盒做并集\n            v2Min(min, min, constraint[0]);\n            v2Max(max, max, constraint[1]);\n        }\n\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(vec2.clone(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n\n            vec2.sub(v, nextPoint, prevPoint);\n\n            // use degree to scale the handle length\n            v2Scale(v, v, smooth);\n\n            var d0 = v2Distance(point, prevPoint);\n            var d1 = v2Distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n\n            v2Scale(v1, v, -d0);\n            v2Scale(v2, v, d1);\n            var cp0 = v2Add([], point, v1);\n            var cp1 = v2Add([], point, v2);\n            if (constraint) {\n                v2Max(cp0, cp0, min);\n                v2Min(cp0, cp0, max);\n                v2Max(cp1, cp1, min);\n                v2Min(cp1, cp1, max);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n\n        return cps;\n    };\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/helper/smoothBezier.js\n ** module id = 61\n ** module chunks = 0\n **/","/**\n * @module zrender/graphic/shape/Polyline\n */\n\n\n    var polyHelper = require('../helper/poly');\n\n    module.exports = require('../Path').extend({\n        \n        type: 'polyline',\n\n        shape: {\n            points: null,\n\n            smooth: false,\n\n            smoothConstraint: null\n        },\n\n        style: {\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            polyHelper.buildPath(ctx, shape, false);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Polyline.js\n ** module id = 62\n ** module chunks = 0\n **/","/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n\n\n    var roundRectHelper = require('../helper/roundRect');\n\n    module.exports = require('../Path').extend({\n\n        type: 'rect',\n\n        shape: {\n            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n            // r缩写为1         相当于 [1, 1, 1, 1]\n            // r缩写为[1]       相当于 [1, 1, 1, 1]\n            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n            r: 0,\n\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var width = shape.width;\n            var height = shape.height;\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                roundRectHelper.buildPath(ctx, shape);\n            }\n            ctx.closePath();\n            return;\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Rect.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n\n    module.exports = require('../Path').extend({\n\n        type: 'line',\n\n        shape: {\n            // Start point\n            x1: 0,\n            y1: 0,\n            // End point\n            x2: 0,\n            y2: 0,\n\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var percent = shape.percent;\n\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Line.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\n\n\n    var curveTool = require('../../core/curve');\n    var quadraticSubdivide = curveTool.quadraticSubdivide;\n    var cubicSubdivide = curveTool.cubicSubdivide;\n    var quadraticAt = curveTool.quadraticAt;\n    var cubicAt = curveTool.cubicAt;\n\n    var out = [];\n    module.exports = require('../Path').extend({\n\n        type: 'bezier-curve',\n\n        shape: {\n            x1: 0,\n            y1: 0,\n            x2: 0,\n            y2: 0,\n            cpx1: 0,\n            cpy1: 0,\n            // cpx2: 0,\n            // cpy2: 0\n\n            // Curve show percent, for animating\n            percent: 1\n        },\n\n        style: {\n            stroke: '#000',\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n\n            ctx.moveTo(x1, y1);\n\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(\n                        x1, cpx1, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(\n                        y1, cpy1, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n\n                ctx.quadraticCurveTo(\n                    cpx1, cpy1,\n                    x2, y2\n                );\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(\n                        x1, cpx1, cpx2, x2, percent, out\n                    );\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(\n                        y1, cpy1, cpy2, y2, percent, out\n                    );\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(\n                    cpx1, cpy1,\n                    cpx2, cpy2,\n                    x2, y2\n                );\n            }\n        },\n\n        /**\n         * Get point at percent\n         * @param  {number} percent\n         * @return {Array.<number>}\n         */\n        pointAt: function (p) {\n            var shape = this.shape;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            if (cpx2 === null || cpy2 === null) {\n                return [\n                    quadraticAt(shape.x1, shape.cpx1, shape.x2, p),\n                    quadraticAt(shape.y1, shape.cpy1, shape.y2, p)\n                ];\n            }\n            else {\n                return [\n                    cubicAt(shape.x1, shape.cpx1, shape.cpx1, shape.x2, p),\n                    cubicAt(shape.y1, shape.cpy1, shape.cpy1, shape.y2, p)\n                ];\n            }\n        }\n    });\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/BezierCurve.js\n ** module id = 65\n ** module chunks = 0\n **/","/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\n \n\n    module.exports = require('../Path').extend({\n\n        type: 'arc',\n\n        shape: {\n\n            cx: 0,\n\n            cy: 0,\n\n            r: 0,\n\n            startAngle: 0,\n\n            endAngle: Math.PI * 2,\n\n            clockwise: true\n        },\n\n        style: {\n\n            stroke: '#000',\n\n            fill: null\n        },\n\n        buildPath: function (ctx, shape) {\n\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        }\n    });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/shape/Arc.js\n ** module id = 66\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, x2, y2 are all percent from 0 to 1\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {number} [x2=1]\n     * @param {number} [y2=0]\n     * @param {Array.<Object>} colorStops\n     */\n    var LinearGradient = function (x, y, x2, y2, colorStops) {\n        this.x = x == null ? 0 : x;\n\n        this.y = y == null ? 0 : y;\n\n        this.x2 = x2 == null ? 1 : x2;\n\n        this.y2 = y2 == null ? 0 : y2;\n\n        Gradient.call(this, colorStops);\n    };\n\n    LinearGradient.prototype = {\n\n        constructor: LinearGradient,\n\n        type: 'linear',\n\n        updateCanvasGradient: function (shape, ctx) {\n            var rect = shape.getBoundingRect();\n            // var size =\n            var x = this.x * rect.width + rect.x;\n            var x2 = this.x2 * rect.width + rect.x;\n            var y = this.y * rect.height + rect.y;\n            var y2 = this.y2 * rect.height + rect.y;\n\n            var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n\n            var colorStops = this.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n\n            this.canvasGradient = canvasGradient;\n        }\n\n    };\n\n    zrUtil.inherits(LinearGradient, Gradient);\n\n    module.exports = LinearGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/LinearGradient.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\n\n\n    var zrUtil = require('../core/util');\n\n    var Gradient = require('./Gradient');\n\n    /**\n     * x, y, r are all percent from 0 to 1\n     * @param {number} [x=0.5]\n     * @param {number} [y=0.5]\n     * @param {number} [r=0.5]\n     * @param {Array.<Object>} [colorStops]\n     */\n    var RadialGradient = function (x, y, r, colorStops) {\n        this.x = x == null ? 0.5 : x;\n\n        this.y = y == null ? 0.5 : y;\n\n        this.r = r == null ? 0.5 : r;\n\n        Gradient.call(this, colorStops);\n    };\n\n    RadialGradient.prototype = {\n\n        constructor: RadialGradient,\n\n        type: 'radial',\n\n        updateCanvasGradient: function (shape, ctx) {\n            var rect = shape.getBoundingRect();\n\n            var width = rect.width;\n            var height = rect.height;\n            var min = Math.min(width, height);\n            // var max = Math.max(width, height);\n\n            var x = this.x * width + rect.x;\n            var y = this.y * height + rect.y;\n            var r = this.r * min;\n\n            var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n\n            var colorStops = this.colorStops;\n            for (var i = 0; i < colorStops.length; i++) {\n                canvasGradient.addColorStop(\n                    colorStops[i].offset, colorStops[i].color\n                );\n            }\n\n            this.canvasGradient = canvasGradient;\n        }\n    };\n\n    zrUtil.inherits(RadialGradient, Gradient);\n\n    module.exports = RadialGradient;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/zrender/lib/graphic/RadialGradient.js\n ** module id = 68\n ** module chunks = 0\n **/","/**\r\n * 事件决策多边形\r\n * @module fish-topo-bo/node/EventDecisionNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    function EventDecisionNode(data, opts) {\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = data;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        this._type = opts.type || 'boEvent';\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._clickable = opts.clickable || false;\r\n        this._popupOpts = opts.popupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var eventProto = EventDecisionNode.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    eventProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成事件决策图形\r\n     * @private\r\n     */\r\n    eventProto._render = function () {\r\n        //多边形\r\n        this._createEventShape();\r\n        //文字\r\n        this._createEVentName();\r\n    };\r\n\r\n    /**\r\n     * 事件决策多边形\r\n     * @private\r\n     */\r\n    eventProto._createEventShape = function () {\r\n\r\n        //多边形高度\r\n        var height = Const.BO_EVENT_HEIGHT,\r\n            x = this._startPos.x + 1,\r\n            y = this._startPos.y,\r\n            width = this._type == 'boEvent' ? Const.BO_EVENT_WIDTH : Const.BO_ATTR_EVENT_WIDTH,\r\n\r\n            shape = new graphic.Polygon({\r\n                name: this._data.id,\r\n                shape: {\r\n                    points: [\r\n                        [x, y],\r\n                        [x + width - 10, y],\r\n                        [x + width, y + height / 2],\r\n                        [x + width - 10, y + height],\r\n                        [x, y + height]]\r\n                },\r\n\r\n                style: {\r\n                    fill: '#FFCCCC',\r\n                    stroke: '#000000',\r\n                    lineWidth: 0.75\r\n                }\r\n\r\n            });\r\n\r\n        if (this._clickable) {\r\n            shape.clickable = this._clickable;\r\n            shape._data = this._data;\r\n            shape._popupOpts = this._popupOpts;\r\n            shape.onclick = this._click;\r\n        }\r\n\r\n\r\n        this._group.add(shape);\r\n    };\r\n\r\n    /**\r\n     * 点击事件\r\n     * @private\r\n     */\r\n    eventProto._click = function () {\r\n        var options = fish.extend(\r\n            {\r\n                viewOption: {\r\n                    DATA: this._data\r\n                },\r\n                width: 800,\r\n                height: 500\r\n            }, this._popupOpts);\r\n\r\n        fish.popupView(options);\r\n    };\r\n\r\n    /**\r\n     * 事件决策名称\r\n     * @private\r\n     */\r\n    eventProto._createEVentName = function () {\r\n        var x = this._startPos.x + (this._type == 'boEvent' ? Const.BO_ATTR_PADDING_LEFT : 15),\r\n            y = this._startPos.y,\r\n\r\n            eventNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_EVENT_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        if (this._clickable) {\r\n            eventNameShape.clickable = this._clickable;\r\n            eventNameShape._data = this._data;\r\n            eventNameShape._popupOpts = this._popupOpts;\r\n            eventNameShape.onclick = this._click;\r\n        }\r\n\r\n        this._group.add(eventNameShape);\r\n    };\r\n\r\n    module.exports = EventDecisionNode;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/EventDecisionNode.js\n ** module id = 69\n ** module chunks = 0\n **/","/**\r\n * BO矩形内部的横线，分为实线和虚线两种\r\n * @module fish-topo-bo/node/LineNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n    var util = require('zrender/lib/core/util');\r\n    /**\r\n     * BO名字下面的实现\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function BoLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y};\r\n\r\n        return _line(startPos, endPos);\r\n    }\r\n\r\n    /**\r\n     * BO属性之间的虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrLine(startPos) {\r\n\r\n        var endPos = {x: startPos.x + Const.BO_NODE_WIDTH, y: startPos.y},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * BO属性与BO事件决策之间的垂直虚线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {int} attrHeight, 高度\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @constructor\r\n     */\r\n    function AttrEventLine(startPos, attrHeight) {\r\n        var endPos = {x: startPos.x, y: startPos.y + attrHeight},\r\n            style = {lineDash: [Const.LINE_DASH]};\r\n\r\n        return _line(startPos, endPos, style);\r\n    }\r\n\r\n    /**\r\n     * 画线\r\n     * @param {{x: *, y: *}} startPos, 开始坐标\r\n     * @param {{x: *, y: *}} endPos, 结束坐标\r\n     * @param {Object} style, 样式,可空\r\n     * @returns {zrender/graphic/shape/Line}\r\n     * @private\r\n     */\r\n    function _line(startPos, endPos, style) {\r\n\r\n        var _style = {\r\n            strokeColor: '#000000',\r\n            lineWidth: 0.5,\r\n            percent: 1\r\n        };\r\n\r\n        util.extend(_style, style);\r\n\r\n        var shape = new graphic.Line({\r\n            shape: {\r\n                // Start point\r\n                x1: startPos.x,\r\n                y1: startPos.y,\r\n\r\n                // End point\r\n                x2: endPos.x,\r\n                y2: endPos.y,\r\n\r\n                percent: 1\r\n            },\r\n\r\n            style: _style\r\n        });\r\n\r\n        return shape;\r\n    }\r\n\r\n\r\n    module.exports = {\r\n        BoLine: BoLine,\r\n        AttrLine: AttrLine,\r\n        AttrEventLine: AttrEventLine\r\n    };\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/LineNode.js\n ** module id = 70\n ** module chunks = 0\n **/","/**\r\n * BO属性\r\n * 1.BO属性名字\r\n * 2.BO属性数据类型\r\n * 3.BO属性事件决策\r\n * @module fish-topo-bo/node/BoAttrNode\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var EventDecision = require('../node/EventDecisionNode');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param {{\r\n     *          id: String bo属性标识,\r\n     *          code: String bo属性编码\r\n     *          keyValue: boolean 是否为主键,\r\n     *          dataType: String 属性数据类型,\r\n     *          boAttrEventArr:[] 属性事件决策数组\r\n     *          }} boAttrData BO属性数据对象,\r\n     * @param {{\r\n     *          startPos: {x: number, y: number}起始位置,\r\n     *          displayDataType: boolean 是否显示数据类型,\r\n     *          displayEventDecision: boolean 是否显示事件决策,\r\n     *          eventClickable: boolean BO属性事件决策是否支持点击事件, 可空 默认false,\r\n     *          eventPopupOpts: Object 点击BO属性事件决策弹出页面参数，url,width,height等,\r\n     *          }} opts\r\n     * @constructor\r\n     */\r\n    function BoAttr(boAttrData, opts) {\r\n        /**\r\n         * BO属性数据\r\n         * @type {Object}\r\n         * @private\r\n         */\r\n        this._data = boAttrData;\r\n\r\n        /**\r\n         * 是否为主键\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._keyValue = boAttrData.keyValue || false;\r\n\r\n        /**\r\n         * 起始位置坐标\r\n         * @type {startPos}\r\n         * @private\r\n         */\r\n        this._startPos = opts.startPos;\r\n\r\n        /**\r\n         * 是否显示数据类型\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayDataType = opts.displayDataType || false;\r\n\r\n        /**\r\n         * 是否显示事件决策\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._displayEventDecision = opts.displayEventDecision || false;\r\n\r\n        /**\r\n         * 是否支持点击\r\n         * @type {boolean}\r\n         * @private\r\n         */\r\n        this._eventClickable = opts.eventClickable || false;\r\n        this._eventPopupOpts = opts.eventPopupOpts;\r\n\r\n        /**\r\n         * Group容器\r\n         * @type zrender/graphic/Group\r\n         * @private\r\n         */\r\n        this._group = new graphic.Group();\r\n        this._group.name = this._data.id;\r\n\r\n        //生成BO属性图形\r\n        this._render();\r\n    }\r\n\r\n    var boAttrProto = BoAttr.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {zrender/graphic/Group}\r\n     */\r\n    boAttrProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n\r\n    /**\r\n     * 生成BO属性图形\r\n     * @private\r\n     */\r\n    boAttrProto._render = function () {\r\n        //属性名字\r\n        this._createText();\r\n\r\n        //属性数据类型\r\n        this._createDataType();\r\n\r\n        //属性事件决策\r\n        this._createEventDecision();\r\n    };\r\n\r\n    /**\r\n     * 属性名字\r\n     * @private\r\n     */\r\n    boAttrProto._createText = function () {\r\n\r\n        var x = this._startPos.x + Const.BO_ATTR_PADDING_LEFT,\r\n            y = this._startPos.y,\r\n\r\n            attrNameShape = new graphic.Text({\r\n                style: {\r\n                    text: this._data.name,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: 'left',  //靠左开始，便于计算位置\r\n                    textBaseline: 'top',\r\n                    //lineWidth: 1,\r\n                    fill: this._keyValue ? 'red' : 'black'\r\n                },\r\n\r\n                position: [x, y]\r\n            });\r\n\r\n        //重新设置图形高度 = 文本高度 + padding-top + padding-bottom\r\n        attrNameShape.getBoundingRect().height += Const.BO_ATTR_PADDING_TOP + Const.BO_ATTR_PADDING_BOTTOM;\r\n        //重新设置图形高度 = BO矩形宽度，用于后续Relation画图计算\r\n        attrNameShape.getBoundingRect().width = Const.BO_NODE_WIDTH;\r\n\r\n        //重新设置B起始水平坐标 = 减去偏移量\r\n        attrNameShape.getBoundingRect().x += -Const.BO_ATTR_PADDING_LEFT;\r\n        //attrNameShape.getBoundingRect().y = + attrNameShape.position[1];\r\n\r\n        this._group.add(attrNameShape);\r\n    };\r\n\r\n    /**\r\n     * 属性数据类型\r\n     * @private\r\n     */\r\n    boAttrProto._createDataType = function () {\r\n        if (!this._displayDataType) {\r\n            return;\r\n        }\r\n\r\n        var x = this._startPos.x + Const.BO_NODE_WIDTH - 10,\r\n            y = this._startPos.y,\r\n            textAlign = 'right';\r\n\r\n        //如果还要显示事件决策，则宽度重新计算\r\n        if (this._displayEventDecision) {\r\n            textAlign = 'left';\r\n            x = this._startPos.x + Const.BO_NODE_WIDTH / 3;\r\n        }\r\n\r\n        var _dataTypeShape = new graphic.Text({\r\n            style: {\r\n                text: this._data.dataType || '',\r\n                textFont: Const.BO_ATTR_FONT,\r\n                textAlign: textAlign,  //靠左开始，便于计算位置\r\n                textBaseline: 'top',\r\n                lineWidth: 1\r\n            },\r\n\r\n            position: [x, y]\r\n        });\r\n\r\n        this._group.add(_dataTypeShape);\r\n    };\r\n\r\n    /**\r\n     * 属性事件决策\r\n     * @private\r\n     */\r\n    boAttrProto._createEventDecision = function () {\r\n        if (!this._displayEventDecision) {\r\n            return;\r\n        }\r\n\r\n        var _boAttrEventArr = this._data.boAttrEventArr || [],\r\n            _boAttrEventLen = _boAttrEventArr.length,\r\n            padding = (_boAttrEventLen > 1) ? 10 : 0,\r\n            _startPos = {\r\n                x: this._startPos.x + Const.BO_NODE_WIDTH / 2 + Const.BO_ATTR_EVENT_WIDTH * (_boAttrEventLen - 1) - padding,\r\n                y: this._startPos.y\r\n            };\r\n\r\n        //从右向左画，\r\n        for (var i = _boAttrEventLen - 1; i >= 0; i--) {\r\n            this._group.add(new EventDecision(_boAttrEventArr[i], {\r\n                startPos: _startPos,\r\n                type: 'boAttrEvent',\r\n                clickable: this._eventClickable,\r\n                popupOpts: this._eventPopupOpts\r\n            }).getShape());\r\n            _startPos = {x: _startPos.x - Const.BO_ATTR_EVENT_WIDTH + 10, y: _startPos.y};\r\n        }\r\n        /*_startPos = {\r\n         x: this._startPos.x + Const.BO_NODE_WIDTH / 2,\r\n         y: this._startPos.y};\r\n\r\n         for (var i = 0; i < _boAttrEventLen; i++) {\r\n         this._group.add(event.BoAttrEvent(_boAttrEventArr[i], _startPos, i + 2));\r\n         _startPos = {x: _startPos.x + Const.BO_ATTR_EVENT_WIDTH - 5, y: _startPos.y};\r\n         }*/\r\n\r\n\r\n    };\r\n\r\n    module.exports = BoAttr;\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/BoAttrNode.js\n ** module id = 71\n ** module chunks = 0\n **/","/**\r\n * 用来创建关联关系\r\n * 关联关系包括折线、箭头、关系文字说明\r\n * @module fish-topo-bo/node/Relation\r\n * Created by majianan on 16/5/19.\r\n */\r\n\r\n    var Const = require('../models/Const');\r\n    var graphic = require(\"../../../fish-topo-core/lib/graphic.js\");\r\n\r\n    /**\r\n     *\r\n     * @param sourceShape, 开始图形\r\n     * @param targetShape, 目标图形\r\n     * @param {String} sourceText, 关系开始文字说明,可空\r\n     * @param {String} targetText, 关系结束文字说明,可空\r\n     * @constructor\r\n     */\r\n    function Relation(sourceShape, targetShape, sourceText, targetText) {\r\n        this._sourceText = sourceText;\r\n        this._targetText = targetText;\r\n\r\n        this._group = new graphic.Group();\r\n\r\n        //左侧开始位置\r\n        this._lStartPos = {\r\n            x: sourceShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //左侧结束位置\r\n        this._lEndPos = {\r\n            x: targetShape.getBoundingRect().x - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧开始位置\r\n        this._rStartPos = {\r\n            x: sourceShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: sourceShape.getBoundingRect().y + sourceShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //右侧结束位置\r\n        this._rEndPos = {\r\n            x: targetShape.getBoundingRect().x + Const.BO_NODE_WIDTH - Const.BO_ATTR_PADDING_LEFT,\r\n            y: targetShape.getBoundingRect().y + targetShape.getBoundingRect().height / 2\r\n        };\r\n\r\n        //判断画线方向\r\n        this._leftDirection = this._lStartPos.x - this._lEndPos.x <= 0;\r\n\r\n        //生成图形\r\n        this._render();\r\n    }\r\n\r\n    var relationProto = Relation.prototype;\r\n\r\n    /**\r\n     * 获取关系整体图形\r\n     * @returns {*}\r\n     */\r\n    relationProto.getShape = function () {\r\n        return this._group;\r\n    };\r\n\r\n    /**\r\n     * 生成关系整体图形\r\n     * @private\r\n     */\r\n    relationProto._render = function () {\r\n        //画线\r\n        this._createLine();\r\n\r\n        //箭头\r\n        this._createArrow();\r\n\r\n        //关系说明文字\r\n        this._createText();\r\n    };\r\n\r\n    /**\r\n     * 生成关系折线\r\n     * @private\r\n     */\r\n    relationProto._createLine = function () {\r\n        var _linePoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //第一点\r\n            _linePoints.push([this._lStartPos.x, this._lStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._lStartPos.x - Const.RELATION_OFFSET, this._lEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n        }\r\n        else {\r\n            //第一点\r\n            _linePoints.push([this._rStartPos.x, this._rStartPos.y]);\r\n            //第二点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._lStartPos.y]);\r\n            //第三点\r\n            _linePoints.push([this._rStartPos.x + Const.RELATION_OFFSET, this._rEndPos.y]);\r\n            //第四点\r\n            _linePoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n        }\r\n\r\n        var _lineShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _linePoints\r\n            },\r\n\r\n            style: {\r\n                //fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_lineShape);\r\n    };\r\n\r\n    /**\r\n     * 生成箭头图形\r\n     * @private\r\n     */\r\n    relationProto._createArrow = function () {\r\n        var _arrowPoints = [];\r\n\r\n        if (this._leftDirection) {\r\n            //右侧第一点\r\n            _arrowPoints.push([this._lEndPos.x, this._lEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._lEndPos.x - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n        else {\r\n            //左侧第一点\r\n            _arrowPoints.push([this._rEndPos.x, this._rEndPos.y]);\r\n            //下面第二点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y + Const.RELATION_ARROW_HEIGHT]);\r\n            //上面第三点\r\n            _arrowPoints.push([this._rEndPos.x + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_ARROW_HEIGHT]);\r\n        }\r\n\r\n        var _arrowShape = new graphic.Polyline({\r\n            shape: {\r\n                points: _arrowPoints\r\n            },\r\n\r\n            style: {\r\n                fill: 'blue',\r\n                stroke: 'blue'\r\n            }\r\n        });\r\n\r\n        this._group.add(_arrowShape);\r\n    };\r\n\r\n    /**\r\n     * 生成文字说明\r\n     * @private\r\n     */\r\n    relationProto._createText = function () {\r\n        var _sourceTextPos,\r\n            _targetTextPos,\r\n            _textAlign;\r\n\r\n        if (this._leftDirection) {\r\n            _sourceTextPos = [this._lStartPos.x - 10, this._lStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._lEndPos.x - 10 - Const.RELATION_ARROW_WIDTH, this._lEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'right';\r\n        }\r\n        else {\r\n            _sourceTextPos = [this._rStartPos.x + 10, this._rStartPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _targetTextPos = [this._rEndPos.x + 10 + Const.RELATION_ARROW_WIDTH, this._rEndPos.y - Const.RELATION_TEXT_OFFSET_Y];\r\n            _textAlign = 'left';\r\n        }\r\n\r\n        //开始文字\r\n        if (this._sourceText) {\r\n            var _srcTextShape = new graphic.Text({\r\n                position: _sourceTextPos,\r\n\r\n                style: {\r\n                    text: this._sourceText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_srcTextShape);\r\n        }\r\n\r\n        //结束文字\r\n        if (this._targetText) {\r\n            var _targetTextShape = new graphic.Text({\r\n                position: _targetTextPos,\r\n\r\n                style: {\r\n                    text: this._targetText,\r\n                    textFont: Const.BO_ATTR_FONT,\r\n                    textAlign: _textAlign,\r\n                    textBaseline: 'buttom',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n            this._group.add(_targetTextShape);\r\n        }\r\n\r\n    };\r\n\r\n    module.exports = Relation;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/fish-topo-bo/lib/node/Relation.js\n ** module id = 72\n ** module chunks = 0\n **/"],"sourceRoot":"/source/"}